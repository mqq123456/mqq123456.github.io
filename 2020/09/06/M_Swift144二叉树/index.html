<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="二叉树的前中后序遍历void traverse(TreeNode root) &amp;#123;     &#x2F;&#x2F; 前序遍历     traverse(root.left)     &#x2F;&#x2F; 中序遍历     traverse(root.right)     &#x2F;&#x2F; 后序遍历 &amp;#125; 非递归前序遍历 void preorder(TreeNode *root, vector&lt;int&gt;&amp; r">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="http://example.com/2020/09/06/M_Swift144%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="二叉树的前中后序遍历void traverse(TreeNode root) &amp;#123;     &#x2F;&#x2F; 前序遍历     traverse(root.left)     &#x2F;&#x2F; 中序遍历     traverse(root.right)     &#x2F;&#x2F; 后序遍历 &amp;#125; 非递归前序遍历 void preorder(TreeNode *root, vector&lt;int&gt;&amp; r">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-06T09:30:26.000Z">
<meta property="article:modified_time" content="2020-09-06T09:30:26.000Z">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/09/06/M_Swift144%E4%BA%8C%E5%8F%89%E6%A0%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>二叉树 | Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift144%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          二叉树
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:26" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:26+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h2><pre><code>void traverse(TreeNode root) &#123;
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
&#125;
非递归前序遍历
void preorder(TreeNode *root, vector&lt;int&gt;&amp; res)
&#123;
    stack&lt; pair&lt;TreeNode*, bool&gt; &gt; s;
    s.push(make_pair(root, false));
    bool visited;
    while(!s.empty()) &#123;
        root = s.top().first;
        visited = s.top().second;
        s.pop();
        if(root == NULL) &#123;
            continue;
        &#125;
        if(visited) &#123;
            res.push_back(root-&gt;val);
        &#125; else &#123;
            // 后序遍历
            s.push(make_pair(root-&gt;right, false));
            // 中序遍历
            s.push(make_pair(root-&gt;left, false));
            // 前序遍历
            s.push(make_pair(root, true));
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的广度优先搜索-（从上到下打印二叉树）"><a href="#二叉树的广度优先搜索-（从上到下打印二叉树）" class="headerlink" title="二叉树的广度优先搜索 （从上到下打印二叉树）"></a>二叉树的广度优先搜索 （从上到下打印二叉树）</h2><pre><code>本质上是前序遍历，用一个队列存储二叉树的（先入先出）
public int[] levelOrder(TreeNode root) &#123;
    if(root == null) return new int[0];
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;
    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
    while(!queue.isEmpty()) &#123;
        TreeNode node = queue.poll();
        ans.add(node.val);
        if(node.left != null) queue.add(node.left);
        if(node.right != null) queue.add(node.right);
    &#125;
    int[] res = new int[ans.size()];
    for(int i = 0; i &lt; ans.size(); i++)
        res[i] = ans.get(i);
    return res;
&#125;
</code></pre>
<h2 id="二叉树的深度优先搜索"><a href="#二叉树的深度优先搜索" class="headerlink" title="二叉树的深度优先搜索"></a>二叉树的深度优先搜索</h2><pre><code>本质上是二叉树的后续遍历，用栈存储（先入后出）
public class Solution &#123;
public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;
    ArrayList&lt;Integer&gt; lists=new ArrayList&lt;Integer&gt;();
    if(root==null)
        return lists;
    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();
    stack.push(root);
    while(!stack.isEmpty())&#123;
        TreeNode tree=stack.pop();
　　　 //先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。
            if(tree.right!=null)
                stack.push(tree.right);
            if(tree.left!=null)
                stack.push(tree.left);
            lists.add(tree.val);
        &#125;
        return lists;
    &#125;
&#125;
</code></pre>
<h2 id="树的子结构-（判断B是不是A的子结构。）"><a href="#树的子结构-（判断B是不是A的子结构。）" class="headerlink" title="树的子结构 （判断B是不是A的子结构。）"></a>树的子结构 （判断B是不是A的子结构。）</h2><pre><code>本质是二叉树的递归遍历（递归判断左右子树是不是相同）
代码步骤：A和B不能是Null，A和B相同、A的左边和B相同、A的右边和B相同
public boolean isSubStructure(TreeNode A, TreeNode B) &#123;
      return (A != null &amp;&amp; B != null) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    &#125;
    boolean recur(TreeNode A, TreeNode B) &#123;
        if(B == null) return true;
        if(A == null || A.val != B.val) return false;
        return recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);
    &#125;
</code></pre>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><pre><code>本质是二叉树的递归遍历 （交换left和right）
代码步骤：判断是否是空、交换左右的遍历结果
public TreeNode mirrorTree(TreeNode root) &#123;
        if(root == null) return null;
        TreeNode tmp = root.left;
        root.left = mirrorTree(root.right);
        root.right = mirrorTree(tmp);
        return root;
    &#125;
方法二：辅助栈（或队列）
利用栈（或队列）遍历树的所有节点 node ，并交换每个 node 的左 / 右子节点。
 public TreeNode mirrorTree(TreeNode root) &#123;
        if(root == null) return null;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
        while(!stack.isEmpty()) &#123;
            TreeNode node = stack.pop();
            if(node.left != null) stack.add(node.left);
            if(node.right != null) stack.add(node.right);
            TreeNode tmp = node.left;
            node.left = node.right;
            node.right = tmp;
        &#125;
        return root;
    &#125;
</code></pre>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><pre><code>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树
二叉树的先序遍历
// 判断左右两个数的左边和右边是不是一样，递归调用前序遍历
public boolean isSymmetric(TreeNode root) &#123;
        //方法调用
        return isSymmetric(root,root);
    &#125;

public boolean isSymmetric(TreeNode root1,TreeNode root2)&#123;
    if(root1 == null &amp;&amp; root2 == null)&#123;
        return true;
    &#125;

    //某结点只有一个子结点，故不对称，所以返回false
    if(root1 == null || root2 == null)&#123;
        return false;
    &#125;

    //对称结点存在，但是值不相同
    if(root1.val != root2.val)&#123;
        return false;
    &#125;

    //递归调用左子节点和右子节点
    return isSymmetric(root1.left, root2.right) &amp;&amp; isSymmetric(root1.right,root2.left);
&#125;
</code></pre>
<h2 id="从上到下打印二叉树-同一层的节点按从左到右的顺序打印"><a href="#从上到下打印二叉树-同一层的节点按从左到右的顺序打印" class="headerlink" title="从上到下打印二叉树 同一层的节点按从左到右的顺序打印"></a>从上到下打印二叉树 同一层的节点按从左到右的顺序打印</h2><pre><code>前序遍历，用队列存储每一层的值
将每一层数据存放到队列中
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) &#123;
            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();
            for(int i = queue.size(); i &gt; 0; i--) &#123;
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            &#125;
            res.add(tmp);
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="从上到下打印二叉树-之字形顺序打印二叉树"><a href="#从上到下打印二叉树-之字形顺序打印二叉树" class="headerlink" title="从上到下打印二叉树 之字形顺序打印二叉树"></a>从上到下打印二叉树 之字形顺序打印二叉树</h2><pre><code>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
方法一：层序遍历 + 双端队列
利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列），奇数层 则添加至 尾部，偶数层添加至头部
 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) &#123;
            LinkedList&lt;Integer&gt; tmp = new LinkedList&lt;&gt;();
            for(int i = queue.size(); i &gt; 0; i--) &#123;
                TreeNode node = queue.poll();
                if(res.size() % 2 == 0) tmp.addLast(node.val); // 偶数层 -&gt; 队列头部
                else tmp.addFirst(node.val); // 奇数层 -&gt; 队列尾部
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            &#125;
            res.add(tmp);
        &#125;
        return res;
    &#125;
</code></pre>
<h2 id="二叉搜索树的后序"><a href="#二叉搜索树的后序" class="headerlink" title="二叉搜索树的后序"></a>二叉搜索树的后序</h2><pre><code>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。
每一层判断左右子树和根节点的大小关系，如果满足则继续向下判断；否则直接返回失败
递归分治 / 单调栈， 遍历顺序为 “左、右、根” 
    二叉搜索树定义： 左子树中所有节点的值 &lt; 根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。
    public boolean verifyPostorder(int[] postorder) &#123;
        return recur(postorder, 0, postorder.length - 1);
    &#125;
    boolean recur(int[] postorder, int i, int j) &#123;
        if(i &gt;= j) return true;
        int p = i;
        while(postorder[p] &lt; postorder[j]) p++;
        int m = p;
        while(postorder[p] &gt; postorder[j]) p++;
        return p == j &amp;&amp; recur(postorder, i, m - 1) &amp;&amp; recur(postorder, m, j - 1);
    &#125;
</code></pre>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><pre><code>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。
前序遍历：从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
 LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();
    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); 
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;
        recur(root, sum);
        return res;
    &#125;
    void recur(TreeNode root, int tar) &#123;
        if(root == null) return;
        path.add(root.val);
        tar -= root.val;
        if(tar == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)
            res.add(new LinkedList(path));
        recur(root.left, tar);
        recur(root.right, tar);
        path.removeLast();
    &#125;
</code></pre>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><pre><code>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
本文解法基于性质：二叉搜索树的中序遍历为 递增序列 。排序链表，双向链表。循环链表\
并在访问每个节点时构建 
cur 和前驱节点   pre 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可
中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 
head 和  pre 的双向节点引用即可。
Node pre, head;
    public Node treeToDoublyList(Node root) &#123;
        if(root == null) return null;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    &#125;
    void dfs(Node cur) &#123;
        if(cur == null) return;
        dfs(cur.left);
        if(pre != null) pre.right = cur;
        else head = cur;
        cur.left = pre;
        pre = cur;
        dfs(cur.right);
    &#125;
</code></pre>
<h2 id="序列化二叉树-层序遍历-BFS"><a href="#序列化二叉树-层序遍历-BFS" class="headerlink" title="序列化二叉树  层序遍历 BFS"></a>序列化二叉树  层序遍历 BFS</h2><pre><code>定义 StringBuilder 前序遍历拼接，删除最后一个逗号
 public String serialize(TreeNode root) &#123;
        if(root == null) return &quot;[]&quot;;
        StringBuilder res = new StringBuilder(&quot;[&quot;);
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
        while(!queue.isEmpty()) &#123;
            TreeNode node = queue.poll();
            if(node != null) &#123;
                res.append(node.val + &quot;,&quot;);
                queue.add(node.left);
                queue.add(node.right);
            &#125;
            else res.append(&quot;null,&quot;);
        &#125;
        res.deleteCharAt(res.length() - 1);
        res.append(&quot;]&quot;);
        return res.toString();
    &#125;

public TreeNode deserialize(String data) &#123;
    if(data.equals(&quot;[]&quot;)) return null;
    String[] vals = data.substring(1, data.length() - 1).split(&quot;,&quot;);
    TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
    int i = 1;
    while(!queue.isEmpty()) &#123;
        TreeNode node = queue.poll();
        if(!vals[i].equals(&quot;null&quot;)) &#123;
            node.left = new TreeNode(Integer.parseInt(vals[i]));
            queue.add(node.left);
        &#125;
        i++;
        if(!vals[i].equals(&quot;null&quot;)) &#123;
            node.right = new TreeNode(Integer.parseInt(vals[i]));
            queue.add(node.right);
        &#125;
        i++;
    &#125;
    return root;
&#125;
</code></pre>
<h2 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h2><pre><code>第k小的话，我觉得可以反过来遍历
class Solution &#123;
    int res, k;
    public int kthLargest(TreeNode root, int k) &#123;
        this.k = k;
        dfs(root);
        return res;
    &#125;
    void dfs(TreeNode root) &#123;
        if(root == null) return;
        dfs(root.right);
        if(k == 0) return;
        if(--k == 0) res = root.val;
        dfs(root.left);
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h2><pre><code>BST 的特性：BST 的中序遍历是升序序列。
通过构造 BST 的中序遍历序列，则第 k-1 个元素就是第 k 小的元素
方法一：递归
class Solution &#123;
  public ArrayList&lt;Integer&gt; inorder(TreeNode root, ArrayList&lt;Integer&gt; arr) &#123;
    if (root == null) return arr;
    inorder(root.left, arr);
    arr.add(root.val);
    inorder(root.right, arr);
    return arr;
  &#125;

  public int kthSmallest(TreeNode root, int k) &#123;
    ArrayList&lt;Integer&gt; nums = inorder(root, new ArrayList&lt;Integer&gt;());
    return nums.get(k - 1);
  &#125;
&#125;
</code></pre>
<h2 id="二叉树的深度（后序遍历）"><a href="#二叉树的深度（后序遍历）" class="headerlink" title="二叉树的深度（后序遍历）"></a>二叉树的深度（后序遍历）</h2><pre><code>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
方法一：后序遍历（DFS）
  public int maxDepth(TreeNode root) &#123;
        if(root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    &#125;

方法二：层序遍历（BFS）
class Solution &#123;
    public int maxDepth(TreeNode root) &#123;
        if(root == null) return 0;
        List&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;
        int res = 0;
        while(!queue.isEmpty()) &#123;
            tmp = new LinkedList&lt;&gt;();
            for(TreeNode node : queue) &#123;
                if(node.left != null) tmp.add(node.left);
                if(node.right != null) tmp.add(node.right);
            &#125;
            queue = tmp;
            res++;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><pre><code>递归，0.1，
class Solution &#123;
  public int minDepth(TreeNode root) &#123;
    if (root == null) &#123;
      return 0;
    &#125;

    if ((root.left == null) &amp;&amp; (root.right == null)) &#123;
      return 1;
    &#125;

    int min_depth = Integer.MAX_VALUE;
    if (root.left != null) &#123;
      min_depth = Math.min(minDepth(root.left), min_depth);
    &#125;
    if (root.right != null) &#123;
      min_depth = Math.min(minDepth(root.right), min_depth);
    &#125;

    return min_depth + 1;
  &#125;
&#125;
方法2:广度优先搜索迭代
class Solution &#123;
  public int minDepth(TreeNode root) &#123;
    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root == null) &#123;
      return 0;
    &#125;
    else &#123;
      stack.add(new Pair(root, 1));
    &#125;

    int current_depth = 0;
    while (!stack.isEmpty()) &#123;
      Pair&lt;TreeNode, Integer&gt; current = stack.poll();
      root = current.getKey();
      current_depth = current.getValue();
      if ((root.left == null) &amp;&amp; (root.right == null)) &#123;
        break;
      &#125;
      if (root.left != null) &#123;
        stack.add(new Pair(root.left, current_depth + 1));
      &#125;
      if (root.right != null) &#123;
        stack.add(new Pair(root.right, current_depth + 1));
      &#125;
    &#125;
    return current_depth;
  &#125;
&#125;
</code></pre>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><pre><code>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
方法一：后序遍历 + 剪枝 （从底至顶）
class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        return recur(root) != -1;
    &#125;

private int recur(TreeNode root) &#123;
    if (root == null) return 0;
    int left = recur(root.left);
    if(left == -1) return -1;
    int right = recur(root.right);
    if(right == -1) return -1;
    return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1;
&#125;
&#125;
方法二：先序遍历 + 判断深度 （从顶至底）
class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);
    &#125;

    private int depth(TreeNode root) &#123;
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><pre><code>用集合遍历根树，保存Hashmap
用set保存一个二叉树在集合中的结果
遍历另一个二叉树，看set中是否有，有则为最近公共祖先
方法一：迭代
class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        if(p.val &gt; q.val) &#123; // 保证 p.val &lt; q.val
            TreeNode tmp = p;
            p = q;
            q = tmp;
        &#125;
        while(root != null) &#123;
            if(root.val &lt; p.val) // p,q 都在 root 的右子树中
                root = root.right; // 遍历至右子节点
            else if(root.val &gt; q.val) // p,q 都在 root 的左子树中
                root = root.left; // 遍历至左子节点
            else break;
        &#125;
        return root;
    &#125;
&#125;
方法二：递归
class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)
            return lowestCommonAncestor(root.right, p, q);
        if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)
            return lowestCommonAncestor(root.left, p, q);
        return root;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h2><h2 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a>最小高度树</h2><pre><code>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。
二分，拿到中间元素，然后递归创建左右子树
class Solution &#123;
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        return createTree(nums, 0, n - 1);
    &#125;
    TreeNode* createTree(vector&lt;int&gt;&amp; nums, int start, int end) &#123;
        if (start &gt; end) return nullptr;
        int mid = (start + end) &gt;&gt; 1;
        TreeNode* root = new TreeNode(nums[mid]);
        root-&gt;left = createTree(nums, start, mid - 1);
        root-&gt;right = createTree(nums, mid + 1, end);
        return root;
    &#125;
&#125;;
</code></pre>
<h2 id="合法二叉搜索树"><a href="#合法二叉搜索树" class="headerlink" title="合法二叉搜索树"></a>合法二叉搜索树</h2><pre><code>实现一个函数，检查一棵二叉树是否为二叉搜索树。
双百，递归遍历树，分别检查左右根节点的大小
    public boolean isValidBST(TreeNode root) &#123;
        if(root==null) return true;
        return isValidBSThelp(root.left,Long.MIN_VALUE,root.val)&amp;&amp;isValidBSThelp(root.right,root.val,Long.MAX_VALUE);
    &#125;
    private boolean isValidBSThelp(TreeNode root,long min,long max)&#123;
        if(root==null) return true;
        if(root.val&lt;=min||root.val&gt;=max) return false;
        boolean left = isValidBSThelp(root.left,min,root.val);
        boolean right = isValidBSThelp(root.right,root.val,max);
        return left &amp;&amp; right;
    &#125;
</code></pre>
<h2 id="二叉树中最大路径和"><a href="#二叉树中最大路径和" class="headerlink" title="二叉树中最大路径和"></a>二叉树中最大路径和</h2><pre><code>给定一个非空二叉树，返回其最大路径和。
递归计算，更新max，（递归中返回较大的）
class Solution &#123;
    int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) &#123;
    maxGain(root);
    return maxSum;
&#125;

public int maxGain(TreeNode node) &#123;
    if (node == null) &#123;
        return 0;
    &#125;
    
    // 递归计算左右子节点的最大贡献值
    // 只有在最大贡献值大于 0 时，才会选取对应子节点
    int leftGain = Math.max(maxGain(node.left), 0);
    int rightGain = Math.max(maxGain(node.right), 0);

    // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
    int priceNewpath = node.val + leftGain + rightGain;

    // 更新答案
    maxSum = Math.max(maxSum, priceNewpath);

    // 返回节点的最大贡献值
    return node.val + Math.max(leftGain, rightGain);
&#125;
&#125;
</code></pre>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><pre><code>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
输入: 
    Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
         3
        / \
       4   5
      / \   \ 
     5   4   7
public class Solution &#123;
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;
        if (t1 == null)
            return t2;
        if (t2 == null)
            return t1;
        t1.val += t2.val;
        t1.left = mergeTrees(t1.left, t2.left);
        t1.right = mergeTrees(t1.right, t2.right);
        return t1;
    &#125;
&#125;
</code></pre>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><pre><code>public TreeNode invertTree(TreeNode root) &#123;
    if (root == null) &#123;
        return null;
    &#125;
    TreeNode right = invertTree(root.right);
    TreeNode left = invertTree(root.left);
    root.left = right;
    root.right = left;
    return root;
&#125;
</code></pre>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><pre><code>给定一个二叉树，我们在树的节点上安装摄像头。
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
计算监控树的所有节点所需的最小摄像头数量。
根据每个节点的左右子节点来判断当前节点的状态，因此左右根后续遍历
class Solution &#123;
public:
    //记录需要放置摄像头的数量
    int res = 0;
    int minCameraCover(TreeNode* root) 
    &#123;
        //后序遍历，从下自上遍历。
        //若遍历至最上面，root标志为0，则多加一个摄像头
        if(dfs(root) == 0)
        &#123;
            res++;  
        &#125;
        return res;
    &#125;
    int dfs(TreeNode* root)
    &#123;

    //0：未被覆盖(当前节点未被照到)
    //1：已被覆盖(摄像头已经照到这个节点)
    //2：需放置摄像头

    //到根节点，
    if(root == NULL) return 1;
    //遍历左节点
    int left = dfs(root-&gt;left);
    //遍历右节点
    int right = dfs(root-&gt;right);
    //一个节点左右确定后，判断左右节点情况
    //所有情况00,01,02,11,12,22
    //左右孩子中有一个未被覆盖，则当前节点需要放置摄像头，当前节点标志为2
    if(left ==0 || right==0)
    &#123;
        res++;
        return 2;
    &#125;
    //左右孩子均为已覆盖状态,则当前节点未被覆盖，标志为0
    if(left == 1 &amp;&amp; right == 1)
    &#123;
        return 0;
    &#125;
    //若左右孩子为一个覆盖一个放置了摄像头，则当前节点为已被覆盖，标志为1
    if(left+right &gt;= 3)
    &#123;
        return 1;
    &#125;
    //此时已经组合完了根节点所有情况，随便返回一个整数即可
    return 0;
&#125;
&#125;;
</code></pre>
<h2 id="验证二叉树"><a href="#验证二叉树" class="headerlink" title="验证二叉树"></a>验证二叉树</h2><pre><code>如果一棵树是一个二叉树的话 必定除了根节点 每个非空节点的入度都为1
样例还给了某一个节点被两个&quot;父节点&quot;引用的例子 那这个节点的入度就为2了 也就不能构成二叉树

public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) &#123;
    int[] in = new int[n];
    for (int i = 0; i &lt; n; i++) &#123;
        if (leftChild[i] != -1) in[leftChild[i]]++;
        if (rightChild[i] != -1) in[rightChild[i]]++;
    &#125;

    int count0 = 0;
    int countOther = 0;
    for (int temp : in) &#123;
        if (temp == 0) count0++;
        if (temp &gt; 1) countOther++;
    &#125;
    return count0 == 1 &amp;&amp; countOther == 0;
&#125;
</code></pre>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><pre><code>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：
二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。
public class Solution &#123;
    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;
        return construct(nums, 0, nums.length);
    &#125;
    public TreeNode construct(int[] nums, int l, int r) &#123;
        if (l == r)
            return null;
        int max_i = max(nums, l, r);
        TreeNode root = new TreeNode(nums[max_i]);
        root.left = construct(nums, l, max_i);
        root.right = construct(nums, max_i + 1, r);
        return root;
    &#125;
    public int max(int[] nums, int l, int r) &#123;
        int max_i = l;
        for (int i = l; i &lt; r; i++) &#123;
            if (nums[max_i] &lt; nums[i])
                max_i = i;
        &#125;
        return max_i;
    &#125;
&#125;
</code></pre>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><pre><code>给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。
class Solution &#123;
  public boolean helper(TreeNode node, Integer lower, Integer upper) &#123;
    if (node == null) return true;
    int val = node.val;
    if (lower != null &amp;&amp; val &lt;= lower) return false;
    if (upper != null &amp;&amp; val &gt;= upper) return false;

    if (! helper(node.right, val, upper)) return false;
    if (! helper(node.left, lower, val)) return false;
    return true;
&#125;

public boolean isValidBST(TreeNode root) &#123;
    return helper(root, null, null);
  &#125;
&#125;
</code></pre>
<h2 id="单值二叉树"><a href="#单值二叉树" class="headerlink" title="单值二叉树"></a>单值二叉树</h2><pre><code>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
我们先进行一次深度优先搜索，获取这颗树中的所有节点的值。然后，就可以判断所有节点的值是不是都相等了。
class Solution &#123;
    List&lt;Integer&gt; vals;
    public boolean isUnivalTree(TreeNode root) &#123;
        vals = new ArrayList();
        dfs(root);
        for (int v: vals)
            if (v != vals.get(0))
                return false;
        return true;
    &#125;

public void dfs(TreeNode node) &#123;
    if (node != null) &#123;
        vals.add(node.val);
        dfs(node.left);
        dfs(node.right);
    &#125;
&#125;
&#125;
方法二：递归
思路与算法
一颗树是单值的，当且仅当根节点的子节点所在的子树也是单值的，同时根节点的值与子节点的值相同。
class Solution &#123;
    public boolean isUnivalTree(TreeNode root) &#123;
        boolean left_correct = (root.left == null ||
                (root.val == root.left.val &amp;&amp; isUnivalTree(root.left)));
        boolean right_correct = (root.right == null ||
                (root.val == root.right.val &amp;&amp; isUnivalTree(root.right)));
        return left_correct &amp;&amp; right_correct;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><pre><code>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
方法：深度优先搜索
首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。
而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。
class Solution &#123;
    int ans;
    public int diameterOfBinaryTree(TreeNode root) &#123;
        ans = 1;
        depth(root);
        return ans - 1;
    &#125;
    public int depth(TreeNode node) &#123;
        if (node == null) return 0; // 访问到空节点了，返回0
        int L = depth(node.left); // 左儿子为根的子树的深度
        int R = depth(node.right); // 右儿子为根的子树的深度
        ans = Math.max(ans, L+R+1); // 计算d_node即L+R+1 并更新ans
        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的坡度"><a href="#二叉树的坡度" class="headerlink" title="二叉树的坡度"></a>二叉树的坡度</h2><pre><code>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。
整个树的坡度就是其所有节点的坡度之和。
输入：
         1
       /   \
      2     3
输出：1
解释：
结点 2 的坡度: 0
结点 3 的坡度: 0
结点 1 的坡度: |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1
方法：递归
我们需要求出该结点的左子树上所有结点和以及其右子树上全部结点和的差值。
在任何结点调用该函数，都会返回当前结点下面（包括其自身）的结点和。借助于任何结点的左右子结点的这一和值，我们可以直接获得该结点所对应的坡度。
public class Solution &#123;
    int tilt=0;
    public int findTilt(TreeNode root) &#123;
        traverse(root);
        return tilt;
    &#125;
    public int traverse(TreeNode root)
    &#123;
        if(root==null )
            return 0;
        int left=traverse(root.left);
        int right=traverse(root.right);
        tilt+=Math.abs(left-right);
        return left+right+root.val;
    &#125;
&#125;
</code></pre>
<h2 id="恢复一棵-BST"><a href="#恢复一棵-BST" class="headerlink" title="恢复一棵 BST"></a>恢复一棵 BST</h2><pre><code>二叉搜索树中的两个节点被错误地交换。
请在不改变其结构的情况下，恢复这棵树。
方法一：对数组进行排序
我们直到 BST 的中序遍历是升序序列。下面展示了如何计算中序遍历。
这里被交换了两个节点，因此中序遍历是一个几乎排好序的数组，其中有两个元素被交换。识别排序数组中两个交换元素是可以在线性时间内解决的经典问题。
public int[] findTwoSwapped(List&lt;Integer&gt; nums) &#123;
  int n = nums.size();
  int x = -1, y = -1;
  for(int i = 0; i &lt; n - 1; ++i) &#123;
    if (nums.get(i + 1) &lt; nums.get(i)) &#123;
      y = nums.get(i + 1);
      // first swap occurence
      if (x == -1) x = nums.get(i);
      // second swap occurence
      else break;
    &#125;
  &#125;
  return new int[]&#123;x, y&#125;;
&#125;
方法二：递归中序遍历
class Solution &#123;
  TreeNode x = null, y = null, pred = null;

  public void swap(TreeNode a, TreeNode b) &#123;
    int tmp = a.val;
    a.val = b.val;
    b.val = tmp;
  &#125;

  public void findTwoSwapped(TreeNode root) &#123;
    if (root == null) return;
    findTwoSwapped(root.left);
    if (pred != null &amp;&amp; root.val &lt; pred.val) &#123;
      y = root;
      if (x == null) x = pred;
      else return;
    &#125;
    pred = root;
    findTwoSwapped(root.right);
  &#125;

  public void recoverTree(TreeNode root) &#123;
    findTwoSwapped(root);
    swap(x, y);
  &#125;
&#125;
</code></pre>
<h2 id="求二叉树中叶子节点的个数"><a href="#求二叉树中叶子节点的个数" class="headerlink" title="求二叉树中叶子节点的个数"></a>求二叉树中叶子节点的个数</h2><pre><code>class Solution &#123;
    public int getLeafCount(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        if (root.left == null &amp;&amp; root.right == null) &#123;
            // 输出叶子节点
            System.out.println(&quot;leaf nodes:&quot; + root.val);
            return 1;
        &#125;
        return getLeafCount(root.left) + getLeafCount(root.right);
    &#125;
&#125;
</code></pre>
<h2 id="求二叉树第K层的节点个数"><a href="#求二叉树第K层的节点个数" class="headerlink" title="求二叉树第K层的节点个数"></a>求二叉树第K层的节点个数</h2><pre><code>  if (level == k)
    &#123;
        ++num;
        return num;
    &#125;
    _FindKLevel(root-&gt;_left, k, level + 1);
    _FindKLevel(root-&gt;_right, k, level + 1);
</code></pre>
<h2 id="求二叉树中最远的两个节点的距离"><a href="#求二叉树中最远的两个节点的距离" class="headerlink" title="求二叉树中最远的两个节点的距离"></a>求二叉树中最远的两个节点的距离</h2><pre><code>（1）如果具有最远距离的两个节点经过了根节点，那么最远的距离就是左边最深的深度加上右边最深的深度之和。
（2）如果具有最远距离的两个节点之间的路径不经过根节点，那么最远的距离就在根节点的其中一个子树上的两个叶子结点。

 int _Height(Node* root, int&amp; distance)
       &#123;
              if (root == NULL)
              &#123;
                     return 0;
              &#125;
              int leftH = _Height(root-&gt;_left);
              int rightH = _Height(root-&gt;_right);
              if (leftH+rightH &gt; distance)
              &#123;
                     distance = leftH + rightH;
              &#125;
              return leftH &gt; rightH ? leftH+1 : rightH+1;
</code></pre>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><pre><code>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
class Solution &#123;
    private TreeNode pre = null;
    private int[] ret;
    private int retCount = 0;
    private int maxCount = 0;
    private int currCount = 0;

public int[] findMode(TreeNode root) &#123;
    inOrder(root);
    pre = null;
    ret = new int[retCount];
    retCount = 0;
    currCount = 0;
    inOrder(root);
    return ret;
&#125;

private void inOrder(TreeNode root) &#123;
    if (root == null)
        return;
    inOrder(root.left);
    if (pre != null &amp;&amp; pre.val == root.val)
        currCount++;
    else
        currCount = 1;
    if (currCount &gt; maxCount) &#123;
        maxCount = currCount;
        retCount = 1;
    &#125;
    else if (currCount == maxCount) &#123;
        if (ret != null)
            ret[retCount] = root.val;
        retCount++;
    &#125;
    pre = root;
    inOrder(root.right);
&#125;
&#125;
</code></pre>
<h2 id="还原一棵二叉树"><a href="#还原一棵二叉树" class="headerlink" title="还原一棵二叉树"></a>还原一棵二叉树</h2><pre><code>根据前序遍历和中序遍历的结果还原一棵二叉树
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

前序遍历的第一个节点是根节点，只要找到根节点在中序遍历中的位置，在根节点之前被访
问的节点都位于左子树，在根节点之后被访问的节点都位于右子树，由此可知左子树和右子树分别有多少个节点。
不要看这个函数的参数很多，只是为了控制数组索引而已，本质上该算法也就是一个前序遍历。
class Solution &#123;
    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        if (preorder == null || preorder.length == 0) &#123;
            return null;
        &#125;
        Map&lt;Integer, Integer&gt; indexMap = new HashMap&lt;Integer, Integer&gt;(); // 存储位置
        int length = preorder.length;
        for (int i = 0; i &lt; length; i++) &#123;
            indexMap.put(inorder[i], i);
        &#125;
        TreeNode root = buildTree(preorder, 0, length - 1, inorder, 0, length - 1, indexMap);
        return root;
    &#125;

public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd, int[] inorder, int inorderStart, int inorderEnd, Map&lt;Integer, Integer&gt; indexMap) &#123;
    if (preorderStart &gt; preorderEnd) &#123;
        return null;
    &#125;
    int rootVal = preorder[preorderStart];
    TreeNode root = new TreeNode(rootVal);
    if (preorderStart == preorderEnd) &#123;
        return root;
    &#125; else &#123;
        int rootIndex = indexMap.get(rootVal);
        int leftNodes = rootIndex - inorderStart, rightNodes = inorderEnd - rootIndex;
        TreeNode leftSubtree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);
        TreeNode rightSubtree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);
        root.left = leftSubtree;
        root.right = rightSubtree;
        return root;
    &#125;
&#125;
&#125;
</code></pre>
<h2 id="二叉搜索树序列"><a href="#二叉搜索树序列" class="headerlink" title="二叉搜索树序列"></a>二叉搜索树序列</h2><pre><code>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉搜索树，输出所有可能生成此树的数组。
给定如下二叉树

        2
       / \
      1   3
返回：

[
   [2,1,3],
   [2,3,1]
]
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;vector&lt;int&gt;&gt; BSTSequences(TreeNode* root) &#123;
    
    if(root == nullptr) return &#123;&#123;&#125;&#125;;

    // queue 数据结构 并不是一个好的选项 
    // queue&lt;TreeNode*&gt; q;  // q 用于保存 前后顺序不影响最终BST结果的 节点
    deque&lt;TreeNode*&gt; q;
    vector&lt;int&gt; path;
    q.push_back(root);

    dfs(q, path);
    return res;
&#125;

void dfs(deque&lt;TreeNode*&gt;&amp; q, vector&lt;int&gt;&amp; path)&#123;
    // cout &lt;&lt; &quot;size of path:&quot; &lt;&lt; path.size() &lt;&lt;endl;
    if(q.empty()) &#123;
        res.push_back(path);
        return;
    &#125;

    int size = q.size();
    cout &lt;&lt; &quot;***&quot; &lt;&lt; q.size() &lt;&lt; endl;
    for(int i = 0; i &lt; size; i++)&#123;
        auto curr = q.front();
        q.pop_front();

        path.push_back(curr-&gt;val);
        if(curr &amp;&amp; curr-&gt;left) q.push_back(curr-&gt;left);
        if(curr &amp;&amp; curr-&gt;right) q.push_back(curr-&gt;right);
        
        dfs(q, path);

        // 回溯要保证 状态还原
        if(curr &amp;&amp; curr-&gt;left) q.pop_back();
        if(curr &amp;&amp; curr-&gt;right) q.pop_back();
        q.push_back(curr);
        
        path.pop_back();
    &#125;
&#125;
&#125;;
</code></pre>
<h2 id="二叉搜索树总结"><a href="#二叉搜索树总结" class="headerlink" title="二叉搜索树总结"></a>二叉搜索树总结</h2><pre><code>void BST(TreeNode root,int target) &#123;
    if(root.val == target) 
        //找到目标，做点什么
    if(root.val &lt; target) 
        BST(root.right, target);
    if(root.val &gt; target) 
        BST(root.left, target);
&#125;
</code></pre>
<h2 id="在BST中插入一个元素，在BST删除一个元素"><a href="#在BST中插入一个元素，在BST删除一个元素" class="headerlink" title="在BST中插入一个元素，在BST删除一个元素"></a>在BST中插入一个元素，在BST删除一个元素</h2><h2 id="快速计算完全二叉树的节点"><a href="#快速计算完全二叉树的节点" class="headerlink" title="快速计算完全二叉树的节点"></a>快速计算完全二叉树的节点</h2><h2 id="单调栈、单调队列的作用"><a href="#单调栈、单调队列的作用" class="headerlink" title="单调栈、单调队列的作用"></a>单调栈、单调队列的作用</h2><h2 id="双指针的使用技巧"><a href="#双指针的使用技巧" class="headerlink" title="双指针的使用技巧"></a>双指针的使用技巧</h2><pre><code>快慢指针：判断是否有环、环的起始位置、链表的中心点、链表的倒数第k的元素、去除有序数组的重复元素
左右指针：二分查找、翻转数组、
滑动窗口
</code></pre>
<h2 id="位运算相关"><a href="#位运算相关" class="headerlink" title="位运算相关"></a>位运算相关</h2><p>前缀和<br>字符串乘法<br>贪心：跳跃游戏<br>k个一组翻转链表<br>深度优先<br>1、全排列问题<br>2、一个环由个圈组成，把自然数1，2，…，N分别放在每一个圆内，数字的在两个相邻圈之和应该是一个素数。 注意：第一圈数应始终为1。<br>3、油田问题<br>4、棋盘问题</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/06/M_Swift143%E6%95%B0%E7%BB%84/" rel="prev" title="数组">
      <i class="fa fa-chevron-left"></i> 数组
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/06/M_Swift145%E4%BA%8C%E5%88%86%E5%8F%8A%E6%8E%92%E5%BA%8F/" rel="next" title="二分查找">
      二分查找 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.</span> <span class="nav-text">二叉树的前中后序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%EF%BC%88%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">二叉树的广度优先搜索 （从上到下打印二叉树）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">3.</span> <span class="nav-text">二叉树的深度优先搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84-%EF%BC%88%E5%88%A4%E6%96%ADB%E6%98%AF%E4%B8%8D%E6%98%AFA%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%82%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">树的子结构 （判断B是不是A的子结构。）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">5.</span> <span class="nav-text">二叉树的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.</span> <span class="nav-text">对称二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%90%8C%E4%B8%80%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E6%8C%89%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0"><span class="nav-number">7.</span> <span class="nav-text">从上到下打印二叉树 同一层的节点按从左到右的顺序打印</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">8.</span> <span class="nav-text">从上到下打印二叉树 之字形顺序打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">二叉搜索树的后序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">10.</span> <span class="nav-text">二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">11.</span> <span class="nav-text">二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-BFS"><span class="nav-number">12.</span> <span class="nav-text">序列化二叉树  层序遍历 BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-number">13.</span> <span class="nav-text">二叉搜索树的第k大节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">14.</span> <span class="nav-text">二叉搜索树中第K小的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%EF%BC%88%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%89"><span class="nav-number">15.</span> <span class="nav-text">二叉树的深度（后序遍历）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">16.</span> <span class="nav-text">二叉树的最小深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">17.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">18.</span> <span class="nav-text">二叉搜索树的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="nav-number">19.</span> <span class="nav-text">二叉树的最大宽度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91"><span class="nav-number">20.</span> <span class="nav-text">最小高度树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E6%B3%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">21.</span> <span class="nav-text">合法二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">22.</span> <span class="nav-text">二叉树中最大路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">23.</span> <span class="nav-text">合并二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">24.</span> <span class="nav-text">翻转二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">25.</span> <span class="nav-text">监控二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">26.</span> <span class="nav-text">验证二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">27.</span> <span class="nav-text">最大二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">28.</span> <span class="nav-text">验证二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">29.</span> <span class="nav-text">单值二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">30.</span> <span class="nav-text">二叉树的直径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6"><span class="nav-number">31.</span> <span class="nav-text">二叉树的坡度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E4%B8%80%E6%A3%B5-BST"><span class="nav-number">32.</span> <span class="nav-text">恢复一棵 BST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">33.</span> <span class="nav-text">求二叉树中叶子节点的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AC%ACK%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-number">34.</span> <span class="nav-text">求二叉树第K层的节点个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E8%BF%9C%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="nav-number">35.</span> <span class="nav-text">求二叉树中最远的两个节点的距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="nav-number">36.</span> <span class="nav-text">二叉搜索树中的众数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%98%E5%8E%9F%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">37.</span> <span class="nav-text">还原一棵二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%BA%8F%E5%88%97"><span class="nav-number">38.</span> <span class="nav-text">二叉搜索树序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%80%BB%E7%BB%93"><span class="nav-number">39.</span> <span class="nav-text">二叉搜索树总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8BST%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E5%9C%A8BST%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">40.</span> <span class="nav-text">在BST中插入一个元素，在BST删除一个元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">41.</span> <span class="nav-text">快速计算完全二叉树的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E3%80%81%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">42.</span> <span class="nav-text">单调栈、单调队列的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="nav-number">43.</span> <span class="nav-text">双指针的使用技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3"><span class="nav-number">44.</span> <span class="nav-text">位运算相关</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">303</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
