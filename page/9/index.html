<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift133%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift133%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:23" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:23+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="同步串行"><a href="#同步串行" class="headerlink" title="同步串行"></a>同步串行</h2><pre><code> // 队列引起的循环等待
//    dispatch_sync(dispatch_get_main_queue(), ^&#123;
//        [self print];
//    &#125;);
</code></pre>
<h2 id="同步并行"><a href="#同步并行" class="headerlink" title="同步并行"></a>同步并行</h2><pre><code>// 同步并行
//    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;
//        NSLog(@&quot;1&quot;);
//        dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;
//            NSLog(@&quot;2&quot;);
//        &#125;);
//        NSLog(@&quot;3&quot;);
//    &#125;);
//
</code></pre>
<h2 id="异步串行"><a href="#异步串行" class="headerlink" title="异步串行"></a>异步串行</h2><pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;
       NSLog(@&quot;1&quot;);
       
       [self performSelector:@selector(print) withObject:nil afterDelay:2];
       [[NSRunLoop currentRunLoop] run];
   &#125;);
   NSLog(@&quot;3&quot;);
    // 在gcd中开启的线程没有runloop，我们提交任务到runloop中是会失效的
     //而performSelector:withObject:afterDelay:其实就是在内部创建了一个NSTimer，
       //然后会添加到当前线程的Runloop中。所以当该方法添加到子线程中时，需要格外的注意两个地方
       // 因为子线程中的runloop默认是没有启动的状态。使用run方法开启当前线程的runloop，但是一定要注意run方法和执行该延迟方法的顺序。
       //而performSelector:withObject:afterDelay:其实就是在内部创建了一个NSTimer
       //所以在子线程中两者的顺序必须是先执行performSelector延迟方法之后再执行run方法。
   //因为run方法只是尝试想要开启当前线程中的runloop，但是如果该线程中并没有任何事件(source、timer、observer)的话，并不会成功的开启。
</code></pre>
<h2 id="异步并行"><a href="#异步并行" class="headerlink" title="异步并行"></a>异步并行</h2><p>NSOperation<br>需要和NSOperationQueue配合使用来实现多线程方案（如果直接start的话，是在主线程执行）<br>添加任务依赖<br>任务执行状态控制<br>最大并发量</p>
<p>NSOperation 实现多线程的使用步骤分为三步：</p>
<p>创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。<br>创建队列：创建 NSOperationQueue 对象。<br>将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。<br>凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行，感谢指正）<br>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。</p>
<p>系统是怎么移除一个isFinished=YES的NSOperation<br>通过KVO的方式</p>
<p>常用属性方法<br>判断操作状态方法</p>
<ul>
<li>(void)cancel; 可取消操作，实质是标记 isCancelled 状态。</li>
<li>(BOOL)isFinished; 判断操作是否已经结束。</li>
<li>(BOOL)isCancelled; 判断操作是否已经标记为取消。</li>
<li>(BOOL)isExecuting; 判断操作是否正在在运行。</li>
<li>(BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</li>
</ul>
<p>操作同步</p>
<ul>
<li>(void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。</li>
<li>(void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。</li>
<li>(void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li>(void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。<br>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。<br>NSOperationQueue 常用属性和方法</li>
</ul>
<p>取消/暂停/恢复操作</p>
<ul>
<li>(void)cancelAllOperations; 可以取消队列的所有操作。</li>
<li>(BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。</li>
<li>(void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。<br>操作同步</li>
<li>(void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。<br>添加/获取操作</li>
<li>(void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。</li>
<li>(void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束</li>
<li>(NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。</li>
<li>(NSUInteger)operationCount; 当前队列中的操作数。<br>获取队列</li>
</ul>
<ul>
<li>(id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。</li>
<li>(id)mainQueue; 获取主队列。</li>
</ul>
<p>NSThread启动流程<br>start-》创建pthread-〉main函数-》执行-〉结束</p>
<p>iOS常见的锁<br>@synchronized 一般创建单例对象的时候使用<br>atomic<br>修饰属性的关键字<br>对被修饰对象进行院子性操作（不负责使用）<br>atomic作用：多线程下将属性设置为atomic可以保证读取数据的一致性。因为他将保证数据只能被一个线程占用，也就是说一个线程对属性进行写操作时，会使用自旋锁锁住该属性。不允许其他的线程对其进行读取操作了。<br>简而言之，atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。<br>atomic修饰的实际上是这个指针，也就是占8个字节内存的指针，因此就不可能随意使用多线程来操作这块内存的。因为这块内存是原子性的。是线程安全的。<br>真正不安全的是指针指向的那块内存区域，他是非原子性的，当多个线程去操作这块内存的时候，就会出现不安全的情况。<br>OSSpinLock循环等待询问，不释放资源，用于轻量级数据访问，简单的int值+ 1 -1操作<br>NSLock 互斥锁<br>//主线程中<br>NSLock *lock = [[NSLock alloc] init];</p>
<p>//线程1<br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    [lock lock];<br>    NSLog(@”线程1”);<br>    sleep(2);<br>    [lock unlock];<br>    NSLog(@”线程1解锁成功”);<br>});</p>
<p>//线程2<br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    sleep(1);//以保证让线程2的代码后执行<br>    [lock lock];<br>    NSLog(@”线程2”);<br>    [lock unlock];<br>});<br>2016-08-19 14:23:09.659 ThreadLockControlDemo[1754:129663] 线程1<br>2016-08-19 14:23:11.663 ThreadLockControlDemo[1754:129663] 线程1解锁成功<br>2016-08-19 14:23:11.665 ThreadLockControlDemo[1754:129659] 线程2<br>NSLock 对象是在应用中用于协调多个线程操作<br>你不应该把这个类实现递归锁。如果在同一个线程上调用两次lock方法，将会对这个线程永久上锁。使用NSRecursiveLock类来才可以实现递归锁。<br>解锁一个没有被锁定的锁是一个程序错误，这个地方需要注意。<br>某个线程A调用lock方法。这样，NSLock将被上锁。可以执行“关键部分”，完成后，调用unlock方法。<br>如果，在线程A 调用unlock方法之前，另一个线程B调用了同一锁对象的lock方法。那么，线程B只有等待。直到线程A调用了unlock。<br>同一个线程不能连续两次调用加锁</p>
<p>NSRecursiveLock  递归锁<br>它允许同一线程多次加锁，而不会造成死锁。</p>
<p>发挥CPU多核（多线程）的优势</p>
<p>dispatch_semaphore_t 唤醒一个被动行为</p>
<p>GCD的常见作用<br>延迟执行dispatch_time<br>一次执行dispatch_once<br>dispatch_group_async的使用，调度，当所有任务执行完成之后再执行dispatch_group_notify<br>dispatch_barrier_async等待一些任务完成之后才能继续执行，使用barrier来等待之前任务完成，避免数据竞争等问题。<br>dispatch_semaphore信号量</p>
<p>多线程使用场景<br>类似聊天页的小视频和本地视频列表这样的tableView在显示视频的缩略图时，需要使用多线程来解决tableView的卡顿问题。因为对视频进行切图的操作是耗时的，如果在主线程进行，则会卡住tableView的滑动。<br>异步加载网络数据及解析<br>批量下载图片、图片压缩等处理，之后再刷新ui，<br>延迟执行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift132%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift132%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:17" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:17+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><pre><code>方法 URL 协议版本号 首部字段 实体
</code></pre>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><pre><code>版本 状态码 短语 首部字段 实体
</code></pre>
<h2 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h2><pre><code>GET、POST、HEAD、PUT、DELETE、OPTIONS
</code></pre>
<h2 id="HTTP三次握手"><a href="#HTTP三次握手" class="headerlink" title="HTTP三次握手"></a>HTTP三次握手</h2><pre><code>客户端发送SYN请求连接
服务端接受SYN，返回SYN和ACK
客户端接受SYN和ACK，返回服务端ACK
“第三次握手”是客户端向服务器端发送数据，这个数据就是要告诉服务器，客户端有没有收到服务器“第二次握手”时传过去的数据。若发送的这个数据是“收到了”的信息，接收后服务器就正常建立TCP连接，否则建立TCP连接失败，服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。
</code></pre>
<h2 id="HTTP四次挥手"><a href="#HTTP四次挥手" class="headerlink" title="HTTP四次挥手"></a>HTTP四次挥手</h2><pre><code>客户端发送FIN请求释放连接  FIN-WAIT-1阶段
服务端返回ACK，服务端处于准备断开状态  CLOSE-WAIT阶段（半关闭状态），客户端收到，进入FIN-WAIT-2阶段
服务端做好释放准备，再次向客户端发送FIN和ACK，LAST-ACK阶段
客户端收到FIN和ACK，发送ACK断开连接，TIME-WAIT阶段
随后客户端开始在TIME-WAIT阶段等待2MSL
服务端收到客户端LAST-ACK，进入CLOSED阶段。
与“三次挥手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续&quot;挥手&quot;，以此确保了&quot;四次挥手&quot;的顺利完成。
</code></pre>
<h2 id="为什么“握手”是三次，“挥手”却要四次？"><a href="#为什么“握手”是三次，“挥手”却要四次？" class="headerlink" title="为什么“握手”是三次，“挥手”却要四次？"></a>为什么“握手”是三次，“挥手”却要四次？</h2><pre><code>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。
释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。
</code></pre>
<h2 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL?"></a>为什么客户端在TIME-WAIT阶段要等2MSL?</h2><pre><code>为的是确认服务器端是否收到客户端发出的ACK确认报文
当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。

（1）序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
（2）确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
（3）标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：
URG：紧急指针（urgent pointer）有效。
ACK：确认序号有效。
PSH：接收方应该尽快将这个报文交给应用层。
RST：重置连接。
SYN：发起一个新连接。
FIN：释放一个连接。
</code></pre>
<h2 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h2><pre><code>无连接：HTTP的持久性
是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接
无状态：Cookie/Session
无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。
</code></pre>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><pre><code>即HTTP下加入SSL层
SSL/TLS协议提供的服务主要有：
1、认证用户和服务器，确保数据发送到正确的客户机和服务器；
2、加密数据以防止数据中途被窃取；
3、维护数据的完整性，确保数据在传输过程中不被改变。
SSL安全机制

1、身份验证机制
基于证书利用数字签名方法对服务器和客户端进行身份验证，其中客户端的身份验证是可选的。
2、数据传输的机密性
利用对称密钥算法对传输的数据进行加密。
3、消息完整性验证
消息传输过程中使用MAC算法来检验消息的完整性。
</code></pre>
<h2 id="TLS的主要增强内容"><a href="#TLS的主要增强内容" class="headerlink" title="TLS的主要增强内容"></a>TLS的主要增强内容</h2><pre><code>TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS 在SSL v3.0 的基础上，提供了以下增强内容：

1、更安全的MAC算法
2、更严密的警报
3、“灰色区域”规范的更明确的定义
</code></pre>
<h2 id="TLS对于安全性的改进"><a href="#TLS对于安全性的改进" class="headerlink" title="TLS对于安全性的改进"></a>TLS对于安全性的改进</h2><pre><code>1、对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。
2、增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。
3、改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。
4、一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。
5、特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。
</code></pre>
<h2 id="基本运行过程"><a href="#基本运行过程" class="headerlink" title="基本运行过程"></a>基本运行过程</h2><pre><code>1、客户端向服务器端索要并验证公钥。
2、双方协商生成&quot;对话密钥&quot;。
3、双方采用&quot;对话密钥&quot;进行加密通信。
其中，前两个阶段，被称为“握手阶段”。

TLS握手过程有单向验证和双向验证之分，简单解释一下，单向验证就是server端将证书发送给客户端，客户端验证server端证书的合法性等，例如百度、新浪、google等普通的https网站，双向验证则是不仅客户端会验证server端的合法性，同时server端也会验证客户端的合法性，例如银行网银登陆，支付宝登陆交易等。
1、确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
2、一个服务器生成的随机数（Sever Random），稍后用于生成&quot;对话密钥&quot;。
3、确认使用的加密方法，比如RSA公钥加密。
4、服务器证书（Certificate）。
5、支持的一些SSL/TLS扩展。

客户端需要对服务端的证书进行检查，如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥。然后，向服务器发送下面三项信息：

1、一个随机数（Pre Master Secret）。该随机数用服务器公钥加密，防止被窃听。
2、编码改变通知（Change Chiper Spec），表示随后的信息都将用双方商定的加密方法和密钥发送。
3、客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
</code></pre>
<h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><pre><code>&quot;不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。
</code></pre>
<h2 id="HTTPS通信的步骤"><a href="#HTTPS通信的步骤" class="headerlink" title="HTTPS通信的步骤"></a>HTTPS通信的步骤</h2><pre><code>①客户端发送报文进行SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件列表（加密算法及密钥长度等）。
②服务器应答，并在应答报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接受到的客户端加密组件内筛选出来的。
③服务器发送报文，报文中包含公开密钥证书。
④服务器发送报文通知客户端，最初阶段SSL握手协商部分结束。
⑤SSL第一次握手结束之后，客户端发送一个报文作为回应。报文中包含通信加密中使用的一种被称Pre-master secret的随机密码串。该密码串已经使用服务器的公钥加密。
⑥客户端发送报文，并提示服务器，此后的报文通信会采用Pre-master secret密钥加密。
⑦客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够完成成功，要以服务器是否能够正确解密该报文作为判定标准。
⑧服务器同样发送Change Cipher Spec报文。
⑨服务器同样发送Finished报文。
⑩服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。
⑪应用层协议通信，即发送HTTP响应。
⑫最后由客户端断开链接。断开链接时，发送close_nofify报文
</code></pre>
<h2 id="中间人攻击（charles抓包原理）"><a href="#中间人攻击（charles抓包原理）" class="headerlink" title="中间人攻击（charles抓包原理）"></a>中间人攻击（charles抓包原理）</h2><pre><code>流程如下：
1、截获客户端与服务器通信的通道
2、然后在 SSL 建立连接的时候，进行中间人攻击
3、将自己伪装成客户端，获取到服务器真实有效的 CA 证书（非对称加密的公钥）
4、将自己伪装成服务器，获取到客服端的之后通信的密钥（对称加密的密钥）
5、有了证书和密钥就可以监听之后通信的内容了
抓取https包的时候,青花瓷会要求使用者 对抓包的设备(手机或其他设备)
,安装一个证书,安装这个证书的时候,其实是安装了一个根证书(允许颁发CA的一个证书机构的根证书),当你安装了该根证书之后,该证书机构颁发的其他证书,默认都会被你的系统所信任,这个就是青花瓷完成https抓包的一个重要前提!!
</code></pre>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><pre><code>UDP协议：

无连接协议，也称透明协议，也位于传输层。
UDP通讯协议的特点：

将数据封装为数据包。面向无连接。
每个数据包大小限制在64K。
因为无连接，所以不可靠。
因为不需要建立连接，所以速度快。
UDP通讯是不分服务端和客服端的，只分发送端和接收端。

两者区别：

1） TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。
2） TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。
3） TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。
4） TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。
</code></pre>
<h2 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h2><pre><code>    基于连接（点对点）
    传输数据前需要建立好连接，然后在传输
    双工通信
    TCP连接一旦建立，就可以在连接上进行双向的通信
    基于字节流而非报文
    将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制能够保证TCP协议的有序性和完整性，因此TCP能够提供可靠性传输

    可靠传输
    拥塞控制
    慢启动，拥塞避免，拥塞发生，快速恢复四个算法
    流量控制能力
通过滑动窗口控制数据的发送速率，滑动窗口的本质是动态缓冲区，接收区根据自己的能力在TCP的header中动态调整窗口大小，通过ACK应答包通知给发送端，发送端根据窗口大小调控发送速率
</code></pre>
<h2 id="TCP传输是可靠的原因"><a href="#TCP传输是可靠的原因" class="headerlink" title="TCP传输是可靠的原因"></a>TCP传输是可靠的原因</h2><pre><code>（1）TCP协议采用发送应答机制，即发送端发送的每个
TCP报文段都必须得到接收方的应答，才能认为这个TCP报文段传输成功。
（2）TCP协议采用超时重传机制，发送端在发送出一个TCP报文
段之后启动定时器，如果在定时时间内未收到应答，它将重新发送该报文段。
（3）由于TCP报文段最终是以IP数据报发送的，而IP数
据报到达接收端可能乱序、重复、所以TCP协议还会将接收到的TCP报文段重排、整理、再交付给应用层。
TCP使用滑动窗口机制来进行流量控制。
建立连接时，各端分配一个缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给
另一端。接收方发送的确认消息中包含了自己剩余的缓冲区尺寸。剩余缓冲区空间的数
量叫做窗口。其实就是建立连接的双虎互相知道彼此剩余的缓冲区大小。
 （5）、拥塞控制
 拥塞控制：防止过多的数据注入到网路中，这样可以使网络中的路由器
 或链路不至于阻塞。拥塞控制是一个全局性的过程，和流量控制不同，流量控制是点对点的控制。
 2.拥塞避免：
 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的
 拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按照线性规律缓慢增长。
</code></pre>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><pre><code>DNS服务器一般分三种，根DNS服务器，顶级DNS服务器，权威DNS服务器。
1）浏览器缓存　　
2）系统缓存　　
3）路由器缓存　　　　
4） ISP（互联网服务提供商）DNS缓存
5）根域名服务器　　　
6）顶级域名服务器　　
8）保存结果至缓存
</code></pre>
<h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><pre><code>一般而言，用户上网的DNS服务器都是运营商分配的，所以，在这个节点上，运营商可以为所欲为。
例如，访问http://jiankang.qq.com/index.html，
正常DNS应该返回腾讯的ip，而DNS劫持后，会返回一个运营商的中间服务器ip。
访问该服务器会一致性的返回302，让用户浏览器跳转到预处理好的带广告的网页，
在该网页中再通过iframe打开用户原来访问的地址。
</code></pre>
<h2 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h2><pre><code>在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而
且是html类型请求，则拦截处理。后续做法往往分为2种，1种是类
似DNS劫持返回302让用户浏览器跳转到另外的地址，还有1种是在服务器返
回的HTML数据中插入js或dom节点（广告）。
</code></pre>
<p>Cookie<br>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。<br>服务器在向客户端回传相应的超文本的同时也会发回这些个人信息存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置<br>自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。<br>Cookie的maxAge决定着Cookie的有效期，单位为秒（Second）。Cookie中通过getMaxAge()方法与setMaxAge(int maxAge)方法来读写maxAge属性。 如果maxAge属性为正数，则表示该Cookie会在maxAge秒之后自动失效。<br>Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。读者可以通过上例的程序进行验证，设置不同的属性。</p>
<p>Session机制</p>
<p>除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。<br>Session技术则是服务端的解决方案，它是通过服务器来保持状态的。<br>URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。HttpServletResponse类提供了encodeURL(Stringurl)实现URL地址重写，例如：</p>
<p>Cookie与Session的区别</p>
<p>cookie数据存放在客户的浏览器上，session数据放在服务器上；<br>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；<br>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；<br>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；<br>Cookie和Session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，上面我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用（注意：有些资料说ASP解决这个问题，当浏览器的cookie被禁掉，服务端的session任然可以正常使用，ASP我没试验过，但是对于网络上很多用php和jsp编写的网站，我发现禁掉cookie，网站的session都无法正常的访问）。</p>
<p>如何保证cookie的安全<br>对cookie进行加密处理<br>只在https上携带cookie<br>设置cookie为httpOnly，防止跨站脚本攻击</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift131RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift131RunLoop/" class="post-title-link" itemprop="url">RunLoop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:11" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:11+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>概念<br>数据结构<br>事件循环机制<br>RunLoop和NStimer<br>RunLoop和多线程<br>RunLoop是通过内部维护的事件循环来对事件/消息进行管理的一个对象<br>没有消息需要处理时，休眠以避免资源占用<br>用户态-》核心态<br>有消息处理时，立即被唤醒<br>核心态-〉用户态</p>
<p>CFRunLoop<br>CFRunLoopMode<br>Source/Timer/Observer</p>
<p>source0<br>需要手动唤醒线程<br>source1<br>具备唤醒线程的能力</p>
<p>CFRunLoopObserver<br>观测时间点<br>kCFRunLoopEntry<br>kCFRunLoopBeforeTimers</p>
<p>CommonMode的特性<br>NSRunLoopCommonModes<br>commonMode不是实际存在的一种mode<br>是同步Source/Timer/Observer到多个Mode中的一种技术方案</p>
<p>如何实现一个常驻线程<br>给子线程添加RunLoop<br> @autoreleasepool {<br>    // 子线程对应的runloop需要自己创建并开启<br>    // 创建子线程对应的runloop,使子线程一直存在<br>    NSRunLoop *currentRunloop = [NSRunLoop currentRunLoop];<br>    // 给runloop添加一个基于port的事件(系统事件),让runloop的运行模式不为空,保证runloop不退出<br>    [currentRunloop addPort:[NSPort port] forMode:NSDefaultRunLoopMode];<br>    // 开启运行循环<br>    [currentRunloop run];<br>    }<br>利用 runloop 解释一下页面的渲染的过程？</p>
<p>当我们调用 [UIView setNeedsDisplay] 时，这时会调用当前 View.layer 的 [view.layer setNeedsDisplay]方法。</p>
<p>这等于给当前的 layer 打上了一个脏标记，而此时并没有直接进行绘制工作。而是会到当前的 Runloop 即将休眠，也就是 beforeWaiting 时才会进行绘制工作。</p>
<p>紧接着会调用 [CALayer display]，进入到真正绘制的工作。CALayer 层会判断自己的 delegate 有没有实现异步绘制的代理方法 displayer:，这个代理方法是异步绘制的入口，如果没有实现这个方法，那么会继续进行系统绘制的流程，然后绘制结束。</p>
<p>CALayer 内部会创建一个 Backing Store，用来获取图形上下文。接下来会判断这个 layer 是否有 delegate。</p>
<p>如果有的话，会调用 [layer.delegate drawLayer:inContext:]，并且会返回给我们 [UIView DrawRect:] 的回调，让我们在系统绘制的基础之上再做一些事情。</p>
<p>如果没有 delegate，那么会调用 [CALayer drawInContext:]。</p>
<p>以上两个分支，最终 CALayer 都会将位图提交到 Backing Store，最后提交给 GPU。</p>
<p>至此绘制的过程结束。</p>
<p>二 你在开发过程中怎么使用RunLoop？什么应用场景？</p>
<p>开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来的消息，处理其他事件）</p>
<p>在子线程中开启一个定时器</p>
<p>在子线程中进行一些长期监控</p>
<p>可以控制定时器在特定模式下运行</p>
<p>可以让某些事件（行为，任务）在特定模式下执行</p>
<p>可以添加observer监听RunLoop的状态，比如监听点击事件的处理（比如在所有点击事件前做一些处理）<br>   1）NSTimer</p>
<p>   2）ImageView显示：控制方法在特定的模式下可用</p>
<p>   3）PerformSelector</p>
<p>   4）常驻线程：在子线程中开启一个runloop</p>
<p>   5）自动释放池</p>
<pre><code>   第一次创建：进入runloop的时候

   最后一次释放：runloop退出的时候

   其它创建和释放：当runloop即将休眠的时候会把之前的自动释放池释放，然后重新创建一个新的释放池
</code></pre>
<p>// 高性能定时器<br>__block int timeout=300; //倒计时时间<br>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);<br>dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行<br>dispatch_source_set_event_handler(_timer, ^{<br>    if(timeout&lt;=0){ //倒计时结束，关闭<br>        dispatch_source_cancel(_timer);<br>        dispatch_async(dispatch_get_main_queue(), ^{<br>            //设置界面的按钮显示 根据自己需求设置<br>            NSLog(@”=====”)<br>        });</p>
<pre><code>&#125;else&#123;
    int minutes = timeout / 60;
    int seconds = timeout % 60;
    NSString *strTime = [NSString stringWithFormat:@&quot;%d分%.2d秒后重新获取验证码&quot;,minutes, seconds];
    dispatch_async(dispatch_get_main_queue(), ^&#123;
        NSLog(@&quot;*******&quot;);
    &#125;); 
    timeout--; 
&#125; 
</code></pre>
<p>});<br>dispatch_resume(_timer); </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift130Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift130Block/" class="post-title-link" itemprop="url">Block</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:06" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:06+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Block是将函数及其执行上下文封装起来的对象。</p>
<p>Block截获变量<br>对于基本数据类型的局部变量截获的是其值<br>对于对象类型的局部变量连同所有权修饰符一起截获（强引用）<br>以指针形式结果局部静态变量<br>不截获全局变量、全局静态变量</p>
<p>Block本质上是一个结构体，也有自己的isa<br>__block将修饰的变量变成了一个对象<br>a = 20 -&gt;  (a.__forwarding-&gt;a) = 20</p>
<p>本质<br>栈上的block<br>堆上的block（经过copy处理）<br>都有.__forwarding指针<br>栈上的__forwarding指向自己（变量）<br>经过copy后，栈上的.__forwarding指针指向了堆上的__block变量<br>.__forwarding存在的意义<br>不论任何内存位置都可以顺利访问统一个__block变量<br>Block不允许修改外部变量的值,这里所说的外部变量的值,指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有,就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</p>
<p>block类型：全局类型、栈类型、堆类型</p>
<p>栈上的block进行copy在MRC上会不会存在内存泄漏</p>
<p>block循环引用<br>__weak所有权修饰变量，是联通属性关键字拷贝的<br>__block 修改变量<br>__block自动变量的值，被copy进了Block，不带__block的自动变量只能在里面被访问<br>在MRC环境下，__block根本不会对指针所指向的对象执行copy操作，而只是把指针进行的复制。<br>而在ARC环境下，对于声明为__block的外部对象，在block内部会进行retain，以至于在block环境内能安全的引用外部对象。<br>__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。<br>为什么会产生循环引用</p>
<p>怎么理解block截获变量的特性</p>
<p>ARC环境下，一旦Block赋值就会触发copy，__block就会copy到堆上，Block也是__NSMallocBlock。ARC环境下也是存在__NSStackBlock的时候，这种情况下，__block就在栈上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift128OC%E5%B1%9E%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift128OC%E5%B1%9E%E6%80%A7/" class="post-title-link" itemprop="url">OC属性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:03" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:03+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="分类中l可以添加那些内容"><a href="#分类中l可以添加那些内容" class="headerlink" title="分类中l可以添加那些内容"></a>分类中l可以添加那些内容</h3><pre><code>实力方法
类方法
协议
属性（关联对象：）
</code></pre>
<h3 id="为什么不能添加属性"><a href="#为什么不能添加属性" class="headerlink" title="为什么不能添加属性"></a>为什么不能添加属性</h3><pre><code>我们知道在一个类中用@property声明属性，编译器会自动帮我们生成_成员变量和setter/getter，
但分类的指针结构体中，根本没有属性列表。所以在分类中用@property声明属性，
既无法生成_成员变量也无法生成setter/getter。
因此结论是：我们可以用@property声明属性，编译和运行都会通过，只要不使用程序也不会崩溃。
但如果调用了_成员变量和setter/getter方法，报错就在所难免了。
可以使用关联对象以及两个方法来模拟构成属性的三个要素。
</code></pre>
<h3 id="分类的结构"><a href="#分类的结构" class="headerlink" title="分类的结构"></a>分类的结构</h3><pre><code>Category 是表示一个指向分类的结构体的指针，其定义如下：
typedef struct objc_category *Category;
struct objc_category &#123;
  char *category_name                          OBJC2_UNAVAILABLE; // 分类名
  char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名
  struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表
  struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表
  struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表
&#125;
</code></pre>
<h3 id="类扩展与分类的区别如下："><a href="#类扩展与分类的区别如下：" class="headerlink" title="类扩展与分类的区别如下："></a>类扩展与分类的区别如下：</h3><pre><code>&gt;&gt; OC分类属于Runtime运行时特性，是OC语言独有的创新，其他编程语言所不具备这样的特性！ 类扩展属于编译器特性，在编译阶段就会被添加合并到原类中！
</code></pre>
<h3 id="分类是如何实现的"><a href="#分类是如何实现的" class="headerlink" title="分类是如何实现的"></a>分类是如何实现的</h3><pre><code>获取cls中未完成整合的所有分类 unattachendCategoriesForClass
将分类拼接到class上 attachCategories
倒序遍历所有分类
获取该分类的方法、协议添加到主类上
// 添加方法
rw-&gt;methods.attachLists(mlists,mcount);
// 添加类方法
rw-&gt;properties.attachLists(proplists,propcount);
// 添加协议
rw-&gt;properties.attachLists(protolists,protocount);
计算拼接后的元素总数，根据新的总数重新分配内存
重新设置元素总数
执行内存移位
</code></pre>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>分类添加的方法可以覆盖原类方法
原因：分类是在运行时添加到原类上的
同名分类方法是能生效决定于编译顺序（倒序遍历所有分类）
名字相同的分类会引起编译报错
</code></pre>
<h2 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h2><pre><code>关联对象的实现
获取其维护的一个HashMap，是一个全局容器
根据对象指针，查找对象对应的ObjectAssociationMap中的map
添加关联对象
</code></pre>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><pre><code>void objc_setAssociatedObject (id object, void*key, id value, objc_AssociationPolicy policy)
此方法以给定的键和策略为某对象设置关联值。
id objc_getAssociatedObject(id object, void *key)
此方法根据给定的键从某对象中获取相应的关联对象值。
void objc_removeAssociatedObjects(id object)
此方法移除指定对象的全部关联对象。
</code></pre>
<h3 id="为什么分类不能添加属性"><a href="#为什么分类不能添加属性" class="headerlink" title="为什么分类不能添加属性"></a>为什么分类不能添加属性</h3><pre><code>在runtime 中，objc_class 结构体大小是固定的，不可能往这里添加数据，只能修改。
所以，ivars 指向了一个固定区域，只能修改成员变量的值，不能增加成员变量的个数。
方法列表是一个二维数组，可以修改 *methodLists的值来增加成员方法，虽然没办法扩展methodLists指向的内存区域，
却可以改变这个内存区域的值（里面存的是指针），因此，可以动态添加方法，不可以添加成员变量。
</code></pre>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>编译时决定<br>只以声明的形式存在，多数情况下寄生于宿主的.m类中<br>不能为系统类添加扩展<br>类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（<br>用范围只能在自身类，而不是子类或其他地方）；<br>类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中<br>类扩展不能像类别那样拥有独立的实现部分（@implementation部分），也就是说，类扩展所声明的方法必须依托对应类的实现部分来实现。<br>其实.m文件中@interface和@implementation就是扩展声明和实现，扩展的实现必须依托原类</p>
<p>代理<br>代理模式是一种消息传递方式，一个完整的代理模式包括：委托对象、代理对象和协议。<br>代理属性使用weak<br>weak和assign是一种“非拥有关系”的指针，通过这两种修饰符修饰的指针变量，都不会改变被引用对象的引用计数。但是在一个对象被释放后，weak会自动将指针指向nil，而assign则不会。在iOS中，向nil发送消息时不会导致崩溃的，所以assign就会导致野指针的错误<br>代理更加面相过程，block则更面向结果。<br>从性能上来说，block的性能消耗要略大于delegate，因为block会涉及到栈区向堆区拷贝等操作，时间和空间上的消耗都大于代理。而代理只是定义了一个方法列表，在遵守协议对象的objc_protocol_list中添加一个节点，在运行时向遵守协议的对象发送消息即可。</p>
<p>通知<br>KVO<br>KVC<br>属性关键字</p>
<p>Objective-C具有相当多的动态特性，表现为三方面：动态类型（Dynamic typing）、动态绑定（Dynamic binding）和动态加载（Dynamic loading）。动态——必须到运行时（run time）才会做的一些事情。</p>
<p>动态类型：即运行时再决定对象的类型，这种动态特性在日常的应用中非常常见，简单来说就是id类型。事实上，由于静态类型的固定性和可预知性，从而使用的更加广泛。静态类型是强类型，而动态类型属于弱类型，运行时决定接受者。</p>
<p>动态绑定：基于动态类型，在某个实例对象被确定后，其类型便被确定了，该对象对应的属性和响应消息也被完全确定。</p>
<p>动态加载：根据需求加载所需要的资源，最基本就是不同机型的适配，例如，在Retina设备上加载@2x的图片，而在老一些的普通苹设备上加载原图，让程序在运行时添加代码模块以及其他资源，用户可根据需要加载一些可执行代码和资源，而不是在启动时就加载所有组件，可执行代码可以含有和程序运行时整合的新类。</p>
<p>#include与#import的区别、#import 与@class 的区别</p>
<p>#include 和#import其效果相同,都是查询类中定义的行为(方法);</p>
<p>#import不会引起交叉编译,确保头文件只会被导入一次；</p>
<p>@class 的表明,只定 义了类的名称,而具体类的行为是未知的,一般用于.h 文件；</p>
<p>@class 比#import 编译效率更高。<br> 解释 const, static, inline 关键字<br>const 修饰指针,或者常量,比如不可变,<br>static 修饰变量表示作用域,比如全局的私有变量,函数内部的 static 是内部的私有变量。<br>Static 修饰函数表示函数是文件作用域<br>Inline 表示内联。一般来说 inline 需要和 static 联合用 一般用法是 static inline int max(int a, int b) { </p>
<p>return a&gt;b?a:b; } </p>
<p>static inline作用是和宏类似,只不过是方便调试(宏不能断掉调 试,static inline 可以)。运行时候是一样的。<br>一般 c/c++短小的函数都用 static inline 内联函数 </p>
<p>load不是去类对象方法列表，遍历查找的，而是直接找到对象，拿到内存地址去调用的<br>先调用父类的load方法再调用子类的load方法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift129RunTime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift129RunTime/" class="post-title-link" itemprop="url">NSObject数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:02" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:02+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="object-class"><a href="#object-class" class="headerlink" title="object_class"></a>object_class</h2><p>继承:objc_object<br>内部：<br>Class superClass; 父类<br>cache_t cache;  缓存<br>class_data_bits_t bits  数据</p>
<p>isa指针关系<br>实例对象其指针指向类对象<br>类对象其指针指向元类对象</p>
<p>cache_t<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/45d409e77806">https://www.jianshu.com/p/45d409e77806</a><br>用散列表(哈希表)来缓存曾经调用过的方法，可以提高方法的查找速度，底层结构如下：<br>用于快速查找方法执行函数<br>是可增量扩展的哈希表结构<br>是局部性原理的最佳应用<br>cache 本质是一个 Hash表。存储bucket_t<br>bucket_t存储<br>cache_key_t _key;//@selector()<br>IMP _imp;//函数地址<br>哈希查找：发现当发生碰撞的时候，索引会+1，查找下一个。<br>槽位如果不够，_mask 会变换，变为原来的2倍，并且扩展槽位的时候，会清空数组里原有的缓存内容<br>子类没有实现方法会调用父类的方法，会将父类方法加入到子类自己的cache 里。<br>为什么要创建新的新的buckets来替换原有的buckets并抹掉原有的buckets的方案，而不是在在原有buckets的基础上进行扩容？<br>减少对方法快速查找流程的影响：调用objc_msgSend时会触发方法快速查找，如果进行扩容需要做一些读写操作，对快速查找影响比较大。<br>对性能要求比较高：开辟新的buckets空间并抹掉原有buckets的消耗比在原有buckets上进行扩展更加高效<br>当扩容后，会把新mask设置为newCapacity长度减一，然后清空缓存。<br>所有散列表(哈希表)的原理都是一样的，都是通过一个函数，这个函数传入一个key，通过这个key算出一个索引，如果索引冲突了就加一或者减一，直至不冲突为止，不同的就是算法不一样。</p>
<p>struct class_rw_t {<br>    uint32_t flags;<br>    uint32_t version;</p>
<pre><code>const class_ro_t *ro;

method_array_t methods;
property_array_t properties; //属性，和变量的区别，属性是名称，变量是值
protocol_array_t protocols;

Class firstSubclass;
Class nextSiblingClass;
</code></pre>
<p>};<br>class_rw_t结构体内有一个指向class_ro_t结构体的指针。</p>
<p>细看两个结构体的成员变量会发现很多相同的地方，他们都存放着当前类的属性、实例变量、方法、协议等等。区别在于：class_ro_t存放的是编译期间就确定的；而class_rw_t是在runtime时才确定，它会先将class_ro_t的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说class_rw_t是class_ro_t的超集，当然实际访问类的方法、属性等也都是访问的class_rw_t中的内容</p>
<p>哈希碰撞<br>开放地址法<br>链地址法</p>
<p>struct method_t {<br>    SEL name; //函数名<br>    const char *types; //编码（返回值类型、参数类型）<br>    IMP imp;//指向函数的指针（函数地址）<br>};</p>
<p>instance对象的isa指向class对象<br>class对象的isa指向meta-class对象<br>meta-class对象的isa指向基类的meta-class对象</p>
<p>发消息的步骤<br>检查target是不是nil    ObjC的特性允许对一个nil对象发消息而不会崩溃<br>通过isa，<br>对象方法查找类对象（类对象及继承链上找方法）<br>方法缓存列表，hashMap的结构，查找速度快<br>方法缓存找不到就查找类对象的方法列表中遍历class_rw_t，从后向前的遍历<br>查找父类的类对象—-同上，直至nsobjcect<br>类方法查找元类对象（元类对象及继承链上找方法）<br>方法缓存列表，hashMap的结构，查找速度快<br>方法缓存找不到就查找元类对象的方法列表中遍历class_rw_t，从后向前的遍历</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift126UI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift126UI/" class="post-title-link" itemprop="url">UI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:26:04" itemprop="dateCreated datePublished" datetime="2020-09-06T17:26:04+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>程序绘制流程<br>[UIView setNeedsDisplay];<br>[view.layer setNeedsDisplay];<br>[CALayer display];<br>[layer.delegate respondsTo:@selector(displayLayer:)];<br>yes-&gt; 异步绘制入口<br>no-&gt; 系统绘制流程<br>绘制是CPU和GPU共同协作的<br>通过CoreGraphics、CoreImage由CPU预处理，最终通过OpenGL ES将数据传送到屏幕<br>1、CoreAnimation提交会话，包括自己和子树（view hierarchy）的layout状态等；<br>2、RenderServer解析提交的子树状态，生成绘制指令；<br>3、GPU执行绘制指令；<br>4、显示渲染后的数据；<br>调用-setNeedsDisplay的时候，仅会设置图层为dirty。当渲染系统准备就绪，调用视图的-display方法，同时装配像素存储空间，建立一个CoreGraphics上下文（CGContextRef），将上下文push进上下文堆栈，绘图程序进入对应的内存存储空间。<br>渲染时机</p>
<p>上面已经提到过：Core Animation 在 RunLoop 中注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件 。当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。当Oberver监听的事件到来时，回调执行函数中会遍历所有待处理的UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。<br>打包layers并发送到渲染server；递归提交子树的layers；<br>如果子树太复杂，会消耗很大，对性能造成影响；</p>
<p>事件响应流程<br>点击屏幕-》UIApplication-〉UIWindow-》hitTest：withEvent：-〉pointInside：withEvent：<br>-》subviews-〉UIView-》倒序遍历-〉hitTest：withEvent：<br>hitTest：withEvent内部实现</p>
<p>GPU<br>顶点着色<br>图元装配<br>光栅化<br>片着色<br>片段处理</p>
<p>UI卡顿掉帧原理<br>Display 16.7ms<br>GPU<br>CPU<br>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>
<p>滑动优化方案<br>CPU<br>对象创建，调整，销毁<br>预排版（布局计算、文字计算）<br>预渲染（文字等异步绘制l、图片解码等）<br>GPU<br>纹理渲染<br>试图混合</p>
<p>离屏渲染<br>GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作<br>何时会触发<br>圆角（当和maskToBounds一起使用时）<br>图层蒙版<br>阴影<br>光栅化</p>
<p>问题：<br>UI事件的传递机制<br>使tableView滚动流畅的方案和思路<br>什么是离屏渲染<br>UIView和CALayer的关系</p>
<p>.dSYM文件</p>
<h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><p>layer给view提供了基础设施，使得绘制内容和呈现更高效动画更容易、更低耗<br>layer不参与view的事件处理、不参与响应链<br>layer的内容生成一个位图(bitmap)<br>,触发动画的时候，是把这个动画和状态信息传递给图形硬件，<br>图形硬件使用这两个数据就可以构造动画了。处理位图对于图形硬件更快。</p>
<p>阴影是根据layer的alpha值来生成的。模拟一下生成的过程：分配一块同样大小的shadowlayer,在原layer的alpha不为0的地方，shadowlayer填上shadowColor，就跟现实里的影子生成原理一样，不透明的部分才生成阴影。然后把这个shadowlayer做一个偏移(shadowOffset)加到原layer下面。<br>也就是阴影层是根据内容即时计算出来的，而且会触发离屏渲染，所以消耗巨大。</p>
<p>mask是一个layer层，并且作为背景层和组成层之间的一个遮罩层通道，默认是nil。并且如果要创建新的layer赋给mask，那么新的layer必须没有superlayer，也不支持含有子mask。</p>
<p>mask作用的也不只是当前layer的内容，而是layer和它所有子layer的合成内容。这个也是可以测试的，设置viewA的layer的mask,然后不管在viewA上加多少个视图都是会被mask作用到。</p>
<p>我们都知道控件view有一个alpha属性用来设置透明度，默认alpha＝1，只有当alpha不为0是我们才能正常的看到View的样子，alpha其实改变的是mask和background layer的透明度，来实现透明效果。而mask是控件view上的一层layer，mask也有一个alpha，要想看到view，只有当mask的透明度不为0时，我们才能看到mask后面的view的样子，view自带的masklayer是不透明的。新创建的masklayer的是透明的，因此，我们只需要给新创建的masklayer一个颜色，使他不透明就能看见蒙板后的View了，而蒙板外是透明的，这样就能实现蒙板效果了。原理大概是这样了。</p>
<p>如何高性能给UIImageView加圆角</p>
<p>如何使用核心动画？</p>
<p>创建<br>设置相关属性<br>添加到 CALayer 上，会自动执行动画</p>
<p>修改View的响应范围<br>重写View的</p>
<ul>
<li>(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;<br>hitTest：withEvent内部实现<br>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；<br>若返回NO,则hitTest:withEvent:返回nil;<br>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从top到bottom，即从subviews数组的末尾向前遍历,直到有子视图返回非空对象或者全部子视图遍历完毕；<br>若第一次有子视图返回非空对象,则hitTest:withEvent:方法返回此对象，处理结束；<br>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。<br>渲染具体步骤</li>
</ul>
<p>动画和屏幕上组合的图层实际上被一个单独的进程管理，即所谓的渲染服务。<br>当运行一段动画时，这个过程会被四个分离的阶段打破：</p>
<p>布局–准备视图的层级关系，设置图层属性<br>显示–图层的寄宿图片被绘制的阶段。涉及到-drawRect和-drawLayer:inContext：等方法<br>准备–准备发送动画数据给渲染服务的阶段。比如图片解码<br>提交–打包所有图层和动画属性，通过IPC发送到渲染服务<br>渲染服务拿到数据后，反序列化成一个叫做渲染树的图层树，使用这个树状结构，渲染服务队动画的每一帧做如下工作：</p>
<p>对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化三角形）来执行渲染<br>在屏幕上渲染可见的三角形<br>所以一共六个阶段：最后两个阶段在动画过程中不停地重复，前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你真正只能控制前两个阶段：布局和显示。剩下的在CoreAnimation内部处理。</p>
<p>1、帧率一般在多少？</p>
<p>60帧每秒；（TimeProfiler）<br>2、是否存在CPU和GPU瓶颈？ （查看占有率）</p>
<p>更少的使用CPU和GPU可以有效的保存电量；<br>3、额外的使用CPU来进行渲染？</p>
<p>重写了drawRect会导致CPU渲染；在CPU进行渲染时，GPU大多数情况是处于等待状态；<br>4、是否存在过多离屏渲染？</p>
<p>越少越好；离屏渲染会导致上下文切换，GPU产生idle；<br>5、是否渲染过多视图？</p>
<p>视图越少越好；透明度为1的视图更受欢迎；<br>6、使用奇怪的图片格式和大小？</p>
<p>避免格式转换和调整图片大小；一个图片如果不被GPU支持，那么需要CPU来转换。（Xcode有对PNG图片进行特殊的算法优化）<br>7、使用昂贵的特效？</p>
<p>理解特效的消耗，同时调整合适的大小；例如前面提到的UIBlurEffect；</p>
<p>8、视图树上不必要的元素？</p>
<p>理解视图树上所有点的必要性，去掉不必要的元素；忘记remove视图是很常见的事情，特别是当View的类比较大的时候。</p>
<p>性能优化实例<br>1、阴影<br>2、圆角<br>不要使用不必要的mask，可以预处理图片为圆形；或者添加中间为圆形透明的白色背景视图。即使添加额外的视图，会导致额外的计算；但仍然会快一点，因为相对于切换上下文，GPU更擅长渲染。<br>离屏渲染会导致GPU利用率不到100%，帧率却很低。（切换上下文会产生idle time）</p>
<p>3、工具</p>
<p>使用instruments的CoreAnimation工具来检查离屏渲染，黄色是我们不希望看到的颜色。</p>
<p>layoutSubviews<br>继承于UIView的子类重写，进行布局更新，刷新视图。如果某个视图自身的bounds或者子视图的bounds发生改变，那么这个方法会在当前runloop结束的时候被调用。为什么不是立即调用呢？因为渲染毕竟比较消耗性能，特别是视图层级复杂的时候。这种机制下任何UI控件布局上的变动不会立即生效，而是每次间隔一个周期，所有UI控件在布局上的变动统一生效并且在视图上更新，苹果通过这种高性能的机制保障了视图渲染的流畅性。<br>setNeedsLayout<br>标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，在下一轮runloop结束前刷新，对于这一轮runloop之内的所有布局和UI上的更新只会刷新一次，layoutSubviews一定会被调用。<br>layoutIfNeeded<br>如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）</p>
<p>如果想在当前runloop中立即刷新，调用顺序应该是<br>[self setNeedsLayout];<br>[self layoutIfNeeded];</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/02/M_Swift111%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/02/M_Swift111%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-02 17:41:21" itemprop="dateCreated datePublished" datetime="2020-07-02T17:41:21+08:00">2020-07-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Http三次握手"><a href="#Http三次握手" class="headerlink" title="Http三次握手"></a>Http三次握手</h2><pre><code>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。  
第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入
SYN_SEND状态，等待服务器确认； 
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己
也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包
ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完
成三次握手。完成三次握手，客户端与服务器开始传送数据.
</code></pre>
<h2 id="HTTPS-SSL"><a href="#HTTPS-SSL" class="headerlink" title="HTTPS SSL"></a>HTTPS SSL</h2><pre><code>客户端请求建立SSL连接，发送支持的加密方式以及一个随机数client 
random给服务器；
服务器选择其中的一种加密方式，并且再加上另外一个随机数server 
random，和数字证书（其中有公钥），发送给客户端；
客户端确认这个数字证书是有效的，并且再生成一个新的随机数，将这个随机数
用服务器发送给它的数字证书中的公钥进行加密发送给服务器；
服务器收到客户端的回复，利用自己的私钥进行解密，获得这个随机数，然后通
过将前面这三个随机数以及他们协商的加密方式，计算生成一个对称密钥。
释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，
因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。
所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因
</code></pre>
<h2 id="iOS-如何做才安全"><a href="#iOS-如何做才安全" class="headerlink" title="iOS 如何做才安全:"></a>iOS 如何做才安全:</h2><pre><code>1、ipa包加壳
2、敏感信息存储位置
3、设备安全(越狱，丢失)
4、APP反编译(逆向工程)
5、代码内容加密(对称加密/非对称加密)
6、安全密钥更新周期
7、代码混淆
8、接口安全(双向加密)
9、通讯安全，第三方库漏洞
10、敏感信息安全加密
11、通讯网络安全
12、代码调试信息安全管理
</code></pre>
<h2 id="OSI七层协议中每层分别有哪些协议"><a href="#OSI七层协议中每层分别有哪些协议" class="headerlink" title="OSI七层协议中每层分别有哪些协议"></a>OSI七层协议中每层分别有哪些协议</h2><pre><code>1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种
传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强
弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数
转换）。这一层的数据叫做比特。
2.数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介
质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。
3.网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选
择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层
正是管理这种连接的层。
4.传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：
TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量
大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要
求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是
将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一
层数据叫做段。
5.会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。
主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是
IP也可以是MAC或者是主机名）
6.表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读
取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进
制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示
相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间
的转换。
7.应用层： 是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮
件、文件传输和终端仿真）提供网络服务。
</code></pre>
<h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><pre><code>对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥
加密
也就是密钥也可以用作解密密钥，这种方法在密码学中叫做对称加密算法，对称
加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准
（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的
加密性好，而且对计算机功能要求也没有那么高
常见的对称加密算法有DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和
AES 
非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥
（privatekey）。
公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私
有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥
才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称
加密算法。
非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的
一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息
进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息
进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。
非对称加密的典型应用是数字签名。
常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、
El Gamal、DSA（数字签名用）
Hash算法（摘要算法）
Hash算法特别的地方在于它是一种单向算法，用户可以通过hash算法对目标信
息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信
息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。
常见的Hash算法有MD2、MD4、MD5、HAVAL、SHA
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/02/M_Swift113OC%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/02/M_Swift113OC%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">OC常见问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-02 17:29:42" itemprop="dateCreated datePublished" datetime="2020-07-02T17:29:42+08:00">2020-07-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="函数式编程和响应式编程"><a href="#函数式编程和响应式编程" class="headerlink" title="函数式编程和响应式编程"></a>函数式编程和响应式编程</h2><pre><code>https://blog.csdn.net/johnwcheung/article/details/73136476
函数式编程是一系列被不公平对待的编程思想的保护伞，它的核心思想是，它是
一种将程序看成是数学方法的求值、不会改变状态、不会产生副作用（后面我们
马上会谈到）的编程方式。
响应式实际上是观察者模式加上事件源的完成通知能力、错误传播能力和监听者
同事件源通信的能力。
</code></pre>
<h2 id="TMCache"><a href="#TMCache" class="headerlink" title="TMCache"></a>TMCache</h2><pre><code>https://www.jianshu.com/p/a8a45c12d2d2
</code></pre>
<h2 id="NSProxy"><a href="#NSProxy" class="headerlink" title="NSProxy"></a>NSProxy</h2><pre><code>https://www.jianshu.com/p/32c63dbc1b05
负责将消息转发到真正的target的代理类
NSProxy是和NSObject同级的一个类,可以说它是一个虚拟类,它只是实现了
&lt;NSObject&gt;的协议.它的作用有点类似于一个复制类,有人曾经笑谈它是卡卡
西的复制忍术,想想其实也挺贴切的,其实原理确实如此.
用一个继承于NSProxy的子类,在它内部实现一些方法,暴露一个公开方法
transform,这个方法是使它变身的关键.然后它变身之后可以对那些对象发送
消息,并且可以在内部拦截消息的内容并修改.
可以说,几乎可以变身成为任何对象.
</code></pre>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><pre><code>原有的单工程架构就不足以满足架构需求了
业务模块间划分不清晰，模块之间耦合度很大，非常难维护。
所有模块代码都编写在一个项目中，测试某个模块或功能，需要编译运行整个项目。
组件化优点：
业务划分更佳清晰，新人接手更佳容易，可以按组件分配开发任务。
项目可维护性更强，提高开发效率。
更好排查问题，某个组件出现问题，直接对组件进行处理。
开发测试过程中，可以只编译自己那部分代码，不需要编译整个项目代码。
实现：
MGJRouter是一个单例对象，在其内部维护着一个“URL -&gt; block”格式的注
册表，通过这个注册表来保存服务方注册的block，以及使调用方可以通过URL
映射出block，并通过MGJRouter对服务方发起调用。
在服务方组件中都对外提供一个接口类，在接口类内部实现block的注册工作，
以及block对外提供服务的代码实现。每一个block都对应着一个URL，调用方
可以通过URL对block发起调用。
在程序开始运行时，需要将所有服务方的接口类实例化，以完成这个注册工作，
使MGJRouter中所有服务方的block可以正常提供服务。在这个服务注册完成
后，就可以被调用方调起并提供服务。
Protocol方案的中间件
为了解决MGJRouter方案中URL硬编码，以及字典参数类型不明确等问题，蘑
菇街在原有组件化方案的基础上推出了Protocol方案。Protocol方案由两部
分组成，进行组件间通信的ModuleManager类以及
MGJComponentProtocol协议类。
通过中间件ModuleManager进行消息的调用转发，在ModuleManager内部维
护一张映射表，映射表由之前的&quot;URL -&gt; block&quot;变成&quot;Protocol -&gt; 
Class&quot;。
在中间件中创建MGJComponentProtocol文件，服务方组件将可以用来调用
的方法都定义在Protocol中，将所有服务方的Protocol都分别定义到
MGJComponentProtocol文件中，如果协议比较多也可以分开几个文件定
义。这样所有调用方依然是只依赖中间件，不需要依赖除中间件之外的其他组
件。
Protocol方案中每个组件也需要一个“接口类”，此类负责实现当前组件对应的
协议方法，也就是对外提供服务的实现。在程序开始运行时将自身的Class注册
到ModuleManager中，并将Protocol反射出字符串当做key。这个注册过程
和MGJRouter是类似的，都需要提前注册服务。
蘑菇街是OpenURL和Protocol混用的方式，两种实现的调用方式不同，但大体
调用逻辑和实现思路类似，所以下面的调用流程二者差不多。在OpenURL不能
满足需求或调用不方便时，就可以通过Protocol的方式调用。
整体调用流程
在进入程序后，先使用MGJRouter对服务方组件进行注册。每个URL对应一个
block的实现，block中的代码就是服务方对外提供的服务，调用方可以通过
URL调用这个服务。
调用方通过MGJRouter调用openURL:方法，并将被调用代码对应的URL传
入，MGJRouter会根据URL查找对应的block实现，从而调用服务方组件的代
码进行通信。
调用和注册block时，block有一个字典用来传递参数。这样的优势就是参数类
型和数量理论上是不受限制的，但是需要很多硬编码的key名在项目中。
内存管理
蘑菇街组件化方案有两种，Protocol和MGJRouter的方式，但都需要进行
register操作。Protocol注册的是Class，MGJRouter注册的是Block，
注册表是一个NSMutableDictionary类型的字典，而字典的拥有者又是一个
单例对象，这样会造成内存的常驻。
下面是对两种实现方式内存消耗的分析：
首先说一下block实现方式可能导致的内存问题，block如果使用不当，很容易
造成循环引用的问题。
经过暴力测试，证明并不会导致内存问题。被保存在字典中是一个block对象，
而block对象本身并不会占用多少内存。在调用block后会对block体中的方法
进行执行，执行完成后block体中的对象释放。
而block自身的实现只是一个结构体，也就相当于字典中存放的是很多结构体，
所以内存的占用并不是很大。
对于协议这种实现方式，和block内存常驻方式差不多。只是将存储的block对
象换成Class对象，如果不是已经实例化的对象，内存占用还是比较小的。
</code></pre>
<h2 id="RAC"><a href="#RAC" class="headerlink" title="RAC"></a>RAC</h2><pre><code>https://www.jianshu.com/p/addad51569a1
</code></pre>
<h2 id="JSPathch"><a href="#JSPathch" class="headerlink" title="JSPathch"></a>JSPathch</h2><pre><code>能做到通过JS调用和改写OC方法最根本的原因是 Objective-C 是动态语
言，OC上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行
时进行，我们可以通过类名/方法名反射得到相应的类和方法：
对于 Objective-C 对象模型和动态消息发送的原理已有很多文章阐述得很详
细，例如这篇，这里就不详细阐述了。理论上你可以在运行时通过类名/方法名
调用到任何OC方法，替换任何类的实现以及新增任意类。所以 JSPatch 的原
理就是：JS传递字符串给OC，OC通过 Runtime 接口调用和替换OC方法。这
是最基础的原理，实际实现过程还有很多怪要打，接下来看看具体是怎样实现
的。
</code></pre>
<h2 id="NSMutableArray的实现，包括系统提供的常用API的实现"><a href="#NSMutableArray的实现，包括系统提供的常用API的实现" class="headerlink" title="NSMutableArray的实现，包括系统提供的常用API的实现"></a>NSMutableArray的实现，包括系统提供的常用API的实现</h2><pre><code>用链表，每十个放在一段连续的存储空间里
https://www.jianshu.com/p/3c77756a86ab    
</code></pre>
<h2 id="NSUserDefaults存储对象"><a href="#NSUserDefaults存储对象" class="headerlink" title="NSUserDefaults存储对象"></a>NSUserDefaults存储对象</h2><pre><code>NSUserDefaults支持的数据类型有：NSNumber（NSInteger、float、
double），NSString，NSDate，NSArray，NSDictionary，BOOL.
NSUserDefaults 存储的对象全是不可变的（这一点非常关键，弄错的话程序
会出bug），例如，如果我想要存储一个NSMutableArray 对象，我必须先创
建一个不可变数组（NSArray）再将它存入NSUserDefaults中去
使用 NSUserDefaults 存储自定义对象
第一步、将自定义类型转换为NSData类型，利用归档
NSData*data = 
[NSKeyedArchiverarchivedDataWithRootObject:student];
</code></pre>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><pre><code>纯函数 我们应该还记得初中的一些数学知识，函数f的概念就是，对于输入x产
生一个输出y=f（x），这就是普通的纯函数。它的定义是 相同的输入，结果总
会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。
</code></pre>
<h2 id="沙盒存储的路径是NSDocument还是NSLibrary，mainbuneld在哪"><a href="#沙盒存储的路径是NSDocument还是NSLibrary，mainbuneld在哪" class="headerlink" title="沙盒存储的路径是NSDocument还是NSLibrary，mainbuneld在哪"></a>沙盒存储的路径是NSDocument还是NSLibrary，mainbuneld在哪</h2><pre><code>沙盒根目录里有三个文件夹：
Documents，一般应该把应用程序的数据文件存到这个文件夹里，用于存储用
户数据或其他应该定期备份的信息。因为应用的沙盒机制，应用只能在几个目录
下读写文件。苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目
录下，iTunes备份和恢复的时候会包括此目录。
Library，存储程序的默认设置或其它状态信息，其下有两个文件夹：Caches
存储应用程序再次启动所需的信息，存放缓存文件，iTunes不会备份此目录，
此目录下文件不会在应用退出删除；Preferences包含应用程序偏好设置文
件，不过不要在这里修改偏好设置。
tmp，提供一个即时创建临时文件的地方，即应用程序再次启动不需要的文件。
通常来说，这个 mainbundle 就是 当前的可执行app 的在根目录下的绝对
路径，
</code></pre>
<h2 id="反射方法"><a href="#反射方法" class="headerlink" title="反射方法"></a>反射方法</h2><pre><code>系统Foundation框架为我们提供了一些方法反射的API，我们可以通过这些
API执行将字符串转为SEL等操作。由于OC语言的动态性，这些操作都是发生在
运行时的。
通过这些方法，我们可以在运行时选择创建那个实例，并动态选择调用哪个方
法。这些操作甚至可以由服务器传回来的参数来控制，我们可以将服务器传回来
的类名和方法名，实例为我们的对象。
Class class = NSClassFromString(@&quot;ViewController&quot;);
ViewController *vc = [[class alloc] init];
SEL selector = NSSelectorFromString(@&quot;getDataList&quot;);
[vc performSelector:selector];
判断方法
在NSObject类中为我们提供了一些基础方法，用来做一些判断操作，这些方法都是发生在运行时动态判断的
// 当前对象是否这个类或其子类的实例
- (BOOL)isKindOfClass:(Class)aClass;
// 当前对象是否是这个类的实例
- (BOOL)isMemberOfClass:(Class)aClass;
// 当前对象是否遵守这个协议
- (BOOL)conformsToProtocol:(Protocol *)aProtocol;
// 当前对象是否实现这个方法
- (BOOL)respondsToSelector:(SEL)aSelector;    
</code></pre>
<h2 id="链表与数组的区别"><a href="#链表与数组的区别" class="headerlink" title="链表与数组的区别"></a>链表与数组的区别</h2><pre><code>链表的特性是在中间任意位置添加删除元素的都非常的快，不需要移动其它的元
素。通常链表每一个元素都要保存一个指向下一个元素的指针（单链表）。双链
表的话每个元素即要保存到下一个元素的指针，还要保存一个上一个元素的指
针。循环链表则把最后一个元素中保存下一个元素指针指向第一个元素。   
数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素,每个
数组元素都有一个编号,这个编号叫做下标,我们可以通过下标来区别这些元素。
数组元素的个数有时也称之为数组的长度。  
数组是将元素在内存中连续存放，由于每个元素占用内存相同，所以你可以通过
下标迅速访问数组中任何元素。但是如果你要在数组中增加一个元素，你需要移
动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同
样的道理，如果你想删除一个元素，你同样需要移动大量元素去填掉被移动的元
素。 
链表恰好相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的
指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到
最后一个元素。如果你要访问链表中一个元素，你需要从第一个元素开始，一直
找到你需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单
了， 只要修改元素中的指针就可以了。
</code></pre>
<h2 id="设置了成员变量—str，属性里面也设置了-synchronized-property（）str，两种写法有什么区别"><a href="#设置了成员变量—str，属性里面也设置了-synchronized-property（）str，两种写法有什么区别" class="headerlink" title="设置了成员变量—str，属性里面也设置了@synchronized @property（）str，两种写法有什么区别"></a>设置了成员变量—str，属性里面也设置了@synchronized @property（）str，两种写法有什么区别</h2><pre><code>1)在.h头文件中:
@property在头文件中应用于声明:
@property NSInteger age;
编译器会自动在.h头文件中声明了2个方法:(setter,getter方法)
- (NSInteger)age;      - (void)setAge:(NSInteger)age;
2)在.m实现文件中:
@sythesize在.m实现文件中应用于实现:
例如:
@synthesize age = _age; 
编译器会自动在.m文件中实现2个方法:(setter,getter方法)
- (void)setAge:(NSInteger)age
&#123;
_age  =  age;
&#125;
- (NSInteger)age
&#123;
return   _age;
&#125;
</code></pre>
<h2 id="组件化路由的实现方式（有url，meditor，自己的组件路由）"><a href="#组件化路由的实现方式（有url，meditor，自己的组件路由）" class="headerlink" title="组件化路由的实现方式（有url，meditor，自己的组件路由）"></a>组件化路由的实现方式（有url，meditor，自己的组件路由）</h2><h2 id="Masonry-update-remake区别"><a href="#Masonry-update-remake区别" class="headerlink" title="Masonry update remake区别"></a>Masonry update remake区别</h2><pre><code>mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针
对于同一对象的约束 否则会报错
mas_updateConstraints 针对上面的情况 会更新在block中出现的约
束 不会导致出现两个相同约束的情况
mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束
</code></pre>
<h2 id="常见动画"><a href="#常见动画" class="headerlink" title="常见动画"></a>常见动画</h2><pre><code>https://www.jianshu.com/p/9aead7675221
</code></pre>
<h2 id="分类和原来的类都有某个方法，如何保证安全性和规范性"><a href="#分类和原来的类都有某个方法，如何保证安全性和规范性" class="headerlink" title="分类和原来的类都有某个方法，如何保证安全性和规范性"></a>分类和原来的类都有某个方法，如何保证安全性和规范性</h2><pre><code>1.添加警告
2.分类中方法执行完再执行原类方法
</code></pre>
<h2 id="设备唯一码怎么获取"><a href="#设备唯一码怎么获取" class="headerlink" title="设备唯一码怎么获取"></a>设备唯一码怎么获取</h2><pre><code>当我们从真机上卸载这个软件重新安装的时候，UUID变了(模拟器每次都变)，
对，确实变了
keychain的使用
keychain的使用确实帮我们解决了这个问题，我们可以在第一次生成我们需要
的UUID的时候，保存他，然后就用keychain里保存的值来代替他的UUID，这
样卸载之后，生成新的UUID，但是keychain里的数据是不会消失的，这样就
实现了唯一识别码的目的。
</code></pre>
<h2 id="GCD在什么场景下会死锁，代码怎么写"><a href="#GCD在什么场景下会死锁，代码怎么写" class="headerlink" title="GCD在什么场景下会死锁，代码怎么写"></a>GCD在什么场景下会死锁，代码怎么写</h2><pre><code>http://ios.jobbole.com/82622/
</code></pre>
<h2 id="GCD和NSOperationQueue都可以调整队列执行顺序吗？如何调整"><a href="#GCD和NSOperationQueue都可以调整队列执行顺序吗？如何调整" class="headerlink" title="GCD和NSOperationQueue都可以调整队列执行顺序吗？如何调整"></a>GCD和NSOperationQueue都可以调整队列执行顺序吗？如何调整</h2><h2 id="链表的单个节点的删除"><a href="#链表的单个节点的删除" class="headerlink" title="链表的单个节点的删除"></a>链表的单个节点的删除</h2><pre><code>实现一个算法，删除单向链表中间的某个结点，假定你只能访问该结点。 
给定带删除的节点，请执行删除操作，若该节点为尾节点，返回false，否则返回true 
算法思路： 
利用该节点可以访问其下一个节点，可以将下一个节点的值复制给该节点，将下一个节点删除。
</code></pre>
<h2 id="如何去让一部分对象调原来的类的方法，一部分对象调分类里的方法？（方法列表有反射机制，可以用runtime）"><a href="#如何去让一部分对象调原来的类的方法，一部分对象调分类里的方法？（方法列表有反射机制，可以用runtime）" class="headerlink" title="如何去让一部分对象调原来的类的方法，一部分对象调分类里的方法？（方法列表有反射机制，可以用runtime）"></a>如何去让一部分对象调原来的类的方法，一部分对象调分类里的方法？（方法列表有反射机制，可以用runtime）</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/02/M_Swift108%E9%80%9A%E7%9F%A5%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/02/M_Swift108%E9%80%9A%E7%9F%A5%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">通知原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-02 14:44:07" itemprop="dateCreated datePublished" datetime="2020-07-02T14:44:07+08:00">2020-07-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖
于它的对象都得到通知并自动更新。
</code></pre>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>1.向通知中心注册观察者
    addObserver:selector:name:object:
    （观察者接收到通知后执行任务的代码在发送通知的线程中执行）
    addObserverForName:object:queue:usingBlock:
    （观察者接收到通知后执行任务的代码在指定的操作队列中执行）
2.通知中心向所有注册的观察者发送通知
    postNotification:
    postNotificationName:object:
    postNotificationName:object:userInfo:
</code></pre>
<h2 id="通知与线程关系"><a href="#通知与线程关系" class="headerlink" title="通知与线程关系"></a>通知与线程关系</h2><pre><code>同步和异步都是相对于发送通知所在的线程的。
postNotification:总是会卡住当前线程，待observer执行（如不特殊处
理selector也会在postNotification:所在线程执行）结束之后才会继续
往下执行。所以是同步的。
我们在底层当中的消息的触发其实是依赖与端口的，我们想要在一个线程中发消
息，在另一个线程中进行处理的话，我们可以用端口来实现
enqueueNotification:notification postingStyle:NSPostWhenIdle coalesceMask:NSNotificationNoCoalescing forModes:@[NSDefau
这里并不是让通知回调在异步执行，只是让通知回调等待到runloop空闲的时候再去执行，如果方法中有高耗时操作，主线程中还是会住UI刷新。
</code></pre>
<h2 id="为什么要移除通知"><a href="#为什么要移除通知" class="headerlink" title="为什么要移除通知"></a>为什么要移除通知</h2><pre><code>若在iOS8或之前版本系统中，对一个对象
addObserver:selector:name:object:（假设name为@“111”），但是
并没有在dealloc的之前或之中，对其进行remove操作。那么，在发送通知、
（name为@“111”）的时候，会因为bad_access（野指针）而crash。
若在iOS9及以后，同上操作，不会crash。
iOS8及以前，NSNotificationCenter持有的是观察者的
unsafe_unretained指针（可能是为了兼容老版本），这样，在观察者回收
的时候未removeOberser，而后再进行post操作，则会向一段被回收的区域
发送消息，所以出现野指针crash。而iOS9以后，unsafe_unretained改成
了weak指针，即使dealloc的时候未removeOberser，再进行post操作，
则会向nil发送消息，所以没有任何问题
</code></pre>
<h2 id="Notification-Queues和异步通知"><a href="#Notification-Queues和异步通知" class="headerlink" title="Notification Queues和异步通知"></a>Notification Queues和异步通知</h2><pre><code>[[NSNotificationQueue defaultQueue] 
enqueueNotification:notification 
postingStyle:NSPostWhenIdle 
coalesceMask:NSNotificationNoCoalescing 
forModes:@[NSDefaultRunLoopMode]];
该参数的三个可选参数：
1，NSPostWhenIdle：runloop空闲的时候回调通知方法
2，NSPostASAP：runloop能够调用的时候就回调通知方法
3，NSPostNow：runloop立即回调通知方法
根据其type，NSNotificationQueue在合适的时机将其post到
NSNotificationCenter。这样就完成了异步的需求。
</code></pre>
<h2 id="NSNotification与KVO异同点"><a href="#NSNotification与KVO异同点" class="headerlink" title="NSNotification与KVO异同点"></a>NSNotification与KVO异同点</h2><pre><code>kvo： 这些代码都只需在观察者里边进行实现，被观察者不用添加任何代码，所以谁要监听谁注册，然后对响应进行处理即可，使得观察者与被观察者完全解耦，运用很灵活，很简单.
缺点:
KVO只能检测类中的属性，并且属性名都是通过NSString来查找，编译器不会帮你去检测与补全，纯手敲可能比较容易出错.
NSNotification：一对多”，在APP中，很多控制器都需要知道一个事件，应该用通知；
要被观察者先主动发出通知，然后观察者注册监听后再来进行响应，比KVO 多了发送通知的一步，但是其优点是监听不局限于属性的变化，还可以对多种多样的装填变化进行监听，监听范围广，使用也更灵活
</code></pre>
<h2 id="在子现成发送通知"><a href="#在子现成发送通知" class="headerlink" title="在子现成发送通知"></a>在子现成发送通知</h2><pre><code>[NSThread detachNewThreadWithBlock:^&#123;
    NSLog(@&quot;1&quot;);
    NSLog(@&quot;%@&quot;, [NSThread currentThread]);
    NSNotification *notification = [NSNotification notificationWithName:@&quot;JKRNO&quot; object:nil];
    [[NSNotificationQueue defaultQueue] enqueueNotification:notification postingStyle:NSPostWhenIdle
    coalesceMask:NSNotificationNoCoalescing forModes:@[NSDefaultRunLoopMode]];
    NSLog(@&quot;3&quot;);
&#125;];
这样写了之后，发现无论怎么发送这个通知，通知都不会回调到，这个是因为并没有为该子线程添加runloop，
这个线程触发之后马上就结束了。（没有添加通知队列的时候，是可以回调到的，因为那种情况下，
通知发送后，通知回调马上就会执行，该线程会等待通知回调执行完毕后才结束）
这个时候，我们就需要添加为子线程添加一个runloop，让子线程常驻：
@property (nonatomic, strong) NSThread *thread;
...
- (NSThread *)thread &#123;
    if (!_thread) &#123;
        _thread = [[NSThread alloc] initWithBlock:^&#123;
            NSRunLoop *ns_runloop = [NSRunLoop currentRunLoop];
            [ns_runloop addPort:[NSPort port] forMode:NSRunLoopCommonModes];

            CFRunLoopRef runloop = CFRunLoopGetCurrent();
            CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;
                switch (activity) &#123;
                    case kCFRunLoopEntry:
                        NSLog(@&quot;进入runLoop&quot;);
                        break;
                    case kCFRunLoopBeforeTimers:
                        NSLog(@&quot;处理timer事件&quot;);
                        break;
                    case kCFRunLoopBeforeSources:
                        NSLog(@&quot;处理source事件&quot;);
                        break;
                    case kCFRunLoopBeforeWaiting:
                        NSLog(@&quot;进入睡眠&quot;);
                        break;
                    case kCFRunLoopAfterWaiting:
                        NSLog(@&quot;被唤醒&quot;);
                        break;
                    case kCFRunLoopExit:
                        NSLog(@&quot;退出&quot;);
                        break;
                    default:
                        break;
                &#125;
            &#125;);
            CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes);
            CFRelease(observer);
            [ns_runloop run];
        &#125;];
        [_thread start];
    &#125;
    return _thread;
&#125;

- (IBAction)postNotification:(UIButton *)sender &#123;
    [self performSelector:@selector(postNotification) onThread:self.thread withObject:nil waitUntilDone:YES];
&#125;

- (void)postNotification &#123;
    NSLog(@&quot;1&quot;);
    NSLog(@&quot;%@&quot;, [NSThread currentThread]);
    //NSPostWhenIdle
    //NSPostASAP
    //NSPostNow
    NSNotification *notification = [NSNotification notificationWithName:@&quot;JKRNO&quot; object:nil];
    [[NSNotificationQueue defaultQueue] enqueueNotification:notification postingStyle:NSPostWhenIdle coalesceMask:NSNotificationNoCoalescing forModes:@[NSDefaultRunLoopMode]];
    NSLog(@&quot;3&quot;);
&#125;

- (void)receiceNotification:(NSNotification *)notification &#123;
    NSLog(@&quot;2&quot;);
    NSLog(@&quot;%@&quot;, [NSThread currentThread]);
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">288</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
