<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/23/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/23/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/15/M_Swift115AndroidStdio%E5%BF%AB%E6%8D%B7%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/15/M_Swift115AndroidStdio%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="post-title-link" itemprop="url">Android Stdio 快捷键</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-15 16:45:54" itemprop="dateCreated datePublished" datetime="2018-10-15T16:45:54+08:00">2018-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>快速定位类名：Cmd + O<br>查看本类中方法：Cmd + Fn + F12<br>查看方法被调用的位置：Option + Fn + F7<br>项目内全局搜索：Cmd + Shift + F<br>格式化代码：Cmd + Option + L<br>快速定位所有类名及其中的方法名：Cmd + Option + O<br>清除无效包引用：Ctrl + Option + O（自动清除无用包，加载有用包，Android Studio基本自动执行了）<br>显示Version Control面板：Cmd + Shift + 9</p>
<p>复制当前行：Cmd + D<br>查找：Cmd + F<br>构造方法，set get方法等生成的快捷菜单：Cmd + N<br>查找+替换：Cmd + R<br>删除行：Cmd + Delete<br>注释代码(//)：Cmd + /<br>导包（提示错误解决方案）：Option + Enter<br>重命名变量：⇧F6</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/15/M_Swift116%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/15/M_Swift116%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">小程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-15 16:40:14" itemprop="dateCreated datePublished" datetime="2018-10-15T16:40:14+08:00">2018-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>api地址：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/">https://developers.weixin.qq.com/miniprogram/dev/component/</a></p>
<p>1.小程序配置 app.json<br>    app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。<br>    {<br>        “pages”:[<br>            “pages/index/index”,<br>        ],<br>        “window”:{<br>            “backgroundTextStyle”:”light”,<br>            “navigationBarBackgroundColor”: “#fff”,<br>            “navigationBarTitleText”: “WeChat”,<br>            “navigationBarTextStyle”:”black”<br>        }<br>    }<br>2.pages小程序页面<br>    小程序页面包含4个部分<br>    wxml： 是用来描述当前这个页面的结构<br>    wxss：用来描述页面的样子<br>    js：通常是用来处理这个页面和用户的交互<br>    json：页面配置，页面中配置项会覆盖 app.json 的 window 中相同的配置项。<br>3.数据绑定js交互<br>    <view></view><br>    Page({<br>        clickMe: function() {<br>        this.setData({ msg: “Hello World” })<br>        }<br>    })<br>4.小程序的启动<br>    默认第一个配置就是启动页面<br>5.页面 Page<br>    data    Object    页面的初始数据<br>    生命周期函数等等<br>6.页面跳转<br>    打开新页面    调用 API wx.navigateTo<br>    页面重定向    调用 API wx.redirectTo<br>    页面返回    调用 API wx.navigateBack<br>    Tab 切换    调用 API wx.switchTab<br>    重启动    调用 API wx.reLaunch<br>7.组件<br>    view、label、text等等<br>8.微信开放api</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/15/M_Swift117web%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/15/M_Swift117web%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">web百度地图使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-15 16:38:51" itemprop="dateCreated datePublished" datetime="2018-10-15T16:38:51+08:00">2018-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前段时间写了一个前端的页面，今天没事总结一下吧，前端使用百度地图，后段使用php，比较简短，也没有丰富的web前端开发经验，就简单写一下开发流程吧，作为自己一个经验<br>1.考虑地图上要放很多数据，我最后我发现有2万8千个数据，那么同时在百度地图上展示是否卡顿，最后决定使用百度聚合api这个接口展示还是比较不错的，缩放显示也比较美观，我也就选择了这个。<br>2.数据使用，一开始思考了很多，数据如何使用在百度地图上让我费了很大的功夫，用php做了很久，最后终于实现了，也是通过判断一些经纬度是不是在行政区域内来做的。耗时比较长，当时忙忙碌碌的，也算是弄的头疼。<br>3.数据做好之后，我便开发php接口了，比较简单，只要把数据吐出来就可以了，基本上没有多少逻辑判断<br>4.页面开发，最后就是页面了，因为我html和css的功底不行，所以我也是经过百度了很多效果，最后展示出来这个样式。<br>页面地址：<a target="_blank" rel="noopener" href="http://www.heqinuc.com/bigdata/shenyang/beijingpublic.html">http://www.heqinuc.com/bigdata/shenyang/beijingpublic.html</a><br>5.页面逻辑，页面展示涉及一些地图操作逻辑，不是太难，就是麻烦一些。<br>这些所有的东西我基本上三天搞定了，感觉挺累，纪念十月一之前的这些日子吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/16/M_Swift110%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/16/M_Swift110%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">算法-查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-16 19:39:30" itemprop="dateCreated datePublished" datetime="2018-08-16T19:39:30+08:00">2018-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字符串转化为整数"><a href="#字符串转化为整数" class="headerlink" title="字符串转化为整数"></a>字符串转化为整数</h2><pre><code>首先判断字符串是否为空，返回0
考虑前面的是否是空格，使用trim()去掉，然后判断长度是否为0，是的话，返回0
判断第一个字符是不是+和-，设置变量sign记录
循环取得字符串的数字，考虑字符串中有非数字，遇到就退出，保留前面的数字
考虑溢出的情况，溢出返回Integer的最大值或最小值
public static int myAutoNumber(String str)&#123;
    //首先判断空值
    if(str == null)&#123;
        return 0;
    &#125;
    //去掉空格的情况
    str = str.trim();
    if(str.length() == 0)
    return 0;
    //正负数标志
    int sign = 1;
    int index = 0;
    if(str.charAt(index) == &#39;+&#39;)
        index ++;
    else if(str.charAt(index) == &#39;-&#39;)&#123;
        index ++;
        sign = -1;
    &#125;
    //取得数字部分，遇到溢出和非数字退出
    long number = 0;
    for(; index &lt; str.length();index++)&#123;
        if(str.charAt(index) &lt; &#39;0&#39; &amp;&amp; str.charAt(index) &gt; &#39;9&#39;)&#123;
        break;
    &#125;
    number = number * 10 + (str.charAt(index) - &#39;0&#39;);
    if(number &gt;= Integer.MAX_VALUE)
        break;
    &#125;
    if(number * sign &lt;= Integer.MIN_VALUE)
    return Integer.MIN_VALUE;
    if(number * sign &gt;= Integer.MAX_VALUE)
    return Integer.MAX_VALUE;
    return (int) number * sign;
&#125;
</code></pre>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><pre><code>// 顺序存储结构的递归先序遍历
var tree = [1, 2, 3, 4, 5, , 6, , , 7];
void function preOrderTraverse(x, visit) &#123;
    visit(tree[x]);
    if (tree[2 * x + 1]) preOrderTraverse(2 * x + 1, visit);
    if (tree[2 * x + 2]) preOrderTraverse(2 * x + 2, visit);
    &#125;(0, function (value) &#123;
        console.log(value);
&#125;);

// 链式存储结构的递归先序遍历
BinaryTree.prototype.preOrderTraverse = function preOrderTraverse(visit) &#123;
visit(this.data);
if (this.leftChild) preOrderTraverse.call(this.leftChild, visit);
if (this.rightChild) preOrderTraverse.call(this.rightChild, visit);
&#125;;
非递归
// 链式存储的非递归先序遍历
// 方法1
BinaryTree.prototype.preOrder_stack = function (visit) &#123;
var stack = new Stack();
stack.push(this);
while (stack.top) &#123;
var p;
// 向左走到尽头
while ((p = stack.peek())) &#123;
    p.data &amp;&amp; visit(p.data);
    stack.push(p.leftChild);
&#125;
stack.pop();
if (stack.top) &#123;
    p = stack.pop();
    stack.push(p.rightChild);
&#125;
// 方法2
BinaryTree.prototype.preOrder_stack2 = function (visit) &#123;
var stack = new Stack();
var p = this;
while (p || stack.top) &#123;
    if (p) &#123;
        stack.push(p);
        p.data &amp;&amp; visit(p.data);
        p = p.leftChild;
    &#125; else &#123;
        p = stack.pop();
        p = p.rightChild;
    &#125;
&#125;
</code></pre>
<h2 id="查询链表第N个元素"><a href="#查询链表第N个元素" class="headerlink" title="查询链表第N个元素"></a>查询链表第N个元素</h2><pre><code>第一种方法先求出元素个数，在遍历元素个数-n个，时间复杂度为：O(N+N-、
n)=O(2N-n)。
第二种设置俩个指针，第一个先走N步，第二个开始走。俩者速度一样，时间复
杂度为O(N)。
代码如下：
/** 
* 获取单链表倒数第N个元素 
* @author xiucai 
*/  
public class SingleLinkedList_LastN &#123;  
/** 
* 第一种方法先求出元素个数，在遍历元素个数-n个 
* 时间复杂度为：O(N+N-n)=O(2N-n) 
* @param list 
* @param n 
* @return 
* @throws Exception 
*/  
public static&lt;T&gt; T getLastN1(SingleLinkedList&lt;T&gt; list,int n) throws Exception&#123;  
int count=0;  
Node&lt;T&gt; node=list.head;  
while(node.next!=null)&#123;  
count++;  
node=node.next;  
&#125;  
if(count&lt;n)  
throw new Exception(&quot;单链表元素个数小于 &quot;+n+&quot; !&quot;);  
node=list.head;  
for(int i=0;i&lt;count-n;i++)&#123;  
node=node.next;  
&#125;  
return (T)node.data;  
&#125;  

/** 
* 设置俩个指针，第一个先走N步，第二个开始走。俩者速度一样 
* 时间复杂度为O(N) 
* @param list 
* @param n 
* @return 
* @throws Exception  
*/  
public static&lt;T&gt; T getLastN2(SingleLinkedList&lt;T&gt; list,int n) throws Exception&#123;  
//fastN先走N步，slowN等fastN走N步后在开始走  
Node&lt;T&gt; fastN=list.head,slowN=list.head;  
for(int i=0;i&lt;n;i++)&#123;  
if(fastN.next==null)&#123;  
throw new Exception(&quot;单链表元素个数小于 &quot;+n+&quot; ！&quot;);  
/*try &#123; 

&#125; catch (Exception e) &#123; 
// TODO Auto-generated catch block 
e.printStackTrace(); 
&#125;*/  
&#125;  
fastN=fastN.next;  
&#125;  
while(fastN.next!=null)&#123;  
fastN=fastN.next;  
slowN=slowN.next;  
&#125;  
return (T)slowN.data;  
&#125; 
</code></pre>
<h2 id="100个球三种颜色多少种情况"><a href="#100个球三种颜色多少种情况" class="headerlink" title="100个球三种颜色多少种情况"></a>100个球三种颜色多少种情况</h2><pre><code>//假设白球1个，红球和黄球任意组合，那么有 1，98，98，1
//98 个可能，猜测，觉得应该不对
//那么98 * 98 = 9604
</code></pre>
<h2 id="集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡"><a href="#集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡" class="headerlink" title="集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡"></a>集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡</h2><pre><code>为了解决这个问题，我们可以定义一个哈希表（外部空间），其键值（Key）是
字符，而值（Value）是该字符出现的次数。
同时我们还需要从头开始扫描字符串两次：
1）第一次扫描字符串时，每扫描到一个字符就在哈希表的对应项中把次数加1。
（时间效率O(n)）
2）第二次扫描时，每扫描到一个字符就能从哈希表中得到该字符出现的次数。
这样第一个只出现一次的字符就是符合要求的输出。（时间效率O(n)）
这样算起来，总的时间复杂度仍然是O(n)，满足了题目要求，擦一擦汗，感
叹：这*装得真有点技术！
public class Solution &#123;
public int FirstNotRepeatingChar(String str) &#123;
　if(str == null || str.length() == 0)
    　return -1;
    　int[] sign = new int[256];
    　char[] array = str.toCharArray();
    　for(int i=0;i&lt;array.length;i++)&#123;
    　if(sign[array[i]] &lt; 2)
    　sign[array[i]] ++ ;
　&#125;
　for(int i=0;i&lt;array.length;i++)&#123;
    　if(sign[array[i]] == 1)
    　   return i;
    　&#125;
　   return -1;
　&#125;
&#125;
</code></pre>
<h2 id="最长无重复字符的子串"><a href="#最长无重复字符的子串" class="headerlink" title="最长无重复字符的子串"></a>最长无重复字符的子串</h2><pre><code>思路：[pre,i]表示一个无重复子串，用hash表记录子串中每个字符的出现次
数。初始pre = 0，i = 0，i从左往右扫描字符串，maxLength保存当前最
大长度。每扫描一个字符，根据对应的值来判断这个字符是否已经出现。
如果A[i]已存在, 将pre与当前字符A[i]位置的下一个位置进行比较，选择最
大者作为最新pre所指位置，然后再更新maxLength；   
如果不存在，则继续扫描，(i - pre + 1)与最大长度进行比较，更新
maxLength。   
将A[i]以及对应的位置i保存，更新字符最近出现的位置。
int longestSubstring(string A, int n) &#123;
    map&lt;char, int&gt; m; 
    //map中的键key存放字符串中出现的字符，值value存放该字符当前的位置  
    int maxLength = 0;  //保存最长字串长度  
    int pre = 0;        //记录头指针位置 
    for(int i=0; i&lt;n; i++ )&#123;  
    map&lt;char, int&gt;::iterator iter=m.find(A[i]);
    if(iter!=m.end())&#123;//如果map中已存在当前字符   m[A[i]]
    //更新当前指针位置，如果当前指针大，则使用当前指针，否则使用该指
    针下一个字符的位置
    pre = max(pre, (m[A[i]]+1));
    &#125; 
    maxLength = max(maxLength, i-pre+1);//更新最长字串的长度
    m[A[i]]=i;//修改当前字符的value，记录最新位置     
    &#125;  
    return maxLength; 
&#125;
另一种类似：
int longestSubstring(string A, int n) &#123;
    map&lt;char, int&gt; m; //表示字符串中每个字符是否出现，初始化为
    0，表示未出现  
    int start = 1,MAX = 0;  
    //遍历该字符串，每遍历一个字母时，利用map去找该字母最近一次出现
    是什么时候  
    //中间这一段便是无重复字符的字符串。  
    for (int i = 1; i &lt;= n; i++)&#123;  
    char c = A[i - 1];    
    if (m[c] &gt;= start)&#123;    
    start = m[c] + 1;   
    &#125;
    MAX = max(MAX, i - start + 1); 
    m[c] = i;   //map添加数据  mapStudent[char] = int 
    &#125;    
    return MAX;
&#125;
</code></pre>
<h2 id="二分查找法查找多少次"><a href="#二分查找法查找多少次" class="headerlink" title="二分查找法查找多少次"></a>二分查找法查找多少次</h2><h2 id="寻找距离最近的公共父视图，已知两个节点和根节点"><a href="#寻找距离最近的公共父视图，已知两个节点和根节点" class="headerlink" title="寻找距离最近的公共父视图，已知两个节点和根节点"></a>寻找距离最近的公共父视图，已知两个节点和根节点</h2><pre><code>二叉树查找
栈的push和pop的时间复杂度，实现O（1）的找出栈中最小值的算法（栈只在一端操作，以空间换时间）
</code></pre>
<h2 id="Hash碰撞冲突"><a href="#Hash碰撞冲突" class="headerlink" title="Hash碰撞冲突"></a>Hash碰撞冲突</h2><pre><code>我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么
HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样
时，这就发生了碰撞冲突。如下将介绍如何处理冲突，当然其前提是一致性
hash。
1.开放地址法
开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)
其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为
1,2,3,…m-1，称线性探测再散列。
如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为
1,-1,2,-2,4,-4,9,-9,16,-16,…k*k,-k*k(k&lt;=m/2)，称二次探测再散
列。
如果di取值可能为伪随机数列。称伪随机探测再散列。
2.再哈希法
当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺
点：计算时间增加。
比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第
二位进行哈希，再冲突，第三位，直到不冲突为止
3.链地址法（拉链法）
NSMutableArray以及NSMutableDictionary的设计不是多线程安全的，
当然这种设计的好处是处理速度快，不需要任何锁进行同步，所以我们在使用
Objective-C的这些容器的时候需要注意，在哪个线程中创建它们就在哪个线
程中对它们进行操作。不过在某些情况下，我们由于一些算法或业务需求，需要
在多个线程中共享一个NSMutableArray容器对象，这时候我们需要通过一些
同步机制来实现多线程操作的安全性。
一个对象的引用计数记录在一个hash表中的话，如何保证多线程的时候计数的
准确性？（从上到下加锁消耗太大，可以采用分治，每十个加一个锁）
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/16/M_Swift114UI%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/16/M_Swift114UI%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">UI相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-16 19:39:30" itemprop="dateCreated datePublished" datetime="2018-08-16T19:39:30+08:00">2018-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="UIView绘制原理"><a href="#UIView绘制原理" class="headerlink" title="UIView绘制原理"></a>UIView绘制原理</h2><pre><code>当UIView调用setNeedDisplay之后,系统会调用view对应layer的 
setNeedsDisplay方法,相当于在当前layer上打上了一个脏标记,然后会在
当前runloop即将结束的时候调用CALayer的display方法,才会真正的进入
当前视图的绘制流程当中,所以视图的绘制时机,是在当前runloop即将结束的
时候才会开始.
CALayer的display方法的内部实现,首先会判断layer的delegete是否响
应display方法,如果代理不响应就会进入到系统的绘制流程当中,如果响应,实
际上就为我们提供了异步绘制的接口,这样就构成了UIView的绘制原理
进行异步绘制,其实就是基于系统给我们开的口子layer.delegate,如果遵从
或者实现了displayLayer方法,我们就可以进入到异步绘制流程当中,在异步
绘制的过程当中
1.就由delegete去负责生成bitmap位图
2.设置改bitmap作为layer.content属性的值
</code></pre>
<h2 id="Masonry"><a href="#Masonry" class="headerlink" title="Masonry"></a>Masonry</h2><pre><code>https://www.cnblogs.com/ludashi/archive/2016/07/11/5591572.html
是一个对系统NSLayoutConstraint进行封装的第三方自动布局框架，采用链
式编程的方式提供给开发者API
UIView的对象可以直接调用mas_makeConstraints方法来为相应的View对
象添加约束。因为mas_makeConstraints方法位于UIView的
View+MASAdditions类目中，所以UIView的对象可以直接调用。同样在
View+MASAdditions类目还有其他方法供UIView的对象使用
MASViewAttribute这个类名中我们就能看出，这个类是对UIView和
NSLayoutAttribute的封装。使用等式来表示就是MASViewAttribute = 
UIView + NSLayoutAttribute + item。在MASViewAttribute类中
的view属性表示所约束的对象，而item就是该对象上可以被约束的部分。
MASViewConstraint做的最核心的一件事情就是初始化
NSLayoutConstriant对象，并将该对象添加在相应的视图上
MASConstraintMaker类。该类就是一个工厂类，负责创建MASConstraint
类型的对象（依赖于MASConstraint接口，而不依赖于具体实现）
</code></pre>
<h2 id="圆角性能问题"><a href="#圆角性能问题" class="headerlink" title="圆角性能问题"></a>圆角性能问题</h2><pre><code>OpenGL中，GPU屏幕渲染有以下两种方式：
On-Screen Rendering
意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。
Off-Screen Rendering
意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。
相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：
创建新缓冲区
要想进行离屏渲染，首先要创建一个新的缓冲区。
上下文切换
离屏渲染触发方式
设置了以下属性时，都会触发离屏绘制：
shouldRasterize（光栅化）
masks（遮罩）
shadows（阴影）
edge antialiasing（抗锯齿）
group opacity（不透明）
实现圆角cornerRadius要比mask高效很多。
方案：
直接使用setCornerRadius
这种就是最常用的，也是最耗性能的。
setCornerRadius设置圆角之后，shouldRasterize=YES光栅化
avatarImageView.clipsToBounds = YES;
[avatarImageView.layer setCornerRadius:50];
avatarImageView.layer.shouldRasterize = YES;
avatarImageViewUrl.layer.rasterizationScale=[UIScreen mainScreen].scale;
直接覆盖一张中间为圆形透明的图片（推荐使用）
这种方法就是多加了一张透明的图片，GPU计算多层的混合渲染blending也是会消耗一点性能的，但比第一种方法还是好上很多的。
Core Graphics绘制圆角
这种方式GPU损耗最低，但是UIButton上不知道怎么绘制，可以用UIimageView添加个点击手势当做UIButton使用。
可以用Instruments的 GPU Driver进行测试：
</code></pre>
<h2 id="Target-Action-设计模式"><a href="#Target-Action-设计模式" class="headerlink" title="Target-Action 设计模式"></a>Target-Action 设计模式</h2><pre><code>Target-Action，意为 目标-行为，行为即要调用的方法，目标即消息的接收
对象（Objective-C 语言使用消息机制，类似但不同于方法调用，该两种概
念可能未来会进行探讨）。整个过程为：用户点击按钮，触发某事件发生，该消
息由按钮传到另外的接收对象，接收对象再做相应处理。接收对象可以为任何对
象，但通常为控制器
[self.btnCooking addTarget:self    
action:@selector(pressCooking:) 
forControlEvents:UIControlEventTouchUpInside];
1、self 指目标对象为当前对象，及WViewController； 
2、action 即 在目标对象上的点击方法； 
3、何时调用该方法，UIControlEventTouchUpInside即单击时。 
</code></pre>
<h2 id="layer与view的区别"><a href="#layer与view的区别" class="headerlink" title="layer与view的区别"></a>layer与view的区别</h2><pre><code>UIView相比CALayer最大区别是UIView可以响应用户事件，
而CALayer不可以。UIView侧重于对显示内容的管理，CALayer侧重于对内
容的绘制。
UIView的继承结构为: UIResponder : NSObject。 
UIResponder是用来响应事件的，也就是UIView可以响应用户事件。
CALayer的继承结构为： NSObject。 
直接从 NSObject继承，因为缺少了UIResponder类，所以CALayer悲催的
不能响应任何用户事件。 
CALayer定义了position、size、transform、animations 等基本属
性。
View和CALayer的Frame映射及View如何创建CALayer.
一个 Layer 的 frame 是由它的 anchorPoint,position,bounds,和 
transform 共同决定的，而一个 View 的 frame 只是简单的返回 Layer
的 frame，同样 View 的 center和 bounds 也是返回 Layer 的一些属
性。
</code></pre>
<h2 id="viewController-push生命周期"><a href="#viewController-push生命周期" class="headerlink" title="viewController push生命周期"></a>viewController push生命周期</h2><pre><code>------------------------PUSH---------------------------
A-willDisappear --&gt; B-willAppear --&gt; A-didDisappear --&gt; B-didAppear
---------------------NormalPresent---------------------
A-willDisappear --&gt; B-willAppear --&gt; B-didAppear --&gt; A-didDisappear
-----------------------TabBar切换------------------------
B-willAppear --&gt; A-willDisappear --&gt; A-didDisappear --&gt; B-didAppear
</code></pre>
<h2 id="轮播图实现原理"><a href="#轮播图实现原理" class="headerlink" title="轮播图实现原理"></a>轮播图实现原理</h2><pre><code>第一种：基于collectionView进行的封装（推荐）
这种方式应该是实现起来最简单的一种方式了，也是个人最喜欢的一种封装方
式。它的原理就是几个collectionView，至于无限轮播，很简单，只需要你
的轮播数组给collectionView赋值的时候乘以一个较大的数字即可（例如
100），collectionView本身处理了重用等一系列问题。
第二种：基于scrollView的无限轮播（首尾各多创建一个展示图片的
ImageView）
这种实现方式个人感觉是最麻烦，而且还需要考虑重用等性能问题的一种。基本
的原理就是在根据你轮播数组的个数在首尾各多创建一个ImageView，当然首
位之前多创建一个展示轮播数组最后一个的ImageView，而尾部多创建一个展
示轮播数组第一个的ImageView。
第三种：同样是基于scrollView的无限轮播（总共就创建三个ImageView）
这种实现方式比第二种的好处就是不需要考虑重用问题，不论数组是多少个轮播
图，我只创建三个ImageView。它与第二种的不同之处是其实用户每次看到的
一直都是中间那张的ImageView,只是上边的内容改变了。其内部实现其实是在
不断的改变那个轮播数组。    
</code></pre>
<h2 id="xib的约束，拖出线后系统默认为什么是weak"><a href="#xib的约束，拖出线后系统默认为什么是weak" class="headerlink" title="xib的约束，拖出线后系统默认为什么是weak"></a>xib的约束，拖出线后系统默认为什么是weak</h2><pre><code>IBOutlet的属性一般可以设为weak是因为它已经被view引用了，除非view
被释放，否则IBOutlet的属性也不会被释放，另外IBOutlet属性的生命周期
和view应该是一致的，所以IBOutlet属性一般设为weak。
从storyboard或者xib上创建控件，在控件放在view上的时候，已经形成了
如下的引用关系,以UIButton为例：
UIViewController-&gt;UIView-&gt;subView-&gt;UIButton
然后你为这个UIButton声明一个weak属性
@property(nonatomic,weak) IBOOutlet UIButton *btn;
相当于xib/sb对这个Button是强引用，你声明的属性对它是弱引用。
</code></pre>
<h2 id="label只设置上和左的约束正常，UIview这样设置为什么会有约束警告"><a href="#label只设置上和左的约束正常，UIview这样设置为什么会有约束警告" class="headerlink" title="label只设置上和左的约束正常，UIview这样设置为什么会有约束警告"></a>label只设置上和左的约束正常，UIview这样设置为什么会有约束警告</h2><pre><code>大概意思是并不是所有的View都有Intrinsic Content Size,而拥有
Intrinsic Content Size的view有这样的特征：它们可以根据view中的
内容来确定view的size。例如Button，我们可以不用指定它们已经计算好的
size，只需要指定position即可。在Masonry中，UIButton的布局我们可
以这样子写：
Content Compression Resistance即为抗压缩阻力，而Content 
Hugging即为抗拉伸阻力
View    Intrinsic content size
UIView and NSView    No intrinsic content size.
Sliders    Defines only the width (iOS).
Labels, buttons, switches, and text fields    Defines both the height and the width.
Text views and image views    Intrinsic content size can vary.
</code></pre>
<h2 id="position与anchorPoint"><a href="#position与anchorPoint" class="headerlink" title="position与anchorPoint"></a>position与anchorPoint</h2><pre><code>每一个UIView内部都默认关联着一个CALayer, UIView有frame、bounds
和center三个属性，CALayer也有类似的属性，分别为frame、bounds、
position、anchorPoint。frame和bounds比较好理解，bounds可以视为
x坐标和y坐标都为0的frame，那position、anchorPoint是什么呢？先看
看两者的原型，可知都是CGPoint点。
position是layer中的anchorPoint点在superLayer中的位置坐标。因此
可以说, position点是相对suerLayer的，anchorPoint点是相对layer
的，两者是相对不同的坐标空间的一个重合点。
总结
1、position是layer中的anchorPoint在superLayer中的位置坐标。 
2、互不影响原则：单独修改position与anchorPoint中任何一个属性都不
影响另一个属性。
anchorPoint 是相对于自身的位置，而 position 是相对于父图层的，改
变 anchorPoint 只是更改了图层自身旋转地位置，但始终还是要通过改变 
frame 使 anchorPoint 和 position 重合
</code></pre>
<h2 id="显示动画和隐式动画区别"><a href="#显示动画和隐式动画区别" class="headerlink" title="显示动画和隐式动画区别"></a>显示动画和隐式动画区别</h2><pre><code>显式动画是指用户自己通过beginAnimations:context:和
commitAnimations创建的动画。    
隐式动画是指通过UIView的animateWithDuration:animations:方法创
建的动画。
区别就是使用隐式动画后，View会暂时不能接收用户的触摸、滑动等手势。这
就造成了当一个列表滚动时，如果对其中的view使用了隐式动画，就会感觉滚
动无法主动停止下来，必须等动画结束了才能停止。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/16/M_Swift112Xcode%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/16/M_Swift112Xcode%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Xcode相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-16 19:38:54" itemprop="dateCreated datePublished" datetime="2018-08-16T19:38:54+08:00">2018-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="pod-install与pod-update的区别"><a href="#pod-install与pod-update的区别" class="headerlink" title="pod install与pod update的区别"></a>pod install与pod update的区别</h2><pre><code>pod install一般是你第一次想要为项目添加pod的时候使用的，它同样也使
用在你为Podfile文件添加或移除pod库的时候。
每次pod install命令运行的时候，pod install会为每一个它安装的pod
库在Podfile.lock文件中写入其版本号。Podfile.lock文件追踪每一个安
装的pod库的版本号，并锁定这些版本号。
当你运行pod install是，它将只解决不在Podfile.lock中的pod库依赖关
系 
对于在Podfile.lock文件中的pod库，pod install会只下载
Podfile.lock文件中指定的版本，而不会去检查这个库是否有更新的版本。
对于不在Podfile.lock文件中的pod库，pod install会搜索这个pod库在
Podfile文件中指定的版本
pod update
当你运行了pod update PODNAME命令，CocoaPods会在不考虑
Podfile.lock中版本的情况下试着去查找PODNAME的最新版本。pod 
update PODNAME命令会将相应的pod更新到最新的版本（新版本仍然遵守你
在Podfile中做的限制）
用法
通过pod update PODNAME,你可以只更新某个特定的pod库（检查是否存在
新版本并更新相应的pod库）。相反，pod install则不会去更新已安装的
pod库。
当你向Podfile中添加了pod，你应该使用pod install而不是pod update
去在不更新已安装的pod库的版本基础上安装新添加的pod库。
当你想过更新某个特定pod库（或所有的库）的版本时你只需要使用pod 
update
</code></pre>
<h2 id="pod-lock产生冲突的原因"><a href="#pod-lock产生冲突的原因" class="headerlink" title="pod.lock产生冲突的原因"></a>pod.lock产生冲突的原因</h2><pre><code>Podfile.lock 不一致的原因：
Podfile.lock和Manifest.lock：
项目中集成 cocoapods 的时候，运行 pod install 后，项目根目录中会
生成Podfile.lock，而Pods目录中会有Manifest.lock。
Xcode 编译项目的时候，会执行 Build Phases 中的[CP] Check Pods 
Manifest.lock 脚本，这个脚本会比对Podfile.lock和
Manifest.lock，如果两个文件不相同就会报错。
Podfile.lock是什么：
Podfile.lock 文件主要包含三个块：PODS、DEPENDENCIES、SPEC 
CHECKSUMS，用来记录每个pod的版本号、依赖的其他库和每个库对应的
podspec.json文件的 checksum(SHA-1算法)。通过这些信息可以确保多
人协作的时候，大家使用的是相同版本的第三方库。
删掉Pod.lock文件，然后重新执行pod install --verbose --no-
repo-update
</code></pre>
<h2 id="CocoaPods原理和说明"><a href="#CocoaPods原理和说明" class="headerlink" title="CocoaPods原理和说明"></a>CocoaPods原理和说明</h2><pre><code>1、第三方库会被编译成.a静态库供我们真正的工程使用。    
CocoaPods会将所有的第三方库以target的方式组成一个名为Pods的工程，
该工程就放在刚才新生成的Pods目录下。整个第三方库工程会生成一个名称为
libPods.a的静态库提供给我们自己的CocoaPodsTest工程使用。
对于资源文件，CocoaPods提供了一个名为Pods-resources.sh的bash脚
本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到
目标目录中。
2、我们的工程和第三方库所在的工程会由一个新生成的workspace管理
为了方便我们直观的管理工程和第三方库，CocoaPodsTest工程和Pods工程
会被以workspace的形式组织和管理，也就是我们刚才看到的
CocoaPodsTest.xcworkspace文件。
3、原来的工程设置已经被更改了，这时候我们直接打开原来的工程文件去编译
就会报错，只能使用新生成的workspace来进行项目管理。
4、CocoaPods通过一个名为Pods.xcconfig的文件来在编译时设置所有的依
赖和参数。
</code></pre>
<h2 id="dSYM-文件"><a href="#dSYM-文件" class="headerlink" title="dSYM 文件"></a>dSYM 文件</h2><pre><code>什么是 dSYM 文件    
Xcode编译项目后，我们会看到一个同名的 dSYM 文件，dSYM 是保存 16 
进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文
件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件，位于 /
Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives 目录下，对于
每一个发布版本我们都很有必要保存对应的 Archives 文件 
( AUTOMATICALLY SAVE THE DSYM FILES 这篇文章介绍了通过脚本每次
编译后都自动保存 dSYM 文件)。
dSYM 文件有什么作用
当我们软件 release 模式打包或上线后，不会像我们在 Xcode 中那样直观
的看到用崩溃的错误，这个时候我们就需要分析 crash report 文件了，
iOS 设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 Xcode 
的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件，
这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数
名和文件名。大前提是我们需要有软件版本对应的 dSYM 文件，这也是为什么
我们很有必要保存每个发布版本的 Archives 文件了。
如何将文件一一对应
每一个 xx.app 和 xx.app.dSYM 文件都有对应的 UUID，crash 文件也
有自己的 UUID，只要这三个文件的 UUID 一致，我们就可以通过他们解析出
正确的错误函数信息了。
</code></pre>
<h2 id="Git和SVN"><a href="#Git和SVN" class="headerlink" title="Git和SVN"></a>Git和SVN</h2><pre><code>1. Git是分布式的，SVN是集中式的，好处是跟其他同事不会有太多的冲突，
自己写的代码放在自己电脑上，一段时间后再提交、合并，也可以不用联网在本
地提交；
2. Git下载下来后，在本地不必联网就可以看到所有的log，很方便学习，
SVN却需要联网；
3. Git鼓励分Branch，而SVN，说实话，我用Branch的次数还挺少的，SVN
自带的Branch merge我还真没用过，有merge时用的是Beyond Compare工
具合并后再Commit的；
4. Tortoise也有出Git版本，真是好东西；
5. SVN在Commit前，我们都建议是先Update一下，跟本地的代码编译没问
题，并确保开发的功能正常后再提交，这样其实挺麻烦的，有好几次同事没有先
Updata，就
Commit了，发生了一些错误，耽误了大家时间，Git可能这种情况会少些。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/16/M_Swift90%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/16/M_Swift90%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">算法之数学计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-16 19:34:20" itemprop="dateCreated datePublished" datetime="2018-08-16T19:34:20+08:00">2018-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><pre><code>function binarySeach( arr,val,leftIndex,rightIndex )&#123;
    //找到中间的值
    var midIndex = Math.floor((leftIndex+rightIndex)/2);
    var midval=arr[midIndex];
    //console.log(midval );
    if( leftIndex &gt; rightIndex )&#123;
        console.log(&quot;前一位是&quot;,midval );
        console.log(&quot;下标：&quot;,midIndex);
        return ;
    &#125;
    if( midval &gt; val )&#123;
        binarySeach(arr,val,leftIndex,midIndex-1);
    &#125;else if(midval &lt; val)&#123;
        binarySeach(arr,val,midIndex+1,rightIndex);
    &#125;else&#123;
        console.log(&quot;找到了,下标为:&quot;+midIndex);
        return;
    &#125;
&#125;
var arr=[1,3,12,21,24,44,54,67];
binarySeach(arr,25,0,arr.length-1);
</code></pre>
<h2 id="求两个数的最大公约数，递归"><a href="#求两个数的最大公约数，递归" class="headerlink" title="求两个数的最大公约数，递归"></a>求两个数的最大公约数，递归</h2><pre><code>function Gcd(var a, var b)
 &#123;
      if(a&lt;=0||b&lt;=0)
          return -1;
     else if(a&gt;b)
         return Gcd(a-b, b);
     else if(a&lt;b)
         return Gcd(a, b-a);
     else
         return a;
 &#125;
// 最小公倍数 两个整数的乘积 / 最大公约数
// a* b/gcd(a,b)
</code></pre>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><pre><code>function Fibonacci(int n) &#123;
    if(n &lt; 0)&#123;
        return 0;
    &#125;
    if(n == 0)&#123;
        return 0;
    &#125;else if(n == 1)&#123;
        return 1;
    &#125;else return Fibonacci(n-1)+ Fibonacci(n-2);
&#125;
</code></pre>
<h2 id="累加求和"><a href="#累加求和" class="headerlink" title="累加求和"></a>累加求和</h2><pre><code>int sum = 0;//定义初始化总和
for(int i=1;i&lt;=100;i++)&#123;//从1开始循环到100
sum=sum+i;//加上当前序号
&#125;
System.out.println(sum);//在控制台中打印出来
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/15/M_Swift98%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/15/M_Swift98%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-15 10:50:36" itemprop="dateCreated datePublished" datetime="2018-08-15T10:50:36+08:00">2018-08-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简述一下OC的内存管理方式"><a href="#简述一下OC的内存管理方式" class="headerlink" title="简述一下OC的内存管理方式"></a>简述一下OC的内存管理方式</h2><pre><code>包括alloc，retain，copy，release，autorelease，
delalloc这些方法理解
OC中每个对象都有一个与之对应的整数，叫“引用计数器”，
当一个对象在创建之后它的引用计数器值加1，当调用这个对象的
alloc、retain、new、copy方法之后引用计数器值自动在原
来的基础上加1，当调用这个对象的release方法之后它的引用计
数器值减1，如果一个对象的引用计数器值为0，则系统会自动
调用这个对象的dealloc方法来销毁这个对象。
在alloc的时候调用了allocWithZone分配了内存
alloc、retain、new、copy方法之后引用计数器值自
动在原来的基础上加1
</code></pre>
<h2 id="用MRC写一个setter方法"><a href="#用MRC写一个setter方法" class="headerlink" title="用MRC写一个setter方法"></a>用MRC写一个setter方法</h2><pre><code>- (void)setName:(NSString *)name &#123;
    if(_name != name) &#123;
        [name retain];
        [_name relrase];
        _name = name;
    &#125;
&#125;
</code></pre>
<h2 id="描述autorelease对象释放时机，"><a href="#描述autorelease对象释放时机，" class="headerlink" title="描述autorelease对象释放时机，"></a>描述autorelease对象释放时机，</h2><pre><code>在没有手加Autorelease Pool的情况下，Autorelease对象
是在当前的runloop迭代结束时释放的，而它能够释放的原因是
系统在每个runloop迭代中都加入了自动释放池Push和Pop
</code></pre>
<h2 id="简述autorelrasePool的工作机制"><a href="#简述autorelrasePool的工作机制" class="headerlink" title="简述autorelrasePool的工作机制"></a>简述autorelrasePool的工作机制</h2><pre><code>每一个线程创建的时候就会有一个autorelease pool的创建，
并且在线程退出的时候，清空整个autorelease pool。
（ps:如果在子线程中设置一个循环，autorelease对象确实无
法释放）所以子线程的autorelease对象，
要么在子线程中设置runloop清楚
RutoreleasePoolPage
&#123;
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage *const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
&#125;
AutoreleasePool并没有单独的结构，而是由若干个
AutoreleasePoolPage以双向链表的形式组合而成（
分别对应结构中的parent指针和child指针）
AutoreleasePool是按线程一一对应的
（结构中的thread指针指向当前线程）
AutoreleasePoolPage每个对象会开辟4096字节内存
（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，
剩下的空间全部用来储存autorelease对象的地址
上面的id *next指针作为游标指向栈顶最新add进来
的autorelease对象的下一个位置
一个AutoreleasePoolPage的空间被占满时，
会新建一个AutoreleasePoolPage对象，连接链表，
后来的autorelease对象在新的page加入
runtime 黑魔法之Thread Local Storage
Thread Local Storage（TLS）线程局部存储，
目的很简单，将一块内存作为某个线程专有的存储，
以key-value的形式进行读写，比如在非arm架构下，
使用pthread提供的方法实现：
在返回值身上调用objc_autoreleaseReturnValue方法时，
runtime将这个返回值object储存在TLS中，然后直接返回这
个object（不调用autorelease）；同时，在外部接收这个返
回值的objc_retainAutoreleasedReturnValue里，发
现TLS中正好存了这个对象，那么直接返回这个object
（不调用retain）。
于是乎，调用方和被调方利用TLS做中转，
很有默契的免去了对返回值的内存管理。
于是问题又来了，假如被调方和主调方只有一边是ARC
环境编译的该咋办？（比如我们在ARC环境下用了非
ARC编译的第三方库，或者反之）
只能动用更高级的黑魔法。
黑魔法之__builtin_return_address
这个内建函数原型是char *__builtin_return_address
(int level)，作用是得到函数的返回地址，参数表示层数，
如__builtin_return_address(0)表示当前函数体返回地址
，传1是调用这个函数的外层函数的返回值地址，以此类推。
如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对
于不同情况做不同的处理
</code></pre>
<h2 id="在一个类中retaion一个NSTimer类型的成员变量会有什么问题吗？请简述问题产生的根本原因"><a href="#在一个类中retaion一个NSTimer类型的成员变量会有什么问题吗？请简述问题产生的根本原因" class="headerlink" title="在一个类中retaion一个NSTimer类型的成员变量会有什么问题吗？请简述问题产生的根本原因"></a>在一个类中retaion一个NSTimer类型的成员变量会有什么问题吗？请简述问题产生的根本原因</h2><pre><code>类有一个成员变量_timer，给_timer设置的target为这个类本、
身。这样类保留_timer，_timer又保留了这个类，就会出现循环
引用的问题，最后导致类无法正确释放。

解决这个问题的方式也很简单，当类的使用者能够确定不需要使用这
个计时器时，就调用
[_timer invalidate];
_timer = nil;
</code></pre>
<h2 id="assgin和weak区别"><a href="#assgin和weak区别" class="headerlink" title="assgin和weak区别"></a>assgin和weak区别</h2><h3 id="修饰变量类型的区别"><a href="#修饰变量类型的区别" class="headerlink" title="修饰变量类型的区别"></a>修饰变量类型的区别</h3><pre><code>weak 只可以修饰对象。如果修饰基本数据类型，编译器会报
错-“Property with ‘weak’ attribute must be of 
object type”。
assign 可修饰对象，和基本数据类型。当需要修饰对象类型时，
MRC时代使用unsafe_unretained。当然，
unsafe_unretained也可能产生野指针，所以它名字
是&quot;unsafe_”。
</code></pre>
<h3 id="是否产生野指针的区别"><a href="#是否产生野指针的区别" class="headerlink" title="是否产生野指针的区别"></a>是否产生野指针的区别</h3><pre><code>weak 不会产生野指针问题。因为weak修饰的对象释放后（引用计
数器值为0），指针会自动被置nil，之后再向该对象发消息也不会
崩溃。 weak是安全的。
assign 如果修饰对象，会产生野指针问题；如果修饰基本数据类
型则是安全的。修饰的对象释放后，指针不会自动被置空，此时向对
象发消息会崩溃。
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>assign 适用于基本数据类型如int,float,struct等值类型，不
适用于引用类型。因为值类型会被放入栈中，遵循先进后出原则，由
系统负责管理栈内存。而引用类型会被放入堆中，需要我们自己手动
管理内存或通过ARC管理。
weak 适用于delegate和block等引用类型，不会导致野指针问
题，也不会循环引用，非常安全。
</code></pre>
<h2 id="weak实现原理"><a href="#weak实现原理" class="headerlink" title="weak实现原理"></a>weak实现原理</h2><pre><code>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak
表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的
地址（这个地址的值是所指对象的地址）数组。
1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak
指针指向对象的地址。
2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， 
objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。
3、释放时，调用clearDeallocating函数。clearDeallocating函数首
先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数
据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。        
</code></pre>
<h3 id="当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？"><a href="#当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？" class="headerlink" title="当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？"></a>当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？</h3><pre><code>1、调用objc_release
2、因为对象的引用计数为0，所以执行dealloc
3、在dealloc中，调用了_objc_rootDealloc函数
4、在_objc_rootDealloc中，调用了object_dispose函数
5、调用objc_destructInstance
6、最后调用objc_clear_deallocating,详细过程如下：
    a. 从weak表中获取废弃对象的地址为键值的记录
    b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为 nil
    c. 将weak表中该记录删除
    d. 从引用计数表中删除废弃对象的地址为键值的记录
</code></pre>
<h2 id="为什么NSMutableArray必须用strong，而NSArray必须用copy？"><a href="#为什么NSMutableArray必须用strong，而NSArray必须用copy？" class="headerlink" title="为什么NSMutableArray必须用strong，而NSArray必须用copy？"></a>为什么NSMutableArray必须用strong，而NSArray必须用copy？</h2><pre><code>NSArray：被strong修饰之后，由于只是强引用，所以副本对象数
组和源对象数组只是指向同一个内存区域，这样就会造成副本对象数
组会随着源对象数组的改变而改变,即便有时候你并不想让副本对象
跟着改变。测试打印结果显示，array的长度发生了变化，具有调用
mutableArray方法的能力。
NSMutableArray只能用strong修饰，不存在有copy修饰的情
况，写了就成NSArray了。
</code></pre>
<h2 id="循环引用如何定位"><a href="#循环引用如何定位" class="headerlink" title="循环引用如何定位"></a>循环引用如何定位</h2><pre><code>FBRetainCycleDetector
其原理完全是基于 DFS 算法（深度优先搜索）：把整个对象的之间
的引用情况当做图进行处理，查找其中的环，就找到了循环引用。
</code></pre>
<h2 id="masnory的block会循环引用吗"><a href="#masnory的block会循环引用吗" class="headerlink" title="masnory的block会循环引用吗"></a>masnory的block会循环引用吗</h2><pre><code>masonry中设置布局的方法中的block对象并没有被View所引用，
而是直接在方法内部同步执行，执行完以后block将释放，其中捕捉
的外部变量的引用计数也将还原到之前。
</code></pre>
<h2 id="对象a1，a2，a3没有dosomething方法，想让a1调的时候不崩溃"><a href="#对象a1，a2，a3没有dosomething方法，想让a1调的时候不崩溃" class="headerlink" title="对象a1，a2，a3没有dosomething方法，想让a1调的时候不崩溃"></a>对象a1，a2，a3没有dosomething方法，想让a1调的时候不崩溃</h2><pre><code>1.runtime动态添加方法
2.写category，使方法向前引用，在通过动态方法解析，不让丢出错误
3.用方法混淆
4.用kvo
</code></pre>
<h2 id="数组addobject如何不强引用"><a href="#数组addobject如何不强引用" class="headerlink" title="数组addobject如何不强引用"></a>数组addobject如何不强引用</h2><pre><code>1.使用NSPointerArray
2.使用代理中间类来代替
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift93%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift93%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:55:26" itemprop="dateCreated datePublished" datetime="2018-08-14T19:55:26+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><pre><code>1.并发，当有多个线程在操作时，如果系统只有一个CPU，
则它根本不可能真正同时进行一个以上的线程，它只能把CPU运
行时间划分为若干了时间段，再将时间段分配给各个线程执行，
在一个时间段的线程代码运行时，其他线程处于挂起状。这
种方式我们称之为并发。
2.并行，系统有一个以上CPU时，则线程的操作有可能非并发，
当一个cpu执行一个线程时，另一个cpu可以执行另一个线程，
两个线程互相不抢占cpu资源，可以同时进行，这种方式称为并行。
区别：并发和并行是既相似又有区别的两个概念，并行是指两个活
着多个时间在同一时刻发生；而并发是指两个或多个事件同一
时间间隔内发生。
</code></pre>
<h2 id="你理解的多线程"><a href="#你理解的多线程" class="headerlink" title="你理解的多线程"></a>你理解的多线程</h2><h3 id="第一种：pthread"><a href="#第一种：pthread" class="headerlink" title="第一种：pthread"></a>第一种：pthread</h3><pre><code>a.特点：
    1）一套通用的多线程API
    2）适用于Unix\Linux\Windows等系统
    3）跨平台\可移植
    4）使用难度大
b.使用语言：c语言
c.使用频率：几乎不用
d.线程生命周期：由程序员进行管理
</code></pre>
<h3 id="第二种：NSThread"><a href="#第二种：NSThread" class="headerlink" title="第二种：NSThread"></a>第二种：NSThread</h3><pre><code>a.特点：
    1）使用更加面向对象
    2）简单易用，可直接操作线程对象
    b.使用语言：OC语言
    c.使用频率：偶尔使用
    d.线程生命周期：由程序员进行管理
</code></pre>
<h3 id="第三种：GCD"><a href="#第三种：GCD" class="headerlink" title="第三种：GCD"></a>第三种：GCD</h3><pre><code>a.特点：
    1）旨在替代NSThread等线程技术
    2）充分利用设备的多核（自动）
b.使用语言：C语言
c.使用频率：经常使用
d.线程生命周期：自动管理
</code></pre>
<h3 id="第四种：NSOperation"><a href="#第四种：NSOperation" class="headerlink" title="第四种：NSOperation"></a>第四种：NSOperation</h3><pre><code>a.特点：
    1）基于GCD（底层是GCD）
    2）比GCD多了一些更简单实用的功能
    3）使用更加面向对象
b.使用语言：OC语言
c.使用频率：经常使用
d.线程生命周期：自动管理
</code></pre>
<h2 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h2><pre><code>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）
多线程并发（同时）执行，其实是CPU快速地在多条线程之间
调度（切换）
如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
思考：如果线程非常非常多，会发生什么情况？
CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源
每条线程被调度执行的频次会降低（线程的执行效率降低）
</code></pre>
<h2 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h2><pre><code>能适当提高程序的执行效率    
能适当提高资源利用率（CPU、内存利用率）
</code></pre>
<h2 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h2><pre><code>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，
子线程占用512KB），如果开启大量的线程，会占用大量的内存
空间，降低程序的性能
线程越多，CPU在调度线程上的开销就越大
程序设计更加复杂：比如线程之间的通信、多线程的数据共享
</code></pre>
<h2 id="GCD和NSOperation区别，你更倾向于哪一种？"><a href="#GCD和NSOperation区别，你更倾向于哪一种？" class="headerlink" title="GCD和NSOperation区别，你更倾向于哪一种？"></a>GCD和NSOperation区别，你更倾向于哪一种？</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><pre><code>1.GCD是底层的C语言构成的API，而NSOperationQueue及
相关对象是Objc的对象。在GCD中，在队列中执行的是由block
构成的任务，这是一个轻量级的数据结构；而Operation作为一
个对象，为我们提供了更多的选择；
2.在NSOperationQueue中，我们可以随时取消已经设定要准备
执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停
止已经加入queue的block(其实是有的，但需要许多复杂的代码)；
3.NSOperation能够方便地设置依赖关系，我们可以让一个
Operation依赖于另一个Operation，这样的话尽管两个
Operation处于同一个并行队列中，但前者会直到后者执行完毕后
再执行；
4.我们能将KVO应用在NSOperation中，可以监听一
个Operation是否完成或取消，这样子能比GCD更加有效地掌控
我们执行的后台任务；
5.在NSOperation中，我们能够设置NSOperation的
priority优先级，能够使同一个并行队列中的任务区分先后地执
行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分
block任务的优先级，也需要大量的复杂代码；
6.我们能够对NSOperation进行继承，在这之上添加成员变量与成
员方法，提高整个代码的复用度，这比简单地将block任务排入执行
队列更有自由度，能够在其之上添加更多自定制的功能。
总的来说，Operationqueue提供了更多你在编写多线程程序时需
要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代
码，为我们提供简单的API入口。从编程原则来说，一般我们需要尽
可能的使用高等级、封装完美的API，在必须时才使用底层API。但
是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的
GCD或许是个更好的选择，而Operationqueue 为我们提供能更多
的选择。
</code></pre>
<h3 id="倾向于GCD："><a href="#倾向于GCD：" class="headerlink" title="倾向于GCD："></a>倾向于GCD：</h3><pre><code>1.GCD是纯C语言的API，轻量级 。
2.GCD的执行速度比NSOperationQueue快。
3.代码更底层简洁
</code></pre>
<h3 id="倾向于：NSOperation"><a href="#倾向于：NSOperation" class="headerlink" title="倾向于：NSOperation"></a>倾向于：NSOperation</h3><pre><code>NSOperation拥有更多的函数可用
NSOperationQueue可以方便的设置operation之间的依
赖关系，GCD则需要很多代码。
NSOperationQueue支持KVO，可以检测operation是
否正在执行（isExecuted）,是否结束（isFinished）,
是否取消（isCanceled）
GCD 只支持FIFO 的队列，NSOperationQueue可以调
整队列的执行顺序（通过调整权重）。NSOperationQueue可
以方便的管理并发、NSOperation之间的优先级。
</code></pre>
<h3 id="使用场合："><a href="#使用场合：" class="headerlink" title="使用场合："></a>使用场合：</h3><pre><code>任务之间不太相互依赖，一般的需求很简单的多线程操作，
用GCD都可以了，简单高效。
任务之间有依赖或要监听任务的执行情况用 NSOperationQueue
</code></pre>
<h2 id="ios-几种线程锁"><a href="#ios-几种线程锁" class="headerlink" title="ios 几种线程锁"></a>ios 几种线程锁</h2><pre><code>锁是最常用的同步工具。一段代码段在同一个时间只能允许被一个线程访问
，比如一个线程A进入加锁代码之后由于已经加锁，另一个线程B就无法访问，
只有等待前一个线程A执行完加锁代码后解锁，B线程才能访问加锁代码。
@synchronized 一个对象层面的锁，锁住了整个对象，底层使用了互斥递归锁来实现
pathread_mutex 互斥锁（c语言）和信号量的实现原理类似，也是阻塞线程并进入睡眠，需要进行上下文切换。
NSLock 对象锁-简单的互斥锁（内部封装了一个 pthread_mutex）
NSCondition （封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件
变量保证执行顺序）同样实现了NSLocking协议，
所以它和NSLock一样，也有NSLocking协议的lock和unlock方法，
可以当做NSLock来使用解决线程同步问题，用法完全一样。NSCondition
提供更高级的用法。wait和signal
NSCondition和NSLock、@synchronized等是不同的是，
NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。
这是非常强大。
NSConditionLock （借助 NSCondition 来实现，本质是生产者-消费者模型）
也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。
NSRecursiveLock 递归锁有时候“加锁代码”中存在递归调用，递归开始前加
锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，
这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不
造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被
最终释放。
dispatch_semaphore GCD中信号量，也可以解决资源抢占问题,
支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；
每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，
直到信号量大于0开始执行
OSSpinLock 自旋锁(不建议使用)
自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取
锁就需要等待a线程释放锁。在没有获得锁的期间，b线程会一直处于忙等的状
态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太
划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。
</code></pre>
<h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><pre><code>相同点：都能保证同一时间只有一个线程访问共享资源。
都能保证线程安全。
不同点：
互斥锁：如果共享数据已经有其他线程加锁了，线程会进入
休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的
线程会被唤醒。
自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环
的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会
立即执行。
自旋锁的效率高于互斥锁。
由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放
自旋锁，否则等待该自旋锁的线程会一直在哪里自旋，这就会浪
费CPU时间。
持有自旋锁的线程在sleep之前应该释放自旋锁以便其他可以获得
该自旋锁。内核编程中，如果持有自旋锁的代码sleep了就可能
导致整个系统挂起。
</code></pre>
<h2 id="GCD的一些常用的函数？（group，-barrier，信号量-线程同步）"><a href="#GCD的一些常用的函数？（group，-barrier，信号量-线程同步）" class="headerlink" title="GCD的一些常用的函数？（group， barrier，信号量 线程同步）"></a>GCD的一些常用的函数？（group， barrier，信号量 线程同步）</h2><pre><code>延迟函数dispatch_after
一次性 dispatch_once
创建串行队列 dispatch_queue_create 
获取并发队列 dispatch_get_global_queue
获取主队列 dispatch_get_main_queue
异步执行任务 dispatch_async
同步执行任务 dispatch_sync
提交一个调度队列 dispatch_group_async
新建的queue设置优先级 dispatch_set_target_queue
任务执行完成通知回调 dispatch_group_notify 
让当前任务等待queue其他任务完成再执行 dispatch_barrier_async
</code></pre>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><pre><code>-(void)clickButton &#123;
    dispatch_sync(dispath_get_main_queue(), ^(void)&#123;
        NSLog(&quot;test&quot;);
    &#125;);
&#125;
以上代码座位一个UIButton的响应方法有什么问题，能看到log吗？
原因如下：
在ios使用 dispatch_sync(dispatch_get_main_queue()^()&#123;block体&#125;)；
dispath向主队列加一个同步的block；
此时主队列在等待    dispatch_sync(dispatch_get_main_queue()，^()&#123;block体&#125;)；执行
dispatch_sync在等待主队列执行完毕。
造成死锁。
</code></pre>
<h2 id="同时存在A-B-C三个网络请求，要求同时发起三个网络请求，当三个网络请求都返回数据以后再处理事件"><a href="#同时存在A-B-C三个网络请求，要求同时发起三个网络请求，当三个网络请求都返回数据以后再处理事件" class="headerlink" title="同时存在A,B,C三个网络请求，要求同时发起三个网络请求，当三个网络请求都返回数据以后再处理事件"></a>同时存在A,B,C三个网络请求，要求同时发起三个网络请求，当三个网络请求都返回数据以后再处理事件</h2><pre><code>首先创建并行队列，创建队列组，将队列和需要处理的网络请求分别
添加到组中，当组中所有队列处理完事件后调用
dispatch_group_notify，我们需要在里边处理事件。由于队列
在处理网络请求时将”发送完一个请求”作为事件完成的标记（此时还
未获得网络请求返回数据），所以在这里需要用信号量进行控制，在
执行dispatch_group_notify前发起信号等待（三次信号等待，
分别对应每个队列的信号通知），在每个队列获取到网络请求返回数
据时发出信号通知。这样就能完成需求中的要求。
如果需求中改为：同时存在A,B,C三个任务，要求ABC依次进行处
理，当上一个完成时再进行下一个任务，当三个任务都完成时再处理
事件。这时只需要将队列改为串行队列即可（不在需要信号量控
制）。
</code></pre>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><pre><code>信号量是一个计数器，常用于处理进程或线程的同步问题，特别是对临界资源的同步访问。
临界资源可以简单的理解为在某一时刻只能由一个进程或线程进行操作的资源，这里的资源
可以是一段代码、一个变量或某种硬件资源。信号量的值大于或等于0时表示可供并发进程使用的
资源实体数；小于0时代表正在等待使用临界资源的进程数。
注意：这里的信号量跟信号是没有关系的。
3、信号量的操作
信号量的值与相应资源的使用情况有关，当它的值大于0时，表示当前可用资源的数量，当他的值小于0时，其绝对值表示等待
使用这个资源的进程个数。信号量的值仅能由PV操作来改变。
</code></pre>
<h2 id="某些线程执行完之后去执行其他线程"><a href="#某些线程执行完之后去执行其他线程" class="headerlink" title="某些线程执行完之后去执行其他线程"></a>某些线程执行完之后去执行其他线程</h2><pre><code>1.利用GCD中的barrier
dispatch_async — A
dispatch_async — B
dispatch_barrier_async — middle
dispatch_async — C
2.利用GCD中的group
创建一个dispatch_group_t
dispatch_group_async — 依次添加并发操作
dispatch_group_notify
</code></pre>
<h2 id="两个线程的notification怎么实现，除GCD"><a href="#两个线程的notification怎么实现，除GCD" class="headerlink" title="两个线程的notification怎么实现，除GCD"></a>两个线程的notification怎么实现，除GCD</h2><pre><code>这里讲到了“重定向”，就是我们在Notification所在的默认线程
中捕获这些分发的通知，然后将其重定向到指定的线程中。
一种重定向的实现思路是自定义一个通知队列(注意，不是
NSNotificationQueue对象，而是一个数组)，让这个队列去维
护那些我们需要重定向的Notification。我们仍然是像平常一样
去注册一个通知的观察者，当Notification来了时，先看看post
这个Notification的线程是不是我们所期望的线程，如果不是，
则将这个Notification存储到我们的队列中，并发送一个信号
(signal)到期望的线程中，来告诉这个线程需要处理一个
Notification。指定的线程在收到信号后，将Notification从
队列中移除，并进行处理。
</code></pre>
<h2 id="如何保证NSNotificationCenter线程安全"><a href="#如何保证NSNotificationCenter线程安全" class="headerlink" title="如何保证NSNotificationCenter线程安全"></a>如何保证NSNotificationCenter线程安全</h2><pre><code>当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来
确保观察者是可用的。
主线程调用dealloc操作会让Observer对象的引用计数减为0，这
时对象会被释放掉。
后台线程发送一个通知，如果此时Observer还未被释放，则会用其
转出消息，并执行回调方法。而如果在回调执行的过程中对象被释放
了，就会出现上面的问题。
那我们该怎么做呢？这里有一些好的建议：
尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能
确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用
dealloc方法，所以这一点还是比较困难。
注册监听都时，使用基于block的API。这样我们在block还要继续
调用self的属性或方法，就可以通过weak-strong的方式来处理。
具体大家可以改造下上面的代码试试是什么效果。
使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过
了，在应用的整个生命周期都不会被释放。
使用代理。
</code></pre>
<h2 id="GCD-信号量控制并发"><a href="#GCD-信号量控制并发" class="headerlink" title="GCD 信号量控制并发"></a>GCD 信号量控制并发</h2><pre><code>信号量是一个整形值并且具有一个初始计数值，并且支持两个操作：
信号通知和等待。当一个信号量被信号通知，其计数会被增加。当一
个线程在一个信号量上等待时，线程会被阻塞（如果有必要的话），
直至计数器大于零，然后线程会减少这个计数。
dispatch_semaphore_signal是发送一个信号，自然会让信号
总量加1，dispatch_semaphore_wait等待信号，当信号总量少
于0的时候就会一直等待，否则就可以正常的执行，并让信号总、
量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步
任务和有限资源访问控制。
</code></pre>
<h2 id="iOS线程间的通信"><a href="#iOS线程间的通信" class="headerlink" title="iOS线程间的通信"></a>iOS线程间的通信</h2><pre><code>iOS中，两个线程之间要想互相通信，可以使用：NSMachPort 
首先NSMarchPort是一个task内线程之间异步通信用的 
你需要在你的两个object内重写handlePortMessage:方法来截
取接收到的消息，使用NSPortMessage来发送消息 
消息一般都是有唯一id和数据组成的 
数据需要经过序列化通过NSPortMessage的components来传递 
接收到数据之后需要进行反序列化 
</code></pre>
<h2 id="get和set的属性如何保证线程的安全"><a href="#get和set的属性如何保证线程的安全" class="headerlink" title="get和set的属性如何保证线程的安全"></a>get和set的属性如何保证线程的安全</h2><pre><code>property 的 atomic 是采用 spinlock_t 也就是俗称的自旋
锁实现的。
atomic通过这种方法，在运行时保证 set,get方法的原子性。 
仅仅是保证了set,get方法的原子性。 
这种线程是不安全的。
self.intA 是原子操作，但是self.intA = self.intA + 1
这个表达式并不是原子操作。 
所以线程是不安全的。 
threadA 在执行表达式 self.intA之后 self.intA = 
self.intA + 1;并没有执行完毕 
此时threadB 执行self.intA = self.intA + 1; 
再回到threadA时，self.intA的数值就被更新了
所以仅仅使用atomic并不能保证线程安全。
</code></pre>
<h2 id="GCD-的珊栏方法"><a href="#GCD-的珊栏方法" class="headerlink" title="GCD 的珊栏方法"></a>GCD 的珊栏方法</h2><pre><code>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能
开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方
法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包
含一个或多个任务。这就需要用到dispatch_barrier_async方
法在两个操作组间形成栅栏
</code></pre>
<h2 id="延时操作主要有4种方式"><a href="#延时操作主要有4种方式" class="headerlink" title="延时操作主要有4种方式"></a>延时操作主要有4种方式</h2><pre><code>1.sleep方式
[NSThread sleepForTimeInterval:1.0f];
[self delayMethod];
使用sleep方式在主线程和子线程中均可执行,但是这是中阻塞线程
的方式,所以建议放到子线程中使用,以免卡住主线程使界面卡住.
没有发现取消执行的方法.
2.NSTimer定时器方式
[NSTimer scheduledTimerWithTimeInterval:1.0f 
target:self selector:@selector(delayMethod) 
userInfo:nil repeats:NO];
使用定时器方式必须放到主线程中使用,否则无效. 是一种非阻塞的
方式.
可以通过- (void)invalidate;方法取消执行。
3.GCD方式
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;
//write code here
&#125;);
该方式可选择线程去执行,是一种非阻塞的方式.
没有发现取消执行的方法.
4.performSelector方式
[self performSelector:@selector(delayMethod) 
withObject:nil afterDelay:1.0f];
使用该方式必须放到主线程中使用,否则无效. 是一种非阻塞的方式.
取消执行方法如下:
[[self class] 
cancelPreviousPerformRequestsWithTarget:self 
selector:@selector(delayMethod) object:nil];
</code></pre>
<h2 id="NSLock死锁"><a href="#NSLock死锁" class="headerlink" title="NSLock死锁"></a>NSLock死锁</h2><pre><code>使用锁最容易犯的一个错误就是在递归或循环中造成死锁
如下代码中，因为在线程1中的递归block中，锁会被多次的lock，
所以自己也被阻塞了。
此处将NSLock换成NSRecursiveLock，便可解决问题。
NSRecursiveLock类定义的锁可以在同一线程多次lock，而不会
造成死锁。
递归锁会跟踪它被多少次lock。每次成功的lock都必须平衡调用
unlock操作。
只有所有的锁住和解锁操作都平衡的时候，锁才真正被释放给其他线
程获得。
</code></pre>
<h2 id="NSNotificationCenter的同步和异步"><a href="#NSNotificationCenter的同步和异步" class="headerlink" title="NSNotificationCenter的同步和异步"></a>NSNotificationCenter的同步和异步</h2><pre><code>默认的NSNotificationCenter是同步的
您可以通过NSNotificationQueue的
enqueueNotification:postingStyle:和enqueueNotification:postingStyle:coalesceMask:f
orModes:方法将通告放入队列，实现异步发送，在把通告放入队列
之后，这些方法会立即将控制权返回给调用对象。
通过这里的时间间隔可以看出， 通过通知队列来管理通知，不会再
造成阻塞。
</code></pre>
<h2 id="NSTimer在子线程可以执行吗，如果想执行的话runloop里要怎么操作"><a href="#NSTimer在子线程可以执行吗，如果想执行的话runloop里要怎么操作" class="headerlink" title="NSTimer在子线程可以执行吗，如果想执行的话runloop里要怎么操作"></a>NSTimer在子线程可以执行吗，如果想执行的话runloop里要怎么操作</h2><pre><code>开辟子线程：（使用子线程的runloop）
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
[thread start];
- (void)newThread
&#123;     @autoreleasepool
        &#123;
            [NSTimer scheduledTimerWithTimeInterval:2.0 
            target:self selector:@selector(addTime) 
            userInfo:nil repeats:YES];
            [[NSRunLoop currentRunLoop] run];
        &#125;
&#125;
</code></pre>
<h2 id="原子属性"><a href="#原子属性" class="headerlink" title="原子属性"></a>原子属性</h2><pre><code>原子属性（线程安全），是针对多线程设计的，是默认属性
多个线程在写入原子属性时（调用 setter 方法），能够保证同一
时间只有一个线程执行写入操作
原子属性是一种单(线程)写多(线程)读的多线程技术
原子属性的效率比互斥锁高，不过可能会出现脏数据
在定义属性时，必须显示地指定 nonatomic，否则默认为atomic
多线程——atomic nonatomic的区别
原子性atomic ,默认属性，编译器会在property上自动添加原子锁
非原子性nonatomic，不考虑多线程情况时使用，提高效率
原子属性内部的锁是自旋锁，自旋锁的执行效率比互斥锁高
atomic本质上就是给get/set方法加锁，即原子锁，以避免线程A
还没执行完setter，线程B又开始执行的，导致读取数据错误的问
题。
</code></pre>
<h3 id="atomic一定是线程安全的么？"><a href="#atomic一定是线程安全的么？" class="headerlink" title="atomic一定是线程安全的么？"></a>atomic一定是线程安全的么？</h3><pre><code>不一定，首先atomic的释义是原子性，并不是线程安全。原子性这
个概念表示一个操作序列就像一个操作一样不被打断，而不像一个操
作序列一样中间容许被打断。所以nonatomic一定是线程不安全
的，但是atomic却不一定是线程安全的。
假设线程A执行在对某属性get之前线程B release了该属性，会导
致程序崩溃。
原子属性内部的锁是自旋锁，自旋锁的执行效率比互斥锁高
</code></pre>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><pre><code>一般说来，确保线程安全的方法有这几个：竞争与原子操作、同步与
锁、可重入、过度优化。
竞争与原子操作 
多个线程同时访问和修改一个数据，可能造成很严重的后果。出现严
重后果的原因是很多操作被操作系统编译为汇编代码之后不止一条指
令，因此在执行的时候可能执行了一半就被调度系统打断了而去执行
别的代码了。一般将单指令的操作称为原子的(Atomic)，因为不管
怎样，单条指令的执行是不会被打断的。
因此，为了避免出现多线程操作数据的出现异常，Linux系统提供了
一些常用操作的原子指令，确保了线程的安全。但是，它们只适用于
比较简单的场合，在复杂的情况下就要选用其他的方法了。
同步与锁 
为了避免多个线程同时读写一个数据而产生不可预料的后果，开发人
员要将各个线程对同一个数据的访问同步，也就是说，在一个线程访
问数据未结束的时候，其他线程不得对同一个数据进行访问。
同步的最常用的方法是使用锁(Lock)，它是一种非强制机制，每个
线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放
锁；在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新
可用。
二元信号量是最简单的一种锁，它只有两种状态：占用与非占用，它
适合只能被唯一一个线程独占访问的资源。对于允许多个线程并发访
问的资源，要使用多元信号量(简称信号量)。
可重入 
一个函数被重入，表示这个函数没有执行完成，但由于外部因素或内
部因素，又一次进入该函数执行。一个函数称为可重入的，表明该函
数被重入之后不会产生任何不良后果。可重入是并发安全的强力保
障，一个可重入的函数可以在多线程环境下放心使用。
过度优化 
在很多情况下，即使我们合理地使用了锁，也不一定能够保证线程安
全，因此，我们可能对代码进行过度的优化以确保线程安全。
我们可以使用volatile关键字试图阻止过度优化，它可以做两件
事：第一，阻止编译器为了提高速度将一个变量缓存到寄存器而不写
回；第二，阻止编译器调整操作volatile变量的指令顺序。
在另一种情况下，CPU的乱序执行让多线程安全保障的努力变得很困
难，通常的解决办法是调用CPU提供的一条常被称作barrier的指
令，它会阻止CPU将该指令之前的指令交换到barrier之后，反之亦
然。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift95OC%E5%8F%91%E6%B6%88%E6%81%AF%E6%AD%A5%E9%AA%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift95OC%E5%8F%91%E6%B6%88%E6%81%AF%E6%AD%A5%E9%AA%A4/" class="post-title-link" itemprop="url">OC发消息</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:55:18" itemprop="dateCreated datePublished" datetime="2018-08-14T19:55:18+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="发消息步骤"><a href="#发消息步骤" class="headerlink" title="发消息步骤"></a>发消息步骤</h2><pre><code>1.检查这个selector是不是要被忽略的，比如mac os开发，
有垃圾回收，就不考虑 retain，release这些函数
2.检测这个target是不是nil对象，
ObjC的特性允许对一个nil对象发消息而不会崩溃
3.如果以上都通过了，就通过isa指针开始查找这个类的方法列表，
先从缓存中找，完了跳到对应函数执行
4.如果缓存列表找不到，就找一下方法分发表
5.如果方法列表找不到，就到超类的方法分发列表找，
一直找到NSObject
6.如果还找不到，就开始进行动态方法解析，调用
+(Bool)resolveInstanceMethod(SEL)selector；（实例方法）
+(Bool)resolveClassMethod(SEL)selector；（类方法）
该方法的参数就是那个位置的选择子（方法），其返回值为bool，
表示这个类能否新增一个实例方法用于处理该未知的方法
一般用这个方法可以动态的添加方法
7.如果还是找不到，那么运行系统就会问，
能不能把这条消息转发给其他的接受者处理。调用
+(id)forwardingTargetForSelector(SEL)selector；
当前接收者如果能找到备选对象，那么将其返回，
如果找不到，返回nil
8.如果还是找不到，那么会创建一个NSInvocation对象，
把这个尚未处理的那条消息有关的全部细节都封装其中，
此对象包含选择子，目标对象及参数，
并调用下面的方法进行消息转发
-（void）forwardInvocation：(NSInvocation *)invocation；
9.如果最后都没有出来的话，那么就抛出异常
</code></pre>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><pre><code>当前对象无论调用任何方法返回的都是当前对象
无论何时，要调用objc_msgSend函数，必须要将函数强制转
换成合适的函数指针类型才能调用。
其实编译器会根据情况在objc_msgSend,
objc_msgSend_stret, objc_msgSendSuper, 或
objc_msgSendSuper_stret四个方法中选择一个来调用。
</code></pre>
<h2 id="消息转发："><a href="#消息转发：" class="headerlink" title="消息转发："></a>消息转发：</h2><h3 id="消息转发机流程"><a href="#消息转发机流程" class="headerlink" title="消息转发机流程"></a>消息转发机流程</h3><pre><code>1、动态方法解析resolveInstanceMethod
2、备用接受者forwardingTargetForSelector
3、完整转发forwardInvocation
你可以实现forwardInvocation方法，将消息转发给另一个
对象，forwardInvocation方法是一个动态方法，在响应者无法
响应方法时，会调用forwardInvocation方法，可以重写这个方
法，实现消息转发。
</code></pre>
<h2 id="Objc中向一个nill对象发消息，会发生什么？"><a href="#Objc中向一个nill对象发消息，会发生什么？" class="headerlink" title="Objc中向一个nill对象发消息，会发生什么？"></a>Objc中向一个nill对象发消息，会发生什么？</h2><pre><code>如果self为nil，那么selector也会为空，直接返回，不会出现问题。
（返回值时对象，是标量，结构体）
如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0
地址返回，所以不会出现任何错误
如果返回值类型是对象，那么返还nil
如果回值类型是标量，那么是0，
如果回值类型是结构体为0，
其他为返回值是未定义的。
但对于[NSNull null]对象发送消息时，是会crash的，因为
NSNull类只有一个null方法。
</code></pre>
<h3 id="unrecognized-selector-sent-to-instance的错误是怎么回事？"><a href="#unrecognized-selector-sent-to-instance的错误是怎么回事？" class="headerlink" title="unrecognized selector sent to instance的错误是怎么回事？"></a>unrecognized selector sent to instance的错误是怎么回事？</h3><pre><code>这是因为这个对象已经被释放了（引用计数为0了），那么这个时候再去调用方
法肯定是会Crash的，因为这个时候这个对象就是一个野指针（指向僵尸对象
（对象的引用计数为0，指针指向的内存已经不可用）的指针）了，安全的做法
是释放后将对象重新置为nil，使它成为一个空指针，大家可以在关闭ARC后手
动release对象验证一下。
</code></pre>
<h3 id="空指针和野指针的区别"><a href="#空指针和野指针的区别" class="headerlink" title="空指针和野指针的区别"></a>空指针和野指针的区别</h3><pre><code>没有存储任何内存地址的指针就称为空指针(NULL指针)
空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。
&quot;野指针&quot;不是NULL指针，是指向&quot;垃圾&quot;内存（不可用内存）的指针。
野指针是非常危险的。
</code></pre>
<h2 id="函数调用和OC的消息传递机制区别"><a href="#函数调用和OC的消息传递机制区别" class="headerlink" title="函数调用和OC的消息传递机制区别"></a>函数调用和OC的消息传递机制区别</h2><pre><code>对于C语言，函数的调用在编译器的时候决定调用那个函数。编译完之后直接
顺序执行。
OC的函数调用成为消息发送。属于动态调用过程。在编译的时候决不能决定
真正调用那个函数（实时证明，在编译阶段，oc可以调用任何函数，及时这个
函数并未实现，只要申明过就不会报错，而c语言在编译阶段或报错）。
</code></pre>
<h2 id="消息转发中的resolveInstanceMethod返回值是Bool的话，那不去动态增加方法，直接返回yes行不行？"><a href="#消息转发中的resolveInstanceMethod返回值是Bool的话，那不去动态增加方法，直接返回yes行不行？" class="headerlink" title="消息转发中的resolveInstanceMethod返回值是Bool的话，那不去动态增加方法，直接返回yes行不行？"></a>消息转发中的resolveInstanceMethod返回值是Bool的话，那不去动态增加方法，直接返回yes行不行？</h2><pre><code>返回值文档中说是表示动态决议成功与否。但在上面的例子中（不涉
及消息转发的情况下），如果在该函数内为指定的 selector 提供
实现，无论返回 YES 还是 NO，编译运行都是正确的；但如果在该
函数内并不真正为 selector 提供实现，无论返回 YES 还是 
NO，运行都会 crash，道理很简单，selector 并没有对应的实
现，而又没有实现消息转发。
resolveInstanceMethod 是为对象方法进行决议，
而 resolveClassMethod 是为类方法进行决议。
</code></pre>
<h2 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h2><pre><code>NSInvocation是一个消息调用类，它包含了所有OC消息的成分：
target、selector、参数以及返回值。NSInvocation可以将消
息转换成一个对象，消息的每一个参数能够直接设定，而且当一个
NSInvocation对象调度时返回值是可以自己设定的。一个
NSInvocation对象能够重复的调度不同的目标(target)，而且
它的selector也能够设置为另外一个方法签名。NSInvocation
遵守NSCoding协议，但是仅支持NSPortCoder编码，不支持归档
型操作。
// 通过NSMethodSignature对象创建NSInvocation对象，NSMethodSignature为方法签名类
+ (NSInvocation *)invocationWithMethodSignature:(NSMethodSignature *)sig;
// 获取NSMethodSignature对象
@property (readonly, retain) NSMethodSignature *methodSignature;
// 保留参数，它会将传入的所有参数以及target都retain一遍
- (void)retainArguments;
// 判断参数是否还存在
// 调用retainArguments之前，值为NO，调用之后值为YES
@property (readonly) BOOL argumentsRetained;
// 设置消息调用者，注意：target最好不要是局部变量
@property (nullable, assign) id target;
// 设置要调用的消息
@property SEL selector;
// 获取消息返回值
- (void)getReturnValue:(void *)retLoc;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/22/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/40/">40</a><a class="extend next" rel="next" href="/page/24/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">400</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
