<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/10/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/M_Swift236%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/M_Swift236%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">常见的汇编指令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-25 16:39:39" itemprop="dateCreated datePublished" datetime="2021-02-25T16:39:39+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-28 14:56:36" itemprop="dateModified" datetime="2021-09-28T14:56:36+08:00">2021-09-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>AT&amp;T<br>寄存器名称    %rax<br>操作数顺序    movq %rax %rdx<br>常数、立即数    movq $3 %rax<br>内存赋值    movq $0xa, 0x1ff7(%rip)<br>取内存地址    leaq -0x18(%rbp),%rax<br>jmp指令 jmp 0x4000102<br>call指令 call *%rdx<br>操作长度 movl %eax %edx<br>B = byte 8<br>S = short 16<br>W = word 16<br>L = long 32<br>Q = quad 64<br>T = ten bytes 80</p>
<p>常见的寄存器：<br>rax 、rbx、rcx、rdx、rsx、rdi、rbp、rsp<br>r8、r9、r10、r11、r12、r13、r14、r15<br>寄存器的具体用途：<br>rax、rdx常作为函数返回值使用<br>rdi、rsi、rdx、rcx、r8、r9等寄存器常用于存放函数参数<br>rsp、rdp用于栈操作<br>rip 作为指令指针</p>
<p>规律：<br>内存地址格式为： 0x4bdc(%rip), 一般是全局变量，全局区（数据段）<br>内存地址格式为：-0x78(%rbp), 一般是局部变量，栈空间<br>内存地址格式为：0x10(%rax), 一般是堆空间</p>
<p>guard语句最大的优势就是在解包(Optional)时候, 比用 if 语句解包更优雅, 避免在大量串行解包的时候出现金字塔.<br>// guard let 保证变量／常量一定有值，没有值则返回。<br>var a: String? = “ddd”<br>guard let b = a else { print(“a is nil”) }<br>print(b) //注意解包之后b的作用域仍然有效</p>
<p>//if<br>var a: String? = “ddd”<br> if let b = a {<br>     print(b) //解包之后b的只有在 { … } 内才有作用域<br> }</p>
<p>ArrayList、LinkedList</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/M_Swift240Cesium%E9%A3%9E%E8%A1%8C%E6%BC%AB%E6%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/M_Swift240Cesium%E9%A3%9E%E8%A1%8C%E6%BC%AB%E6%B8%B8/" class="post-title-link" itemprop="url">Cesium飞行漫游</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-25 16:39:39" itemprop="dateCreated datePublished" datetime="2021-02-25T16:39:39+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 21:42:47" itemprop="dateModified" datetime="2022-03-14T21:42:47+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>window.bxmap = window.bxmap || {};<br>window.bxmap.FlyCesium = {<br>  cesiumViewer: null,<br>  draw3DObj: null,<br>  drawHelper: null,<br>  isDrawFly: false, //设定路线模式<br>  drawPolyline: null, //飞行绘制路线<br>  data: [<br>    {<br>      id: “1”,<br>      name: “阳江闸坡”,<br>      geojson:<br>        ‘{“orientation”:{“heading”:0.07372076173362352,”pitch”:-1.5574628887292024,”roll”:0},”position”:{“x”:-2205629.231433604,”y”:5509184.64306962,”z”:2331219.615547844},”geometry”:{“type”:”LineString”,”coordinates”:[[111.8181532375421,21.57868178213224],[111.81835028960268,21.578460581633188],[111.81832383076255,21.57812489081727],[111.81847943987464,21.577930686377922],[111.81878489838651,21.57765953027421],[111.81916083936886,21.577412646930927],[111.81958489944898,21.57729241143278],[111.82004766614196,21.57718315464893],[111.8206409631356,21.577000552080584],[111.82134398589339,21.576873639989994],[111.8219423400026,21.576726154070943],[111.822467537162,21.576376210912294],[111.82307030263561,21.576058642812292],[111.8237103973151,21.5756704298083],[111.8240924390803,21.575296152837485],[111.82504071801145,21.575766169089448],[111.82603850185104,21.576124273877287],[111.82694738799758,21.576428149353344],[111.82754018969692,21.576728981595224],[111.828099605676,21.57697046673728],[111.82845968318266,21.577307788777407],[111.8287111214647,21.577998110617774],[111.82881328135024,21.578557636789135],[111.82905095574245,21.57877846306897],[111.82918966895863,21.579074053131905],[111.82928422024466,21.579329257594996],[111.82930019172734,21.579630618390876],[111.82966603969574,21.580020790142015],[111.82960868244719,21.580744679418963],[111.82989219533579,21.581251462292837],[111.83013608532544,21.582236343172],[111.83037855800974,21.58254231013029],[111.83032824715998,21.58299431932842],[111.83001717858694,21.583468817164515],[111.8299185766154,21.584290601587544],[111.82948276544901,21.58496623602712],[111.8289749235787,21.58556878427974],[111.82886305199469,21.585776309810406],[111.8287779821505,21.585946333271792],[111.82865496967007,21.586265136888645],[111.82847674720864,21.586438092096014],[111.82845974740698,21.586567373767977],[111.828355170664,21.586736247366822],[111.82830843296874,21.586863152790087],[111.82825365102633,21.58710380271154],[111.82821734971404,21.587138762444976],[111.82817916952548,21.587294814193356],[111.82787759367034,21.587314539280754],[111.82719468513524,21.587237821164194],[111.82672929414602,21.58716013804561],[111.82658494057793,21.587131014021804],[111.82652478882481,21.587094797111455],[111.82647814913857,21.58694770659332],[111.82649812273736,21.58651375697629],[111.82650209141173,21.586517166652694],[111.82650209141173,21.586517166652694]]}}’,<br>    },<br>  ], //漫游路径信息模拟数据<br>  Init: function(cesiumViewer, drawHelper) {<br>    this.cesiumViewer = cesiumViewer; //cesium对象<br>    this.drawHelper = drawHelper; //drawHelper对象<br>    this.InitEvent();<br>    //this.loadData();<br>  },<br>  InitEvent: function() {<br>    //飞行路径顶端部分的切换事件<br>    // $(“.fly3DPaths_tab li”).bind(“click”, function () {<br>    //     $(‘.fly3DPaths_tab_ul&gt;li’).each(function(index){<br>    //         $(‘.fly3DPaths_tab_ul&gt;li’).eq(index).removeClass(‘select’);<br>    //     })<br>    //     //三角形标识切换<br>    //     switch ($(this).index()) {<br>    //         case 0://预设路线<br>    //             $(‘#overFlyClick’).addClass(‘select’);<br>    //             $(“#overFlyPage”).css({ display: “block” });<br>    //             $(“#drawFlyPage”).css({ display: “none” });<br>    //             bxmap.FlyCesium.loadData();<br>    //             break;<br>    //         case 1://手动绘制<br>    //             $(‘#drawFlyCilck’).addClass(‘select’);<br>    //             $(“#overFlyPage”).css({ display: “none” });<br>    //             $(“#drawFlyPage”).css({ display: “block” });<br>    //             break;<br>    //     }<br>    // });<br>    // //开始飞行<br>    // $(“#start_Fly3DPaths”).click(function(){<br>    //     //debugger;<br>    //     if(bxmap.FlyCesium.draw3DObj){<br>    //         bxmap.FlyCesium.showFly3DPaths(bxmap.FlyCesium.draw3DObj);<br>    //     }else{<br>    //         jDialog.dialog({<br>    //             title: “提示信息”,<br>    //             modal: true,// 非模态，即不显示遮罩层<br>    //             autoClose: 1500,<br>    //             content: “漫游路线不存在”<br>    //         });<br>    //     }<br>    // });<br>    // //暂停飞行<br>    // $(“#pause_Fly3DPaths”).click(function(){<br>    //     bxmap.FlyCesium.pauseFly3DPaths();<br>    // });<br>    // //向前飞行<br>    // $(“#playForward_Fly3DPaths”).click(function(){<br>    //     bxmap.FlyCesium.playForwardFly3DPaths();<br>    // });<br>    // //向后飞行<br>    // $(“#playReverse_Fly3DPaths”).click(function(){<br>    //     bxmap.FlyCesium.playReverseFly3DPaths();<br>    // });<br>    // //退出飞行<br>    // $(“#stop_Fly3DPaths”).click(function(){<br>    //     $(“#cesiumFly3DPaths”).click();<br>    //     bxmap.FlyCesium.stopFly3DPaths();<br>    // });<br>    // //清空路线<br>    // $(“#clear_Fly3DPaths”).click(function(){<br>    //     bxmap.FlyCesium.clearFly3DPaths();<br>    // });<br>    //<br>    // //设定路线<br>    // $(“#draw_Fly3DPaths”).click(function(){<br>    //     if(!bxmap.FlyCesium.drawHelper){<br>    //         bxmap.FlyCesium.drawHelper = new this.DrawHelper(bxmap.FlyCesium.cesiumViewer);<br>    //     }<br>    //     bxmap.FlyCesium.draw3DObj = bxmap.FlyCesium.DrawFly3DPaths(bxmap.FlyCesium.drawHelper);<br>    // });<br>    // //保存路线<br>    // $(“#save_Fly3DPaths”).click(function(){<br>    //     if(bxmap.FlyCesium.draw3DObj &amp;&amp; bxmap.FlyCesium.isDrawFly){<br>    //         jDialog.dialog({<br>    //             title: ‘保存路线’,<br>    //             content: ‘<div><span>名称:</span><input type="text" id="FlyAdd_name" value="'+name+'"></div>‘,<br>    //             width: 300,<br>    //             height: 120,<br>    //             modal: true,// 非模态，即不显示遮罩层<br>    //             buttons: [<br>    //                 {<br>    //                     text: ‘确定’,<br>    //                     handler: function (button, dialog) {<br>    //                         var draw3DObj=JSON.stringify(bxmap.FlyCesium.draw3DObj); //将JSON对象转化为JSON字符<br>    //                         var TbFly={id:Math.random().toString(36).substr(2),name:$(“#FlyAdd_name”).val(),geojson:draw3DObj};<br>    //                         bxmap.FlyCesium.data.push(TbFly);<br>    //                         $(“#overFlyClick”).click();<br>    //                         dialog.close();<br>    //                         bxmap.FlyCesium.clearFly3DPaths();<br>    //<br>    //                     }<br>    //                 }, {<br>    //                     text: ‘取消’,<br>    //                     handler: function (button, dialog) {<br>    //                         dialog.close();<br>    //                     }<br>    //                 }<br>    //             ]<br>    //         });<br>    //<br>    //     }else{<br>    //         jDialog.dialog({<br>    //             title: “提示信息”,<br>    //             modal: true,// 非模态，即不显示遮罩层<br>    //             autoClose: 1500,<br>    //             content: “设定的漫游路线不存在，请绘制再保存”<br>    //         });<br>    //     }<br>    //<br>    // });<br>  },<br>  //飞行路径列表表格监听事件<br>  flyTableOnclick: function() {<br>    $(“#overFly_table td”).click(function() {<br>      var trSeq = $(this)<br>        .parent()<br>        .parent()<br>        .find(“tr”)<br>        .index($(this).parent()); //选中的哪行<br>      var geojson = $(<br>        “#overFly_table tr:gt(0):eq(“ + trSeq + “) td:eq(5)”<br>      ).text(); //获取选中行的geojson列值<br>      var name = $(“#overFly_table tr:gt(0):eq(“ + trSeq + “) td:eq(0)”).text(); //获取选中行的name列值<br>      var id = $(“#overFly_table tr:gt(0):eq(“ + trSeq + “) td:eq(4)”).text(); //获取选中行的id列值<br>      geojson = eval(“(“ + geojson + “)”);<br>      var tdSeq = $(this)<br>        .parent()<br>        .find(“td”)<br>        .index($(this)); //选中哪一列<br>      switch (tdSeq) {<br>        case 0: //名称<br>          break;<br>        case 1: //飞行<br>          bxmap.FlyCesium.draw3DObj = geojson;<br>          //bxmap.FlyCesium.cesium.showFly3DPaths(geojson);<br>          bxmap.FlyCesium.showFly3DPaths(geojson);<br>          $(“#drawFlyCilck”).click();<br>          break;<br>        case 2: //修改<br>          jDialog.dialog({<br>            title: “修改路线”,<br>            content:<br>              ‘<div><span>名称:</span><input type="text" id="Fly_name" value="' +
              name +
              '"></div>‘,<br>            width: 300,<br>            height: 120,<br>            modal: true, // 非模态，即不显示遮罩层<br>            buttons: [<br>              {<br>                text: “确定”,<br>                handler: function(button, dialog) {<br>                  bxmap.FlyCesium.data = bxmap.FlyCesium.modifyElement(<br>                    bxmap.FlyCesium.data,<br>                    id,<br>                    $(“#Fly_name”).val()<br>                  );<br>                  $(“#overFlyClick”).click();<br>                  dialog.close();<br>                },<br>              },<br>              {<br>                text: “取消”,<br>                handler: function(button, dialog) {<br>                  dialog.close();<br>                },<br>              },<br>            ],<br>          });<br>          break;<br>        case 3: //删除<br>          //删除<br>          jDialog.dialog({<br>            title: “删除路线”,<br>            modal: true, // 非模态，即不显示遮罩层<br>            content: “确定要删除该漫游路线?”,<br>            buttons: [<br>              {<br>                text: “确定”,<br>                handler: function(button, dialog) {<br>                  bxmap.FlyCesium.data = bxmap.FlyCesium.delElement(<br>                    bxmap.FlyCesium.data,<br>                    id<br>                  );<br>                  $(“#overFlyClick”).click();<br>                  dialog.close();<br>                },<br>              },<br>              {<br>                text: “取消”,<br>                handler: function(button, dialog) {<br>                  dialog.close();<br>                },<br>              },<br>            ],<br>          });<br>          break;<br>      }<br>    });<br>  },<br>  /**<br>     * 从数组中移除指定的元素,要是存在的话<br>     @ serviceArray筛选数组<br>     @ id移除元素id<br>     <em>/<br>  delElement: function(serviceArray, id) {<br>    var array = [];<br>    for (var i = 0; i &lt; serviceArray.length; i++) {<br>      if (serviceArray[i].id != id) {<br>        array.push(serviceArray[i]);<br>      }<br>    }<br>    return array;<br>  },<br>  /**<br>     * 从数组中修改指定的元素,要是存在的话<br>     @ serviceArray筛选数组<br>     @ id修改元素id<br>     @ name修改元素名称<br>     */<br>  modifyElement: function(serviceArray, id, name) {<br>    var array = [];<br>    for (var i = 0; i &lt; serviceArray.length; i++) {<br>      if (serviceArray[i].id == id) {<br>        serviceArray[i].name = name;<br>      }<br>      array.push(serviceArray[i]);<br>    }<br>    return array;<br>  },<br>  loadData: function() {<br>    var data = bxmap.FlyCesium.data;<br>    var html = “”;<br>    if (data.length &gt; 0) {<br>      for (var i = 0; i &lt; data.length; i++) {<br>        var flydata = data[i];<br>        html +=<br>          “<tr>“ +<br>          // ‘<td><input type="checkbox" name="FLYNAME" id="'+flydata.id+'" style="cursor: pointer;" onchange=""></td>‘+<br>          ‘<td><a style="color:#fff;text-decoration:none;font-size:12px;">‘ +<br>          flydata.name +<br>          “</a></td>“ +<br>          ‘<td><button class="btn btn-default btn-xs" style="color:#fff;">飞行</button></td>‘ +<br>          ‘<td><button class="btn btn-default btn-xs" style="color:#fff;">修改</button></td>‘ +<br>          ‘<td><button class="btn btn-default btn-xs" style="color:#fff;">删除</button></td>‘ +<br>          “<td><a style='color:black;text-decoration:none;font-size:13px;'>“ +<br>          flydata.id +<br>          “</a></td>“ +<br>          “<td><a style='color:black;text-decoration:none;font-size:13px;'>“ +<br>          flydata.geojson +<br>          “</a></td>“ +<br>          “<td><a style='color:black;text-decoration:none;font-size:13px;'>“ +<br>          flydata.position +<br>          “</a></td>“ +<br>          “<td><a style='color:black;text-decoration:none;font-size:13px;'>“ +<br>          flydata.orientation +<br>          “</a></td>“ +<br>          “</tr>“;<br>      }<br>      $(“#overFly_table tbody”).html(html);<br>      $(“#overFly_table”)<br>        .find(“td:eq(4)”)<br>        .hide(); //隐藏id字段列<br>      $(“#overFly_table”)<br>        .find(“td:eq(5)”)<br>        .hide(); //隐藏geojson字段列<br>      $(“#overFly_table”)<br>        .find(“td:eq(6)”)<br>        .hide(); //隐藏position字段列<br>      $(“#overFly_table”)<br>        .find(“td:eq(7)”)<br>        .hide(); //隐藏orientation字段列<br>      //表格—行点击事件<br>      bxmap.FlyCesium.flyTableOnclick();<br>    }<br>  },<br>  /</em>*</p>
<ul>
<li><p>清空漫游路径</p>
</li>
<li><p>@method stopFly3DPaths</p>
</li>
<li><p>@param</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>clearFly3DPaths: function() {<br>this.cesiumViewer.trackedEntity = undefined;<br>bxmap.FlyCesium.isDrawFly = false;<br>bxmap.FlyCesium.draw3DObj = null;<br>this.cesiumViewer.entities.removeAll(); //清空所有模型<br>//清空绘制飞行路线<br>if (this.drawPolyline) {<br>  this.cesiumViewer.scene.primitives.remove(this.drawPolyline);<br>  this.drawPolyline = null;<br>}<br>},<br>setFlySpeed(multiplier) {<br>this.cesiumViewer.clock.multiplier = multiplier;<br>},<br>getFlySpeed() {<br>return this.cesiumViewer.clock.multiplier;<br>},<br>/**</p>
</li>
<li><p>飞行漫游路径</p>
</li>
<li><p>@method showFly3DPaths</p>
</li>
<li><p>@param  pathsData 飞行路径信息,格式如下:{“orientation”:{“heading”:2.411783930363565,”pitch”:-0.21097267398444197,”roll”:0.0015622392231300353},”position”: {“x”:-2206260.239730831,”y”:5510911.392077349,”z”:2331987.10863007}, “geometry”:{“type”: “LineString”, “coordinates”: [[101.80089882736969, 26.60700234866561], [101.80082205161088, 26.607156056057718]]} }</p>
</li>
<li><p>@param  position 飞行路径跳转位置</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>showFly3DPaths: function(pathsData) {<br>var T = this;<br>this.clearFly3DPaths();<br>T.cesiumViewer.camera.setView({<br>  destination: pathsData.position,<br>  orientation: pathsData.orientation,<br>});<br>setTimeout(function() {<br>  executeFly3D();<br>}, 200);<br>function executeFly3D() {<br>  if (pathsData &amp;&amp; pathsData.geometry) {</p>
<pre><code>var positionA = pathsData.geometry.coordinates;
var position = [];
if (positionA.length &gt; 0) &#123;
  for (var i = 0; i &lt; positionA.length; i++) &#123;
    var x = positionA[i][0];
    var y = positionA[i][1];
    position.push(&#123; x: x, y: y &#125;);
  &#125;
&#125; else &#123;
  return;
&#125;
function computeCirclularFlight() &#123;
  var property = new Cesium.SampledPositionProperty();
  for (var i = 0; i &lt; position.length; i++) &#123;
    if (i == 0) &#123;
      var time = Cesium.JulianDate.addSeconds(
        start,
        i,
        new Cesium.JulianDate()
      );
      //var _position = Cesium.Cartesian3.fromDegrees(position[i].x, position[i].y, 1170);
      var _position = Cesium.Cartesian3.fromDegrees(
        position[i].x,
        position[i].y,
        0
      );
      property.addSample(time, _position);
    &#125;
    if (i &lt; 10000 &amp;&amp; i &gt; 0) &#123;
      var position_a = new Cesium.Cartesian3(
        property._property._values[i * 3 - 3],
        property._property._values[i * 3 - 2],
        property._property._values[i * 3 - 1]
      );
      if (i &lt; 976) &#123;
        //var _position = Cesium.Cartesian3.fromDegrees(position[i].x, position[i].y, 1170);
        var _position = Cesium.Cartesian3.fromDegrees(
          position[i].x,
          position[i].y,
          0
        );
      &#125; else if (i &gt; 975 &amp;&amp; i &lt; 986) &#123;
        //var _position = Cesium.Cartesian3.fromDegrees(position[i].x, position[i].y, 1170 + 20 * (i - 980));
        var _position = Cesium.Cartesian3.fromDegrees(
          position[i].x,
          position[i].y,
          0
        );
      &#125; else if (i &gt; 985) &#123;
        //var _position = Cesium.Cartesian3.fromDegrees(position[i].x, position[i].y, 1170 + 200);
        var _position = Cesium.Cartesian3.fromDegrees(
          position[i].x,
          position[i].y,
          0
        );
      &#125;

      var positions = [
        Cesium.Ellipsoid.WGS84.cartesianToCartographic(position_a),
        Cesium.Ellipsoid.WGS84.cartesianToCartographic(_position),
      ];
      var a = new Cesium.EllipsoidGeodesic(positions[0], positions[1]);
      var long = a.surfaceDistance;
      var _time = long / 50;
      var time = Cesium.JulianDate.addSeconds(
        property._property._times[i - 1],
        _time,
        new Cesium.JulianDate()
      );

      property.addSample(time, _position);
    &#125;
  &#125;
  return property;
&#125;
var start = Cesium.JulianDate.fromDate(new Date(2018, 3, 15, 16));
var stop = Cesium.JulianDate.addSeconds(
  start,
  30000,
  new Cesium.JulianDate()
);

//Make sure viewer is at the desired time.
T.cesiumViewer.clock.startTime = start.clone();
T.cesiumViewer.clock.stopTime = stop.clone();
T.cesiumViewer.clock.currentTime = start.clone();
T.cesiumViewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; //Loop at the end
//T.cesiumViewer.clock.clockRange = Cesium.ClockRange.UNBOUNDED; //
//T.cesiumViewer.clock.clockStep = Cesium.ClockStep.SYSTEM_CLOCK; //
//T.cesiumViewer.clock.multiplier = 10;//值越大，飞行越快
T.cesiumViewer.clock.multiplier = 0.6;
T.cesiumViewer.clock.canAnimate = false;
T.cesiumViewer.clock.shouldAnimate = true; //设置时间轴动态效果

var _position = computeCirclularFlight();

T.entityFly = T.cesiumViewer.entities.add(&#123;
  //Set the entity availability to the same interval as the simulation time.
  availability: new Cesium.TimeIntervalCollection([
    new Cesium.TimeInterval(&#123;
      start: start,
      stop: stop,
    &#125;),
  ]),
  position: _position,
  orientation: new Cesium.VelocityOrientationProperty(_position),
  /*model: &#123;
            uri:GLOBAL.domainResource+&quot;/systems/common-bx-gis/models/cesium/SampleData/models/CesiumAir/Cesium_Air.gltf&quot;,
            scale: 6,
            minimumPixelSize: 64,
            //heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
        &#125;,*/
  point: &#123;
    color: Cesium.Color.RED,
    outlineColor: Cesium.Color.WHITE,
    outlineWidth: 2,
    pixelSize: 15,
  &#125;,
  //Show the path as a pink line sampled in 1 second increments.
  path: &#123;
    resolution: 1,
    material: new Cesium.PolylineGlowMaterialProperty(&#123;
      glowPower: 0.1,
      color: Cesium.Color.YELLOW,
    &#125;),
    //width: 30
    width: 10,
  &#125;,
&#125;);
T.cesiumViewer.trackedEntity = T.entityFly;
setTimeout(function() &#123;
  T.cesiumViewer.camera.zoomOut(500.0); //缩小地图，避免底图没有数据
&#125;, 100);
</code></pre>
<p>  } else {</p>
<pre><code>return;
</code></pre>
<p>  }<br>}<br>},<br>/**</p>
</li>
<li><p>暂停飞行漫游路径</p>
</li>
<li><p>@method pauseFly3DPaths</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>pauseFly3DPaths: function() {<br>var clockViewModel = this.cesiumViewer.clockViewModel;<br>if (clockViewModel.shouldAnimate) {<br>  clockViewModel.shouldAnimate = false;<br>} else if (this.cesiumViewer.clockViewModel.canAnimate) {<br>  clockViewModel.shouldAnimate = true;<br>}<br>},<br>/**</p>
</li>
<li><p>向前飞行漫游路径</p>
</li>
<li><p>@method playForwardFly3DPaths</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>playForwardFly3DPaths: function() {<br>var clockViewModel = this.cesiumViewer.clockViewModel;<br>var multiplier = clockViewModel.multiplier;<br>if (multiplier &lt; 0) {<br>  clockViewModel.multiplier = -multiplier;<br>}<br>clockViewModel.shouldAnimate = true;<br>},<br>/**</p>
</li>
<li><p>向后飞行漫游路径</p>
</li>
<li><p>@method playForwardFly3DPaths</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>playReverseFly3DPaths: function() {<br>var clockViewModel = this.cesiumViewer.clockViewModel;<br>var multiplier = clockViewModel.multiplier;<br>if (multiplier &gt; 0) {<br>  clockViewModel.multiplier = -multiplier;<br>}<br>clockViewModel.shouldAnimate = true;<br>},<br>/**</p>
</li>
<li><p>设定飞行漫游路径</p>
</li>
<li><p>@method DrawFly3DPaths</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>DrawFly3DPaths: function(drawHelper) {<br>var T = this;<br>this.clearFly3DPaths();<br>drawHelper.startDrawingPolyline({<br>  callback: function(positions) {</p>
<pre><code>T.drawPolyline = new DrawHelper.PolylinePrimitive(&#123;
  positions: positions,
  width: 5,
  type: &quot;plot&quot;,
  geodesic: true,
&#125;);
T.cesiumViewer.scene.primitives.add(T.drawPolyline);
T.drawPolyline.setEditable();
//构造设定路线的返回信息
var coordinates = [];
var position = null;
var heading = null;
var pitch = null;
var roll = null;
for (var i = 0; i &lt; positions.length; i++) &#123;
  var cartographic = Cesium.Cartographic.fromCartesian(positions[i]); //世界坐标转地理坐标（弧度）
  var point = [
    (cartographic.longitude / Math.PI) * 180,
    (cartographic.latitude / Math.PI) * 180,
  ]; //地理坐标（弧度）转经纬度坐标
  //console.log(point);
  coordinates.push(point);
&#125;
//orientation&quot;:&#123;&quot;heading&quot;:2.411783930363565,&quot;pitch&quot;:-0.21097267398444197,&quot;roll&quot;:0.0015622392231300353&#125;,&quot;position&quot;: &#123;&quot;x&quot;:-2206260.239730831,&quot;y&quot;:5510911.392077349,&quot;z&quot;:2331987.10863007&#125;,
position = drawHelper._cameraPosition;
heading = drawHelper._cameraHeading;
pitch = drawHelper._cameraPitch;
roll = drawHelper._cameraRoll;
var pathsData = &#123;
  orientation: &#123; heading: heading, pitch: pitch, roll: roll &#125;,
  position: position,
  geometry: &#123; type: &quot;LineString&quot;, coordinates: coordinates &#125;,
&#125;;
if (bxmap.FlyCesium) &#123;
  bxmap.FlyCesium.draw3DObj = T.draw3DObj = pathsData;
  bxmap.FlyCesium.isDrawFly = true;
&#125;
//return T.draw3DObj;
</code></pre>
<p>  },<br>});<br>},<br>/**</p>
</li>
<li><p>退出飞行漫游路径</p>
</li>
<li><p>@method stopFly3DPaths</p>
</li>
<li><p>@param</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>stopFly3DPaths: function() {<br>var start = Cesium.JulianDate.fromDate(new Date());<br>this.cesiumViewer.clock.startTime = start.clone();<br>var stop = Cesium.JulianDate.addSeconds(<br>  start,<br>  300000000,<br>  new Cesium.JulianDate()<br>);<br>this.cesiumViewer.clock.stopTime = stop.clone();<br>//this.cesiumViewer.entities.remove(this.entityFly);<br>this.clearFly3DPaths();<br>},<br>};</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/M_Swift241Cesium%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/M_Swift241Cesium%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Cesium分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-25 16:39:39" itemprop="dateCreated datePublished" datetime="2021-02-25T16:39:39+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-14 21:42:50" itemprop="dateModified" datetime="2022-03-14T21:42:50+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>坡度分析<br>slope<br>等高线<br>contourLine<br>地形开挖<br>clipping<br>淹没分析<br>SubmergeAnalysis<br>光照分析<br>SunshineAnalysis<br>坐标<br>WHCGCE2000ToWGS84<br>三维飞行初始化<br>flycesium<br>ViewShedStage<br>addHeatMap<br>addBillboard<br>addSkyBoxFn<br>DrawTool</p>
<h2 id="山谷、山脊"><a href="#山谷、山脊" class="headerlink" title="山谷、山脊"></a>山谷、山脊</h2><p>export const elevation = function (viewer, show) {<br>    viewer.scene.globe.enableLighting = true;<br>    var elevationRamp = [0.0, 0.045, 0.1, 0.15, 0.37, 0.54, 1.0];<br>    function getColorRamp(selectedShading) {<br>      var ramp = document.createElement(“canvas”);<br>      ramp.width = 100;<br>      ramp.height = 1;<br>      var ctx = ramp.getContext(“2d”);<br>      var values;<br>      if (selectedShading === “elevation”) {<br>        values = elevationRamp;<br>      }<br>      var grd = ctx.createLinearGradient(0, 0, 100, 0);<br>      grd.addColorStop(values[0], “#000000”); //black<br>      grd.addColorStop(values[1], “#2747E0”); //blue<br>      grd.addColorStop(values[2], “#D33B7D”); //pink<br>      grd.addColorStop(values[3], “#D33038”); //red<br>      grd.addColorStop(values[4], “#FF9742”); //orange<br>      grd.addColorStop(values[5], “#ffd700”); //yellow<br>      grd.addColorStop(values[6], “#ffffff”); //white<br>      ctx.fillStyle = grd;<br>      ctx.fillRect(0, 0, 100, 1);<br>      return ramp;<br>    }</p>
<pre><code>var minHeight = -414.0; // approximate dead sea elevation
var maxHeight = 8777.0; // approximate everest elevation
var contourColor = Cesium.Color.RED.clone();
var contourUniforms = &#123;&#125;;
var shadingUniforms = &#123;&#125;;

// The viewModel tracks the state of our mini application.
var viewModel = &#123;
  selectedShading: &quot;elevation&quot;,
  changeColor: function () &#123;
    contourUniforms.color = Cesium.Color.fromRandom(
      &#123; alpha: 1.0 &#125;,
      contourColor
    );
  &#125;,
&#125;;
function updateMaterial(selectedShading) &#123;
  viewModel.selectedShading = selectedShading;
  var globe = viewer.scene.globe;
  var material;
  if (selectedShading === &quot;elevation&quot;) &#123;
    material = Cesium.Material.fromType(&quot;ElevationRamp&quot;);
    shadingUniforms = material.uniforms;
    shadingUniforms.minimumHeight = minHeight;
    shadingUniforms.maximumHeight = maxHeight;
  &#125; 
  if (selectedShading !== &quot;none&quot;) &#123;
    shadingUniforms.image = getColorRamp(selectedShading);
  &#125;
  globe.material = material;
&#125;
updateMaterial(show? &quot;elevation&quot; : &quot;none&quot;);
</code></pre>
<p>}</p>
<h2 id="坡度分析"><a href="#坡度分析" class="headerlink" title="坡度分析"></a>坡度分析</h2><p>export const slope = function(viewer){<br>    viewer.scene.globe.enableLighting = true;<br>    var material = Cesium.Material.fromType(‘SlopeRamp’);<br>    var shadingUniforms = material.uniforms;<br>    shadingUniforms.image = getColorRamp();<br>    viewer.scene.globe.material = material;<br>    function getColorRamp() {<br>        var ramp = document.createElement(‘canvas’);<br>        ramp.width = 100;<br>        ramp.height = 1;<br>        var ctx = ramp.getContext(‘2d’);</p>
<pre><code>    var grd = ctx.createLinearGradient(0, 0, 100, 0);
   
    // var values = [0.0, 0.25,0.5];

    var values = [0.0,0.2,0.6,1];
    grd.addColorStop(values[0], &#39;rgba(0,0,0,0.0)&#39;); //black
    grd.addColorStop(values[1], &#39;rgba(220,20,60,0.6)&#39;); //blue
    grd.addColorStop(values[2], &#39;rgba(255,255,0,1.0)&#39;); //
    grd.addColorStop(values[3], &#39;rgba(255,0,255,1.0)&#39;); //green

    // var values = [0.0, 0.25, 0.5];
    // grd.addColorStop(values[0], &#39;rgba(0,0,0,0.8)&#39;); //black
    // grd.addColorStop(values[1], &#39;rgba(39,71,224,0.8)&#39;); //blue
    // grd.addColorStop(values[2], &#39;rgba(211,48,56,0.8)&#39;); //red

    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, 100, 1);
    return ramp;
&#125;
</code></pre>
<p>}</p>
<h2 id="等高线"><a href="#等高线" class="headerlink" title="等高线"></a>等高线</h2><p>export const contourLine = function (viewer) {</p>
<pre><code>viewer.scene.globe.enableLighting = true;

// 创建一个拥有高程阴影和等高线的组合样式
function getElevationContourMaterial() &#123;
    return new Cesium.Material(&#123;
        fabric: &#123;
            type: &#39;ElevationColorContour&#39;,
            materials: &#123;
                contourMaterial: &#123;
                    type: &#39;ElevationContour&#39;
                &#125;,
                elevationRampMaterial: &#123;
                    type: &#39;ElevationRamp&#39;
                &#125;
            &#125;,
            components: &#123;
                diffuse: &#39;contourMaterial.alpha == 0.0 ? elevationRampMaterial.diffuse : contourMaterial.diffuse&#39;,
                alpha: &#39;max(contourMaterial.alpha, elevationRampMaterial.alpha)&#39;
            &#125;
        &#125;,
        translucent: false
    &#125;);
&#125;

var minHeight = 50.0; // 最低接近死海高度
var maxHeight = 1000.0; // 最高接近珠峰高度
var contourColor = Cesium.Color.AQUA.withAlpha(0.8); // 等高线的颜色
var contourSpacing = 100.0; // 等高线的等间距
var contourWidth = 2.0; // 等高线的宽度

// 1、高程阴影
// var material = Cesium.Material.fromType(&#39;ElevationRamp&#39;);
// var shadingUniforms = material.uniforms;
// shadingUniforms.minimumHeight = minHeight;
// shadingUniforms.maximumHeight = maxHeight;
// shadingUniforms.image = getColorRamp();

// 2、等高线
// var material = Cesium.Material.fromType(&#39;ElevationContour&#39;);
// var contourUniforms = material.uniforms;
// contourUniforms.width = contourWidth;
// contourUniforms.spacing = contourSpacing;
// contourUniforms.color = contourColor;

// 3、高程阴影+等高线
var material = getElevationContourMaterial();
var shadingUniforms = material.materials.elevationRampMaterial.uniforms;
shadingUniforms.minimumHeight = minHeight;
shadingUniforms.maximumHeight = maxHeight;
shadingUniforms.image = getColorRamp();

var contourUniforms = material.materials.contourMaterial.uniforms;
contourUniforms.width = contourWidth;
contourUniforms.spacing = contourSpacing;
contourUniforms.color = contourColor;
viewer.scene.globe.material = material;

function getColorRamp() &#123;
    var ramp = document.createElement(&#39;canvas&#39;);
    ramp.width = 100;
    ramp.height = 1;
    var ctx = ramp.getContext(&#39;2d&#39;);
    var values = [0.0, 0.045, 0.1, 0.15, 0.37, 0.54, 1.0];
    var grd = ctx.createLinearGradient(0, 0, 100, 0);

    // grd.addColorStop(values[0], &#39;rgba(0,0,0,0.0)&#39;); //black
    // grd.addColorStop(values[1], &#39;rgba(39,71,224,0.8)&#39;); //blue
    // grd.addColorStop(values[2], &#39;rgba(211,59,125,0.8)&#39;); //pink
    // grd.addColorStop(values[3], &#39;rgba(211,48,56,0.8)&#39;); //red
    // grd.addColorStop(values[4], &#39;rgba(255,151,66,0.8)&#39;); //orange
    // grd.addColorStop(values[5], &#39;rgba(255,215,0,0.8)&#39;); //yellow
    // grd.addColorStop(values[6], &#39;rgba(255,255,255,0.8)&#39;); //white


    grd.addColorStop(values[0], &#39;rgba(255,255,255,0)&#39;); //black
    grd.addColorStop(values[1], &#39;rgba(39,71,224,0.8)&#39;); //blue
    grd.addColorStop(values[2], &#39;rgba(211,59,125,0.8)&#39;); //pink
    grd.addColorStop(values[3], &#39;rgba(211,48,56,0.8)&#39;); //red
    grd.addColorStop(values[4], &#39;rgba(255,151,66,0.8)&#39;); //orange
    grd.addColorStop(values[5], &#39;rgba(255,215,0,0.8)&#39;); //yellow
    grd.addColorStop(values[6], &#39;rgba(255,255,255,0.8)&#39;); //white

   


    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, 100, 1);
    return ramp;
&#125;
</code></pre>
<p>}</p>
<h2 id="地形开挖"><a href="#地形开挖" class="headerlink" title="地形开挖"></a>地形开挖</h2><p>class ClippingPlane {<br>  constructor(tileset,viewer,image) {<br>    this._viewer = viewer;<br>    this.activeShapePoints = [];<br>    this.activeShape = null;<br>    this.floatingPoint = null;<br>    this.points = [];<br>    this.drawingMode = “polygon”; //多边形<br>    this.handler = null;<br>    this.image = image;<br>    this.init();<br>  }<br>  /**</p>
<ul>
<li><p>绑定点击事件</p>
</li>
<li><p>/<br>init() {</p>
<p>let that = this;</p>
<p>that.handler = new Cesium.ScreenSpaceEventHandler(that._viewer.canvas);</p>
<p>//双击鼠标左键清除默认事件<br>that._viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(<br>  Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK<br>);</p>
<p>that.handler.setInputAction(function(event) {</p>
<p>  // We use <code>viewer.scene.pickPosition</code> here instead of <code>viewer.camera.pickEllipsoid</code> so that<br>  // we get the correct point when mousing over terrain.<br>  // scene.pickPosition只有在开启地形深度检测，且不使用默认地形时是准确的。<br>  var earthPosition = that._viewer.scene.pickPosition(event.position);</p>
<p>  // <code>earthPosition</code> will be undefined if our mouse is not over the globe.<br>  if (Cesium.defined(earthPosition)) {</p>
<pre><code>if (that.activeShapePoints.length === 0) &#123;
  that.floatingPoint = that.createPoint(earthPosition);
  that.activeShapePoints.push(earthPosition);
  var dynamicPositions = new Cesium.CallbackProperty(function() &#123;
    if (that.drawingMode === &quot;polygon&quot;) &#123;
      return new Cesium.PolygonHierarchy(that.activeShapePoints);
    &#125;
    return that.activeShapePoints;
  &#125;, false);
  that.activeShape = that.drawShape(dynamicPositions); //绘制动态图
&#125;
that.activeShapePoints.push(earthPosition);
that.points.push(earthPosition)
that.createPoint(earthPosition);
</code></pre>
<p>  }<br>}, Cesium.ScreenSpaceEventType.LEFT_CLICK);</p>
<p>//鼠标移动<br>that.handler.setInputAction(function(event) {<br>  if (Cesium.defined(that.floatingPoint)) {</p>
<pre><code>var newPosition = that._viewer.scene.pickPosition(event.endPosition);
if (Cesium.defined(newPosition)) &#123;
  that.floatingPoint.position.setValue(newPosition);
  that.activeShapePoints.pop();
  that.activeShapePoints.push(newPosition);
&#125;
</code></pre>
<p>  }<br>}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);</p>
<p>that.handler.setInputAction(function(event) {<br>  that._viewer.entities.remove(that.activeShape);<br>  that._viewer.entities.remove(that.floatingPoint);<br>  var earthPosition = that._viewer.scene.pickPosition(event.position);<br>  that.points.push(earthPosition);<br>  // console.log(‘points’, that.points);<br>  var planes = that.createClippingPlane(that.points);<br>  // console.log(‘planes’,planes)<br>  //赋值给globe的 clippingPlanes<br>  that._viewer.scene.globe.clippingPlanes = new Cesium.ClippingPlaneCollection({</p>
<pre><code>  planes: planes,
  edgeWidth: 1.0,
  edgeColor: Cesium.Color.WHITE
</code></pre>
<p>  })<br>  //依次计算顶点与下个顶点之间组成的线段，中间按照精度大小插值n个点，然后计算每个点的地形高度<br>  let promises = []<br>  for (let i = 0; i &lt; that.points.length - 1; i++) {</p>
<pre><code>  promises.push(that.calHeight(that._viewer, that.points[i], that.points[i + 1], 100)); // 返回promise对象
</code></pre>
<p>  }<br>  // 待所有的计算完毕后，处理坐标点，构造多边形<br>  Promise.all([…promises]).then(data =&gt; {</p>
<pre><code>  var positons = Array.prototype.concat.apply([], data); // 数组降维
  var hierarchy = [];
  positons.forEach(element =&gt; &#123;
      hierarchy.push(Cesium.Math.toDegrees(element.longitude));
      hierarchy.push(Cesium.Math.toDegrees(element.latitude));
      hierarchy.push(element.height);
  &#125;);
  that._viewer.entities.add(&#123;
      polygon: &#123;
          hierarchy: Cesium.Cartesian3.fromDegreesArrayHeights(hierarchy),
          closeTop: false, // 这个要设置为false
      material: that.image ?
        new Cesium.ImageMaterialProperty(&#123;
          image:that.image,
          // repeat:new Cesium.Cartesian2(100.0, 100.0)
        &#125;) : new Cesium.ColorMaterialProperty(Cesium.Color.BROWN),                  
          extrudedHeight: 0,
          perPositionHeight: true // 这个要设置true
      &#125;
  &#125;);
</code></pre>
<p>  })<br>}, Cesium.ScreenSpaceEventType.RIGHT_CLICK);<br>}<br>/**</p>
</li>
<li><p>根据点集计算 ClippingPlane</p>
</li>
<li><p>@param {*} points </p>
</li>
<li><p>@returns </p>
</li>
<li><p>/<br>createClippingPlane(points) {<br>var pointsLength = points.length;<br>var clippingPlanes = []; // 存储ClippingPlane集合<br>for (var i = 0; i &lt; pointsLength; ++i) {<br>  var nextIndex = (i + 1) % pointsLength;<br>  var midpoint = Cesium.Cartesian3.add(</p>
<pre><code>points[i],
points[nextIndex],
new Cesium.Cartesian3()
</code></pre>
<p>  );<br>  midpoint = Cesium.Cartesian3.multiplyByScalar(midpoint, 0.5, midpoint);<br>  var up = Cesium.Cartesian3.normalize(midpoint, new Cesium.Cartesian3());<br>  var right = Cesium.Cartesian3.subtract(</p>
<pre><code>points[nextIndex],
midpoint,
new Cesium.Cartesian3()
</code></pre>
<p>  );<br>  right = Cesium.Cartesian3.normalize(right, right);<br>  var normal = Cesium.Cartesian3.cross(right, up, new Cesium.Cartesian3());<br>  normal = Cesium.Cartesian3.normalize(normal, normal);<br>  var originCenteredPlane = new Cesium.Plane(normal, 0.0);<br>  var distance = Cesium.Plane.getPointDistance(</p>
<pre><code>originCenteredPlane,
midpoint
</code></pre>
<p>  );<br>  clippingPlanes.push(new Cesium.ClippingPlane(normal, distance));<br>}<br>return clippingPlanes;<br>}<br>/**</p>
</li>
<li><p>插值、计算坐标点高度（如果不加载地形的话，这步可以省略）</p>
</li>
<li><p>@param {*} viewer </p>
</li>
<li><p>@param {*} fromPoint </p>
</li>
<li><p>@param {*} endPoint </p>
</li>
<li><p>@param {*} count </p>
</li>
<li><p>@returns </p>
</li>
<li><p>/<br>calHeight(viewer, fromPoint, endPoint, count) {<br>var positions = [];<br>for (var i = 0; i &lt;= count; i++) {<br>  var cart = Cesium.Cartesian3.lerp(</p>
<pre><code>fromPoint,
endPoint,
i / count,
new Cesium.Cartesian3()
</code></pre>
<p>  );<br>  positions.push(Cesium.Cartographic.fromCartesian(cart));<br>}<br>return new Promise((resolve, reject) =&gt; {<br>  var promise = Cesium.sampleTerrainMostDetailed(</p>
<pre><code>viewer.terrainProvider,
positions
</code></pre>
<p>  );<br>  Cesium.when(promise, function(updatedPositions) {</p>
<pre><code>resolve(updatedPositions);
</code></pre>
<p>  });<br>});<br>}<br>//绘制点<br>createPoint(worldPosition) {<br>var point = this._viewer.entities.add({<br>  position: worldPosition,<br>  point: {</p>
<pre><code>color: Cesium.Color.GREENYELLOW,
pixelSize: 9,
heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
</code></pre>
<p>  },<br>});<br>return point;<br>}<br>//绘制图形<br>drawShape(positionData) {<br>var that = this;<br>var shape;<br>shape = that._viewer.entities.add({<br>  polygon: {</p>
<pre><code>hierarchy: positionData,
perPositionHeight: true,
extrudedHeight: 4,
//new Cesium.Color.fromBytes(0,191,255,100),
//new Cesium.ColorMaterialProperty(Cesium.Color.AQUA.withAlpha(0.3))
material: new Cesium.Color.fromBytes(0, 191, 255, 100),
</code></pre>
<p>  },<br>});<br>return shape;<br>}</p>
</li>
</ul>
<p>  clear(){<br>    this._viewer.scene.globe.clippingPlanes &amp;&amp;  this._viewer.scene.globe.clippingPlanes.removeAll();<br>    this._viewer.entities.removeAll();<br>    this.activeShapePoints = [];<br>    this.activeShape = null;<br>    this.floatingPoint = null;<br>    this.points = [];<br>  }<br>}</p>
<h2 id="日照分析"><a href="#日照分析" class="headerlink" title="日照分析"></a>日照分析</h2><p>class SunshineAnalysis{</p>
<pre><code>    constructor(option)&#123;
          this._viewer = option.viewer
          this.init();
          this.eventBus = &#123;&#125;;
    &#125;

    init()&#123;
        
    &#125;

    $on(event, cb) &#123;
        if (!this.eventBus[event]) &#123;
            this.eventBus[event] = new Set()
        &#125;
        this.eventBus[event].add(cb)
    &#125;
    $emit(event, ...args) &#123;

        if (this.eventBus[event]) &#123;
            Array.from(this.eventBus[event]).forEach((handle) =&gt; &#123;

                handle.call(this, args)
            &#125;)
        &#125;
    &#125;
    $off(event, cb) &#123;
        if (this.eventBus[event]) &#123;
            this.eventBus[event].delete(cb)
        &#125;
    &#125;
</code></pre>
<p>}</p>
<h2 id="可视域分析"><a href="#可视域分析" class="headerlink" title="可视域分析"></a>可视域分析</h2><p>/**</p>
<ul>
<li>可视域分析。</li>
<li>@author</li>
<li>@date</li>
<li>@alias ViewShedStage</li>
<li>@class</li>
<li>@param {Cesium.Viewer} viewer Cesium三维视窗。</li>
<li>@param {Object} options 选项。</li>
<li>@param {Cesium.Cartesian3} options.viewPosition 观测点位置。</li>
<li>@param {Cesium.Cartesian3} options.viewPositionEnd 最远观测点位置（如果设置了观测距离，这个属性可以不设置）。</li>
<li>@param {Number} options.viewDistance 观测距离（单位<code>米</code>，默认值100）。</li>
<li>@param {Number} options.viewHeading 航向角（单位<code>度</code>，默认值0）。</li>
<li>@param {Number} options.viewPitch 俯仰角（单位<code>度</code>，默认值0）。</li>
<li>@param {Number} options.horizontalViewAngle 可视域水平夹角（单位<code>度</code>，默认值90）。</li>
<li>@param {Number} options.verticalViewAngle 可视域垂直夹角（单位<code>度</code>，默认值60）。</li>
<li>@param {Cesium.Color} options.visibleAreaColor 可视区域颜色（默认值<code>绿色</code>）。</li>
<li>@param {Cesium.Color} options.invisibleAreaColor 不可视区域颜色（默认值<code>红色</code>）。</li>
<li>@param {Boolean} options.enabled 阴影贴图是否可用。</li>
<li>@param {Boolean} options.softShadows 是否启用柔和阴影。</li>
<li>@param {Boolean} options.size 每个阴影贴图的大小。</li>
<li>/</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/05/M_Swift170Mac%20Homebrew%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/05/M_Swift170Mac%20Homebrew%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">mac 开发homebrew使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-05 15:33:50" itemprop="dateCreated datePublished" datetime="2021-02-05T15:33:50+08:00">2021-02-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 15:55:50" itemprop="dateModified" datetime="2021-04-12T15:55:50+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.安装最新的Xcode<br>2.Homebrew<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1265310832e6">https://www.jianshu.com/p/1265310832e6</a><br><a target="_blank" rel="noopener" href="https://brew.sh/">https://brew.sh</a><br>homebrew配置：brew config<br>安装软件，如：brew install node<br>卸载软件，如：brew uninstall node<br>搜索软件，如：brew search node<br>更新软件，如：brew upgrade node<br>查看安装列表，如：brew list<br>列出可更新的软件包，brew outdated<br>检测已经过时的软件：brew outdated<br>升级所有已过时的软件，即列出的以过时软件 ： brew upgrade<br>启动服务 brew services start mysql<br>查看包依赖 brew deps git</p>
<p>brew install ruby<br>gem sources -l<br>gem sources –add <a target="_blank" rel="noopener" href="https://gems.ruby-china.com/">https://gems.ruby-china.com/</a> –remove <a target="_blank" rel="noopener" href="https://rubygems.org/">https://rubygems.org/</a><br>sudo gem install -n /usr/local/bin cocoapods</p>
<p>brew install node<br>brew install python3<br>brew install wget<br>brew install git<br>brew install mysql<br>brew install maven<br>brew install nginx<br>brew install mongodb<br>brew install hexo</p>
<p>brew install google-chrome<br>brew install launchrocket<br>brew install visual-studio-code<br>brew install docker<br>brew install visual-studio-code<br>brew install sourcetree<br>brew install sublime-text<br>brew install charles<br>brew install betterzip<br>brew install cleanmymac<br>brew install smartsvn<br>brew install wechat<br>brew install docker<br>2.安装cocoapods<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/baicai_520/article/details/112697063">https://blog.csdn.net/baicai_520/article/details/112697063</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/44c894b69cf6">https://www.jianshu.com/p/44c894b69cf6</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19484963/article/details/83110004">https://blog.csdn.net/qq_19484963/article/details/83110004</a></p>
<p>M1电脑预装软件列表<br>Office 软件<br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1MZjAv01_fT2ZOV5Pi7yDkA?errmsg=Auth+Login+Sucess&amp;errno=0&amp;ssnerror=0&amp;">https://pan.baidu.com/s/1MZjAv01_fT2ZOV5Pi7yDkA?errmsg=Auth+Login+Sucess&amp;errno=0&amp;ssnerror=0&amp;</a></p>
<p>wps<br><a target="_blank" rel="noopener" href="https://www.wps.cn/">https://www.wps.cn</a></p>
<p>idea  webstorm pycharm  ps</p>
<p>node<br><a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012843349/article/details/112856593">https://blog.csdn.net/u012843349/article/details/112856593</a></p>
<p>IDEA<br><a target="_blank" rel="noopener" href="https://download.jetbrains.8686c.com/idea/ideaIU-2020.3.2-aarch64.dmg">https://download.jetbrains.8686c.com/idea/ideaIU-2020.3.2-aarch64.dmg</a></p>
<p>VS code<br><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">https://code.visualstudio.com</a></p>
<p>chrome<br><a target="_blank" rel="noopener" href="https://www.google.com/chrome/">https://www.google.com/chrome/</a></p>
<p>mysql<br><a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/">https://dev.mysql.com/downloads/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42006613/article/details/111773038">https://blog.csdn.net/qq_42006613/article/details/111773038</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/studio">https://developer.android.com/studio</a></p>
<p>github<br><a target="_blank" rel="noopener" href="https://desktop.github.com/">https://desktop.github.com</a></p>
<p>xCode<br><a target="_blank" rel="noopener" href="https://apps.apple.com/us/app/xcode/id497799835">https://apps.apple.com/us/app/xcode/id497799835</a></p>
<p><a target="_blank" rel="noopener" href="https://proxyman.io/">https://proxyman.io</a></p>
<p><a target="_blank" rel="noopener" href="https://www.charlesproxy.com/download/">https://www.charlesproxy.com/download/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.python.org/">https://www.python.org</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Macvcl/p/14019852.html">https://www.cnblogs.com/Macvcl/p/14019852.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/04/M_Swift172%202020%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/M_Swift172%202020%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2020年终总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-04 15:21:38" itemprop="dateCreated datePublished" datetime="2021-02-04T15:21:38+08:00">2021-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 15:57:18" itemprop="dateModified" datetime="2021-04-12T15:57:18+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2020年注定是不平凡的一年，它将在人类历史上留下深刻的烙印，平凡的我们依旧行尸走肉的在这里生活着<br>回想这一年我都干了些什么，经历了什么，从公交规划到c++的数据编译到地图导航SDK到现在的前端项目，感觉经历了之前几年没有经历的东西，收获还是蛮多的，比之前的几年是有很好的提升了吧<br>现在的公司越来越不稳定了，明年估计是一次变化的一年，总之今年还算是比较平稳的一年<br>明年我想如果房子好了的话，不知道是不是还要花很多的钱，明年的话我想还是要稳定的发展吧，自己本身起点很低，我想做东西慢慢吸收经验能好很多。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/M_Swift160%E7%82%B9%E7%BA%BF%E9%9D%A2%E7%BB%98%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/M_Swift160%E7%82%B9%E7%BA%BF%E9%9D%A2%E7%BB%98%E5%88%B6/" class="post-title-link" itemprop="url">OpenGL点线面绘制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 14:25:12" itemprop="dateCreated datePublished" datetime="2020-12-02T14:25:12+08:00">2020-12-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于地图应用程序来讲一般来说绘制的都是三角形类型的数据，GL_TRIANGLES<br>点的绘制：<br>一般是绘制图标和文本，涉及的问题主要是计算图标及文本的位置<br>线的绘制：<br>一般是根据线的宽度，生成三角形数据的线，然后进行绘制<br>面的绘制：<br>一般是绘制三角形数据</p>
<p>地图层级绘制：<br>这涉及到地图数据编译的开发，地图数据编译一个重要方面是数据分层，要将数据展示在不同级别的比例尺的地图上，所以不同比例尺下，我们看到地图展示的数据是不一样的，我们要抽希数据放在高层比例尺上，比如北京市，我们可能在20km以上的比例尺才会显示，在较低的比例尺上我们就不会再显示，这就是数据的分层。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/M_Swift159OpenGL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/M_Swift159OpenGL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">OpenGL常用函数说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 11:57:27" itemprop="dateCreated datePublished" datetime="2020-12-02T11:57:27+08:00">2020-12-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>OpenGL中所有函数都以字符gl作为前缀，还有些以glfw、gl3w或glew为前缀的函数，来自于第三方库GLFW、GL3W、GLEW</p>
<p>由于OpenGL是C语言的库，没有重载，所以OpenGL中区分同名函数使用后缀的变化来标记，例如glUniform2f()和glUniform3fv()，2f中的2表示两个参数，f表示参数类型为GLfloat类型，即glUniform2f()需要传入两个GLfloat类型的参数，而glUniform3fv()中v表示vector(向量)类型，即这个函数我们需要使用一个3维向量作为参数传入，这个三维向量的每个分量都是GLfloat类型，注意，在OpenGL中，向量vector类型是使用一维数组来表示，所以glUniform3fv()的参数为一个含有3个GLfloat值的一维数组<br>后缀与参数类型对应关系<br>b 8位整数  char<br>s 16位整数 short<br>i 32位整数 int<br>f 32位浮点 float<br>d 64位浮点 double<br>ub 8位无符号整型<br>us 16位无符号整型<br>ui 323位无符号整型</p>
<p>Uniform：属性是一种对整个批次属性都取统一值的单一值。它是不变的。通过设置uniform变量就紧接着发送一个图元批次命令，Uniform变量实际上可以无数次限制地使用，设置一个应用于整个表面的单个颜色值，还可以设置一个时间值。在每次渲染某种类型的顶点动画时修改它。、</p>
<p>glEnable(GL_LINE_STIPPLE);//打开虚线模式glDisable（GL_LINE_STIPPLE）可关闭<br>glLineStipple(2, 0x0F0F);//void glLineStipple(GLint factor, GLushort pattern); pattern为虚线样式序列（16位二进制数）</p>
<p>glClear度<br>glBegin(GL_LINES);</p>
<p>点</p>
<p>线<br>glLineWidth(10.0f);//线宽<br>glEnable(GL_LINE_STIPPLE);<br>glDisable(GL_LINE_STIPPLE);</p>
<p>面<br>正面反面<br>GL_FRONT<br>GL_BACK<br>面的处理方式则有填充和轮廓<br>glPolygonMode<br>GL_LINE<br>GL_FILL<br>glEnable(GL_POLYGON_STIPPLE);//打开镂空模式</p>
<p>glDeleteTextures - 删除纹理<br>glPushMatrix<br>glTranslatef<br>glScalef<br>glRotatef<br>glDisable<br>glEnable<br>glBlendFunc<br>glEnableClientState<br>glBindTexture<br>glTexParameterf</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/flycatdeng/article/details/82588903">https://blog.csdn.net/flycatdeng/article/details/82588903</a></p>
<p>glActiveTexture - 激活纹理单元<br>glAttachShader- 将着色器对象附加到program对象<br>glBindAttribLocation - 将通用顶点属性索引与命名属性变量相关联<br>glBindAttribLocation - 将通用顶点属性索引与命名属性变量相关联</p>
<p>glEnable( GL_BLEND );   // 启用混合<br>glBlendFunc( GLenum sfactor , GLenum dfactor );         // 混合函数</p>
<p>sfactor 源混合因子</p>
<p>dfactor 目标混合因子<br>OpenGL——纹理过滤函数glTexParameteri()<br>    图象从纹理图象空间映射到帧缓冲图象空间(映射需要重新构造纹理图像,这样就会造成应用到多边形上的图像失真),这时就可用glTexParmeteri()函数来确定如何把纹理象素映射成像素.<br>GL_TEXTURE_2D: 操作2D纹理.<br>GL_TEXTURE_WRAP_S: S方向上的贴图模式.<br> GL_CLAMP: 将纹理坐标限制在0.0,1.0的范围之内.如果超出了会如何呢.不会错误,只是会边缘拉伸填充.<br>GL_LINEAR: 线性过滤, 使用距离当前渲染像素中心最近的4个纹素加权平均值.<br>GL_REPEAT</p>
<p>openggl 图片优化<br>如果纹理很大，并且您每次分配新内存来存储越来越多的副本，那么很快就会用完的记忆。解决方案是在应用程序初始化期间调用 glTexImage2D 一次，并且仅在要使用它时才调用 glBindTexture 。如果要在单击时更改纹理本身，请仅调用 glBindTexture 和 glTexImage2D 。如果新图像的大小与先前图像的大小相同，则可以调用 glTexSubImage2D 告诉OpenGL覆盖旧图像数据，而不是删除并上传新图像数据。 / p&gt; </p>
<h2 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><pre><code>/*
 * glGenRenderbuffers 的原型为：
 * void glGenRenderbuffers (GLsizei n, GLuint* renderbuffers)
 * 它是为 renderbuffer 申请一个 id（或曰名字）。
 * 参数 n 表示申请生成 renderbuffer 的个数，
 * 而 renderbuffers 返回分配给 renderbuffer 的 id，
 * 注意：返回的 id 不会为0，id 0 是OpenGL ES 保留的，我们也不能使用 id 为0的 renderbuffer。
 */
glGenRenderbuffers(1, &amp;self-&gt;_colorRenderBuffer);

/*
 * glBindRenderbuffer 的原型为：
 * void glBindRenderbuffer (GLenum target, GLuint renderbuffer)
 * 这个函数将指定 id 的 renderbuffer 设置为当前 renderbuffer。
 * 参数 target 必须为 GL_RENDERBUFFER，参数 renderbuffer 是就是使用 glGenRenderbuffers 生成的 id。
 * 当指定 id 的 renderbuffer 第一次被设置为当前 renderbuffer 时，会初始化该 renderbuffer 对象，其初始值为：
 * width 和 height：像素单位的宽和高，默认值为0；
 * internal format：内部格式，三大 buffer 格式之一 -- color，depth or stencil；
 * Color bit-depth：仅当内部格式为 color 时，设置颜色的 bit-depth，默认值为0；
 * Depth bit-depth：仅当内部格式为 depth时，默认值为0；
 * Stencil bit-depth: 仅当内部格式为 stencil，默认值为0；
 */
glBindRenderbuffer(GL_RENDERBUFFER, self.colorRenderBuffer);


/*
 * glFramebufferRenderbuffer的函数原型为：
 * void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
 * 该函数是将相关 buffer（三大buffer之一）attach到framebuffer上（如果 renderbuffer不为 0，
 * 知道前面为什么说glGenRenderbuffers 返回的id 不会为 0 吧）或从 framebuffer上detach
 * （如果 renderbuffer为 0）。参数 attachment 是指定 renderbuffer 被装配到那个装配点上，zm
 * 其值是GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT中的一个，
 * 分别对应 color，depth和 stencil三大buffer。
 */
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.colorRenderBuffer);

/*
 * glDrawElements 函数的原型为：
 * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
 * 第一个参数 mode 为描绘图元的模式，其有效值为：GL_POINTS, GL_LINES, GL_LINE_STRIP,  GL_LINE_LOOP,  GL_TRIANGLES,  GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN。这些模式具体含义下面有介绍。
 * 第二个参数 count 为顶点索引的个数也就是，type 是指顶点索引的数据类型，因为索引始终是正值，索引这里必须是无符号型的非浮点类型，
 * 因此只能是 GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT 之一，为了减少内存的消耗，尽量使用最小规格的类型如 GL_UNSIGNED_BYTE。
 * 第三个参数 indices 是存放顶点索引的数组。（indices 是 index 的复数形式，3D 里面很多单词的复数都挺特别的。）
 */
glDrawElements(GL_LINES, sizeof(indices)/sizeof(GLubyte), GL_UNSIGNED_BYTE, indices);


/*
 * glClearColor用来设置清屏颜色，默认为黑色
 */
glClearColor(0, 1.0, 0, 1.0);

/*
 * glClear(GLbitfieldmask)用来指定要用清屏颜色来清除由mask指定的buffer
 * mask 可以是 GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT的自由组合。
 */
glClear(GL_COLOR_BUFFER_BIT);

/*
 * 设置 viewport
 * glViewport  表示渲染 surface 将在屏幕上的哪个区域呈现出来，
 */
glViewport(0, 0, self.frame.size.width, self.frame.size.height);
</code></pre>
<h2 id="glPushMatrix、glPopMatrix"><a href="#glPushMatrix、glPopMatrix" class="headerlink" title="glPushMatrix、glPopMatrix"></a>glPushMatrix、glPopMatrix</h2><pre><code>操作事实上就相当于栈里的入栈和出栈。
https://blog.csdn.net/u010579736/article/details/51884989
比如你当前的坐标系原点在你电脑屏幕的左上方。如今你调用glPushMatrix，然后再调用一堆平移、旋转代码等等，然后再绘图。那些平移和旋转都是基于左上角为原点进行变化的。并且都会改变坐标的位置，经过了这些变化后，你的坐标肯定不再左上角了。
　　那假设想恢复怎么办呢？这时就调用glPopMatrix从栈里取出一个“状态”了，这个状态就是你调用glPushMatrix之前的那个状态。就如非常多opengl的书上所讲：调用glPushMatrix事实上就是把当前状态做一个副本放入堆栈之中。

当你做了一些移动或旋转等变换后，使用glPushMatrix();
OpenGL 会把这个变换后的位置和角度保存起来。
然后你再随便做第二次移动或旋转变换，再用glPopMatrix();
OpenGL 就把刚刚保存的那个位置和角度恢复。

比方：
glLoadIdentity();
glTranslatef(1,0,0);//向右移动(1,0,0)
glPushMatrix();//保存当前位置
glTranslatef(0,1,0);//如今是(1,1,0)了
glPopMatrix();//这样，如今又回到(1,0,0)了
1.原理解说

最终明确为什么使用glPushMatrix()和glPopMatrix()的原因了。将本次须要运行的缩放、平移等操作放在glPushMatrix和glPopMatrix之间。glPushMatrix()和glPopMatrix()的配对使用能够消除上一次的变换对本次变换的影响。使本次变换是以世界坐标系的原点为參考点进行。以下对上述结论做进一步的解释：

1）OpenGL中的modelview矩阵变换是一个马尔科夫过程：上一次的变换结果对本次变换有影响，上次modelview变换后物体在世界坐标系下的位置是本次modelview变换的起点。默认时本次变换和上次变换不独立。

2）OpenGL物体建模实际上是分两步走的。第一步，在世界坐标系的原点位置绘制出该物体；第二步，通过modelview变换矩阵对世界坐标系原点处的物体进行仿射变换，将该物体移动到世界坐标系的目标位置处。

3）将modelview变换放在glPushMatrix和glPopMatrix之间能够使本次变换和上次变换独立。

4）凡是使用glPushMatrix()和glPopMatrix()的程序一般能够判定是采用世界坐标系建模。既世界坐标系固定，modelview矩阵移动物体。
</code></pre>
<h2 id="glTranslatef-函数和glRotatef-函数和glLoadIdentity-函数"><a href="#glTranslatef-函数和glRotatef-函数和glLoadIdentity-函数" class="headerlink" title="glTranslatef()函数和glRotatef()函数和glLoadIdentity()函数"></a>glTranslatef()函数和glRotatef()函数和glLoadIdentity()函数</h2><pre><code>https://blog.csdn.net/code_ac/article/details/60970103

glLoadIdentity()

将当前的用户坐标系的原点移到了屏幕中心：类似于一个复位操作 
glTranslatef(x, y, z)

沿着 X, Y 和 Z 轴移动。

注意在glTranslatef(x, y, z)中,当您移动的时候，您并不是相对屏幕中心移动，而是相对与当前所在的屏幕位置。

glRotatef(angle, x, y, z) 

与glTranslatef(x, y, z)类似，glRotatef(angle, x, y, z)也是对坐标系进行操作。 旋转轴经过原点，方向为(x,y,z),旋转角度为angle，方向满足右手定则。 

glScalef是openGL中的模型缩放函数，就是把当前矩阵与一个表示延各个轴对物体进行拉伸、压缩、反射的矩阵相乘。这个物体的每个点的x,y,z坐标与对应的xyz参数相乘。
例如：
如glScalef(2.0f，3.0f，4.0f);将模型按x,y,z方向分别拉伸了2,3,4倍。


【GL_LINES】
　　独立的线段，下式中，p2与p3间没有连线。
【GL_LINE_STRIP】
　　连续的线段，下式中， p2与p3会连成线段。
【GL_LINE_LOOP】
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/M_Swift151OpenGLES%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/M_Swift151OpenGLES%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Opengl es</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 11:57:06" itemprop="dateCreated datePublished" datetime="2020-12-02T11:57:06+08:00">2020-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 16:08:28" itemprop="dateModified" datetime="2021-04-12T16:08:28+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>opengl 是一个跨平台、跨编程语言的图形处理接口，opengl es是它的一个子集，专门用来针对手机，平板电脑等嵌入式设备的图像处理库。对于手机来说，它的所有对图像的计算和渲染都是在gpu上完成，所以具有较好的性能<br>opengl es的接口设计中不涉及上下文环境和窗口的管理，这由各个平台自行实现。比如ios就是EAGL；安卓就是EGL；<br>tips:<br>libSDL，它是一个跨平台的图形处理库，其中有包含对对OpenGL es的标准接口的封装及各个平台上下文，窗口管理的封装。<br>备注：Opengl es 2.0 官方接口文档 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/">https://www.khronos.org/registry/OpenGL-Refpages/es2.0/</a></p>
<p>gltypes.h 是包含了 OpenGL ES 2.0 的基本数据类型的定义；<br>glext.h 是包含各种宏定义，以及矩阵运算等常用的函数；<br>gl.h 是 OpenGL ES 2.0 所有的核心函数（命令）；</p>
<p>#Opengl es渲染管线<br>这里是opengl es2.0以后的版本的渲染管线<br>1、确定几何形状，比如是要点，线，还是三角形(长方形，正方形和其它二维几何图形都是由三角形来渲染的)。<br>它最终由glDrawArrays()函数的调用来确定，其第一个参数确定了形状可取值如下：<br>GL_POINTS:绘制点<br>GL_LINES:线<br>GL_TRIANGLE_STRIP:三角形<br>2、处理顶点坐标<br>此阶段需要顶点着色器的参与，首先由应用端传递给顶点着色器几何图形的坐标，纹理的坐标(如果有的话)；然后根据opengl es内部的坐标系和投影矩阵进行转化<br>成最终的坐标;在这一步中，应用端需要知道的是基于(左下角为原点(-1,-1),右上角(1,1)，这个范围就是前面glViewPort()开辟大小)的坐标系来确定几何图形的坐标<br>；基于(左上角为原点(0,0),右下角(1,1))的坐标系来确定纹理的坐标,但是纹理坐标要上下翻转180度后在与几何坐标顺序一直传递<br>tips:<br>常用的就是渲染图片，所以图片都是矩形，所以传递的几何坐标如下：<br>static float verData1[8] = {<br>-1.0f, -1.0f, // 左下角<br>1.0f,-1.0f,  // 右下角<br>-1.0f,1.0f, // 左上角<br>1.0f,1.0f,  // 右上角<br>};<br>一般按照如上的顺序传递坐标，取值也可以是其它值，比如<br>static float verData1[8] = {<br>-0.5f, -0.5f, // 左下角<br>0.5f,-0.5f,  // 右下角<br>-0.5f,0.5f, // 左上角<br>0.5f,0.5f,  // 右上角<br>};<br>表示取中间的1/2区域；实际上就是压缩效果<br>static float verData1[8] = {<br>-2.0f, -2.0f, // 左下角<br>2.0f,-2.0f,  // 右下角<br>-2.0f,2.0f, // 左上角<br>2.0f,2.0f,  // 右上角<br>};<br>表示将原来的坐标系放大了一倍后在基于原始的进行截取<br>传递的纹理坐标系(OpenGL es纹理坐标系左上角为原点(0,0),右下角为(1,1)与几何坐标系上下刚好翻转180度)如下：<br>static float uvData[8] = {<br>0.0f, 1.0f,// 左下角<br>1.0f, 1.0f, // 右下角<br>0.0f, 0.0f,// 左上角<br>1.0f, 0.0f, // 右上角<br>};<br>纹理坐标系一般不要去改变它的值，传这个就好，(当然也可该，前提是知道内部的转换原理),如果要实现压缩和裁剪效果，改变几何坐标系方便一些。<br>3、图元组装<br>经过阶段二的顶点处理操作之后，不论模型的顶点还是纹理坐标都已经确定，这个阶段，顶点将会应用程序的指令规则比如glDrawArrays()函数确定的(如<br>GL_POINTS,GL_LINES,GL_TRIANGES等)，将根据这些顶点坐标描绘出具体的图元(比如最终要渲染成一个矩形图元)<br>4、栅格化操作<br>由阶段3传递过来的图元，将在此阶段被分解成更小的单元并对应于帧缓冲区的各个像素，这些单元成为片元，一个片元包含颜色，坐标等属性。片元的坐标属性<br>根据顶点坐标利用插值运算确定，这个过程称为栅格化操作。该阶段只是确定了每个片元的坐标属性，颜色由下阶段通过片元着色器确定。<br>5、片元处理<br>上阶段确定了各个片元的坐标，此阶段将通过片段着色器GLSL语言确定各个片元的颜色。比如可以通过纹理坐标获取纹理中对应片元坐标的颜色，如果应用端传进来的纹理大小和要绘制的几何图形大小不一样，那么opengles会根据应用自己设置的缩放规则(比如用glTexParameteri()函数指定的规则)进行插值运算来获取到对应<br>的颜色)如果没有纹理，可以根据自己的代码规则确定片元颜色;这个过程就是给GLSL的内建变量gl_FragColor赋值<br>6、帧缓存操作<br>该阶段主要指向帧缓冲的写入操作，负责将最终的像素值写入帧缓冲区中。</p>
<p>#光栅化<br>前面就是opengl es标准的渲染管线，但是要想将图像最终呈现到屏幕上，还需要进行光栅化操作(也就是将帧缓冲区中的像素数据渲染到屏幕上)，而<br>这这一步的实现是由各个设备供应商提供的，称为Opengl EGL API，拿苹果ios的例子来说，需要调用EAGLContext 的presentRenderbuffer函数，图<br>像才会最终渲染到屏幕上;</p>
<p>#opengl es api和EGL api<br>opengl es api是用来进行图像渲染操作的，<br>egl api是由各个操作系统实现的系统api，它主要的作用就是创建窗口，创建opengl 上下文环境等。可以由各自厂商自行定义，使用通用的EGL接口。<br>如苹果就是EAGL，安卓就可以用EGL来自行管理，也可以用GLSurface系统创建opengl 环境</p>
<h1 id="opengl-es坐标系"><a href="#opengl-es坐标系" class="headerlink" title="opengl es坐标系"></a>opengl es坐标系</h1><p>1、它以左下角作为原点的坐标系<br>此函数的意思就是，基于当前视图左下角作为原点的坐标系，选取一个左下角坐标为x,y,长宽为w,h的区域作为渲染的区域<br>glViewPort(x,y,w,h) 函数窗口创建的渲染区域</p>
<p>#纹理坐标系<br>在opengl 中，通常将纹理中的像素根据纹理坐标系来进行编址，纹理坐标系的横轴成为S轴，纵轴成为T轴，垂直于ST轴的成为R轴，在2D纹理中，没有<br>R轴，横轴和纵轴又称为UV轴，所以2D纹理坐标系又称为UV坐标系，UV轴的取值范围都是(0,1)。与OpenGL 坐标系不同的是，纹理坐标系的原点位于左<br>上角<br>#纹素<br>纹理中的最小单元就成为纹素，纹理是由一个个纹素组成</p>
<p>#纹理映射<br>纹理的映射就是让物体的每个片元（每个颜色像素）都找到对应的纹理纹素点，在这个映射过程中，因为纹理和物体的不匹配，势必会出现两种情况。<br>第一种是拥有大量纹素的纹理被映射到只还有少量片元的物体中<br>第二种是拥有少量纹素的纹理被映射到含有大量片元的物体中<br>如下：<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR)<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR)<br>GL_TEXTURE_MIN_FILTER:<br>是多个纹素对应一个片元的解决方案。可以设置两个值,GL_NEAREST 和 GL_LINEAR ，这两个值分别对应了两种不同的解决方案。GL_LINEAR 会混合匹配的颜色来得到片元的颜色，产生的颜色可能是纹理中不存在的颜色。例如一个纹理是由交替的黑色和白色的纹素组成，那个线性取样会使最终的片元颜色为灰色。GL_NEAREST 会拾取与片元 U，V 坐标最相近的颜色。<br>GL_TEXTURE_MAG_FILTER:<br>是没有足够的纹素来映射片元的解决方案。可以设置的值同 GL_TEXTURE_MIN_FILTER 一样。GL_LINEAR 会告诉OpenGL ES 混合附近纹素的颜色来计算片元的颜色。GL_LINEAR会有一个放大纹理的效果，当没有足够的纹素来映射片元时，会让纹理模糊的出现在要渲染的图形上。<br>GL_NEAREST 仅仅会拾取片元的 U ，V 位置接近的纹素的颜色，并放大纹理，会使其像素化的出现在要渲染的图形上。<br>GL_LINEAR:<br>线性插值，取最近的点的线性平均值 (性能消耗较大)<br>mipmaps<br>它也是一种纹理过滤算法，按我的理解它是以空间换时间的一种技巧，具体原理就是事先根据纹理生成长和宽逐渐除以2的小纹理，比如原始纹理大小128x128，<br>采用此方法后，会生成64x64 32x32 16x16 8x8 4x4 2x2 1x1的一系列纹理，如果需要20x18的纹理，则取最近的32x32 16x16进行平均<br>该方法很好的解决了如下问题：<br>1、当纹理很大，但是屏幕区域很小，渲染出现的闪烁问题，因为根据最邻近插值和线性插值都无法很快计算出合理的像素<br>它可以取的值如下：<br>GL_NEAREST_MIPMAP_NEAREST 选择最近的mipmap层，然后再用最邻近过滤插值<br>GL_LINEAR_MIPMAP_NEAREST    选择最近mipmap层，然后再用线性插值<br>GL_NEAREST_MIPMAP_LINEAR    选择最近的2层mipmap用最邻近过滤插值<br>GL_LINEAR_MIPMAP_LINEAR       选择最邻近的2层mipmap用线性插值<br>使用如下函数生成mipmaps<br>glGenerateMipmap(GLenum target);</p>
<p>#warp<br>另外一种在映射时可能出现的情况是纹理的四个顶点坐标不是1.0时，将采用如下方式：<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_WARP_S,GL_REPEAT) S轴方向<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_WARP_T,GL_REPEAT) T轴方向<br>GL_REPEAT:纹理没有覆盖的部分重复之前的纹理，当纹理大小大于物体大小时，纹理采样会出错。<br>GL_MIRRODED_REPEAT:将原来的纹理先颠倒再重复，当纹理大小大于物体大小时，纹理采样会出错。<br>GL_CLAMP_TO_EDGE:延续结束时的纹理</p>
<p>#顶点着色器中顶点坐标的顺序规则<br>open gl 中顶点坐标<br>static float verData1[8] = {<br>-1.0f,-1.0f,    // 左下角<br>1.0f,-1.0f,     // 右下角<br>-1.0f,1.0f,     // 左上角<br>1.0f,1.0f,      // 右上角<br>};<br>对应的纹理坐标<br>static float uvData[8] = {<br>0.0f, 1.0f,     // 左下角<br>1.0f, 1.0f,     // 右下角<br>0.0f, 0.0f,     // 左上角<br>1.0f, 0.0f,     // 右上角<br>};<br>对应的为glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); 可以渲染出一张图片</p>
<p>一个纹理的位置值通常称为一个纹理单元(Texture Unit)<br>着色器对象Shader<br>    片段着色器<br>    顶点着色器<br>program对象</p>
<p>缓冲区对象GLuint buffer<br>帧缓冲区对象 GLuint framebuffer</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/M_Swift157OpenGL%E7%BB%98%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/M_Swift157OpenGL%E7%BB%98%E5%88%B6/" class="post-title-link" itemprop="url">OpenGL 渲染</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 11:56:09" itemprop="dateCreated datePublished" datetime="2020-12-02T11:56:09+08:00">2020-12-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="创建render-buffer-（渲染缓冲区）"><a href="#创建render-buffer-（渲染缓冲区）" class="headerlink" title="创建render buffer （渲染缓冲区）"></a>创建render buffer （渲染缓冲区）</h2><p> Render buffer 是OpenGL的一个对象，用于存放渲染过的图像。</p>
<ul>
<li>(void)setupRenderBuffer {<br>  glGenRenderbuffers(1, &amp;_colorRenderBuffer);<br>  glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);<br>  [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_eaglLayer];<br>}</li>
</ul>
<h2 id="创建一个-frame-buffer（帧缓冲区）"><a href="#创建一个-frame-buffer（帧缓冲区）" class="headerlink" title="创建一个 frame buffer（帧缓冲区）"></a>创建一个 frame buffer（帧缓冲区）</h2><ul>
<li>(void)setupFrameBuffer {<br>  GLuint framebuffer;<br>  glGenFramebuffers(1, &amp;framebuffer);<br>  glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<br>  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderBuffer);  // 深度测试<br>  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBuffer);<br>}<h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2></li>
<li>(void)setupDepthBuffer {<br>  glGenRenderbuffers(1, &amp;_depthRenderBuffer);<br>  glBindRenderbuffer(GL_RENDERBUFFER, _depthRenderBuffer);<br>  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, self.frame.size.width, self.frame.size.height);<br>}</li>
</ul>
<h2 id="加载着色器"><a href="#加载着色器" class="headerlink" title="加载着色器"></a>加载着色器</h2><ul>
<li>(void)compileShaders {<br>  // 1<br>  GLuint vertexShader = [self compileShader:@”SimpleVertex5” withType:GL_VERTEX_SHADER];<br>  GLuint fragmentShader = [self compileShader:@”SimpleFragment5” withType:GL_FRAGMENT_SHADER];  // 2<br>  GLuint programHandle = glCreateProgram();<br>  glAttachShader(programHandle, vertexShader);<br>  glAttachShader(programHandle, fragmentShader);<br>  glLinkProgram(programHandle);  // 3 检查link状态<br>  GLint linkSuccess;<br>  glGetProgramiv(programHandle, GL_LINK_STATUS, &amp;linkSuccess);<br>  if (linkSuccess == GL_FALSE) {<pre><code>  GLchar messages[256];
  glGetProgramInfoLog(programHandle, sizeof(messages), 0, &amp;messages[0]);
  NSString *messageString = [NSString stringWithUTF8String:messages];
  NSLog(@&quot;link no Success-------------%@&quot;, messageString);
  exit(1);
</code></pre>
  }  // 4 让OpenGL执行glProgram<br>  glUseProgram(programHandle);  // 5<br>  _positionSlot = glGetAttribLocation(programHandle, “Position”);<br>  _colorSlot = glGetAttribLocation(programHandle, “SourceColor”);<br>  glEnableVertexAttribArray(_positionSlot);<br>  glEnableVertexAttribArray(_colorSlot);  // 投影<br>  _projectionUniform = glGetUniformLocation(programHandle, “Projection”);<br>  // 移动<br>  _modelViewUniform = glGetUniformLocation(programHandle, “Modelview”);<br>}</li>
</ul>
<h2 id="编译着色代码"><a href="#编译着色代码" class="headerlink" title="编译着色代码"></a>编译着色代码</h2><ul>
<li>(GLuint)compileShader:(NSString *)shaderName withType:(GLenum)shaderType {<br>  // 1 查找shader文件<br>  NSString *shaderPath = [[NSBundle mainBundle] pathForResource:shaderName ofType:@”glsl”];<br>  NSFileManager *mg = [NSFileManager defaultManager];  if ([mg fileExistsAtPath:shaderPath]) {<pre><code>  NSLog(@&quot;ok&quot;);
</code></pre>
  }else{<pre><code>  NSLog(@&quot;no&quot;);
</code></pre>
  }  NSError *error;<br>  NSString *shaderString = [NSString stringWithContentsOfFile:shaderPath encoding:NSUTF8StringEncoding error:&amp;error];  if (!shaderString) {<pre><code>  NSLog(@&quot;-----------Error loading shader: %@&quot;, error.localizedDescription);
  exit(1);
</code></pre>
  }  // 2 创建一个代表shader的OpenGL对象, 指定vertex或fragment shader<br>  GLuint shaderHandle = glCreateShader(shaderType);  // 3获取shader的source<br>  const char *shaderStringUTF8 = [shaderString UTF8String];<br>  int shaderStringLength = (int)[shaderString length];<br>  glShaderSource(shaderHandle, 1, &amp;shaderStringUTF8, &amp;shaderStringLength);  // 4 编译shader<br>  glCompileShader(shaderHandle);  // 5查询shader对象的信息<br>  GLint compileSuccess;<br>  glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &amp;compileSuccess);  if (compileSuccess == GL_FALSE) {<pre><code>  GLchar messages[256];
  glGetShaderInfoLog(shaderHandle, sizeof(messages), 0, &amp;messages[0]);
  NSString *messageString = [NSString stringWithUTF8String:messages];
  NSLog(@&quot;compile no Success-----------%@&quot;, messageString);
  exit(1);
</code></pre>
  }  return shaderHandle;<br>}<h2 id="清理屏幕"><a href="#清理屏幕" class="headerlink" title="清理屏幕"></a>清理屏幕</h2></li>
<li>(void)render {<br>  glClearColor(0, 104.0/255.0, 55.0/255.0, 1.0);<br>  glClear(GL_COLOR_BUFFER_BIT);<br>  [_context presentRenderbuffer:GL_RENDERBUFFER];<br>}<h2 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h2>  /**<ol>
<li>GL_ARRAY_BUFFER用于顶点数组</li>
<li>绑定vertexBuffer到GL_ARRAY_BUFFER</li>
<li>给VBO传递数据</li>
<li>取出地址</li>
<li>取出颜色</li>
<li>glVertexAttribPointer的最后一个参数是要获取的参数在GL_ARRAY_BUFFER（每一个Vertex）的偏移量</li>
</ol>
  */</li>
<li>(void)setupVBOs{  GLuint verticesBuffer;<br>  glGenBuffers(1, &amp;verticesBuffer);<br>  glBindBuffer(GL_ARRAY_BUFFER, verticesBuffer);<br>  glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br>  glEnableVertexAttribArray(GLKVertexAttribPosition);<br>  glEnableVertexAttribArray(GLKVertexAttribColor);<br>  glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 0);<br>  glVertexAttribPointer(GLKVertexAttribColor, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 3);<br>}</li>
</ul>
<p>b.流程代码化</p>
<p>  一、配置渲染环境<br>    1) 配置渲染窗口 [ 继承自 UIView ]<br>    2) 配置渲染上下文<br>    3) 配置帧渲染<br>    4) 配置渲染缓存<br>    5) 帧缓存装载渲染缓存的内容<br>    6) 渲染上下文绑定渲染窗口（图层）<br>二、修改背景色</p>
<p>  三、 初始化数据</p>
<p>  四、 配置 OpenGL ES Shader</p>
<pre><code>1) 编写 Vertex Shader Code 文件
2) 编写 Fragment Shader Code 文件
3) 配置 Vertex Shader
4) 配置 Fragment Shader
5) 创建 Shader Program
6) 装载 Vertex Shader 和 Fragment Shader
7) 链接 Shader Program
</code></pre>
<p>  五、渲染绘制</p>
<pre><code>1) 清空旧渲染缓存
2) 设置渲染窗口
3) 使用 Shder Program
4) **关联数据**
5) 绘制图形
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift163iOS%E5%9C%B0%E5%9B%BESDK%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift163iOS%E5%9C%B0%E5%9B%BESDK%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">地图SDK开发设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:11:56" itemprop="dateCreated datePublished" datetime="2020-12-01T14:11:56+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 15:38:42" itemprop="dateModified" datetime="2021-04-12T15:38:42+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="设计方向"><a href="#设计方向" class="headerlink" title="设计方向"></a>设计方向</h2><pre><code>1.距离计算
2.坐标转换
3.覆盖物的设计理念
4.弧线坐标获取逻辑
5.webgl截屏
6.地图手势
7.地图覆盖物管理
8.比例尺计算
9.定位计算
10.坐标转换
11.宏定义
12.覆盖物定义逻辑
13.poi点击
</code></pre>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><pre><code>1.mark问题
目前采用了直接地图绘制marker的方式，后续考虑添加接口实现点击效果
2.地图样式问题
添加地图样式接口，目前配置文件没有其它样式数据
3.地图绘制文本

4.地图导航图标绘制
没有绘制成功，

5.地图定位图标的绘制

6.未完成接口
1.Annomation 接口
2.

1.判断折线是否被点击
    原理：点到线的距离是否大与线的宽度
2.判断是否在弧形上
    原理：点到圆心的距离相同。2点在弧形的三角形内
2.判断是否在圆内
    原理：点到圆心的距离小于半径
3.判断是否在面内
    原理：
5.图形的点击
    判断点是否在rect内

7.覆盖物的选中和非选中状态

6.覆盖物的拖拽：
    原理是修改覆盖物的位置

覆盖物的内容
1.点 MAMarker
2.线 MAPolyline
3.面 MAPolygon
4.圆 MACircle
5.弧 MAArc
6.3d图 MAGroundOverlay

问题：
比例尺不同 ：咱们这个好行0是最大
倾斜角度不同 ：咱们是 0 - 90 度

今天终点是定位，显示定位点，用marker实现，不用annimation

定位点的显示逻辑
1.是否定位
2.是否显示定位点
3.是否自定义定位点
4.是否显示精度圈
5.是否自定义精度圈



初始完成
默认定位是打开的，所以设置完代理时，启动定位
默认显示用户位置，所以启动完定位，添加用户位置

添加定位的逻辑


Annimation使用
由annimation转为view，在地图上添加view、可拖拽的view

点击
选中
取消选中
拖拽


地图Annimation 的重用机制原理
1.添加Annimation 
2.当annimation 位置处在地图以外时，在地图上再添加annimation时，使用屏幕外的annimation 就可以了
3.当annimation位置在、


未实现覆盖物
2.大地曲线
4.路段纹理绘制
5.车标绘制

问题：
1.贴图丢失
2.转角问题
3.大地曲线
4.图片贴图显示问题


https://www.cnblogs.com/csu-lmw/category/1555941.html


未实现接口

图标问题
分段纹理

室内地图
点平滑移动
绘制海量点
获取地址


1.内存问题，map对象不消失，一致占用较大内存
2.室内地图缩放等级不对
3.室内地图绘制poi
4.室内地图事件回调
5.

重用机制
：就是删除数据时候不将数据放到备用池中
室内地图配色
室内地图poi绘制
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">338</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
