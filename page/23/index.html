<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/23/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/23/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift102AFN_SDWebImage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift102AFN_SDWebImage/" class="post-title-link" itemprop="url">AFN SD做了哪些优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:54:20" itemprop="dateCreated datePublished" datetime="2018-08-14T19:54:20+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AFN包括如下模块"><a href="#AFN包括如下模块" class="headerlink" title="AFN包括如下模块"></a>AFN包括如下模块</h2><pre><code>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)
网络状态监听模块(Reachability)
网络通信安全策略模块(Security)
网络通信信息序列化/反序列化模块(Serialization)
对于iOS UIKit库的扩展(UIKit)
</code></pre>
<h2 id="AFN优点"><a href="#AFN优点" class="headerlink" title="AFN优点"></a>AFN优点</h2><pre><code>AFNetworking内置支持JSON,plist文件和XML文件的解析,使用比
较方便我们能够有效的控制并观察一个网络请求的创建、进行、取消、
完成、暂停恢复、异常等问题及状态
可以帮助我们轻松友好的完成请求的创建、响应的系列化,网络状态的监控以
及安全策略以及每一个请求operation的管理(operation的相互依赖或
状态改变)。 
</code></pre>
<h2 id="SDWebImage-概论"><a href="#SDWebImage-概论" class="headerlink" title="SDWebImage 概论"></a>SDWebImage 概论</h2><pre><code>1.提供了一个UIImageView的category用来加载网
络图片并且对网络图片的缓存进行管理
2.采用异步方式来下载网络图片
3.采用异步方式，使用memory＋disk来缓存网
络图片，自动管理缓存。
4.支持GIF动画
5.支持WebP格式
6.同一个URL的网络图片不会被重复下载
7.失效的URL不会被无限重试
8.耗时操作都在子线程，确保不会阻塞主线程
9.使用GCD和ARC
10.支持Arm64
13.图片解码处理在一个 NSOperationQueue 完成，
不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，
最好也在这里完成，效率会好很多。
</code></pre>
<h1 id="AFN、SD缺点"><a href="#AFN、SD缺点" class="headerlink" title="AFN、SD缺点"></a>AFN、SD缺点</h1><pre><code>最近版早早已经支持NSURLSession了，但是不支持iOS7以下系统。
且AFNetworking必须使用ARC
SDWebImage 对gif的处理主要是在UIImage+GIF
这个文件里面，利用ImageIO函数创建二进制数据，如下：
由于SDWebImage通过动图数组来实现动态，
会造成内存不能及时释放
SDWebimage -静态图片加载会产生拉伸
</code></pre>
<h2 id="SD下载完图片为什么要解码"><a href="#SD下载完图片为什么要解码" class="headerlink" title="SD下载完图片为什么要解码"></a>SD下载完图片为什么要解码</h2><pre><code>在我们使用 UIImage 的时候，创建的图片通常不会直接加载到内存，而是在
渲染的时候再进行解压并加载到内存。这就会导致 UIImage 在渲染的时候效
率上不是那么高效。为了提高效率通过 decodedImageWithImage方法把图
片提前解压加载到内存，这样这张新图片就不再需要重复解压了，提高了渲染效
率。这是一种空间换时间的做法。
</code></pre>
<h2 id="旧版本AFN为什么加Runloop"><a href="#旧版本AFN为什么加Runloop" class="headerlink" title="旧版本AFN为什么加Runloop"></a>旧版本AFN为什么加Runloop</h2><pre><code>首先我们知道在旧版本的AFN中使用了 NSURLConnection 来发起并处理网
络连接。AFN 的做法是把网络请求的发起和解析都放在同一个子线程中进行，
但由于子线程默认不开启 runloop，它会向一个 C语言程序那样在运行完所有
代码后退出线程。而网络请求是异步的，这会导致获取到请求数据时，线程已经
退出，代理方法没有机会执行。因此，AFN 的做法是使用一个 runloop 来保
证线程不死，也就是下面这段被讲烂了的代码:
</code></pre>
<h2 id="AFN多重代理如何实现"><a href="#AFN多重代理如何实现" class="headerlink" title="AFN多重代理如何实现"></a>AFN多重代理如何实现</h2><pre><code>https://www.jianshu.com/p/961cfc9a446b
又有小伙伴问了，我们设置的这个代理不是NSURLSessionDelegate吗？怎
么能响应NSUrlSession这么多代理呢？我们点到类的声明文件中去看看：
我们可以看到这些代理都是继承关系，而在NSURLSession实现中，只要设置
了这个代理，它会去判断这些所有的代理，是否respondsToSelector这些代
理中的方法，如果响应了就会去调用。
</code></pre>
<h2 id="SDWebImage的缓存策略"><a href="#SDWebImage的缓存策略" class="headerlink" title="SDWebImage的缓存策略"></a>SDWebImage的缓存策略</h2><pre><code>Memory 和 Disk 双缓存    
</code></pre>
<h2 id="SDWebImage加载图片的流程"><a href="#SDWebImage加载图片的流程" class="headerlink" title="SDWebImage加载图片的流程"></a>SDWebImage加载图片的流程</h2><pre><code>1.入口 setImageWithURL:placeholderImage:options:会
先把 placeholderImage显示，然后 SDWebImageManager根
据 URL 开始处理图片。
2.进入SDWebImageManager 类中
downloadWithURL:delegate:options:userInfo:，交给
SDImageCache从缓存查找图片是否已经下载
queryDiskCacheForKey:delegate:userInfo:.
3.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，
SDImageCacheDelegate回调 
imageCache:didFindImage:forKey:userInfo:到
SDWebImageManager。
4.SDWebImageManagerDelegate 回调
webImageManager:didFinishWithImage: 到 
UIImageView+WebCache,等前端展示图片。
5.如果内存缓存中没有，生成 ｀NSOperation ｀
添加到队列，开始从硬盘查找图片是否已经缓存。
6.根据 URL的MD5值Key在硬盘缓存目录下尝试读取图片文件。这
一步是在 NSOperation 进行的操作，所以回主线程进行结果回
调 notifyDelegate:。
7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如
果空闲内存过小， 会先清空内存缓存）。
SDImageCacheDelegate&#39;回调 
imageCache:didFindImage:forKey:userInfo:`。进而
回调展示图片。
8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图
片，需要下载图片， 回调 
imageCache:didNotFindImageForKey:userInfo:。
9.共享或重新生成一个下载器 SDWebImageDownloader开始下载图片。
10.图片下载由 NSURLConnection来做，实现相关 delegate
来判断图片下载中、下载完成和下载失败。
11.connection:didReceiveData: 中利用 ImageIO做了按
图片下载进度加载效果。
12.connectionDidFinishLoading: 数据下载完成后交给 
SDWebImageDecoder做图片解码处理。
13.图片解码处理在一个 NSOperationQueue完成，不会拖慢主
线程 UI.如果有需要 对下载的图片进行二次处理，最好也在这里
完成，效率会好很多。
14.在主线程 notifyDelegateOnMainThreadWithInfo:
宣告解码完成 
imageDecoder:didFinishDecodingImage:userInfo: 
回调给 SDWebImageDownloader`。
15.imageDownloader:didFinishWithImage:回调给
SDWebImageManager告知图片 下载完成。
16. 通知所有的 downloadDelegates下载完成，回调给需要的
地方展示图片。
17.将图片保存到 SDImageCache中，内存缓存和硬盘缓存同时保
存。写文件到硬盘 也在以单独 NSOperation 完成，避免拖慢主
线程。
18.SDImageCache 在初始化的时候会注册一些消息通知，
在内存警告或退到后台的时 候清理内存图片缓存，应用结束的时候
清理过期图片。
</code></pre>
<h2 id="SDWebimage对相同url图片问题"><a href="#SDWebimage对相同url图片问题" class="headerlink" title="SDWebimage对相同url图片问题"></a>SDWebimage对相同url图片问题</h2><pre><code>找出问题所在了，因为修改头像后，图片的url是不变的，而默认情
况下，SDWebimage对相同url是优先使用缓存的，因此得加
options属性
[self.HeaderImage sd_setImageWithURL:[NSURL URLWithString:yhPic] placeholderImage:[UIImage imageNamed:@&quot;ameng_dh&quot;] options:SDWebImageRefreshCached];
SDWebImageRefreshCached是专门用来处理相同url，图片不同
的情况的。
重点是在SDWebImageManager.m文件中，大概176行左右
在(利用SDWebImageRefreshCached)的基础上，修改SD库
添加这一段代码// remove 
SDWebImageDownloaderUseNSURLCache flag 
downloaderOptions &amp;= 
~SDWebImageDownloaderUseNSURLCache;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift97RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift97RunLoop/" class="post-title-link" itemprop="url">RunLoop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:51:42" itemprop="dateCreated datePublished" datetime="2018-08-14T19:51:42+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>Run loops是线程的基础架构部分，每个线程，
包括程序的主线程main thread都有与之相应的run loop对象。
程序启动的时候会调用UIApplicationMain()函数，
重点是UIApplicationMain()函数，
这个方法会为main thread设置一个NSRunLoop对象
对其它线程来说，run loop默认是没有启动的，
如果你需要更多的线程交互则可以手动配置和启动，
如果线程只是去执行一个长时间的已确定的任务则不需要。
使用run loop可以使你的线程在有工作的时候工作，
没有工作的时候休眠，这可以大大节省系统资源。
</code></pre>
<h2 id="获取线程"><a href="#获取线程" class="headerlink" title="获取线程"></a>获取线程</h2><pre><code>NSRunLoop *runloop = [NSRunLoop currentRunLoop];
RunLoop 一个状态循环
</code></pre>
<h2 id="NSRunLoop不是线程安全的"><a href="#NSRunLoop不是线程安全的" class="headerlink" title="NSRunLoop不是线程安全的"></a>NSRunLoop不是线程安全的</h2><pre><code>我们不能再一个线程中去操作另外一个线程的run loop对象，
那很可能会造成意想不到的后果
不过幸运的是CoreFundation中的不透明类CFRunLoopRef是
线程安全的，而且两种类型的run loop完全可以混合使用。
</code></pre>
<h2 id="NSRunloop数据模型"><a href="#NSRunloop数据模型" class="headerlink" title="NSRunloop数据模型"></a>NSRunloop数据模型</h2><pre><code>NSRunloop，对CFRunLoop的封装
1.ptherd 对应runloop的内部一个线程
2.currendMode， 当前mode， CFRunLoopMode数据结构
    2.1 name 定义别名，比如NSDefaultRunloopMode
    2.2 source0，soures1，都是无序集合
    2.2.1 sourece0 需要用户手动唤醒线程，非基于port的。用户主动触发的事件
    2.2.2 sources1 具备唤醒线程能力 通过内核和其他线程互相发送消息
    2.3timers 数组
    2.4Observers 观测事件点
        KCFRunLoopEntry 准备启动
        BeforeTimers 通知观察者将要处理timer了
        BeforeSources 通知观察者将要处理Soures了
        BeforeWaiting 将要休眠了
        AfterWiaiting 用户态切换到内核不久
        Exit runloop 退出
        AllActivites 观察所有事件
3.Modes CFRunloopMode 的集合
4.commonModes
</code></pre>
<h2 id="autorelease-pool的创建和释放"><a href="#autorelease-pool的创建和释放" class="headerlink" title="autorelease pool的创建和释放"></a>autorelease pool的创建和释放</h2><pre><code>每当一个运行循环结束的时候，它都会释放一次autorelease pool，
同时pool中的所有自动释放类型变量都会被释放掉。
</code></pre>
<h2 id="输入事件来源"><a href="#输入事件来源" class="headerlink" title="输入事件来源"></a>输入事件来源</h2><pre><code>Run loop接收输入事件来自两种不同的来源：
输入源（input source）和定时源（timer source）。
两种源都使用程序的某一特定的处理例程来处理到达的事件。
在NSRunLoop中每一个消息就被打包在
input source或者是timer source
</code></pre>
<h3 id="输入源（input-source）"><a href="#输入源（input-source）" class="headerlink" title="输入源（input source）"></a>输入源（input source）</h3><pre><code>传递异步事件，通常消息来自于其他线程或程序。
输入源传递异步消息给相应的处理例程，
并调用runUntilDate:方法来退出
(在线程里面相关的NSRunLoop对象调用)。
基于端口的输入源：
    基于端口的输入源由内核自动发送。
    你必须人工创建端口和它的run loop源。
    我们可以使用端口相关的函数（CFMachPortRef，
    CFMessagePortRef，CFSocketRef）来创建合适的对象
自定义输入源
    自定义的输入源需要人工从其他线程发送
    必须使用Core Foundation里面的
    CFRunLoopSourceRef类型相关的函数来创建。
Cocoa上的Selector源
    Cocoa定义了自定义输入源，允许你在任何线程执行
    selector方法。和基于端口的源一样，执行selector
    请求会在目标线程上序列化，减缓许多在线程上允许多个方
    法容易引起的同步问题。不像基于端口的源，一个selector
    执行完后会自动从run loop里面移除。
    NSObject类提供了类似如下的selector方法：
    - (void)performSelectorOnMainThread:
    (SEL)aSelector withObject:
    (id)argwaitUntilDone:(BOOL)wait
    modes:(NSArray *)array;
</code></pre>
<h3 id="定时源（timer-source）"><a href="#定时源（timer-source）" class="headerlink" title="定时源（timer source）"></a>定时源（timer source）</h3><pre><code>定时源在预设的时间点同步方式传递消息，
这些消息都会发生在特定时间或者重复的时间间隔。
定时源则直接传递消息给处理例程，不会立即退出run loop。
尽管定时器可以产生基于时间的通知，但它并不是实时机制。
和输入源一样，定时器也和你的run loop的特定模式相关。
如果定时器所在的模式当前未被run loop监视，
那么定时器将不会开始直到run loop运行在相应的模式下。
典型的ScrollView滑动导致定时器不准问题
NSTimer *timer = [NSTimer 
scheduledTimerWithTimeInterval:4.0
target:self
selector:@selector(backgroundThreadFire:) userInfo:nil
repeats:YES];
[[NSRunLoop currentRunLoop]
addTimer:timerforMode:NSDefaultRunLoopMode];
</code></pre>
<h2 id="RunLoop观察者"><a href="#RunLoop观察者" class="headerlink" title="RunLoop观察者"></a>RunLoop观察者</h2><pre><code>源是在合适的同步或异步事件发生时触发，
而run loop观察者则是在run loop本身运行的特定时候触发。
你可以使用run loop观察者来为处理某一特定事件
或是进入休眠的线程做准备。
1.  Runloop入口
2.  Runloop何时处理一个定时器
3.  Runloop何时处理一个输入源
4.  Runloop何时进入睡眠状态
5.  Runloop何时被唤醒，但在唤醒之前要处理的事件
6.  Runloop终止
- (void)addObserverToCurrentRunloop
&#123;
NSRunLoop*mRunLoop = [NSRunLoop currentRunLoop];
CFRunLoopObserverContext context =
&#123;0,self, NULL,NULL, NULL&#125;;
CFRunLoopObserverRefobserver 、
=CFRunLoopObserverCreate(kCFAllocatorDefault,
kCFRunLoopBeforeTimers,YES, 0,
&amp;myRunLoopObserver, &amp;context);
if (observer)
&#123;
    CFRunLoopRef cfLoop = [myRunLoop 
    getCFRunLoop];
    CFRunLoopAddObserver(cfLoop,
    observer, kCFRunLoopDefaultMode);
&#125;
&#125;
</code></pre>
<h2 id="RunLoop的事件队列"><a href="#RunLoop的事件队列" class="headerlink" title="RunLoop的事件队列"></a>RunLoop的事件队列</h2><pre><code>1.通知观察者run loop已经启动
2.通知观察者任何即将要开始的定时器
3.通知观察者任何即将启动的非基于端口的源
4.启动任何准备好的非基于端口的源
5.如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9。
6.通知观察者线程进入休眠
7.将线程置于休眠直到任一下面的事件发生：
    某一事件到达基于端口的源
    定时器启动
    Run loop设置的时间已经超时
    run loop被显式唤醒
8.通知观察者线程将被唤醒。
9.处理未处理的事件
    如果用户定义的定时器启动，处理定时器事件并重启
    run loop。进入步骤2
    如果输入源启动，传递相应的消息
    如果run loop被显式唤醒而且时间还没超时，
    重启run loop。进入步骤2
10.通知观察者run loop结束。
从这个事件队列中可以看出：
①如果是事件到达，消息会被传递给相应的处理程序来处理，
runloop处理完当次事件后，run loop会退出，
而不管之前预定的时间到了没有。你可以重新启动
run loop来等待下一事件。
②如果线程中有需要处理的源，但是响应的事件没有到来的时候，
线程就会休眠等待相应事件的发生。这就是为什么run loop
可以做到让线程有工作的时候忙于工作，
而没工作的时候处于休眠状态。
</code></pre>
<h2 id="RunLoop使用时机"><a href="#RunLoop使用时机" class="headerlink" title="RunLoop使用时机"></a>RunLoop使用时机</h2><pre><code>Run loop在你要和线程有更多的交互时才需要，比如以下情况：
使用端口或自定义输入源来和其他线程通信
使用线程的定时器
Cocoa中使用任何performSelector…的方法
使线程周期性工作
</code></pre>
<h2 id="RunLoop的五个类"><a href="#RunLoop的五个类" class="headerlink" title="RunLoop的五个类"></a>RunLoop的五个类</h2><pre><code>1    CFRunloopRef    【RunLoop本身】
2    CFRunloopModeRef    【Runloop的运行模式】
3    CFRunloopSourceRef    【Runloop要处理的事件源】
4    CFRunloopTimerRef    【Timer事件】
5    CFRunloopObserverRef    【Runloop的观察者（监听者）】
</code></pre>
<h3 id="CFRunLoop-的结构大致如下："><a href="#CFRunLoop-的结构大致如下：" class="headerlink" title="CFRunLoop 的结构大致如下："></a>CFRunLoop 的结构大致如下：</h3><pre><code>struct __CFRunLoop &#123;
    CFMutableSetRef _commonModes;     // Set
    CFMutableSetRef _commonModeItems; // Set
    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
    CFMutableSetRef _modes;           // Set
    ...
&#125;;
 如上，有个概念叫 CommonModes：
 一个 Mode 可以将自己标记为&quot;Common&quot;属性：
 通过将其 ModeName 添加到 RunLoop 的 commonModes 中。例如：
 如上所示，添加 source 的时候，如果 modeName 传入
 kCFRunLoopCommonModes 或者 NSRunLoopCommonModes，
 则该 source 会被保存到 RunLoop 的
 _commonModeItems 中，而且，会被添加到 
 commonModes 中的所有mode中去。
 其实，每当 RunLoop 的内容发生变化时，
 RunLoop 都会自动将 _commonModeItems 
 里的 Source/Observer/Timer 同步到具有 
 Common 标记的所有Mode里。
主线程的 RunLoop 里有两个预置的 Mode
：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。
这两个 Mode 都已经被标记为 Common 属性。
DefaultMode 是 App 平时所处的状态，
TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。
当你创建一个 Timer 并加到 DefaultMode 时，
Timer 会得到重复回调，但此时滑动一个TableView时，
RunLoop 会将 mode 切换为 TrackingRunLoopMode，
这时 Timer 就不会被回调，并且也不会影响到滑动操作。
有时你需要一个 Timer，在两个 Mode 中都能得到回调，
一种办法就是将这个 Timer 分别加入这两个 Mode。
还有一种方式，就是将 Timer 加入到顶层的 RunLoop 
的 commonModeItems 中。commonModeItems 被
RunLoop 自动更新到所有具有 Common 属性的 Mode 里去。
一个 RunLoop 包含若干个 Mode，每个 Mode 
又包含若干个Source/Timer/Observer。
但是，运行的时候，一条线程对应一个 Runloop，
Runloop 总是运行在某种特定的CFRunLoopModeRef
（运行模式）下。
这是因为，在 Runloop 中有多个运行模式，每次调用 
RunLoop 的主函数__CFRunloopRun() 时，只能指定其中一个
Mode（称 CurrentMode）运行， 如果需要切换 Mode，只能是
退出 CurrentMode 切换到指定的 Mode 进入，目的以保证不同
Mode 下的 Source / Timer / Observer 互不影响。
每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，
这个Mode被称作 CurrentMode。如果需要切换 Mode，
只能退出 Loop，再重新指定一个 Mode 进入。
这样做主要是为了分隔开不同组的 Source/Timer/Observer
让其互不影响。
Runloop 要有效，mode 里面 至少 要有一个 timer 
(定时器事件) 或者是 source (源);
</code></pre>
<h2 id="常用案例"><a href="#常用案例" class="headerlink" title="常用案例"></a>常用案例</h2><h3 id="performSelector"><a href="#performSelector" class="headerlink" title="performSelector"></a>performSelector</h3><pre><code>performSelector同样是触发Source0事件。selector也是特殊的
基于自定义的源.理论上来说,允许在当前线程向任何线程上执行发送消息,
和基于端口的源一样,执行selector请求会在目标线程上序列化,
减缓许多在线程上允许多个方法容易引起的同步问题.不像基于端口的源,
一个selector执行完后会自动从run loop里面移除.
当调用上述API，实际上其内部会创建一个 Timer 并添加到当前线程的
RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。
当调用 performSelector:onThread: 时，实际上其会创建一个Timer
加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效.
当前线程指定mode name并延时执行
// 只在NSDefaultRunLoopMode下执行(刷新图片)
[self.myImageView performSelector:@selector
(setImage:) withObject:[UIImage imageNamed:@&quot;&quot;]
afterDelay:ti inModes:@[NSDefaultRunLoopMode]];
</code></pre>
<h3 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源"></a>自定义输入源</h3><pre><code>使用CFRunLoopSourceRef 类型相关的函数 (线程) 来创建自定义输入源。
</code></pre>
<h3 id="端口输入源"><a href="#端口输入源" class="headerlink" title="端口输入源"></a>端口输入源</h3><h3 id="设置定时源"><a href="#设置定时源" class="headerlink" title="设置定时源"></a>设置定时源</h3><pre><code>使用系统Timer
使用自定义Timer
</code></pre>
<h3 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h3><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><pre><code>对于NSTimer，有一个特别的API，这个API会默认把Timer加到 当前线程 中去。
[NSTimer scheduledTimerWithTimeInterval:5.1
target:self selector:@selector(printMessage:)
userInfo:nil repeats:YES];
所以说，当且仅当加到当前线程，下面两个添加NSTimer的方案方可等效：
- (void)defalutTimer &#123;
[NSTimer scheduledTimerWithTimeInterval:1.0 target:
self selector:@selector(doTime) userInfo:nil
repeats:YES];
&#125;
- (void)commonTimer &#123;
NSTimer *timer =[NSTimer timerWithTimeInterval:
1.0 target:self selector:@selector(doTime) 
userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:
timer forMode:NSDefaultRunLoopMode];
&#125;
</code></pre>
<h2 id="NSTimer和RunLoop"><a href="#NSTimer和RunLoop" class="headerlink" title="NSTimer和RunLoop"></a>NSTimer和RunLoop</h2><pre><code>timer不是一种实时的机制，会存在延迟，而且延迟的程度跟当前线
程的执行情况有关。
NSTimer其实也是一种资源，如果看过多线程变成指引文档的话，
我们会发现所有的source如果要起作用，就得加到runloop中去。
同理timer这种资源要想起作用，那肯定也需要加到runloop中才
会又效喽。如果一个runloop里面不包含任何资源的话，运行该
runloop时会立马退出。你可能会说那我们APP的主线程的
runloop我们没有往其中添加任何资源，为什么它还好好的运行。
RunLoop 是用GCD的 dispatch_source_t 实现的 Timer。 
当调用 NSObject 的 performSelecter:afterDelay: 后，
实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 
中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用 
performSelector:onThread: 时，实际上其会创建一个 
Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 
该方法也会失效。
CADisplayLink 是一个和屏幕刷新率（每秒刷新60次）一致的定
时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实
际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个
长任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉。
</code></pre>
<h2 id="动画和RunLoop"><a href="#动画和RunLoop" class="headerlink" title="动画和RunLoop"></a>动画和RunLoop</h2><pre><code>CAAnimation是由RunloopObserver触发回调来重绘
实际上这些背后关联的Layer图层才是真正用来在屏幕上显示和做动
画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触
摸的具体功能，以及Core Animation底层方法的高级接口。
UIView 的 Layer 在系统内部，被维护着三份同样的树形数据结
构，分别是：
1.图层树（这里是代码可以操纵的，设置属性的最终值会立刻在这里更新）； 
2.呈现树（是一个中间层，系统就在这一层上更改属性，进行各种渲
染操作。比如一个动画是更改alpha值从0到1，那么在逻辑树上此
属性会被立刻更新为最终属性1，而在动画树上会根据设置的动画时
间从0逐步变化到1）；
3.渲染树（其属性值就是当前正被显示在屏幕上的属性值）；
隐式动画是系统框架自动完成的。Core Animation在每个
runloop周期中自动开始一次新的事务，即使你不显式的用
[CATransaction begin]开始一次事务，任何在一次runloop
循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。
Core Animation提供的显式动画类型，既可以直接对退曾属性做
动画，也可以覆盖默认的图层行为。
我们经常使用的CABasicAnimation，
CAKeyframeAnimation，CATransitionAnimation，
CAAnimationGroup等都是显式动画类型，这些CAAnimation类
型可以直接提交到CALayer上。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift99Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift99Block/" class="post-title-link" itemprop="url">Block理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:47:23" itemprop="dateCreated datePublished" datetime="2018-08-14T19:47:23+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>本质：带有自动变量值的匿名函数
block的实质是一个oc对象，它有自己的isa指针、invoke变
量 ，是NSObject的子类，可以接收消息
1._NSConcreteGlobalBlock,全局的静态block，不会访问外部的变量。
就是说如果你的block没有调用其他 的外部变量，那你的block类型就是这
种。例如：你仅仅在你的block里面写一个NSLog(&quot;hello world&quot;);
2._NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销
毁。这个block就是你声明的时候不用copy修饰，并且你的block访问了外部
变量。
3._NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时
会被销毁。
</code></pre>
<h2 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h2><pre><code>void (^block)(void) = ^&#123;
    NSLog(@&quot;无参无返回值&quot;);
&#125;;
void (^xiaoming1aa)() = ^(NSString *c)&#123;
    NSLog(@&quot;带参数&quot;);
&#125;;
NSString *(^xiaming2)() = ^NSString *(NSString *dd) &#123;
    return @&quot;带参数与返回&quot;;
&#125;;
@property (nonatomic, copy)
void(^myBlock)();//无参无返回值
@property (nonatomic, copy)
void(^myBlock1)(NSString *);//带参数
@property (nonatomic, copy)
NSString *(^myBlock2)(NSString *);//带参数与返回
</code></pre>
<h2 id="block为什么不能修改外部变量"><a href="#block为什么不能修改外部变量" class="headerlink" title="block为什么不能修改外部变量"></a>block为什么不能修改外部变量</h2><pre><code> 默认情况下，在block中访问的外部变量是复制过去的，
 复制过去的是值，即：写操作不对原变量生效。
</code></pre>
<h2 id="block都做了什么？"><a href="#block都做了什么？" class="headerlink" title="__block都做了什么？"></a>__block都做了什么？</h2><pre><code>Block不允许修改外部变量的值，这里所说的外部变量的值，
指的是栈中指针的内存地址。__block 所起到的作用就是
只要观察到该变量被 block 所持有，就将“外部变量”
在栈中的内存地址放到了堆中。
进而在block内部也可以修改外部变量的值
这也保证了原对象不被销毁，但与此同时，也会导致循环引用问题
</code></pre>
<h2 id="block为什么为引起循环引用"><a href="#block为什么为引起循环引用" class="headerlink" title="block为什么为引起循环引用"></a>block为什么为引起循环引用</h2><pre><code>因为block在拷贝到堆上的时候，会retain其引用的外部变量，
那么如果block中如果引用了他的宿主对象，
那很有可能引起循环引用
循环引用发生的条件就是持有这个block的对象，
被block里边加入的对象持有
</code></pre>
<h2 id="如何解决循环引用"><a href="#如何解决循环引用" class="headerlink" title="如何解决循环引用"></a>如何解决循环引用</h2><pre><code>使用__weak修饰self，使其在block中不被持有，打破循环引用。
__weak typeof(self) weakSelf = self;
</code></pre>
<h2 id="Block为什么要用copy修饰"><a href="#Block为什么要用copy修饰" class="headerlink" title="Block为什么要用copy修饰"></a>Block为什么要用copy修饰</h2><pre><code>针对block的三种类型，
也就是copy修饰的block。他的生命 周期就是随着对象的销毁而结束的。只要
对象不销毁，我们就可以调用的到在堆中的block。这就是为什么我们要用
copy来修饰block。因为不用copy修饰的访问外部变量的block，只在他所在
的函数被调用的那一瞬间可以使用。之后就消失了。
</code></pre>
<h2 id="block执行过程中对象被释放"><a href="#block执行过程中对象被释放" class="headerlink" title="block执行过程中对象被释放"></a>block执行过程中对象被释放</h2><pre><code>在block执行开始时self对象还未被释放，而执行过程中，
self被释放了，此时访问self时，就会发生错误。
对于这种场景，应该在block中对 对象使用__strong修饰，
使得在block期间对 对象持有，block执行结束后，解除其持有。
注：此方法只能保证在block执行期间对象不被释放，
如果对象在block执行执行之前已经被释放了，该方法也无效。
</code></pre>
<h2 id="什么情况下不回发生循环引用"><a href="#什么情况下不回发生循环引用" class="headerlink" title="什么情况下不回发生循环引用"></a>什么情况下不回发生循环引用</h2><pre><code>通用情况:在block本身不被self持有,而被别的对象持有,
同时不产生循环引用的时候,就不需要使用weakself了
UIView动画block，AFN的block
UIView的调用的是类方法，当前控制器不可能强引用一个类 ，
所以循环无法形成 --&gt; 动画block不会造成循环引用的原因。
</code></pre>
<h2 id="函数和block区别"><a href="#函数和block区别" class="headerlink" title="函数和block区别"></a>函数和block区别</h2><pre><code>函数里面只能访问全局变量，而Block代码块不光能访问全局变量，
还拥有当前栈内存和堆内存变量的可读性
（当然通过__block访问指示符修饰的局部变量还可以在block代码块里面进行修改）。
从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，
而block实际上是程序运行过程中在栈内存动态创建的对象，
可以向其发送copy消息将block对象拷贝到堆内存，
以延长其生命周期。
</code></pre>
<h2 id="如何区分block位置"><a href="#如何区分block位置" class="headerlink" title="如何区分block位置"></a>如何区分block位置</h2><pre><code>要点一:
    当block在函数内部，
    且定义的时候就使用了函数内部的变量，
    那么这个block是存储在栈上的。 
要点二:
    当block定义在函数体外面，
    或者定义在函数体内部且当时函数执行的时候，
    block体中并没有需要使用函数内部的局部变量时，
    也就是block在函数执行的时候只是静静地待在一边定义了一下
    而不使用函数体的内容，
    那么block将会被编译器存储为全局block。 
要点三:
    全局block存储在堆中，
    对全局block使用copy操作会返回原函数指针；
    而对栈中的block使用copy操作，
    会产生两个不同的block地址，
    也就是两个匿名函数的入口地址。 
要点四:
    ARC机制优化会将stack的block,
    转为heap的block进行调用。
</code></pre>
<h2 id="delegate为什么用weak-它和block区别"><a href="#delegate为什么用weak-它和block区别" class="headerlink" title="delegate为什么用weak 它和block区别"></a>delegate为什么用weak 它和block区别</h2><pre><code>weak是为了解决循环引用的问题
代理和block的共同特性是回调机制，不同的是，代理的方法比较多，比较分
散，使用block的代码比较集中统一；代理运行成本比较低，一对一的关系，
block需要将使用的数据从栈内存拷贝到堆内存中，对象的话就是加计数，代理
制是保存一个对象指针，直接回调；block写法简单，注重传输，但是需要注意
循环引用
总结：公共接口，方法比较多的时候用delegate进行解耦，异步和简单的回调用block
</code></pre>
<h2 id="在block中对weakSelf再进行—strong的操作，然后以百万级的数量去调用某个方法，与直接用weakSelf去调用有什么区别"><a href="#在block中对weakSelf再进行—strong的操作，然后以百万级的数量去调用某个方法，与直接用weakSelf去调用有什么区别" class="headerlink" title="在block中对weakSelf再进行—strong的操作，然后以百万级的数量去调用某个方法，与直接用weakSelf去调用有什么区别"></a>在block中对weakSelf再进行—strong的操作，然后以百万级的数量去调用某个方法，与直接用weakSelf去调用有什么区别</h2><pre><code>在block中调用self会引起循环引用，但是在block中需要对
weakSelf进行strong,保证代码在执行到block中，self不会被
释放，当block执行完后，会自动释放该strongSelf
进行大量调用会引起内存问题
</code></pre>
<h2 id="block嵌套block还用——strong两遍吗"><a href="#block嵌套block还用——strong两遍吗" class="headerlink" title="block嵌套block还用——strong两遍吗"></a>block嵌套block还用——strong两遍吗</h2><pre><code>只要在最后把外层的block执行一次, 内层的block才会真正地被
加载进内存, 循环引用问题再次出现. 出现循环引用的原因其实也
不难理解, 因为strongPerson说白了也是一个强引用, 它与一般
强引用的区别在于, 它只会在被定义的block中对对象进行强引用, 
在block过后就会把对象释放掉, 所以在第2层block中继续用
strongPerson出现循环引用跟一般造成循环引用的原因其实是一
样的, 解决方法也是如出一辙, 而且可以继续嵌套下去, 此处的警
告同样是结果没被使用:
加上修饰符strong时，当别处把变量释放掉，但调用该变量的
block如果仍然没有执行结束，那么系统就会等待block执行完成后
再释放，对该变量在block中的使用起到了保护作用。当block执行
结束后会自动释放掉。
</code></pre>
<h2 id="block捕获进去静态变量，局部变量，全局变量以后，在block内部以什么形式存在"><a href="#block捕获进去静态变量，局部变量，全局变量以后，在block内部以什么形式存在" class="headerlink" title="block捕获进去静态变量，局部变量，全局变量以后，在block内部以什么形式存在"></a>block捕获进去静态变量，局部变量，全局变量以后，在block内部以什么形式存在</h2><pre><code>在执行Block语法的时候，Block语法表达式所使用的自动变量的值
是被保存进了Block的结构体实例中，也就是Block自身中
Block仅仅捕获了val的值，并没有捕获val的内存地址。
</code></pre>
<h2 id="block-和-delegate使用优先级"><a href="#block-和-delegate使用优先级" class="headerlink" title="block 和 delegate使用优先级"></a>block 和 delegate使用优先级</h2><pre><code>block 和 delegate 都可以通知外面。block 更轻型，使用更
简单，能够直接访问上下文，这样类中不需要存储临时数据，使用 
block 的代码通常会在同一个地方，这样读代码也连贯。
delegate 更重一些，需要实现接口，它的方法分离开来，很多时
候需要存储一些临时数据，另外相关的代码会被分离到各处，没有 
block 好读。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift103%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift103%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E9%A1%BA%E5%BA%8F/" class="post-title-link" itemprop="url">iOS事件响应顺序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:44:31" itemprop="dateCreated datePublished" datetime="2018-08-14T19:44:31+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>只有继承了UIResponder的类才能响应touch事件，
响应顺序，优先是最上层的view响应事件，
如果该view有视图控制器的话会是下一个响应者，否者就是该
view的父视图，这样至上而下传递事件。直到单例UIWindow
对象，最后是单例UIApplication对象以终止，UIApplication
的下一个响应者是nil，已结束整个响应循环。
事件在传递过程中视图可以决定是否需要对该事件进行响应。
</code></pre>
<h2 id="1-事件的产生"><a href="#1-事件的产生" class="headerlink" title="1. 事件的产生"></a>1. 事件的产生</h2><pre><code>发生事件后，系统会将该事件加入到一个由UIApplication
管理的事件队列中。
UIApplication会从事件队列中取出最前面的事件，
并将该事件分发下去处理。通常，先发送事件给应用程序
的主窗口（keywindow）。
keywindow会在视图层次结构中找到一个最合适的视图来处理事件。
</code></pre>
<h2 id="事件分发（Event-Delivery）"><a href="#事件分发（Event-Delivery）" class="headerlink" title="事件分发（Event Delivery）"></a>事件分发（Event Delivery）</h2><pre><code>第一响应者（First responder）指的是当前接受触摸的响应者
对象（通常是一个UIView对象），即表示当前该对象正在与用户
交互，它是响应者链的开端。整个响应者链和事件分发的使命都是
找出第一响应者。

UIWindow对象以消息的形式将事件发送给第一响应者，
使其有机会首先处理事件。如果第一响应者没有进行处理，
系统就将事件（通过消息）传递给响应者链中的下一个响应者
，看看它是否可以进行处理。
事件的传递先从父控件传递到子控件（UIApplication
-&gt;window-&gt;寻找处理事件最合适的view）。
如果父view不能接受触摸事件，那么子view也不能接收到
触摸事件。
</code></pre>
<h3 id="如何找到最合适的view来处理事件"><a href="#如何找到最合适的view来处理事件" class="headerlink" title="如何找到最合适的view来处理事件"></a>如何找到最合适的view来处理事件</h3><pre><code>iOS系统检测到手指触摸(Touch)操作时会将其打包成一
个UIEvent对象，并放入当前活动Application的事件队列，
单例的UIApplication会从事件队列中取出触摸事件并传递给单
例的UIWindow来处理，UIWindow对象首先会使用
hitTest:withEvent:方法寻找此次Touch操作初始点所在的视图
(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为
hit-test view。
UIWindow实例对象会首先在它的内容视图上调用
hitTest:withEvent:，此方法会在其视图层级结构中的每个视图
上调用pointInside:withEvent:（该方法用来判断点击事件发
生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视
图），如果pointInside:withEvent:返回YES，则继续逐级调
用，直到找到touch操作发生的位置，这个视图也就是要找的hit-
test view。
</code></pre>
<h3 id="hitTest-withEvent-方法的处理流程如下"><a href="#hitTest-withEvent-方法的处理流程如下" class="headerlink" title="hitTest:withEvent:方法的处理流程如下:"></a>hitTest:withEvent:方法的处理流程如下:</h3><pre><code>view会调用hitTest:withEvent:方法，
hitTest:withEvent:方法底层会调用
pointInside:withEvent:方法判断触摸点是不是在这个view的
坐标系上。如果在坐标系上，会分发事件给这个view的子view。然
后每个字view重复以上步骤，直至最底层的一个合适的view。
如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。
</code></pre>
<h2 id="事件的响应"><a href="#事件的响应" class="headerlink" title="事件的响应"></a>事件的响应</h2><pre><code>事件响应会先从底层最合适的view开始，然后随着上一步找到的链
一层一层响应touch事件。默认touch事件会传递给上一层。如果到
了viewcontroller的view，就会传递给viewcontroller。如
果viewcontroller不能处理，就会传递给UIWindow。如果
UIWindow无法处理，就会传递给UIApplication。如果
UIApplication无法处理，就会传递给
UIApplicationDelegate。如果UIApplicationDelegate不
能处理，则会丢弃该事件。
</code></pre>
<h2 id="如果一个button有一部分超出父控件的范围了，这部分无法响应点击"><a href="#如果一个button有一部分超出父控件的范围了，这部分无法响应点击" class="headerlink" title="如果一个button有一部分超出父控件的范围了，这部分无法响应点击"></a>如果一个button有一部分超出父控件的范围了，这部分无法响应点击</h2><pre><code>当我去点击View-C的时候，hit-Testing实际上是这样检测的
1.首先，视图会先从View-A开始检查，发现触摸点在View-A，
所以检查View-A的子视图View-B。
2.发现触摸点在View-B内，好棒！看看View-B内的子
视图View-C。
3.发现触摸点在View-C内，但View-C没有子视图了，
所以View-C是此次触摸事件的hit-TestView了。
那么UIView中其实提供了两个方法来确定hit-TestView
1.- (UIView *)hitTest:(CGPoint)point 
withEvent:(UIEvent *)event;
2.- (BOOL)pointInside:(CGPoint)point 
withEvent:(UIEvent *)event;
//这个就是我们上面重写的方法
注意其实在每次递归去调用hitTest:(CGPoint)point
withEvent:(UIEvent *)event之前，都会调用
pointInside:withEvent:来确定该触摸点是否在该View内。
所以当我们重写pointInside:(CGPoint)point 
withEvent:(UIEvent *)event后，其实我们的点击后调
用hitTest来递归的找hit-TestView的区域从这样：
</code></pre>
<h2 id="去点手机屏幕，runloop都干了什么，怎么去通知到响应事件的（runloop的唤醒和休眠，调用NSNotification底层的东西）"><a href="#去点手机屏幕，runloop都干了什么，怎么去通知到响应事件的（runloop的唤醒和休眠，调用NSNotification底层的东西）" class="headerlink" title="去点手机屏幕，runloop都干了什么，怎么去通知到响应事件的（runloop的唤醒和休眠，调用NSNotification底层的东西）"></a>去点手机屏幕，runloop都干了什么，怎么去通知到响应事件的（runloop的唤醒和休眠，调用NSNotification底层的东西）</h2><pre><code>Core Foundation和Foundation为Mach端口提供了高级API。
在内核基础上封装的CFMachPort / NSMachPort可以用做
runloop源
而这个源，正是我们经常在调用栈里看到的source0与source1
苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统
事件，其回调函数为 
__IOHIDEventSystemClientQueueCallback()
当我们触发了事件（触摸/锁屏/摇晃等）后
由IOKit.framework生成一个 IOHIDEvent事件
而IOKit是苹果的硬件驱动框架
由它进行底层接口的抽象封装与系统进行交互传递硬件感应的事件
它专门处理用户交互设备，由IOHIDServices和IOHIDDisplays
两部分组成
其中IOHIDServices是专门处理用户交互的，它会将事件封装成
IOHIDEvents对象，详细请看这里
然后这些事件又由SpringBoard接收，它只接收收按键(锁屏/静音
等)，触摸，加速，接近传感器等几种 Event
接着用mach port转发给需要的App进程
随后苹果注册的那个 Source1 就会触发回调，并调用 
_UIApplicationHandleEventQueue()进行应用内部的分发
_UIApplicationHandleEventQueue()把IOHIDEvent处理包
装成UIEvent进行处理分发，我们平时的UIGesture/处理屏幕旋
转/发送给 UIWindow/UIButton 点击、touchesBegin/
Move/End/Cancel这些事件，都是在这个回调中完成
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift100KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift100KVC/" class="post-title-link" itemprop="url">KVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:39:46" itemprop="dateCreated datePublished" datetime="2018-08-14T19:39:46+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。
键值编码必需的方法在非正式协议NSKeyValueCoding中声明，
默认在NSObject中实现。
</code></pre>
<h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><pre><code>-(id)  valueForKey: (NSString *) key
返回表示属性的键字符串所对应的值。如果不能取得值
，则将引起接收器调用方法valueForUndefinedKey:。
-(void)setValue: (id) value  forKey: (NSString*) key
</code></pre>
<h2 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h2><pre><code>1.接收器中如果有key访问器
（或getKey、isKey、_key、_getKey、setKey）则使用它。
2.没有访问器时，使用接收器的类方法
accessInstanceVariablesDirectly来查询。返回YES时，如果存在实例
变量key（或_key、isKey、_isKey等）则返回或设置其值。使用引用计数管
理方式时，实例变量如果为对象，则旧值会被自动释放，新值被保存并代入。
+(BOOL)accessInstanceVariablesDirectly
通常定义为返回YES，可以在子类中改变。该类方法返回YES时，使用键值编码
可以访问该类的实例变量。返回NO时不可以访问。只要该方法返回YES，实例变
量的可视属性即使有@private修饰，也可以访问。
3.既没有访问器也没有实例变量时，将引起接收器调用方法
valueForUndefinedKey:或setValue:forUndefinedKey:。
-(id) valueForUndefinedKey: (NSStirng *) key
不能取得键字符串对应的值时，从方法valueForKey：中调用该方法。默认情
况下，该方法的执行会触发NSUndefinedKeyException。不过，通过在子类
中修改定义，就可以返回其他对象。
- (void) setValue:(id)value forUndefinedKey:(NSString *) key
不能设置键字符串key对应的属性值时，从方法setValue:forKey中调用该方
法。默认情况下，该方法的执行会触发异常NSUndefinedKeyException。不
过，通过在子类中修改定义，可以返回其他对象。
4.   如果该返回值不是对象，则返回被适当的对象包装的值；设置值时也应先
包装成相应的对象。
属性为对象时，该对象还可能持有属性。这时候可以用“.”连接表示键的字符
串，这种表示方式称为键路径。只要能找到对象，点和键多长都没有关系。
- (id)valueForKeyPath:(NSString *) keyPath
以点切分键路径，并使用第一个键向接收器发送valueForKey：方法。然后，
再使用键路径的下一个键，向得到的对象发送valueForKey：方法，如此反复
操作，返回最后获得的对象。
- (void)setValue:(id) value forKeyPath:(NSString *) keyPath
与valueForKeyPath：方法一样取出对象，这里只对路径中的最后一个键调用
setValue：forKey：方法，并设定属性值为value。
</code></pre>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="KVC提供了验证Key对应的Value是否可用的方法："><a href="#KVC提供了验证Key对应的Value是否可用的方法：" class="headerlink" title="KVC提供了验证Key对应的Value是否可用的方法："></a>KVC提供了验证Key对应的Value是否可用的方法：</h3><pre><code>(BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;  
</code></pre>
<h3 id="KVC对数值和结构体型属性的支持"><a href="#KVC对数值和结构体型属性的支持" class="headerlink" title="KVC对数值和结构体型属性的支持"></a>KVC对数值和结构体型属性的支持</h3><h2 id="NSMutableDictionary的setObject和setValue的区别，哪一个add-nil对象会crash"><a href="#NSMutableDictionary的setObject和setValue的区别，哪一个add-nil对象会crash" class="headerlink" title="NSMutableDictionary的setObject和setValue的区别，哪一个add nil对象会crash"></a>NSMutableDictionary的setObject和setValue的区别，哪一个add nil对象会crash</h2><pre><code>1, setObject：forkey：中value是不能够为nil的，不然会报错。
setValue：forKey：中value能够为nil，但是当value为nil的时候，会自动调用removeObject：forKey方法
2, setValue：forKey：中key的参数只能够是NSString类型，而setObject：forKey：的可以是任何类型
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift107iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift107iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:38:07" itemprop="dateCreated datePublished" datetime="2018-08-14T19:38:07+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><pre><code>场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。
优势：解耦合、多继承
实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。
</code></pre>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><pre><code>场景：当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。
比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。
优势：解耦合
实例：Notification通知中心，注册通知中心，任何位置可以发送消息，
注册观察者的对象可以接收。
kvo，键值对改变通知的观察者，平时基本没用过。
</code></pre>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><pre><code>场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。
注意：
    单例类只能有一个实例。
    单例类必须自己创建自己的唯一实例。
    单例类必须给所有其他对象提供这一实例。
优势：在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实
例，避免对资源的多重占用比如写文件操作
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻
辑，而不关心外面怎么样来实例化。
注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。
实例：UIApplication, NSBundle, NSNotificationCenter, 
NSFileManager, NSUserDefault, NSURLCache等都是单例.
</code></pre>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><pre><code>场景：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式
“专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。”
优势：
    一个调用者想创建一个对象，只要知道其名称就可以了。
    扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
    屏蔽产品的具体实现，调用者只关心产品的接口。
缺点：
    每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统
    中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了
    系统具体类的依赖。这并不是什么好事。
实例：以 NSArray 举例，发现 + alloc 后并非生成了我们期望的类实例，而是一个__NSPlacehodlerArray 的中间对象，后面的 - init 或 - initWithXXXXX 消息都是发送给这个中间对象，再由它做工厂，生成真的对象。生成真的对象。这里的 __NSArrayI 和 __NSArrayM
</code></pre>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><pre><code>是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。
实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。
</code></pre>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><pre><code>它其实是一个 MVC 的增强版，并将表示逻辑从 Controller 移出放到一个
新的对象里，即 View Model
在 iOS 上使用 MVVM 的动机,就是让它能减少 View Controller 的复杂
性并使得表示逻辑更易于测试
</code></pre>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><pre><code>MVP全称Model-View-Presenter。
Presenter：作为model和view的中间人，从model层获取数据之后传给
view，使得View和model没有耦合。
View：这里的View与MVC中的V又有一些小差别，这个View可以是
viewcontroller、view等控件。Presenter通过向View传model数据进行交互。
</code></pre>
<h1 id="MVVM双向绑定"><a href="#MVVM双向绑定" class="headerlink" title="MVVM双向绑定"></a>MVVM双向绑定</h1><pre><code>mvvm框架的双向绑定，即当对象改变时，自动改变相关的dom元素的值，反之，当dom元素改变时，能自动更新对象的值，当然dom元素一般是指可输出的input元素。

1. 首先实现单向绑定，在指定对象的属性值发生改变时触发callback函数。
2. 单向绑定可采用ES5新增的defineProperty实现(或defineProperties)，用了ES5注定就不支持IE9以下了，为了防止递归死循环问题，原有属性需要剪切到一个私有属性中保存。
3. 循环调用defineProperty定义闭包时产生作用域的问题，为解决作用域变量对象的值会取到最后一次运行值问题，多定义一层立即调用的闭包函数将值传入。
4. 我们定义getFN和setFN函数用于在属性get和set的时候触发，它的功能是对私有属性__private的读写并触发回调函数通知UI层更新界面。
5.单向绑定实现完成后，实现反向的绑定，即UI层onchange之后触发更新数据，这个相对比较容易，在dom中通过自定义属性bindKey关联model的值变化，监听使用oninput事件，相比onchange的好处是可以实时变化不用等失焦，而且对右键粘贴、菜单粘贴，拖动文字进文本框等方式都可以触发，完全无死角，缺点是只支持IE9以上，但是在IE9以下有等价的onpropertychange可以用还是能兼容的。
6.总结，双向绑定的原理并不复杂，整体代码不超过50行，非常精简，不过还是有一些技术含量，下面是完整的代码，如果不想使用庞大的框架，可以用一下。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/10/M_Swift92%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/10/M_Swift92%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">算法之排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-10 15:20:39" itemprop="dateCreated datePublished" datetime="2018-08-10T15:20:39+08:00">2018-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>思想：每次遍历，相邻两个比较大小，修改位置
复杂度：n平方
function maopao(arr) &#123;
    for (var i = 0; i &lt; arr.length; i++) &#123;
        for (var j = 0; j &lt; arr.length; j++) &#123;
            if (arr[i] &gt; arr[j]) &#123;
                var temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre><code>思想：一次便利结束后，找到最小的，放到最前面，交换次数较冒泡排序少
排序复杂度：n平方
function xuanze(arr) &#123;
    for (var i = 0; i &lt; arr.length; i++) &#123;
        var min = i;
        for (var j = 0; j &lt; arr.length; j++) &#123;
            if (arr[j] &lt;arr[i]) &#123;
                min = j;
            &#125;
        &#125;
        if (min != i) &#123;
            var temp = arr[i];
            arr[i] = arr[min];
            arr[min] = arr[i];
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre><code>思想：每次往最小数组里插入一个数据，并保证数组是排序的
(1) 将这个序列的第一个元素R0视为一个有序序列； 
(2) 依次把 , , … ,  插入到这个有序序列中； 
(3) 将插入到有序序列中时，前 i-1 个数是有序的，将和 ~ 从后往前进行比较，确定要插入的位置。
function insertSort(arr) &#123;
    var len = arr.length;
    var preIndex,current;
    for (var i = 1; i &lt; len; i++) &#123;
        preIndex = i -1;
        current = arr[i];
        while(preIndex &gt;=0 &amp;&amp; arr[preIndex] &gt; current) &#123;
            arr[preIndex +1] = arr[preIndex];
            preIndex --;
        &#125;
        arr[preIndex +1] = current;
    &#125;
&#125;
</code></pre>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><pre><code>4.希尔排序，希尔排序也是一种插入排序
不同：希尔排序优先比较较远的元素，希尔排序的核心在于间隔序列的设定
对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素
分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对
各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是
有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，
当gap=1时，整个数列就是有序的。
function shellSort(arr) &#123;
    var len = arr.length;
    var temp,gap =1;
    while(gap &lt; len/3)&#123;
        gap = gap *3 +1;
    &#125;
    for (gap; gap&gt; 0; gap = Math.floor(gap/3)) &#123;
        for (var i = gap; i &lt; len; i++) &#123;
            temp = arr[i];
            for (var j = i - gap; j &gt;0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;
                arr[j+gap] = arr[j];
            &#125;
            arr[j+gap] = temp;
        &#125;
    &#125;
    return arr;
&#125;
</code></pre>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code>作为一种典型的分而治之思想的算法应用
将一个数组排序，可以先递归的将它分成两半分别排序，然后再将结果归并起来。
缺点：需要额外的空间
从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这
些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得
到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。
这样就得到了我们想要的排序结果
function mergeSort(arr) &#123;  //采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    var result = [];

    while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
&#125;
</code></pre>
<h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><pre><code>分而治之思想在排序算法。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。
先是把第一个挖出来，作为基值；然后先是从右向左，对比基值，如果如果小，那么放到坑里；然后在从左往右对比基值，如果大，那么放到坑里；当换完一轮了后，把基值放到坑里；然后在根据基值，分左右两组，递归排序；
通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比
另外一部分的所有数据都要小，继续对长度较短的序列进行同样的分割，最后到
达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故
减少了比较次数，降低了排序时间。
function quickSort(arr, left, right) &#123;
    var len = arr.length,
        partitionIndex,
        left = typeof left != &#39;number&#39; ? 0 : left,
        right = typeof right != &#39;number&#39; ? len - 1 : right;

    if (left &lt; right) &#123;
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    &#125;
    return arr;
&#125;

function partition(arr, left ,right) &#123;     //分区操作
    var pivot = left,                      //设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) &#123;
        if (arr[i] &lt; arr[pivot]) &#123;
            swap(arr, i, index);
            index++;
        &#125;        
    &#125;
    swap(arr, pivot, index - 1);
    return index-1;
&#125;

function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;
</code></pre>
<h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><pre><code>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列
堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大
值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将
剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执
行，便能得到一个有序序列了

var len;    //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) &#123;   //建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &amp;gt;= 0; i--) &#123;
        heapify(arr, i);
    &#125;
&#125;

function heapify(arr, i) &#123;     //堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;
        largest = left;
    &#125;

    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;
        largest = right;
    &#125;

    if (largest != i) &#123;
        swap(arr, i, largest);
        heapify(arr, largest);
    &#125;
&#125;

function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;

function heapSort(arr) &#123;
    buildMaxHeap(arr);

    for (var i = arr.length-1; i &gt; 0; i--) &#123;
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    &#125;
    return arr;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/09/M_Swift94Runtime%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/09/M_Swift94Runtime%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">理解Runtime</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 17:45:14" itemprop="dateCreated datePublished" datetime="2018-08-09T17:45:14+08:00">2018-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类结构体模型"><a href="#类结构体模型" class="headerlink" title="类结构体模型"></a>类结构体模型</h2><pre><code>// objc_object对象模型
struct objc_object &#123;
    private:
    isa_t isa;
    public:
    Class ISA();
    Class getIsa();
    // 省略其余方法
    ...
&#125;
// objc_class类模型
struct objc_class : objc_object &#123;
    Class isa  //所属类的指针
    Class super_class//指向父类的指针                                        
    const char *name //类名                                     
    long version // 版本                                 
    long info //供运行期使用的一些位标识。                             
    long instance_size //实例大小                                 
    struct objc_ivar_list *ivars//成员变量数组                      
    struct objc_method_list **methodLists//方法列表                  
    struct objc_cache *cache//指向最近使用的方法.用于方法调用的优化                            
    struct objc_protocol_list *protocols//协议的数组                     
&#125;
在objc_class结构体中定义了对象的method list，
protocal，ivar list等，表示对象的行为。
</code></pre>
<h3 id="为什么说类也是对象"><a href="#为什么说类也是对象" class="headerlink" title="为什么说类也是对象"></a>为什么说类也是对象</h3><pre><code>类被定义为objc_class结构体，objc_class结构体继承自
objc_objct,对象是用 objc_object 结构体表示的，所以类也
是对象。
oc中的类和元类也是一样，都是结构体构成的，由于类的结构体定义
继承自objc_object所以其也是一个对象，并且具有对象的isa特
征。
在应用程序中，类对象只会被创建一份。
</code></pre>
<h3 id="Meta-Class元类"><a href="#Meta-Class元类" class="headerlink" title="Meta Class元类"></a>Meta Class元类</h3><pre><code>isa指针指向Meta Class，因为Objc的类的本身也是一个
Object，为了处理这个关系，runtime就创造了Meta Class，
当给类发送[NSObject alloc]这样消息时，实际上是把这个
消息发给了Class Object
因为一个类是一个对象，它是元类(metaclass)的对象。
元类是关于类对象的描述，
就像类是普通实例对象的描述一样。实际上，元类的方法列表正
是#类方法#：该类对象响应的选择器。
</code></pre>
<h3 id="什么是isa指针"><a href="#什么是isa指针" class="headerlink" title="什么是isa指针"></a>什么是isa指针</h3><pre><code>每个对象都有一个标识对象类的isa实例变量。
运行时使用此指针来确定对象需要时的实际类。
1、 id类型是一个objc_object结构体的指针。
2、objc_object结构体包含一个Class 类型的变量isa。
3、 Class是objc_class结构体的指针。
</code></pre>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><pre><code>objc_msgSend第一个参数类型为id，大家对它都不陌生，
它是一个指向类实例的指针：
typedef struct objc_object *id;
那objc_object又是啥呢：
struct objc_object &#123; Class isa; &#125;;
objc_object结构体包含一个isa指针，根据isa指针就可以
顺藤摸瓜找到对象所属的类。
</code></pre>
<h3 id="为什么id类型可以指向OC中任意对象"><a href="#为什么id类型可以指向OC中任意对象" class="headerlink" title="为什么id类型可以指向OC中任意对象"></a>为什么id类型可以指向OC中任意对象</h3><pre><code>id类型被定义为指向对象的指针
NSObject只有一个Class对象isa，而objc_object也是只有一个Class对
象isa,也就是说id等价于NSObject*。所以id是一个一个比较灵活的对象指
针，并且是一个指向任何一个继承了Object（或者NSObject）类的对象
</code></pre>
<h3 id="为什么不能用isa判断一个类的继承关系"><a href="#为什么不能用isa判断一个类的继承关系" class="headerlink" title="为什么不能用isa判断一个类的继承关系"></a>为什么不能用isa判断一个类的继承关系</h3><pre><code>isa指针不总是指向实例对象所属的类，不能依靠它来确定
类型，而是应该用class方法来确定实例对象的类。
因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类
</code></pre>
<h2 id="类结构关系"><a href="#类结构关系" class="headerlink" title="类结构关系"></a>类结构关系</h2><pre><code>实例对象在运行时被表示成objc_object类型结构体，结构体内部
有个isa指针指向objc_class结构体。objc_class内部保存了类
的变量和方法列表以及其他一些信息，并且还有一个isa指针。这个
isa指针会指向meteClass(元类)，元类里保存了这个类的类方法
列表。
runtime中设计了meta class， 通过meta class来创建类对
象，所以类对象的isa指向对应的meta class。而meta class也
是一个对象，所有元类的isa都指向其根元类，根元类的isa指针指
向自己，通过这种设计，isa的整体结构形成了一个闭环。为了完整
性，其实元类里也有一个isa指针，这个isa指针，指向的是根元
类，根元类的isa指针指向自己
实例对象--(runtime)--&gt;objc_object--(isa)--
&gt;objc_class--(isa)--&gt;元类--isa--&gt;根元类--isa--&gt;自
己。
类和元类都有自己的继承体系，但它们都有共同的根父类
NSObject，而NSObject的父类指向nil。Root 
Class（Class）是NSObject类对象，而Root Class（Meta）
是NSObject的元类对象。对于像NSObject这样的类来说，它其实
代表的是一个类对象，本质上还是一个普通的实例对象，类对象的、
self指针应该指向的是这个类对象自身。
</code></pre>
<h3 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h3><pre><code>当我们调用某个类的方法时，如果这个类的方法列表里没有该方法，
则会去找这个类的父类的方法列表。这种机制就是通过
objc_class的第二个变量super_class指针实现的。
并且这种继承关系会扩展到元类。
</code></pre>
<h2 id="内存布局："><a href="#内存布局：" class="headerlink" title="内存布局："></a>内存布局：</h2><pre><code>类的本质时结构体，在结构体中包含一些成员变量，
如method list，ivar list等，这些都是结构体的一部分，
method protocol，property的实现这些都可以放到类中，
所有对象调用同一份即可，但对象的成员变量不可以放在一起，
因为每个对象的成员变量值都是不同的。
</code></pre>
<h3 id="为什么不能添加变量"><a href="#为什么不能添加变量" class="headerlink" title="为什么不能添加变量"></a>为什么不能添加变量</h3><pre><code>创建实例对象时，会根据其对应的Class分配内存，内存构成
是ivar+isa_t.并且实例变量不只是包含当前class的ivars，
也会包含其继承链的ivars，ivars的内存布局在编译时就已经
决定，运行时需要根据ivars内存布局创建对象，所以runtime
不能动态修改ivars，会破坏已有的内存布局。
</code></pre>
<h3 id="不能向编译后得到的类中增加实例变量"><a href="#不能向编译后得到的类中增加实例变量" class="headerlink" title="不能向编译后得到的类中增加实例变量"></a>不能向编译后得到的类中增加实例变量</h3><pre><code>因为编译后的类已经注册在runtime中，类结构体中的
objc_ivar_list实例变量的链表和instance_size
实例变量的内存大小已经确定，同时runtime会调用
class_setIvarLayout或class_WeakIvarLayout
来处理strong weak引用，所以不能向存在的类中添加实例变量
运行时创建的类时可以添加实例变量，调用class_addIvar函数
，但是得在调用objc_allocateClassPari之后，
objc_registerClassPair之前，原因同上。
</code></pre>
<h3 id="系统如何解决新增实例冲突"><a href="#系统如何解决新增实例冲突" class="headerlink" title="系统如何解决新增实例冲突"></a>系统如何解决新增实例冲突</h3><pre><code>类的结构体在编译时都是固定的，如果想修改类的结构需要重新编译
原来UIViewController的结构体中增加了
childViewControllers属性，这个时候和子类的内存偏移就
发生了冲突，只不过，runtime有检测内存地址冲突的机制，
在类生成实例变量时，会判断实例变量是否有地址冲突，
如果发生冲突则调整对象的地址偏移。
</code></pre>
<h2 id="ivars-methodLists"><a href="#ivars-methodLists" class="headerlink" title="ivars methodLists"></a>ivars methodLists</h2><pre><code>在objc_class结构体中：ivars是objc_ivar_list指针；
methodLists是指向objc_method_list指针的指针。
也就是说可以动态修改 *methodLists 的值来添加成员方法，
这也是Category实现的原理.
</code></pre>
<h2 id="IMP："><a href="#IMP：" class="headerlink" title="IMP："></a>IMP：</h2><pre><code>//结构
typedef void (*IMP)(void /* id, SEL, ... */ );
在runtime中IMP本质上就是一个函数指针
在IMP中有两个默认的参数id和SEL，id也就是方法的self
这和objc_msgSend()函数传递的参数一样；
Runtime提供很多对于IMP的操作API，我们很多Runtime函数都
是IMP操作
</code></pre>
<h2 id="Method："><a href="#Method：" class="headerlink" title="Method："></a>Method：</h2><pre><code>//结构
typedef struct method_t *Method;
struct method_t &#123; 
    SEL name;
    const char *types;
    IMP imp; 
&#125;;
用来表示方法，其中包含SEL和IMP
</code></pre>
<h2 id="Property："><a href="#Property：" class="headerlink" title="Property："></a>Property：</h2><pre><code>在runtime中定义了属性的结构体，用来表示对象中定义的属性。
@property修饰符用来修饰属性，修饰后的属性为
objc_property_t类型，其本质是property_t结构体
    struct property_t &#123;
    const char *name; 
    const char *attributes;
&#125;;
</code></pre>
<h2 id="ivar读写"><a href="#ivar读写" class="headerlink" title="ivar读写"></a>ivar读写</h2><pre><code>实例变量的isa_t指针会指向其所属的类，对象中并不会包含
method，property，protocol，ivar等信息，这些信息在编
译时都保存在只读结构体class_ro_t中。在class_ro_t中ivar
时const只读的，在image load时copy到class_rw_t中时，
是不会copy ivars的，并且class_rw_t中并没有定义ivars
的字段。
在防伪某个成员变量时，直接通过isa_t找到对应的objc_class
并通过其class_ro_t的ivar list做地址偏移，查找对应的对象
内存，正是由于这种方式，所以对象的内存地址是固定不可改变的。
</code></pre>
<h2 id="方法传参："><a href="#方法传参：" class="headerlink" title="方法传参："></a>方法传参：</h2><pre><code>当调用实例变量的方法时，会通过objc_msgSend（）发起调用。
调用是会传入self和SEL，函数内部通过isa在类的内部查找方法
列表对应的IMP，传入对应的参数并发起调用，如果调用的方法涉
及到当前对象的成员变量的访问，这是就是通过objc_msgSend()
内部，通过类的ivar list判断地址偏移，取出ivar并传入调
用的IMP中的。
调用super的方式时则调用objc_msgSendSuper()函数实现
</code></pre>
<h2 id="isa-t"><a href="#isa-t" class="headerlink" title="isa_t:"></a>isa_t:</h2><pre><code>对于对象指针也是一样，在oc1.0时，isa时一个真的指针，
指向一堆区的地址，而在oc2.0时代，一个指针长度时八个字节
也就是64位，在64位中直接存储着对象的信息。当查找对象所属
的类时，直接在isa指针中进行位运算即可，而且由于在栈区进
行操作，查找速度非常快。
例如，isa_t本质时一个结构体，如果创建结构体再用指针指向这
个结构体，内存占用是很大的，但是Tagged Pointer特性中，
直接把结构体的值都存储到指针中，这样就相当节省内存了。
苹果不允许直接访问isa指针，和Tagged Pointer也是有关
系的，因为tagged Pointer的情况下，isa并不是一个指针指
向另一块内存区，而是直接表示对象的值，所以通过直接访问
isa获取到的信息是错误的。
</code></pre>
<h2 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h2><pre><code>它是selector在Objc中的表示类型（Swift中是
Selector类）。selector是方法选择器，
可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:
typedef struct objc_selector *SEL;
从源码中看其实是一个const *的常量字符串，只代表名字而已
其实它就是个映射到方法的C字符串，你可以用 Objc 
编译器命令@selector()或者 Runtime 系统的
sel_registerName函数来获得一个SEL类型的方法选择器。
常见来两个相同的类，并定规两个相同的方法，通过@selector
获取SEL并打印，我们发现SEL都是同一个对象，地址都是相同的，
不同类的相同SEL是同一个对象。
在runtime中维护一个SEL列表，这个表不按照类存储，
只要相同SEL就算作一个，并存储到表中。
</code></pre>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><pre><code>协议存储在protocol_t结构体中，而protocol_t继承objc_object，所以也就具备对象特征
struct protocol_t : objc_object &#123;
    const char *mangledName;
    struct protocol_list_t *protocols; 
    method_list_t *instanceMethods; 
    method_list_t *classMethods;
    method_list_t *optionalInstanceMethods;
    method_list_t *optionalClassMethods;
    property_list_t *instanceProperties;
    uint32_t size; // sizeof(protocol_t) 
    uint32_t flags;
    const char **_extendedMethodTypes; 
    const char *_demangledName; 
    property_list_t *_classProperties;
&#125;;
既然具备了对象的特征，那么也有isa指针，在Protocol中所有的isa都指向同一个类Protocol。Protocol类并没有元类
</code></pre>
<h2 id="runtime如何实现weak变量的自动置nil"><a href="#runtime如何实现weak变量的自动置nil" class="headerlink" title="runtime如何实现weak变量的自动置nil"></a>runtime如何实现weak变量的自动置nil</h2><pre><code>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表
中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时
候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 
在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil
</code></pre>
<h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2><pre><code>在runtime中所有类都存在一个哈希表中，在table的buckets中存储
1. 加载所有类到类的gdb_objc_realized_classes表中
2. 对所有类做重映射
3. 将所有SEL都注册到namedSelectors表中
4. 修复函数指针遗留
5. 将所有Protocol添加到protocol_map表中
6. 将所有Protocol重映射
7. 初始化所有非懒加载的类，进行rw，ro操作 
8. 便利所有懒加载类，执行初始化
9. 处理所有Category包括Class和MetaClass
10. 初始化所有未初始化类
</code></pre>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><pre><code>Load方法是在类加载的时候调用的，是在类加载到运行时的时候调用的，
在mian函数之前，由系统调用，所以比较适合在load中调用钩子方法。只调用
一次，注意load方法是直接调用的，并没有走运行时的objc_msgSend函数
load方法顺序应该是，父类-&gt;子类-&gt;分类
</code></pre>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><pre><code>initialize是由Runtime调用的，与load不同的是，initialize方法是第
一次调用类所属方法时才会调用，如果当前类方法永远不被调用的话
initialize有可能永远不会执行。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/09/M_Swift101%E5%B8%B8%E8%A7%81UI%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/09/M_Swift101%E5%B8%B8%E8%A7%81UI%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">常见UI问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 16:50:19" itemprop="dateCreated datePublished" datetime="2018-08-09T16:50:19+08:00">2018-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 10:29:04" itemprop="dateModified" datetime="2022-04-29T10:29:04+08:00">2022-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="tableView卡顿"><a href="#tableView卡顿" class="headerlink" title="tableView卡顿"></a>tableView卡顿</h2><pre><code>1.最常⽤用的就是cell的重⽤用 
2.避免cell的重新布局
3.提前计算并缓存cell的属性及内容
4.减少cell中控件的数量量
5.不要使⽤用ClearColor，⽆无背景⾊色，透明度也不不要设置为0
6.使⽤局部更新
7.加载⽹络数据，下载图⽚，使用异步加载，并缓存
8.少使⽤用addView 给cell动态添加view
9.按需加载cell，cell滚动很快时，只加载范围内的cell
10.不要实现无用的代理理⽅方法，tableView只遵守两个协议
11.缓存⾏⾼
12.不要做多余的绘制工作。
13.预渲染图像。
14.使⽤用正确的数据结构来存储数据。
</code></pre>
<h2 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h2><pre><code>一、首页启动速度   
    启动过程中做的事情越少越好、不在UI线程上作耗时的
    操作、在合适的时机开始后台任务、尽量减小包的大小
二、页面浏览速度
    json的处理、数据压缩、内容缓存、算法的优化
三、操作流畅度优化：
    见tableVIew的优化
四、数据库的优化：
    数据库设计上面的重构、查询语句的优化、分库分表
五、服务器端和客户端的交互优化：
    客户端尽量减少请求、服务端尽量做多的逻辑
    处理、通信协议的优化
六、非技术性能优化
    产品逻辑性、代码规范、界面交互规范等
</code></pre>
<h2 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h2><pre><code>1.使用instrument
2.在程序运行期间能及时获取卡顿信息
监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事
件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,
就需要从NSRunLoop来入手.其中核心方法CFRunLoopRun简化后的主要逻辑
大概是这样的:
int32_t __CFRunLoopRun()
&#123;
    //通知即将进入runloop
    __CFRunLoopDoObservers(KCFRunLoopEntry);
    do
    &#123;
    // 通知将要处理timer和source
    __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);
    __CFRunLoopDoObservers(kCFRunLoopBeforeSources);

    __CFRunLoopDoBlocks();  //处理非延迟的主线程调用
    __CFRunLoopDoSource0(); //处理UIEvent事件        
    //GCD dispatch main queue
    CheckIfExistMessagesInMainDispatchQueue();
    // 即将进入休眠
    __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);
    // 等待内核mach_msg事件
    mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();
    // Zzz...
    // 从等待中醒来
    __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);
    // 处理因timer的唤醒
    if (wakeUpPort == timerPort)
    __CFRunLoopDoTimers();
    // 处理异步方法唤醒,如dispatch_async
    else if (wakeUpPort == mainDispatchQueuePort)
    __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()
    // UI刷新,动画显示
    else
    __CFRunLoopDoSource1();
    // 再次确保是否有同步的方法需要调用
    __CFRunLoopDoBlocks();
    &#125; while (!stop &amp;&amp; !timeout);
    //通知即将退出runloop
    __CFRunLoopDoObservers(CFRunLoopExit);
&#125;
不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和
kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,
也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.
</code></pre>
<h3 id="量化卡顿的程度"><a href="#量化卡顿的程度" class="headerlink" title="量化卡顿的程度"></a>量化卡顿的程度</h3><pre><code>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它
可以实时获得这些状态值的变化,具体的使用如下:
static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)
&#123;
MyClass *object = (__bridge MyClass*)info;
object-&gt;activity = activity;
&#125;

- (void)registerObserver
&#123;
CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;
    CFRunLoopObserverRef observer = 
    CFRunLoopObserverCreate(kCFAllocatorDefault,
    kCFRunLoopAllActivities,
    YES,
    0,
    &amp;runLoopObserverCallBack,
    &amp;context);
    CFRunLoopAddObserver(CFRunLoopGetMain(), 
    observer, kCFRunLoopCommonModes);
&#125;
只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某
个阀值,便能揪出这些性能杀手.

为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,
所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连
续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上
面两个方法添加计算的逻辑如下:
static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)
&#123;
MyClass *object = (__bridge MyClass*)info;

// 记录状态值
object-&gt;activity = activity;

// 发送信号
dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;
dispatch_semaphore_signal(semaphore);
&#125;

- (void)registerObserver
&#123;
CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;
CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,
kCFRunLoopAllActivities,
YES,
0,
&amp;runLoopObserverCallBack,
&amp;context);
CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);

// 创建信号
semaphore = dispatch_semaphore_create(0);

// 在子线程监控时长
dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;
while (YES)
&#123;
// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)
long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));
if (st != 0)
&#123;
if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)
&#123;
if (++timeoutCount &lt; 5)
continue;

NSLog(@&quot;好像有点儿卡哦&quot;);
&#125;
&#125;
timeoutCount = 0;
&#125;
&#125;);
&#125;
</code></pre>
<h3 id="记录卡顿的函数调用"><a href="#记录卡顿的函数调用" class="headerlink" title="记录卡顿的函数调用"></a>记录卡顿的函数调用</h3><pre><code>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个
第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用
于实时获取各线程的调用堆栈,使用示例如下:
PLCrashReporterConfig *config = [[PLCrashReporterConfig
alloc]initWithSignalHandlerType:
PLCrashReporterSignalHandlerTypeBSD
symbolicationStrategy:
PLCrashReporterSymbolicationStrategyAll];
PLCrashReporter *crashReporter = 
[[PLCrashReporter alloc] initWithConfiguration:config];

NSData *data = [crashReporter generateLiveReport];
PLCrashReport *reporter = [[PLCrashReport alloc]
initWithData:data error:NULL];
NSString *report = [PLCrashReportTextFormatter
stringValueForCrashReport:reporter
withTextFormat:PLCrashReportTextFormatiOS];

NSLog(@&quot;------------\n%@\n------------&quot;, report);
当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到
服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至
此这个实时卡顿监控就大功告成了!
</code></pre>
<h2 id="什么是掉帧"><a href="#什么是掉帧" class="headerlink" title="什么是掉帧"></a>什么是掉帧</h2><pre><code>掉帧一般指由于硬件不足以负荷显示器画面动态显示刷新的频率，从而帧率过低
所造成的画面出现停滞（或短时间或长时间）现象。掉帧在游戏中就是玩游戏过
程中，出现卡这种情况，图像未及时刷新造成，画面粘滞。
帧数就是在1秒钟时间里传输的图片的量，也可以理解为图形处理器每秒钟能够
刷新几次，通常用fps（Frames Per Second）表示。每一帧都是静止的图
象，快速连续地显示帧便形成了运动的假象。高的帧率可以得到更流畅、更逼真
的动画。每秒钟帧数 (fps) 愈多，所显示的动作就会愈流畅。
</code></pre>
<h2 id="APP启动流出"><a href="#APP启动流出" class="headerlink" title="APP启动流出"></a>APP启动流出</h2><pre><code>1.打开程序
2.执行main函数
3.执行UIApplicationMain函数
4.初始化UIApplication（创建和设置代理，开启RunLoop事件循环）
5.监听事件，执行AppDelegate对应函数
    程序加载完成
    程序获取焦点
    程序进入后台
    程序失去焦点
    程序从后台进入前台
    内存警告，可能要终止程序
    程序即将结束
6.结束程序
</code></pre>
<h2 id="封装SDK需要注意哪些"><a href="#封装SDK需要注意哪些" class="headerlink" title="封装SDK需要注意哪些"></a>封装SDK需要注意哪些</h2><pre><code>1.类名、宏定义、枚举、通知、类别等命名时加静态库统一特殊前缀，以避免命名冲突。
2.类别中方法名也需要加特殊前缀，以避免方法覆盖导致不必要麻烦。
3.对于项目中的c、c++中的方法，需要加前缀
4.对于开发静态库时引入的开源库，若体量过大，可外部引用，提供给接入方时
加以说明，体量小的可以对类名及类中所用枚举、通知等加前缀使用。
5.特别需要注意的是在同一个类中多个interface的情况，加前缀时一定要检
查所有的interface，避免遗漏
6.由于一些接入方引入静态库时，对app的体积有严格的控制，所以在开发静态
库时，要尽量精简代码，引入开源库时，可剔除一些不必要的部分，如能用系统
提供的方法实现的功能，尽量不去引入大型第三方库，不然打包出来的.a库可能体积增加很多。
    
</code></pre>
<h2 id="使用drawRect有什么影响"><a href="#使用drawRect有什么影响" class="headerlink" title="使用drawRect有什么影响"></a>使用drawRect有什么影响</h2><pre><code>drawRect方法依赖Core Graphics框架来进行自定义的绘制，但这种方法主
要的缺点就是它处理touch事件的方式：每次按钮被点击后，都会用
setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执
行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/09/M_Swift89Runtime%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/09/M_Swift89Runtime%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Runtime</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 15:42:35" itemprop="dateCreated datePublished" datetime="2018-08-09T15:42:35+08:00">2018-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><pre><code>Objective-C 从三种不同的层级上与 Runtime 系统进行交互，
分别是通过 Objective-C 源代码，
通过 Foundation 框架的NSObject类定义的方法，
通过对 runtime 函数的直接调用。
RunTime简称运行时,就是系统在运行的时候的一些机制，
其中最主要的是消息机制。
每一个oc的方法，底层必然有一个与之对应的runtime方法。
</code></pre>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="获取属性列表"><a href="#获取属性列表" class="headerlink" title="获取属性列表"></a>获取属性列表</h3><pre><code>objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);
for (unsigned int i=0; i&lt;count; i++) &#123;
const char *propertyName = property_getName(propertyList[i]);
NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);
&#125;
</code></pre>
<h3 id="获取方法列表"><a href="#获取方法列表" class="headerlink" title="获取方法列表"></a>获取方法列表</h3><pre><code>Method *methodList = class_copyMethodList([self class], &amp;count);
for (unsigned int i; i&lt;count; i++) &#123;
Method method = methodList[i];
NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));
&#125;
</code></pre>
<h3 id="获取成员变量列表"><a href="#获取成员变量列表" class="headerlink" title="获取成员变量列表"></a>获取成员变量列表</h3><pre><code>Ivar *ivarList = class_copyIvarList([self class], &amp;count);
for (unsigned int i; i&lt;count; i++) &#123;
Ivar myIvar = ivarList[i];
const char *ivarName = ivar_getName(myIvar);
NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);
&#125;
</code></pre>
<h3 id="获取协议列表"><a href="#获取协议列表" class="headerlink" title="获取协议列表"></a>获取协议列表</h3><pre><code>__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);
for (unsigned int i; i&lt;count; i++) &#123;
Protocol *myProtocal = protocolList[i];
const char *protocolName = protocol_getName(myProtocal);
NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);
&#125;
</code></pre>
<h3 id="获得类方法"><a href="#获得类方法" class="headerlink" title="获得类方法"></a>获得类方法</h3><pre><code>Class PersonClass = object_getClass([Person class]);
SEL oriSEL = @selector(test1);
Method oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);
</code></pre>
<h3 id="获取实例方法"><a href="#获取实例方法" class="headerlink" title="获取实例方法"></a>获取实例方法</h3><pre><code>Class PersonClass = object_getClass([xiaoming class]);
SEL oriSEL = @selector(test2);
Method cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);
</code></pre>
<h3 id="添加一个实例变量"><a href="#添加一个实例变量" class="headerlink" title="添加一个实例变量"></a>添加一个实例变量</h3><pre><code>/*
参数一、类名
参数二、属性名称
参数三、开辟字节长度
参数四、对其方式
参数五、参数类型 “@” 官方解释 An object (whether statically typed or typed id) （对象 静态类型或者id类型） 具体类型可参照官方文档
return: BOOL 是否添加成功
*/
BOOL isSuccess = class_addIvar(MyClass, &quot;addIvar&quot;, sizeof(NSString *), 0, &quot;@&quot;);
</code></pre>
<h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><pre><code>/*
参数一、类名
参数二、SEL 添加的方法名字
参数三、IMP指针 (IMP就是Implementation的缩写，它是指向一个方法实现的指针，每一个方法都有一个对应的IMP)
参数四、其中types参数为&quot;i@:@“，按顺序分别表示：具体类型可参照官方文档
i 返回值类型int，若是v则表示void
@ 参数id(self)
: SEL(_cmd)
@ id(str)
V@:表示返回值是void 带有SEL参数 （An object (whether statically typed or typed id)）
*/
BOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));
</code></pre>
<h3 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h3><pre><code>class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));
</code></pre>
<h3 id="交换方法"><a href="#交换方法" class="headerlink" title="交换方法"></a>交换方法</h3><pre><code>method_exchangeImplementations(oriMethod, cusMethod);
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/22/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/39/">39</a><a class="extend next" rel="next" href="/page/24/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">390</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
