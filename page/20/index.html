<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/20/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/16/M_Swift112Xcode%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/16/M_Swift112Xcode%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">Xcode相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-16 19:38:54" itemprop="dateCreated datePublished" datetime="2018-08-16T19:38:54+08:00">2018-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="pod-install与pod-update的区别"><a href="#pod-install与pod-update的区别" class="headerlink" title="pod install与pod update的区别"></a>pod install与pod update的区别</h2><pre><code>pod install一般是你第一次想要为项目添加pod的时候使用的，它同样也使
用在你为Podfile文件添加或移除pod库的时候。
每次pod install命令运行的时候，pod install会为每一个它安装的pod
库在Podfile.lock文件中写入其版本号。Podfile.lock文件追踪每一个安
装的pod库的版本号，并锁定这些版本号。
当你运行pod install是，它将只解决不在Podfile.lock中的pod库依赖关
系 
对于在Podfile.lock文件中的pod库，pod install会只下载
Podfile.lock文件中指定的版本，而不会去检查这个库是否有更新的版本。
对于不在Podfile.lock文件中的pod库，pod install会搜索这个pod库在
Podfile文件中指定的版本
pod update
当你运行了pod update PODNAME命令，CocoaPods会在不考虑
Podfile.lock中版本的情况下试着去查找PODNAME的最新版本。pod 
update PODNAME命令会将相应的pod更新到最新的版本（新版本仍然遵守你
在Podfile中做的限制）
用法
通过pod update PODNAME,你可以只更新某个特定的pod库（检查是否存在
新版本并更新相应的pod库）。相反，pod install则不会去更新已安装的
pod库。
当你向Podfile中添加了pod，你应该使用pod install而不是pod update
去在不更新已安装的pod库的版本基础上安装新添加的pod库。
当你想过更新某个特定pod库（或所有的库）的版本时你只需要使用pod 
update
</code></pre>
<h2 id="pod-lock产生冲突的原因"><a href="#pod-lock产生冲突的原因" class="headerlink" title="pod.lock产生冲突的原因"></a>pod.lock产生冲突的原因</h2><pre><code>Podfile.lock 不一致的原因：
Podfile.lock和Manifest.lock：
项目中集成 cocoapods 的时候，运行 pod install 后，项目根目录中会
生成Podfile.lock，而Pods目录中会有Manifest.lock。
Xcode 编译项目的时候，会执行 Build Phases 中的[CP] Check Pods 
Manifest.lock 脚本，这个脚本会比对Podfile.lock和
Manifest.lock，如果两个文件不相同就会报错。
Podfile.lock是什么：
Podfile.lock 文件主要包含三个块：PODS、DEPENDENCIES、SPEC 
CHECKSUMS，用来记录每个pod的版本号、依赖的其他库和每个库对应的
podspec.json文件的 checksum(SHA-1算法)。通过这些信息可以确保多
人协作的时候，大家使用的是相同版本的第三方库。
删掉Pod.lock文件，然后重新执行pod install --verbose --no-
repo-update
</code></pre>
<h2 id="CocoaPods原理和说明"><a href="#CocoaPods原理和说明" class="headerlink" title="CocoaPods原理和说明"></a>CocoaPods原理和说明</h2><pre><code>1、第三方库会被编译成.a静态库供我们真正的工程使用。    
CocoaPods会将所有的第三方库以target的方式组成一个名为Pods的工程，
该工程就放在刚才新生成的Pods目录下。整个第三方库工程会生成一个名称为
libPods.a的静态库提供给我们自己的CocoaPodsTest工程使用。
对于资源文件，CocoaPods提供了一个名为Pods-resources.sh的bash脚
本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到
目标目录中。
2、我们的工程和第三方库所在的工程会由一个新生成的workspace管理
为了方便我们直观的管理工程和第三方库，CocoaPodsTest工程和Pods工程
会被以workspace的形式组织和管理，也就是我们刚才看到的
CocoaPodsTest.xcworkspace文件。
3、原来的工程设置已经被更改了，这时候我们直接打开原来的工程文件去编译
就会报错，只能使用新生成的workspace来进行项目管理。
4、CocoaPods通过一个名为Pods.xcconfig的文件来在编译时设置所有的依
赖和参数。
</code></pre>
<h2 id="dSYM-文件"><a href="#dSYM-文件" class="headerlink" title="dSYM 文件"></a>dSYM 文件</h2><pre><code>什么是 dSYM 文件    
Xcode编译项目后，我们会看到一个同名的 dSYM 文件，dSYM 是保存 16 
进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文
件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件，位于 /
Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives 目录下，对于
每一个发布版本我们都很有必要保存对应的 Archives 文件 
( AUTOMATICALLY SAVE THE DSYM FILES 这篇文章介绍了通过脚本每次
编译后都自动保存 dSYM 文件)。
dSYM 文件有什么作用
当我们软件 release 模式打包或上线后，不会像我们在 Xcode 中那样直观
的看到用崩溃的错误，这个时候我们就需要分析 crash report 文件了，
iOS 设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 Xcode 
的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件，
这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数
名和文件名。大前提是我们需要有软件版本对应的 dSYM 文件，这也是为什么
我们很有必要保存每个发布版本的 Archives 文件了。
如何将文件一一对应
每一个 xx.app 和 xx.app.dSYM 文件都有对应的 UUID，crash 文件也
有自己的 UUID，只要这三个文件的 UUID 一致，我们就可以通过他们解析出
正确的错误函数信息了。
</code></pre>
<h2 id="Git和SVN"><a href="#Git和SVN" class="headerlink" title="Git和SVN"></a>Git和SVN</h2><pre><code>1. Git是分布式的，SVN是集中式的，好处是跟其他同事不会有太多的冲突，
自己写的代码放在自己电脑上，一段时间后再提交、合并，也可以不用联网在本
地提交；
2. Git下载下来后，在本地不必联网就可以看到所有的log，很方便学习，
SVN却需要联网；
3. Git鼓励分Branch，而SVN，说实话，我用Branch的次数还挺少的，SVN
自带的Branch merge我还真没用过，有merge时用的是Beyond Compare工
具合并后再Commit的；
4. Tortoise也有出Git版本，真是好东西；
5. SVN在Commit前，我们都建议是先Update一下，跟本地的代码编译没问
题，并确保开发的功能正常后再提交，这样其实挺麻烦的，有好几次同事没有先
Updata，就
Commit了，发生了一些错误，耽误了大家时间，Git可能这种情况会少些。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/16/M_Swift90%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/16/M_Swift90%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">算法之数学计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-16 19:34:20" itemprop="dateCreated datePublished" datetime="2018-08-16T19:34:20+08:00">2018-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><pre><code>function binarySeach( arr,val,leftIndex,rightIndex )&#123;
    //找到中间的值
    var midIndex = Math.floor((leftIndex+rightIndex)/2);
    var midval=arr[midIndex];
    //console.log(midval );
    if( leftIndex &gt; rightIndex )&#123;
        console.log(&quot;前一位是&quot;,midval );
        console.log(&quot;下标：&quot;,midIndex);
        return ;
    &#125;
    if( midval &gt; val )&#123;
        binarySeach(arr,val,leftIndex,midIndex-1);
    &#125;else if(midval &lt; val)&#123;
        binarySeach(arr,val,midIndex+1,rightIndex);
    &#125;else&#123;
        console.log(&quot;找到了,下标为:&quot;+midIndex);
        return;
    &#125;
&#125;
var arr=[1,3,12,21,24,44,54,67];
binarySeach(arr,25,0,arr.length-1);
</code></pre>
<h2 id="求两个数的最大公约数，递归"><a href="#求两个数的最大公约数，递归" class="headerlink" title="求两个数的最大公约数，递归"></a>求两个数的最大公约数，递归</h2><pre><code>function Gcd(var a, var b)
 &#123;
      if(a&lt;=0||b&lt;=0)
          return -1;
     else if(a&gt;b)
         return Gcd(a-b, b);
     else if(a&lt;b)
         return Gcd(a, b-a);
     else
         return a;
 &#125;
// 最小公倍数 两个整数的乘积 / 最大公约数
// a* b/gcd(a,b)
</code></pre>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><pre><code>function Fibonacci(int n) &#123;
    if(n &lt; 0)&#123;
        return 0;
    &#125;
    if(n == 0)&#123;
        return 0;
    &#125;else if(n == 1)&#123;
        return 1;
    &#125;else return Fibonacci(n-1)+ Fibonacci(n-2);
&#125;
</code></pre>
<h2 id="累加求和"><a href="#累加求和" class="headerlink" title="累加求和"></a>累加求和</h2><pre><code>int sum = 0;//定义初始化总和
for(int i=1;i&lt;=100;i++)&#123;//从1开始循环到100
sum=sum+i;//加上当前序号
&#125;
System.out.println(sum);//在控制台中打印出来
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/15/M_Swift98%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/15/M_Swift98%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-15 10:50:36" itemprop="dateCreated datePublished" datetime="2018-08-15T10:50:36+08:00">2018-08-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简述一下OC的内存管理方式"><a href="#简述一下OC的内存管理方式" class="headerlink" title="简述一下OC的内存管理方式"></a>简述一下OC的内存管理方式</h2><pre><code>包括alloc，retain，copy，release，autorelease，
delalloc这些方法理解
OC中每个对象都有一个与之对应的整数，叫“引用计数器”，
当一个对象在创建之后它的引用计数器值加1，当调用这个对象的
alloc、retain、new、copy方法之后引用计数器值自动在原
来的基础上加1，当调用这个对象的release方法之后它的引用计
数器值减1，如果一个对象的引用计数器值为0，则系统会自动
调用这个对象的dealloc方法来销毁这个对象。
在alloc的时候调用了allocWithZone分配了内存
alloc、retain、new、copy方法之后引用计数器值自
动在原来的基础上加1
</code></pre>
<h2 id="用MRC写一个setter方法"><a href="#用MRC写一个setter方法" class="headerlink" title="用MRC写一个setter方法"></a>用MRC写一个setter方法</h2><pre><code>- (void)setName:(NSString *)name &#123;
    if(_name != name) &#123;
        [name retain];
        [_name relrase];
        _name = name;
    &#125;
&#125;
</code></pre>
<h2 id="描述autorelease对象释放时机，"><a href="#描述autorelease对象释放时机，" class="headerlink" title="描述autorelease对象释放时机，"></a>描述autorelease对象释放时机，</h2><pre><code>在没有手加Autorelease Pool的情况下，Autorelease对象
是在当前的runloop迭代结束时释放的，而它能够释放的原因是
系统在每个runloop迭代中都加入了自动释放池Push和Pop
</code></pre>
<h2 id="简述autorelrasePool的工作机制"><a href="#简述autorelrasePool的工作机制" class="headerlink" title="简述autorelrasePool的工作机制"></a>简述autorelrasePool的工作机制</h2><pre><code>每一个线程创建的时候就会有一个autorelease pool的创建，
并且在线程退出的时候，清空整个autorelease pool。
（ps:如果在子线程中设置一个循环，autorelease对象确实无
法释放）所以子线程的autorelease对象，
要么在子线程中设置runloop清楚
RutoreleasePoolPage
&#123;
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage *const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
&#125;
AutoreleasePool并没有单独的结构，而是由若干个
AutoreleasePoolPage以双向链表的形式组合而成（
分别对应结构中的parent指针和child指针）
AutoreleasePool是按线程一一对应的
（结构中的thread指针指向当前线程）
AutoreleasePoolPage每个对象会开辟4096字节内存
（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，
剩下的空间全部用来储存autorelease对象的地址
上面的id *next指针作为游标指向栈顶最新add进来
的autorelease对象的下一个位置
一个AutoreleasePoolPage的空间被占满时，
会新建一个AutoreleasePoolPage对象，连接链表，
后来的autorelease对象在新的page加入
runtime 黑魔法之Thread Local Storage
Thread Local Storage（TLS）线程局部存储，
目的很简单，将一块内存作为某个线程专有的存储，
以key-value的形式进行读写，比如在非arm架构下，
使用pthread提供的方法实现：
在返回值身上调用objc_autoreleaseReturnValue方法时，
runtime将这个返回值object储存在TLS中，然后直接返回这
个object（不调用autorelease）；同时，在外部接收这个返
回值的objc_retainAutoreleasedReturnValue里，发
现TLS中正好存了这个对象，那么直接返回这个object
（不调用retain）。
于是乎，调用方和被调方利用TLS做中转，
很有默契的免去了对返回值的内存管理。
于是问题又来了，假如被调方和主调方只有一边是ARC
环境编译的该咋办？（比如我们在ARC环境下用了非
ARC编译的第三方库，或者反之）
只能动用更高级的黑魔法。
黑魔法之__builtin_return_address
这个内建函数原型是char *__builtin_return_address
(int level)，作用是得到函数的返回地址，参数表示层数，
如__builtin_return_address(0)表示当前函数体返回地址
，传1是调用这个函数的外层函数的返回值地址，以此类推。
如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对
于不同情况做不同的处理
</code></pre>
<h2 id="在一个类中retaion一个NSTimer类型的成员变量会有什么问题吗？请简述问题产生的根本原因"><a href="#在一个类中retaion一个NSTimer类型的成员变量会有什么问题吗？请简述问题产生的根本原因" class="headerlink" title="在一个类中retaion一个NSTimer类型的成员变量会有什么问题吗？请简述问题产生的根本原因"></a>在一个类中retaion一个NSTimer类型的成员变量会有什么问题吗？请简述问题产生的根本原因</h2><pre><code>类有一个成员变量_timer，给_timer设置的target为这个类本、
身。这样类保留_timer，_timer又保留了这个类，就会出现循环
引用的问题，最后导致类无法正确释放。

解决这个问题的方式也很简单，当类的使用者能够确定不需要使用这
个计时器时，就调用
[_timer invalidate];
_timer = nil;
</code></pre>
<h2 id="assgin和weak区别"><a href="#assgin和weak区别" class="headerlink" title="assgin和weak区别"></a>assgin和weak区别</h2><h3 id="修饰变量类型的区别"><a href="#修饰变量类型的区别" class="headerlink" title="修饰变量类型的区别"></a>修饰变量类型的区别</h3><pre><code>weak 只可以修饰对象。如果修饰基本数据类型，编译器会报
错-“Property with ‘weak’ attribute must be of 
object type”。
assign 可修饰对象，和基本数据类型。当需要修饰对象类型时，
MRC时代使用unsafe_unretained。当然，
unsafe_unretained也可能产生野指针，所以它名字
是&quot;unsafe_”。
</code></pre>
<h3 id="是否产生野指针的区别"><a href="#是否产生野指针的区别" class="headerlink" title="是否产生野指针的区别"></a>是否产生野指针的区别</h3><pre><code>weak 不会产生野指针问题。因为weak修饰的对象释放后（引用计
数器值为0），指针会自动被置nil，之后再向该对象发消息也不会
崩溃。 weak是安全的。
assign 如果修饰对象，会产生野指针问题；如果修饰基本数据类
型则是安全的。修饰的对象释放后，指针不会自动被置空，此时向对
象发消息会崩溃。
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>assign 适用于基本数据类型如int,float,struct等值类型，不
适用于引用类型。因为值类型会被放入栈中，遵循先进后出原则，由
系统负责管理栈内存。而引用类型会被放入堆中，需要我们自己手动
管理内存或通过ARC管理。
weak 适用于delegate和block等引用类型，不会导致野指针问
题，也不会循环引用，非常安全。
</code></pre>
<h2 id="weak实现原理"><a href="#weak实现原理" class="headerlink" title="weak实现原理"></a>weak实现原理</h2><pre><code>Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak
表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的
地址（这个地址的值是所指对象的地址）数组。
1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak
指针指向对象的地址。
2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， 
objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。
3、释放时，调用clearDeallocating函数。clearDeallocating函数首
先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数
据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。        
</code></pre>
<h3 id="当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？"><a href="#当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？" class="headerlink" title="当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？"></a>当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？</h3><pre><code>1、调用objc_release
2、因为对象的引用计数为0，所以执行dealloc
3、在dealloc中，调用了_objc_rootDealloc函数
4、在_objc_rootDealloc中，调用了object_dispose函数
5、调用objc_destructInstance
6、最后调用objc_clear_deallocating,详细过程如下：
    a. 从weak表中获取废弃对象的地址为键值的记录
    b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为 nil
    c. 将weak表中该记录删除
    d. 从引用计数表中删除废弃对象的地址为键值的记录
</code></pre>
<h2 id="为什么NSMutableArray必须用strong，而NSArray必须用copy？"><a href="#为什么NSMutableArray必须用strong，而NSArray必须用copy？" class="headerlink" title="为什么NSMutableArray必须用strong，而NSArray必须用copy？"></a>为什么NSMutableArray必须用strong，而NSArray必须用copy？</h2><pre><code>NSArray：被strong修饰之后，由于只是强引用，所以副本对象数
组和源对象数组只是指向同一个内存区域，这样就会造成副本对象数
组会随着源对象数组的改变而改变,即便有时候你并不想让副本对象
跟着改变。测试打印结果显示，array的长度发生了变化，具有调用
mutableArray方法的能力。
NSMutableArray只能用strong修饰，不存在有copy修饰的情
况，写了就成NSArray了。
</code></pre>
<h2 id="循环引用如何定位"><a href="#循环引用如何定位" class="headerlink" title="循环引用如何定位"></a>循环引用如何定位</h2><pre><code>FBRetainCycleDetector
其原理完全是基于 DFS 算法（深度优先搜索）：把整个对象的之间
的引用情况当做图进行处理，查找其中的环，就找到了循环引用。
</code></pre>
<h2 id="masnory的block会循环引用吗"><a href="#masnory的block会循环引用吗" class="headerlink" title="masnory的block会循环引用吗"></a>masnory的block会循环引用吗</h2><pre><code>masonry中设置布局的方法中的block对象并没有被View所引用，
而是直接在方法内部同步执行，执行完以后block将释放，其中捕捉
的外部变量的引用计数也将还原到之前。
</code></pre>
<h2 id="对象a1，a2，a3没有dosomething方法，想让a1调的时候不崩溃"><a href="#对象a1，a2，a3没有dosomething方法，想让a1调的时候不崩溃" class="headerlink" title="对象a1，a2，a3没有dosomething方法，想让a1调的时候不崩溃"></a>对象a1，a2，a3没有dosomething方法，想让a1调的时候不崩溃</h2><pre><code>1.runtime动态添加方法
2.写category，使方法向前引用，在通过动态方法解析，不让丢出错误
3.用方法混淆
4.用kvo
</code></pre>
<h2 id="数组addobject如何不强引用"><a href="#数组addobject如何不强引用" class="headerlink" title="数组addobject如何不强引用"></a>数组addobject如何不强引用</h2><pre><code>1.使用NSPointerArray
2.使用代理中间类来代替
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift93%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift93%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:55:26" itemprop="dateCreated datePublished" datetime="2018-08-14T19:55:26+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><pre><code>1.并发，当有多个线程在操作时，如果系统只有一个CPU，
则它根本不可能真正同时进行一个以上的线程，它只能把CPU运
行时间划分为若干了时间段，再将时间段分配给各个线程执行，
在一个时间段的线程代码运行时，其他线程处于挂起状。这
种方式我们称之为并发。
2.并行，系统有一个以上CPU时，则线程的操作有可能非并发，
当一个cpu执行一个线程时，另一个cpu可以执行另一个线程，
两个线程互相不抢占cpu资源，可以同时进行，这种方式称为并行。
区别：并发和并行是既相似又有区别的两个概念，并行是指两个活
着多个时间在同一时刻发生；而并发是指两个或多个事件同一
时间间隔内发生。
</code></pre>
<h2 id="你理解的多线程"><a href="#你理解的多线程" class="headerlink" title="你理解的多线程"></a>你理解的多线程</h2><h3 id="第一种：pthread"><a href="#第一种：pthread" class="headerlink" title="第一种：pthread"></a>第一种：pthread</h3><pre><code>a.特点：
    1）一套通用的多线程API
    2）适用于Unix\Linux\Windows等系统
    3）跨平台\可移植
    4）使用难度大
b.使用语言：c语言
c.使用频率：几乎不用
d.线程生命周期：由程序员进行管理
</code></pre>
<h3 id="第二种：NSThread"><a href="#第二种：NSThread" class="headerlink" title="第二种：NSThread"></a>第二种：NSThread</h3><pre><code>a.特点：
    1）使用更加面向对象
    2）简单易用，可直接操作线程对象
    b.使用语言：OC语言
    c.使用频率：偶尔使用
    d.线程生命周期：由程序员进行管理
</code></pre>
<h3 id="第三种：GCD"><a href="#第三种：GCD" class="headerlink" title="第三种：GCD"></a>第三种：GCD</h3><pre><code>a.特点：
    1）旨在替代NSThread等线程技术
    2）充分利用设备的多核（自动）
b.使用语言：C语言
c.使用频率：经常使用
d.线程生命周期：自动管理
</code></pre>
<h3 id="第四种：NSOperation"><a href="#第四种：NSOperation" class="headerlink" title="第四种：NSOperation"></a>第四种：NSOperation</h3><pre><code>a.特点：
    1）基于GCD（底层是GCD）
    2）比GCD多了一些更简单实用的功能
    3）使用更加面向对象
b.使用语言：OC语言
c.使用频率：经常使用
d.线程生命周期：自动管理
</code></pre>
<h2 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h2><pre><code>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）
多线程并发（同时）执行，其实是CPU快速地在多条线程之间
调度（切换）
如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
思考：如果线程非常非常多，会发生什么情况？
CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源
每条线程被调度执行的频次会降低（线程的执行效率降低）
</code></pre>
<h2 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h2><pre><code>能适当提高程序的执行效率    
能适当提高资源利用率（CPU、内存利用率）
</code></pre>
<h2 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h2><pre><code>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，
子线程占用512KB），如果开启大量的线程，会占用大量的内存
空间，降低程序的性能
线程越多，CPU在调度线程上的开销就越大
程序设计更加复杂：比如线程之间的通信、多线程的数据共享
</code></pre>
<h2 id="GCD和NSOperation区别，你更倾向于哪一种？"><a href="#GCD和NSOperation区别，你更倾向于哪一种？" class="headerlink" title="GCD和NSOperation区别，你更倾向于哪一种？"></a>GCD和NSOperation区别，你更倾向于哪一种？</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><pre><code>1.GCD是底层的C语言构成的API，而NSOperationQueue及
相关对象是Objc的对象。在GCD中，在队列中执行的是由block
构成的任务，这是一个轻量级的数据结构；而Operation作为一
个对象，为我们提供了更多的选择；
2.在NSOperationQueue中，我们可以随时取消已经设定要准备
执行的任务(当然，已经开始的任务就无法阻止了)，而GCD没法停
止已经加入queue的block(其实是有的，但需要许多复杂的代码)；
3.NSOperation能够方便地设置依赖关系，我们可以让一个
Operation依赖于另一个Operation，这样的话尽管两个
Operation处于同一个并行队列中，但前者会直到后者执行完毕后
再执行；
4.我们能将KVO应用在NSOperation中，可以监听一
个Operation是否完成或取消，这样子能比GCD更加有效地掌控
我们执行的后台任务；
5.在NSOperation中，我们能够设置NSOperation的
priority优先级，能够使同一个并行队列中的任务区分先后地执
行，而在GCD中，我们只能区分不同任务队列的优先级，如果要区分
block任务的优先级，也需要大量的复杂代码；
6.我们能够对NSOperation进行继承，在这之上添加成员变量与成
员方法，提高整个代码的复用度，这比简单地将block任务排入执行
队列更有自由度，能够在其之上添加更多自定制的功能。
总的来说，Operationqueue提供了更多你在编写多线程程序时需
要的功能，并隐藏了许多线程调度，线程取消与线程优先级的复杂代
码，为我们提供简单的API入口。从编程原则来说，一般我们需要尽
可能的使用高等级、封装完美的API，在必须时才使用底层API。但
是我认为当我们的需求能够以更简单的底层代码完成的时候，简洁的
GCD或许是个更好的选择，而Operationqueue 为我们提供能更多
的选择。
</code></pre>
<h3 id="倾向于GCD："><a href="#倾向于GCD：" class="headerlink" title="倾向于GCD："></a>倾向于GCD：</h3><pre><code>1.GCD是纯C语言的API，轻量级 。
2.GCD的执行速度比NSOperationQueue快。
3.代码更底层简洁
</code></pre>
<h3 id="倾向于：NSOperation"><a href="#倾向于：NSOperation" class="headerlink" title="倾向于：NSOperation"></a>倾向于：NSOperation</h3><pre><code>NSOperation拥有更多的函数可用
NSOperationQueue可以方便的设置operation之间的依
赖关系，GCD则需要很多代码。
NSOperationQueue支持KVO，可以检测operation是
否正在执行（isExecuted）,是否结束（isFinished）,
是否取消（isCanceled）
GCD 只支持FIFO 的队列，NSOperationQueue可以调
整队列的执行顺序（通过调整权重）。NSOperationQueue可
以方便的管理并发、NSOperation之间的优先级。
</code></pre>
<h3 id="使用场合："><a href="#使用场合：" class="headerlink" title="使用场合："></a>使用场合：</h3><pre><code>任务之间不太相互依赖，一般的需求很简单的多线程操作，
用GCD都可以了，简单高效。
任务之间有依赖或要监听任务的执行情况用 NSOperationQueue
</code></pre>
<h2 id="ios-几种线程锁"><a href="#ios-几种线程锁" class="headerlink" title="ios 几种线程锁"></a>ios 几种线程锁</h2><pre><code>锁是最常用的同步工具。一段代码段在同一个时间只能允许被一个线程访问
，比如一个线程A进入加锁代码之后由于已经加锁，另一个线程B就无法访问，
只有等待前一个线程A执行完加锁代码后解锁，B线程才能访问加锁代码。
@synchronized 一个对象层面的锁，锁住了整个对象，底层使用了互斥递归锁来实现
pathread_mutex 互斥锁（c语言）和信号量的实现原理类似，也是阻塞线程并进入睡眠，需要进行上下文切换。
NSLock 对象锁-简单的互斥锁（内部封装了一个 pthread_mutex）
NSCondition （封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件
变量保证执行顺序）同样实现了NSLocking协议，
所以它和NSLock一样，也有NSLocking协议的lock和unlock方法，
可以当做NSLock来使用解决线程同步问题，用法完全一样。NSCondition
提供更高级的用法。wait和signal
NSCondition和NSLock、@synchronized等是不同的是，
NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。
这是非常强大。
NSConditionLock （借助 NSCondition 来实现，本质是生产者-消费者模型）
也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。
NSRecursiveLock 递归锁有时候“加锁代码”中存在递归调用，递归开始前加
锁，递归调用开始后会重复执行此方法以至于反复执行加锁代码最终造成死锁，
这个时候可以使用递归锁来解决。使用递归锁可以在一个线程中反复获取锁而不
造成死锁，这个过程中会记录获取锁和释放锁的次数，只有最后两者平衡锁才被
最终释放。
dispatch_semaphore GCD中信号量，也可以解决资源抢占问题,
支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；
每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，
直到信号量大于0开始执行
OSSpinLock 自旋锁(不建议使用)
自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取
锁就需要等待a线程释放锁。在没有获得锁的期间，b线程会一直处于忙等的状
态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太
划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。
</code></pre>
<h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><pre><code>相同点：都能保证同一时间只有一个线程访问共享资源。
都能保证线程安全。
不同点：
互斥锁：如果共享数据已经有其他线程加锁了，线程会进入
休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的
线程会被唤醒。
自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环
的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会
立即执行。
自旋锁的效率高于互斥锁。
由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放
自旋锁，否则等待该自旋锁的线程会一直在哪里自旋，这就会浪
费CPU时间。
持有自旋锁的线程在sleep之前应该释放自旋锁以便其他可以获得
该自旋锁。内核编程中，如果持有自旋锁的代码sleep了就可能
导致整个系统挂起。
</code></pre>
<h2 id="GCD的一些常用的函数？（group，-barrier，信号量-线程同步）"><a href="#GCD的一些常用的函数？（group，-barrier，信号量-线程同步）" class="headerlink" title="GCD的一些常用的函数？（group， barrier，信号量 线程同步）"></a>GCD的一些常用的函数？（group， barrier，信号量 线程同步）</h2><pre><code>延迟函数dispatch_after
一次性 dispatch_once
创建串行队列 dispatch_queue_create 
获取并发队列 dispatch_get_global_queue
获取主队列 dispatch_get_main_queue
异步执行任务 dispatch_async
同步执行任务 dispatch_sync
提交一个调度队列 dispatch_group_async
新建的queue设置优先级 dispatch_set_target_queue
任务执行完成通知回调 dispatch_group_notify 
让当前任务等待queue其他任务完成再执行 dispatch_barrier_async
</code></pre>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><pre><code>-(void)clickButton &#123;
    dispatch_sync(dispath_get_main_queue(), ^(void)&#123;
        NSLog(&quot;test&quot;);
    &#125;);
&#125;
以上代码座位一个UIButton的响应方法有什么问题，能看到log吗？
原因如下：
在ios使用 dispatch_sync(dispatch_get_main_queue()^()&#123;block体&#125;)；
dispath向主队列加一个同步的block；
此时主队列在等待    dispatch_sync(dispatch_get_main_queue()，^()&#123;block体&#125;)；执行
dispatch_sync在等待主队列执行完毕。
造成死锁。
</code></pre>
<h2 id="同时存在A-B-C三个网络请求，要求同时发起三个网络请求，当三个网络请求都返回数据以后再处理事件"><a href="#同时存在A-B-C三个网络请求，要求同时发起三个网络请求，当三个网络请求都返回数据以后再处理事件" class="headerlink" title="同时存在A,B,C三个网络请求，要求同时发起三个网络请求，当三个网络请求都返回数据以后再处理事件"></a>同时存在A,B,C三个网络请求，要求同时发起三个网络请求，当三个网络请求都返回数据以后再处理事件</h2><pre><code>首先创建并行队列，创建队列组，将队列和需要处理的网络请求分别
添加到组中，当组中所有队列处理完事件后调用
dispatch_group_notify，我们需要在里边处理事件。由于队列
在处理网络请求时将”发送完一个请求”作为事件完成的标记（此时还
未获得网络请求返回数据），所以在这里需要用信号量进行控制，在
执行dispatch_group_notify前发起信号等待（三次信号等待，
分别对应每个队列的信号通知），在每个队列获取到网络请求返回数
据时发出信号通知。这样就能完成需求中的要求。
如果需求中改为：同时存在A,B,C三个任务，要求ABC依次进行处
理，当上一个完成时再进行下一个任务，当三个任务都完成时再处理
事件。这时只需要将队列改为串行队列即可（不在需要信号量控
制）。
</code></pre>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><pre><code>信号量是一个计数器，常用于处理进程或线程的同步问题，特别是对临界资源的同步访问。
临界资源可以简单的理解为在某一时刻只能由一个进程或线程进行操作的资源，这里的资源
可以是一段代码、一个变量或某种硬件资源。信号量的值大于或等于0时表示可供并发进程使用的
资源实体数；小于0时代表正在等待使用临界资源的进程数。
注意：这里的信号量跟信号是没有关系的。
3、信号量的操作
信号量的值与相应资源的使用情况有关，当它的值大于0时，表示当前可用资源的数量，当他的值小于0时，其绝对值表示等待
使用这个资源的进程个数。信号量的值仅能由PV操作来改变。
</code></pre>
<h2 id="某些线程执行完之后去执行其他线程"><a href="#某些线程执行完之后去执行其他线程" class="headerlink" title="某些线程执行完之后去执行其他线程"></a>某些线程执行完之后去执行其他线程</h2><pre><code>1.利用GCD中的barrier
dispatch_async — A
dispatch_async — B
dispatch_barrier_async — middle
dispatch_async — C
2.利用GCD中的group
创建一个dispatch_group_t
dispatch_group_async — 依次添加并发操作
dispatch_group_notify
</code></pre>
<h2 id="两个线程的notification怎么实现，除GCD"><a href="#两个线程的notification怎么实现，除GCD" class="headerlink" title="两个线程的notification怎么实现，除GCD"></a>两个线程的notification怎么实现，除GCD</h2><pre><code>这里讲到了“重定向”，就是我们在Notification所在的默认线程
中捕获这些分发的通知，然后将其重定向到指定的线程中。
一种重定向的实现思路是自定义一个通知队列(注意，不是
NSNotificationQueue对象，而是一个数组)，让这个队列去维
护那些我们需要重定向的Notification。我们仍然是像平常一样
去注册一个通知的观察者，当Notification来了时，先看看post
这个Notification的线程是不是我们所期望的线程，如果不是，
则将这个Notification存储到我们的队列中，并发送一个信号
(signal)到期望的线程中，来告诉这个线程需要处理一个
Notification。指定的线程在收到信号后，将Notification从
队列中移除，并进行处理。
</code></pre>
<h2 id="如何保证NSNotificationCenter线程安全"><a href="#如何保证NSNotificationCenter线程安全" class="headerlink" title="如何保证NSNotificationCenter线程安全"></a>如何保证NSNotificationCenter线程安全</h2><pre><code>当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来
确保观察者是可用的。
主线程调用dealloc操作会让Observer对象的引用计数减为0，这
时对象会被释放掉。
后台线程发送一个通知，如果此时Observer还未被释放，则会用其
转出消息，并执行回调方法。而如果在回调执行的过程中对象被释放
了，就会出现上面的问题。
那我们该怎么做呢？这里有一些好的建议：
尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能
确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用
dealloc方法，所以这一点还是比较困难。
注册监听都时，使用基于block的API。这样我们在block还要继续
调用self的属性或方法，就可以通过weak-strong的方式来处理。
具体大家可以改造下上面的代码试试是什么效果。
使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过
了，在应用的整个生命周期都不会被释放。
使用代理。
</code></pre>
<h2 id="GCD-信号量控制并发"><a href="#GCD-信号量控制并发" class="headerlink" title="GCD 信号量控制并发"></a>GCD 信号量控制并发</h2><pre><code>信号量是一个整形值并且具有一个初始计数值，并且支持两个操作：
信号通知和等待。当一个信号量被信号通知，其计数会被增加。当一
个线程在一个信号量上等待时，线程会被阻塞（如果有必要的话），
直至计数器大于零，然后线程会减少这个计数。
dispatch_semaphore_signal是发送一个信号，自然会让信号
总量加1，dispatch_semaphore_wait等待信号，当信号总量少
于0的时候就会一直等待，否则就可以正常的执行，并让信号总、
量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步
任务和有限资源访问控制。
</code></pre>
<h2 id="iOS线程间的通信"><a href="#iOS线程间的通信" class="headerlink" title="iOS线程间的通信"></a>iOS线程间的通信</h2><pre><code>iOS中，两个线程之间要想互相通信，可以使用：NSMachPort 
首先NSMarchPort是一个task内线程之间异步通信用的 
你需要在你的两个object内重写handlePortMessage:方法来截
取接收到的消息，使用NSPortMessage来发送消息 
消息一般都是有唯一id和数据组成的 
数据需要经过序列化通过NSPortMessage的components来传递 
接收到数据之后需要进行反序列化 
</code></pre>
<h2 id="get和set的属性如何保证线程的安全"><a href="#get和set的属性如何保证线程的安全" class="headerlink" title="get和set的属性如何保证线程的安全"></a>get和set的属性如何保证线程的安全</h2><pre><code>property 的 atomic 是采用 spinlock_t 也就是俗称的自旋
锁实现的。
atomic通过这种方法，在运行时保证 set,get方法的原子性。 
仅仅是保证了set,get方法的原子性。 
这种线程是不安全的。
self.intA 是原子操作，但是self.intA = self.intA + 1
这个表达式并不是原子操作。 
所以线程是不安全的。 
threadA 在执行表达式 self.intA之后 self.intA = 
self.intA + 1;并没有执行完毕 
此时threadB 执行self.intA = self.intA + 1; 
再回到threadA时，self.intA的数值就被更新了
所以仅仅使用atomic并不能保证线程安全。
</code></pre>
<h2 id="GCD-的珊栏方法"><a href="#GCD-的珊栏方法" class="headerlink" title="GCD 的珊栏方法"></a>GCD 的珊栏方法</h2><pre><code>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能
开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方
法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包
含一个或多个任务。这就需要用到dispatch_barrier_async方
法在两个操作组间形成栅栏
</code></pre>
<h2 id="延时操作主要有4种方式"><a href="#延时操作主要有4种方式" class="headerlink" title="延时操作主要有4种方式"></a>延时操作主要有4种方式</h2><pre><code>1.sleep方式
[NSThread sleepForTimeInterval:1.0f];
[self delayMethod];
使用sleep方式在主线程和子线程中均可执行,但是这是中阻塞线程
的方式,所以建议放到子线程中使用,以免卡住主线程使界面卡住.
没有发现取消执行的方法.
2.NSTimer定时器方式
[NSTimer scheduledTimerWithTimeInterval:1.0f 
target:self selector:@selector(delayMethod) 
userInfo:nil repeats:NO];
使用定时器方式必须放到主线程中使用,否则无效. 是一种非阻塞的
方式.
可以通过- (void)invalidate;方法取消执行。
3.GCD方式
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;
//write code here
&#125;);
该方式可选择线程去执行,是一种非阻塞的方式.
没有发现取消执行的方法.
4.performSelector方式
[self performSelector:@selector(delayMethod) 
withObject:nil afterDelay:1.0f];
使用该方式必须放到主线程中使用,否则无效. 是一种非阻塞的方式.
取消执行方法如下:
[[self class] 
cancelPreviousPerformRequestsWithTarget:self 
selector:@selector(delayMethod) object:nil];
</code></pre>
<h2 id="NSLock死锁"><a href="#NSLock死锁" class="headerlink" title="NSLock死锁"></a>NSLock死锁</h2><pre><code>使用锁最容易犯的一个错误就是在递归或循环中造成死锁
如下代码中，因为在线程1中的递归block中，锁会被多次的lock，
所以自己也被阻塞了。
此处将NSLock换成NSRecursiveLock，便可解决问题。
NSRecursiveLock类定义的锁可以在同一线程多次lock，而不会
造成死锁。
递归锁会跟踪它被多少次lock。每次成功的lock都必须平衡调用
unlock操作。
只有所有的锁住和解锁操作都平衡的时候，锁才真正被释放给其他线
程获得。
</code></pre>
<h2 id="NSNotificationCenter的同步和异步"><a href="#NSNotificationCenter的同步和异步" class="headerlink" title="NSNotificationCenter的同步和异步"></a>NSNotificationCenter的同步和异步</h2><pre><code>默认的NSNotificationCenter是同步的
您可以通过NSNotificationQueue的
enqueueNotification:postingStyle:和enqueueNotification:postingStyle:coalesceMask:f
orModes:方法将通告放入队列，实现异步发送，在把通告放入队列
之后，这些方法会立即将控制权返回给调用对象。
通过这里的时间间隔可以看出， 通过通知队列来管理通知，不会再
造成阻塞。
</code></pre>
<h2 id="NSTimer在子线程可以执行吗，如果想执行的话runloop里要怎么操作"><a href="#NSTimer在子线程可以执行吗，如果想执行的话runloop里要怎么操作" class="headerlink" title="NSTimer在子线程可以执行吗，如果想执行的话runloop里要怎么操作"></a>NSTimer在子线程可以执行吗，如果想执行的话runloop里要怎么操作</h2><pre><code>开辟子线程：（使用子线程的runloop）
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
[thread start];
- (void)newThread
&#123;     @autoreleasepool
        &#123;
            [NSTimer scheduledTimerWithTimeInterval:2.0 
            target:self selector:@selector(addTime) 
            userInfo:nil repeats:YES];
            [[NSRunLoop currentRunLoop] run];
        &#125;
&#125;
</code></pre>
<h2 id="原子属性"><a href="#原子属性" class="headerlink" title="原子属性"></a>原子属性</h2><pre><code>原子属性（线程安全），是针对多线程设计的，是默认属性
多个线程在写入原子属性时（调用 setter 方法），能够保证同一
时间只有一个线程执行写入操作
原子属性是一种单(线程)写多(线程)读的多线程技术
原子属性的效率比互斥锁高，不过可能会出现脏数据
在定义属性时，必须显示地指定 nonatomic，否则默认为atomic
多线程——atomic nonatomic的区别
原子性atomic ,默认属性，编译器会在property上自动添加原子锁
非原子性nonatomic，不考虑多线程情况时使用，提高效率
原子属性内部的锁是自旋锁，自旋锁的执行效率比互斥锁高
atomic本质上就是给get/set方法加锁，即原子锁，以避免线程A
还没执行完setter，线程B又开始执行的，导致读取数据错误的问
题。
</code></pre>
<h3 id="atomic一定是线程安全的么？"><a href="#atomic一定是线程安全的么？" class="headerlink" title="atomic一定是线程安全的么？"></a>atomic一定是线程安全的么？</h3><pre><code>不一定，首先atomic的释义是原子性，并不是线程安全。原子性这
个概念表示一个操作序列就像一个操作一样不被打断，而不像一个操
作序列一样中间容许被打断。所以nonatomic一定是线程不安全
的，但是atomic却不一定是线程安全的。
假设线程A执行在对某属性get之前线程B release了该属性，会导
致程序崩溃。
原子属性内部的锁是自旋锁，自旋锁的执行效率比互斥锁高
</code></pre>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><pre><code>一般说来，确保线程安全的方法有这几个：竞争与原子操作、同步与
锁、可重入、过度优化。
竞争与原子操作 
多个线程同时访问和修改一个数据，可能造成很严重的后果。出现严
重后果的原因是很多操作被操作系统编译为汇编代码之后不止一条指
令，因此在执行的时候可能执行了一半就被调度系统打断了而去执行
别的代码了。一般将单指令的操作称为原子的(Atomic)，因为不管
怎样，单条指令的执行是不会被打断的。
因此，为了避免出现多线程操作数据的出现异常，Linux系统提供了
一些常用操作的原子指令，确保了线程的安全。但是，它们只适用于
比较简单的场合，在复杂的情况下就要选用其他的方法了。
同步与锁 
为了避免多个线程同时读写一个数据而产生不可预料的后果，开发人
员要将各个线程对同一个数据的访问同步，也就是说，在一个线程访
问数据未结束的时候，其他线程不得对同一个数据进行访问。
同步的最常用的方法是使用锁(Lock)，它是一种非强制机制，每个
线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放
锁；在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新
可用。
二元信号量是最简单的一种锁，它只有两种状态：占用与非占用，它
适合只能被唯一一个线程独占访问的资源。对于允许多个线程并发访
问的资源，要使用多元信号量(简称信号量)。
可重入 
一个函数被重入，表示这个函数没有执行完成，但由于外部因素或内
部因素，又一次进入该函数执行。一个函数称为可重入的，表明该函
数被重入之后不会产生任何不良后果。可重入是并发安全的强力保
障，一个可重入的函数可以在多线程环境下放心使用。
过度优化 
在很多情况下，即使我们合理地使用了锁，也不一定能够保证线程安
全，因此，我们可能对代码进行过度的优化以确保线程安全。
我们可以使用volatile关键字试图阻止过度优化，它可以做两件
事：第一，阻止编译器为了提高速度将一个变量缓存到寄存器而不写
回；第二，阻止编译器调整操作volatile变量的指令顺序。
在另一种情况下，CPU的乱序执行让多线程安全保障的努力变得很困
难，通常的解决办法是调用CPU提供的一条常被称作barrier的指
令，它会阻止CPU将该指令之前的指令交换到barrier之后，反之亦
然。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift95OC%E5%8F%91%E6%B6%88%E6%81%AF%E6%AD%A5%E9%AA%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift95OC%E5%8F%91%E6%B6%88%E6%81%AF%E6%AD%A5%E9%AA%A4/" class="post-title-link" itemprop="url">OC发消息</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:55:18" itemprop="dateCreated datePublished" datetime="2018-08-14T19:55:18+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="发消息步骤"><a href="#发消息步骤" class="headerlink" title="发消息步骤"></a>发消息步骤</h2><pre><code>1.检查这个selector是不是要被忽略的，比如mac os开发，
有垃圾回收，就不考虑 retain，release这些函数
2.检测这个target是不是nil对象，
ObjC的特性允许对一个nil对象发消息而不会崩溃
3.如果以上都通过了，就通过isa指针开始查找这个类的方法列表，
先从缓存中找，完了跳到对应函数执行
4.如果缓存列表找不到，就找一下方法分发表
5.如果方法列表找不到，就到超类的方法分发列表找，
一直找到NSObject
6.如果还找不到，就开始进行动态方法解析，调用
+(Bool)resolveInstanceMethod(SEL)selector；（实例方法）
+(Bool)resolveClassMethod(SEL)selector；（类方法）
该方法的参数就是那个位置的选择子（方法），其返回值为bool，
表示这个类能否新增一个实例方法用于处理该未知的方法
一般用这个方法可以动态的添加方法
7.如果还是找不到，那么运行系统就会问，
能不能把这条消息转发给其他的接受者处理。调用
+(id)forwardingTargetForSelector(SEL)selector；
当前接收者如果能找到备选对象，那么将其返回，
如果找不到，返回nil
8.如果还是找不到，那么会创建一个NSInvocation对象，
把这个尚未处理的那条消息有关的全部细节都封装其中，
此对象包含选择子，目标对象及参数，
并调用下面的方法进行消息转发
-（void）forwardInvocation：(NSInvocation *)invocation；
9.如果最后都没有出来的话，那么就抛出异常
</code></pre>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><pre><code>当前对象无论调用任何方法返回的都是当前对象
无论何时，要调用objc_msgSend函数，必须要将函数强制转
换成合适的函数指针类型才能调用。
其实编译器会根据情况在objc_msgSend,
objc_msgSend_stret, objc_msgSendSuper, 或
objc_msgSendSuper_stret四个方法中选择一个来调用。
</code></pre>
<h2 id="消息转发："><a href="#消息转发：" class="headerlink" title="消息转发："></a>消息转发：</h2><h3 id="消息转发机流程"><a href="#消息转发机流程" class="headerlink" title="消息转发机流程"></a>消息转发机流程</h3><pre><code>1、动态方法解析resolveInstanceMethod
2、备用接受者forwardingTargetForSelector
3、完整转发forwardInvocation
你可以实现forwardInvocation方法，将消息转发给另一个
对象，forwardInvocation方法是一个动态方法，在响应者无法
响应方法时，会调用forwardInvocation方法，可以重写这个方
法，实现消息转发。
</code></pre>
<h2 id="Objc中向一个nill对象发消息，会发生什么？"><a href="#Objc中向一个nill对象发消息，会发生什么？" class="headerlink" title="Objc中向一个nill对象发消息，会发生什么？"></a>Objc中向一个nill对象发消息，会发生什么？</h2><pre><code>如果self为nil，那么selector也会为空，直接返回，不会出现问题。
（返回值时对象，是标量，结构体）
如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0
地址返回，所以不会出现任何错误
如果返回值类型是对象，那么返还nil
如果回值类型是标量，那么是0，
如果回值类型是结构体为0，
其他为返回值是未定义的。
但对于[NSNull null]对象发送消息时，是会crash的，因为
NSNull类只有一个null方法。
</code></pre>
<h3 id="unrecognized-selector-sent-to-instance的错误是怎么回事？"><a href="#unrecognized-selector-sent-to-instance的错误是怎么回事？" class="headerlink" title="unrecognized selector sent to instance的错误是怎么回事？"></a>unrecognized selector sent to instance的错误是怎么回事？</h3><pre><code>这是因为这个对象已经被释放了（引用计数为0了），那么这个时候再去调用方
法肯定是会Crash的，因为这个时候这个对象就是一个野指针（指向僵尸对象
（对象的引用计数为0，指针指向的内存已经不可用）的指针）了，安全的做法
是释放后将对象重新置为nil，使它成为一个空指针，大家可以在关闭ARC后手
动release对象验证一下。
</code></pre>
<h3 id="空指针和野指针的区别"><a href="#空指针和野指针的区别" class="headerlink" title="空指针和野指针的区别"></a>空指针和野指针的区别</h3><pre><code>没有存储任何内存地址的指针就称为空指针(NULL指针)
空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。
&quot;野指针&quot;不是NULL指针，是指向&quot;垃圾&quot;内存（不可用内存）的指针。
野指针是非常危险的。
</code></pre>
<h2 id="函数调用和OC的消息传递机制区别"><a href="#函数调用和OC的消息传递机制区别" class="headerlink" title="函数调用和OC的消息传递机制区别"></a>函数调用和OC的消息传递机制区别</h2><pre><code>对于C语言，函数的调用在编译器的时候决定调用那个函数。编译完之后直接
顺序执行。
OC的函数调用成为消息发送。属于动态调用过程。在编译的时候决不能决定
真正调用那个函数（实时证明，在编译阶段，oc可以调用任何函数，及时这个
函数并未实现，只要申明过就不会报错，而c语言在编译阶段或报错）。
</code></pre>
<h2 id="消息转发中的resolveInstanceMethod返回值是Bool的话，那不去动态增加方法，直接返回yes行不行？"><a href="#消息转发中的resolveInstanceMethod返回值是Bool的话，那不去动态增加方法，直接返回yes行不行？" class="headerlink" title="消息转发中的resolveInstanceMethod返回值是Bool的话，那不去动态增加方法，直接返回yes行不行？"></a>消息转发中的resolveInstanceMethod返回值是Bool的话，那不去动态增加方法，直接返回yes行不行？</h2><pre><code>返回值文档中说是表示动态决议成功与否。但在上面的例子中（不涉
及消息转发的情况下），如果在该函数内为指定的 selector 提供
实现，无论返回 YES 还是 NO，编译运行都是正确的；但如果在该
函数内并不真正为 selector 提供实现，无论返回 YES 还是 
NO，运行都会 crash，道理很简单，selector 并没有对应的实
现，而又没有实现消息转发。
resolveInstanceMethod 是为对象方法进行决议，
而 resolveClassMethod 是为类方法进行决议。
</code></pre>
<h2 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h2><pre><code>NSInvocation是一个消息调用类，它包含了所有OC消息的成分：
target、selector、参数以及返回值。NSInvocation可以将消
息转换成一个对象，消息的每一个参数能够直接设定，而且当一个
NSInvocation对象调度时返回值是可以自己设定的。一个
NSInvocation对象能够重复的调度不同的目标(target)，而且
它的selector也能够设置为另外一个方法签名。NSInvocation
遵守NSCoding协议，但是仅支持NSPortCoder编码，不支持归档
型操作。
// 通过NSMethodSignature对象创建NSInvocation对象，NSMethodSignature为方法签名类
+ (NSInvocation *)invocationWithMethodSignature:(NSMethodSignature *)sig;
// 获取NSMethodSignature对象
@property (readonly, retain) NSMethodSignature *methodSignature;
// 保留参数，它会将传入的所有参数以及target都retain一遍
- (void)retainArguments;
// 判断参数是否还存在
// 调用retainArguments之前，值为NO，调用之后值为YES
@property (readonly) BOOL argumentsRetained;
// 设置消息调用者，注意：target最好不要是局部变量
@property (nullable, assign) id target;
// 设置要调用的消息
@property SEL selector;
// 获取消息返回值
- (void)getReturnValue:(void *)retLoc;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift102AFN_SDWebImage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift102AFN_SDWebImage/" class="post-title-link" itemprop="url">AFN SD做了哪些优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:54:20" itemprop="dateCreated datePublished" datetime="2018-08-14T19:54:20+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AFN包括如下模块"><a href="#AFN包括如下模块" class="headerlink" title="AFN包括如下模块"></a>AFN包括如下模块</h2><pre><code>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)
网络状态监听模块(Reachability)
网络通信安全策略模块(Security)
网络通信信息序列化/反序列化模块(Serialization)
对于iOS UIKit库的扩展(UIKit)
</code></pre>
<h2 id="AFN优点"><a href="#AFN优点" class="headerlink" title="AFN优点"></a>AFN优点</h2><pre><code>AFNetworking内置支持JSON,plist文件和XML文件的解析,使用比
较方便我们能够有效的控制并观察一个网络请求的创建、进行、取消、
完成、暂停恢复、异常等问题及状态
可以帮助我们轻松友好的完成请求的创建、响应的系列化,网络状态的监控以
及安全策略以及每一个请求operation的管理(operation的相互依赖或
状态改变)。 
</code></pre>
<h2 id="SDWebImage-概论"><a href="#SDWebImage-概论" class="headerlink" title="SDWebImage 概论"></a>SDWebImage 概论</h2><pre><code>1.提供了一个UIImageView的category用来加载网
络图片并且对网络图片的缓存进行管理
2.采用异步方式来下载网络图片
3.采用异步方式，使用memory＋disk来缓存网
络图片，自动管理缓存。
4.支持GIF动画
5.支持WebP格式
6.同一个URL的网络图片不会被重复下载
7.失效的URL不会被无限重试
8.耗时操作都在子线程，确保不会阻塞主线程
9.使用GCD和ARC
10.支持Arm64
13.图片解码处理在一个 NSOperationQueue 完成，
不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，
最好也在这里完成，效率会好很多。
</code></pre>
<h1 id="AFN、SD缺点"><a href="#AFN、SD缺点" class="headerlink" title="AFN、SD缺点"></a>AFN、SD缺点</h1><pre><code>最近版早早已经支持NSURLSession了，但是不支持iOS7以下系统。
且AFNetworking必须使用ARC
SDWebImage 对gif的处理主要是在UIImage+GIF
这个文件里面，利用ImageIO函数创建二进制数据，如下：
由于SDWebImage通过动图数组来实现动态，
会造成内存不能及时释放
SDWebimage -静态图片加载会产生拉伸
</code></pre>
<h2 id="SD下载完图片为什么要解码"><a href="#SD下载完图片为什么要解码" class="headerlink" title="SD下载完图片为什么要解码"></a>SD下载完图片为什么要解码</h2><pre><code>在我们使用 UIImage 的时候，创建的图片通常不会直接加载到内存，而是在
渲染的时候再进行解压并加载到内存。这就会导致 UIImage 在渲染的时候效
率上不是那么高效。为了提高效率通过 decodedImageWithImage方法把图
片提前解压加载到内存，这样这张新图片就不再需要重复解压了，提高了渲染效
率。这是一种空间换时间的做法。
</code></pre>
<h2 id="旧版本AFN为什么加Runloop"><a href="#旧版本AFN为什么加Runloop" class="headerlink" title="旧版本AFN为什么加Runloop"></a>旧版本AFN为什么加Runloop</h2><pre><code>首先我们知道在旧版本的AFN中使用了 NSURLConnection 来发起并处理网
络连接。AFN 的做法是把网络请求的发起和解析都放在同一个子线程中进行，
但由于子线程默认不开启 runloop，它会向一个 C语言程序那样在运行完所有
代码后退出线程。而网络请求是异步的，这会导致获取到请求数据时，线程已经
退出，代理方法没有机会执行。因此，AFN 的做法是使用一个 runloop 来保
证线程不死，也就是下面这段被讲烂了的代码:
</code></pre>
<h2 id="AFN多重代理如何实现"><a href="#AFN多重代理如何实现" class="headerlink" title="AFN多重代理如何实现"></a>AFN多重代理如何实现</h2><pre><code>https://www.jianshu.com/p/961cfc9a446b
又有小伙伴问了，我们设置的这个代理不是NSURLSessionDelegate吗？怎
么能响应NSUrlSession这么多代理呢？我们点到类的声明文件中去看看：
我们可以看到这些代理都是继承关系，而在NSURLSession实现中，只要设置
了这个代理，它会去判断这些所有的代理，是否respondsToSelector这些代
理中的方法，如果响应了就会去调用。
</code></pre>
<h2 id="SDWebImage的缓存策略"><a href="#SDWebImage的缓存策略" class="headerlink" title="SDWebImage的缓存策略"></a>SDWebImage的缓存策略</h2><pre><code>Memory 和 Disk 双缓存    
</code></pre>
<h2 id="SDWebImage加载图片的流程"><a href="#SDWebImage加载图片的流程" class="headerlink" title="SDWebImage加载图片的流程"></a>SDWebImage加载图片的流程</h2><pre><code>1.入口 setImageWithURL:placeholderImage:options:会
先把 placeholderImage显示，然后 SDWebImageManager根
据 URL 开始处理图片。
2.进入SDWebImageManager 类中
downloadWithURL:delegate:options:userInfo:，交给
SDImageCache从缓存查找图片是否已经下载
queryDiskCacheForKey:delegate:userInfo:.
3.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，
SDImageCacheDelegate回调 
imageCache:didFindImage:forKey:userInfo:到
SDWebImageManager。
4.SDWebImageManagerDelegate 回调
webImageManager:didFinishWithImage: 到 
UIImageView+WebCache,等前端展示图片。
5.如果内存缓存中没有，生成 ｀NSOperation ｀
添加到队列，开始从硬盘查找图片是否已经缓存。
6.根据 URL的MD5值Key在硬盘缓存目录下尝试读取图片文件。这
一步是在 NSOperation 进行的操作，所以回主线程进行结果回
调 notifyDelegate:。
7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如
果空闲内存过小， 会先清空内存缓存）。
SDImageCacheDelegate&#39;回调 
imageCache:didFindImage:forKey:userInfo:`。进而
回调展示图片。
8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图
片，需要下载图片， 回调 
imageCache:didNotFindImageForKey:userInfo:。
9.共享或重新生成一个下载器 SDWebImageDownloader开始下载图片。
10.图片下载由 NSURLConnection来做，实现相关 delegate
来判断图片下载中、下载完成和下载失败。
11.connection:didReceiveData: 中利用 ImageIO做了按
图片下载进度加载效果。
12.connectionDidFinishLoading: 数据下载完成后交给 
SDWebImageDecoder做图片解码处理。
13.图片解码处理在一个 NSOperationQueue完成，不会拖慢主
线程 UI.如果有需要 对下载的图片进行二次处理，最好也在这里
完成，效率会好很多。
14.在主线程 notifyDelegateOnMainThreadWithInfo:
宣告解码完成 
imageDecoder:didFinishDecodingImage:userInfo: 
回调给 SDWebImageDownloader`。
15.imageDownloader:didFinishWithImage:回调给
SDWebImageManager告知图片 下载完成。
16. 通知所有的 downloadDelegates下载完成，回调给需要的
地方展示图片。
17.将图片保存到 SDImageCache中，内存缓存和硬盘缓存同时保
存。写文件到硬盘 也在以单独 NSOperation 完成，避免拖慢主
线程。
18.SDImageCache 在初始化的时候会注册一些消息通知，
在内存警告或退到后台的时 候清理内存图片缓存，应用结束的时候
清理过期图片。
</code></pre>
<h2 id="SDWebimage对相同url图片问题"><a href="#SDWebimage对相同url图片问题" class="headerlink" title="SDWebimage对相同url图片问题"></a>SDWebimage对相同url图片问题</h2><pre><code>找出问题所在了，因为修改头像后，图片的url是不变的，而默认情
况下，SDWebimage对相同url是优先使用缓存的，因此得加
options属性
[self.HeaderImage sd_setImageWithURL:[NSURL URLWithString:yhPic] placeholderImage:[UIImage imageNamed:@&quot;ameng_dh&quot;] options:SDWebImageRefreshCached];
SDWebImageRefreshCached是专门用来处理相同url，图片不同
的情况的。
重点是在SDWebImageManager.m文件中，大概176行左右
在(利用SDWebImageRefreshCached)的基础上，修改SD库
添加这一段代码// remove 
SDWebImageDownloaderUseNSURLCache flag 
downloaderOptions &amp;= 
~SDWebImageDownloaderUseNSURLCache;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift97RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift97RunLoop/" class="post-title-link" itemprop="url">RunLoop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:51:42" itemprop="dateCreated datePublished" datetime="2018-08-14T19:51:42+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>Run loops是线程的基础架构部分，每个线程，
包括程序的主线程main thread都有与之相应的run loop对象。
程序启动的时候会调用UIApplicationMain()函数，
重点是UIApplicationMain()函数，
这个方法会为main thread设置一个NSRunLoop对象
对其它线程来说，run loop默认是没有启动的，
如果你需要更多的线程交互则可以手动配置和启动，
如果线程只是去执行一个长时间的已确定的任务则不需要。
使用run loop可以使你的线程在有工作的时候工作，
没有工作的时候休眠，这可以大大节省系统资源。
</code></pre>
<h2 id="获取线程"><a href="#获取线程" class="headerlink" title="获取线程"></a>获取线程</h2><pre><code>NSRunLoop *runloop = [NSRunLoop currentRunLoop];
RunLoop 一个状态循环
</code></pre>
<h2 id="NSRunLoop不是线程安全的"><a href="#NSRunLoop不是线程安全的" class="headerlink" title="NSRunLoop不是线程安全的"></a>NSRunLoop不是线程安全的</h2><pre><code>我们不能再一个线程中去操作另外一个线程的run loop对象，
那很可能会造成意想不到的后果
不过幸运的是CoreFundation中的不透明类CFRunLoopRef是
线程安全的，而且两种类型的run loop完全可以混合使用。
</code></pre>
<h2 id="NSRunloop数据模型"><a href="#NSRunloop数据模型" class="headerlink" title="NSRunloop数据模型"></a>NSRunloop数据模型</h2><pre><code>NSRunloop，对CFRunLoop的封装
1.ptherd 对应runloop的内部一个线程
2.currendMode， 当前mode， CFRunLoopMode数据结构
    2.1 name 定义别名，比如NSDefaultRunloopMode
    2.2 source0，soures1，都是无序集合
    2.2.1 sourece0 需要用户手动唤醒线程，非基于port的。用户主动触发的事件
    2.2.2 sources1 具备唤醒线程能力 通过内核和其他线程互相发送消息
    2.3timers 数组
    2.4Observers 观测事件点
        KCFRunLoopEntry 准备启动
        BeforeTimers 通知观察者将要处理timer了
        BeforeSources 通知观察者将要处理Soures了
        BeforeWaiting 将要休眠了
        AfterWiaiting 用户态切换到内核不久
        Exit runloop 退出
        AllActivites 观察所有事件
3.Modes CFRunloopMode 的集合
4.commonModes
</code></pre>
<h2 id="autorelease-pool的创建和释放"><a href="#autorelease-pool的创建和释放" class="headerlink" title="autorelease pool的创建和释放"></a>autorelease pool的创建和释放</h2><pre><code>每当一个运行循环结束的时候，它都会释放一次autorelease pool，
同时pool中的所有自动释放类型变量都会被释放掉。
</code></pre>
<h2 id="输入事件来源"><a href="#输入事件来源" class="headerlink" title="输入事件来源"></a>输入事件来源</h2><pre><code>Run loop接收输入事件来自两种不同的来源：
输入源（input source）和定时源（timer source）。
两种源都使用程序的某一特定的处理例程来处理到达的事件。
在NSRunLoop中每一个消息就被打包在
input source或者是timer source
</code></pre>
<h3 id="输入源（input-source）"><a href="#输入源（input-source）" class="headerlink" title="输入源（input source）"></a>输入源（input source）</h3><pre><code>传递异步事件，通常消息来自于其他线程或程序。
输入源传递异步消息给相应的处理例程，
并调用runUntilDate:方法来退出
(在线程里面相关的NSRunLoop对象调用)。
基于端口的输入源：
    基于端口的输入源由内核自动发送。
    你必须人工创建端口和它的run loop源。
    我们可以使用端口相关的函数（CFMachPortRef，
    CFMessagePortRef，CFSocketRef）来创建合适的对象
自定义输入源
    自定义的输入源需要人工从其他线程发送
    必须使用Core Foundation里面的
    CFRunLoopSourceRef类型相关的函数来创建。
Cocoa上的Selector源
    Cocoa定义了自定义输入源，允许你在任何线程执行
    selector方法。和基于端口的源一样，执行selector
    请求会在目标线程上序列化，减缓许多在线程上允许多个方
    法容易引起的同步问题。不像基于端口的源，一个selector
    执行完后会自动从run loop里面移除。
    NSObject类提供了类似如下的selector方法：
    - (void)performSelectorOnMainThread:
    (SEL)aSelector withObject:
    (id)argwaitUntilDone:(BOOL)wait
    modes:(NSArray *)array;
</code></pre>
<h3 id="定时源（timer-source）"><a href="#定时源（timer-source）" class="headerlink" title="定时源（timer source）"></a>定时源（timer source）</h3><pre><code>定时源在预设的时间点同步方式传递消息，
这些消息都会发生在特定时间或者重复的时间间隔。
定时源则直接传递消息给处理例程，不会立即退出run loop。
尽管定时器可以产生基于时间的通知，但它并不是实时机制。
和输入源一样，定时器也和你的run loop的特定模式相关。
如果定时器所在的模式当前未被run loop监视，
那么定时器将不会开始直到run loop运行在相应的模式下。
典型的ScrollView滑动导致定时器不准问题
NSTimer *timer = [NSTimer 
scheduledTimerWithTimeInterval:4.0
target:self
selector:@selector(backgroundThreadFire:) userInfo:nil
repeats:YES];
[[NSRunLoop currentRunLoop]
addTimer:timerforMode:NSDefaultRunLoopMode];
</code></pre>
<h2 id="RunLoop观察者"><a href="#RunLoop观察者" class="headerlink" title="RunLoop观察者"></a>RunLoop观察者</h2><pre><code>源是在合适的同步或异步事件发生时触发，
而run loop观察者则是在run loop本身运行的特定时候触发。
你可以使用run loop观察者来为处理某一特定事件
或是进入休眠的线程做准备。
1.  Runloop入口
2.  Runloop何时处理一个定时器
3.  Runloop何时处理一个输入源
4.  Runloop何时进入睡眠状态
5.  Runloop何时被唤醒，但在唤醒之前要处理的事件
6.  Runloop终止
- (void)addObserverToCurrentRunloop
&#123;
NSRunLoop*mRunLoop = [NSRunLoop currentRunLoop];
CFRunLoopObserverContext context =
&#123;0,self, NULL,NULL, NULL&#125;;
CFRunLoopObserverRefobserver 、
=CFRunLoopObserverCreate(kCFAllocatorDefault,
kCFRunLoopBeforeTimers,YES, 0,
&amp;myRunLoopObserver, &amp;context);
if (observer)
&#123;
    CFRunLoopRef cfLoop = [myRunLoop 
    getCFRunLoop];
    CFRunLoopAddObserver(cfLoop,
    observer, kCFRunLoopDefaultMode);
&#125;
&#125;
</code></pre>
<h2 id="RunLoop的事件队列"><a href="#RunLoop的事件队列" class="headerlink" title="RunLoop的事件队列"></a>RunLoop的事件队列</h2><pre><code>1.通知观察者run loop已经启动
2.通知观察者任何即将要开始的定时器
3.通知观察者任何即将启动的非基于端口的源
4.启动任何准备好的非基于端口的源
5.如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9。
6.通知观察者线程进入休眠
7.将线程置于休眠直到任一下面的事件发生：
    某一事件到达基于端口的源
    定时器启动
    Run loop设置的时间已经超时
    run loop被显式唤醒
8.通知观察者线程将被唤醒。
9.处理未处理的事件
    如果用户定义的定时器启动，处理定时器事件并重启
    run loop。进入步骤2
    如果输入源启动，传递相应的消息
    如果run loop被显式唤醒而且时间还没超时，
    重启run loop。进入步骤2
10.通知观察者run loop结束。
从这个事件队列中可以看出：
①如果是事件到达，消息会被传递给相应的处理程序来处理，
runloop处理完当次事件后，run loop会退出，
而不管之前预定的时间到了没有。你可以重新启动
run loop来等待下一事件。
②如果线程中有需要处理的源，但是响应的事件没有到来的时候，
线程就会休眠等待相应事件的发生。这就是为什么run loop
可以做到让线程有工作的时候忙于工作，
而没工作的时候处于休眠状态。
</code></pre>
<h2 id="RunLoop使用时机"><a href="#RunLoop使用时机" class="headerlink" title="RunLoop使用时机"></a>RunLoop使用时机</h2><pre><code>Run loop在你要和线程有更多的交互时才需要，比如以下情况：
使用端口或自定义输入源来和其他线程通信
使用线程的定时器
Cocoa中使用任何performSelector…的方法
使线程周期性工作
</code></pre>
<h2 id="RunLoop的五个类"><a href="#RunLoop的五个类" class="headerlink" title="RunLoop的五个类"></a>RunLoop的五个类</h2><pre><code>1    CFRunloopRef    【RunLoop本身】
2    CFRunloopModeRef    【Runloop的运行模式】
3    CFRunloopSourceRef    【Runloop要处理的事件源】
4    CFRunloopTimerRef    【Timer事件】
5    CFRunloopObserverRef    【Runloop的观察者（监听者）】
</code></pre>
<h3 id="CFRunLoop-的结构大致如下："><a href="#CFRunLoop-的结构大致如下：" class="headerlink" title="CFRunLoop 的结构大致如下："></a>CFRunLoop 的结构大致如下：</h3><pre><code>struct __CFRunLoop &#123;
    CFMutableSetRef _commonModes;     // Set
    CFMutableSetRef _commonModeItems; // Set
    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
    CFMutableSetRef _modes;           // Set
    ...
&#125;;
 如上，有个概念叫 CommonModes：
 一个 Mode 可以将自己标记为&quot;Common&quot;属性：
 通过将其 ModeName 添加到 RunLoop 的 commonModes 中。例如：
 如上所示，添加 source 的时候，如果 modeName 传入
 kCFRunLoopCommonModes 或者 NSRunLoopCommonModes，
 则该 source 会被保存到 RunLoop 的
 _commonModeItems 中，而且，会被添加到 
 commonModes 中的所有mode中去。
 其实，每当 RunLoop 的内容发生变化时，
 RunLoop 都会自动将 _commonModeItems 
 里的 Source/Observer/Timer 同步到具有 
 Common 标记的所有Mode里。
主线程的 RunLoop 里有两个预置的 Mode
：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。
这两个 Mode 都已经被标记为 Common 属性。
DefaultMode 是 App 平时所处的状态，
TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。
当你创建一个 Timer 并加到 DefaultMode 时，
Timer 会得到重复回调，但此时滑动一个TableView时，
RunLoop 会将 mode 切换为 TrackingRunLoopMode，
这时 Timer 就不会被回调，并且也不会影响到滑动操作。
有时你需要一个 Timer，在两个 Mode 中都能得到回调，
一种办法就是将这个 Timer 分别加入这两个 Mode。
还有一种方式，就是将 Timer 加入到顶层的 RunLoop 
的 commonModeItems 中。commonModeItems 被
RunLoop 自动更新到所有具有 Common 属性的 Mode 里去。
一个 RunLoop 包含若干个 Mode，每个 Mode 
又包含若干个Source/Timer/Observer。
但是，运行的时候，一条线程对应一个 Runloop，
Runloop 总是运行在某种特定的CFRunLoopModeRef
（运行模式）下。
这是因为，在 Runloop 中有多个运行模式，每次调用 
RunLoop 的主函数__CFRunloopRun() 时，只能指定其中一个
Mode（称 CurrentMode）运行， 如果需要切换 Mode，只能是
退出 CurrentMode 切换到指定的 Mode 进入，目的以保证不同
Mode 下的 Source / Timer / Observer 互不影响。
每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，
这个Mode被称作 CurrentMode。如果需要切换 Mode，
只能退出 Loop，再重新指定一个 Mode 进入。
这样做主要是为了分隔开不同组的 Source/Timer/Observer
让其互不影响。
Runloop 要有效，mode 里面 至少 要有一个 timer 
(定时器事件) 或者是 source (源);
</code></pre>
<h2 id="常用案例"><a href="#常用案例" class="headerlink" title="常用案例"></a>常用案例</h2><h3 id="performSelector"><a href="#performSelector" class="headerlink" title="performSelector"></a>performSelector</h3><pre><code>performSelector同样是触发Source0事件。selector也是特殊的
基于自定义的源.理论上来说,允许在当前线程向任何线程上执行发送消息,
和基于端口的源一样,执行selector请求会在目标线程上序列化,
减缓许多在线程上允许多个方法容易引起的同步问题.不像基于端口的源,
一个selector执行完后会自动从run loop里面移除.
当调用上述API，实际上其内部会创建一个 Timer 并添加到当前线程的
RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。
当调用 performSelector:onThread: 时，实际上其会创建一个Timer
加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效.
当前线程指定mode name并延时执行
// 只在NSDefaultRunLoopMode下执行(刷新图片)
[self.myImageView performSelector:@selector
(setImage:) withObject:[UIImage imageNamed:@&quot;&quot;]
afterDelay:ti inModes:@[NSDefaultRunLoopMode]];
</code></pre>
<h3 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源"></a>自定义输入源</h3><pre><code>使用CFRunLoopSourceRef 类型相关的函数 (线程) 来创建自定义输入源。
</code></pre>
<h3 id="端口输入源"><a href="#端口输入源" class="headerlink" title="端口输入源"></a>端口输入源</h3><h3 id="设置定时源"><a href="#设置定时源" class="headerlink" title="设置定时源"></a>设置定时源</h3><pre><code>使用系统Timer
使用自定义Timer
</code></pre>
<h3 id="设置监听"><a href="#设置监听" class="headerlink" title="设置监听"></a>设置监听</h3><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><pre><code>对于NSTimer，有一个特别的API，这个API会默认把Timer加到 当前线程 中去。
[NSTimer scheduledTimerWithTimeInterval:5.1
target:self selector:@selector(printMessage:)
userInfo:nil repeats:YES];
所以说，当且仅当加到当前线程，下面两个添加NSTimer的方案方可等效：
- (void)defalutTimer &#123;
[NSTimer scheduledTimerWithTimeInterval:1.0 target:
self selector:@selector(doTime) userInfo:nil
repeats:YES];
&#125;
- (void)commonTimer &#123;
NSTimer *timer =[NSTimer timerWithTimeInterval:
1.0 target:self selector:@selector(doTime) 
userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:
timer forMode:NSDefaultRunLoopMode];
&#125;
</code></pre>
<h2 id="NSTimer和RunLoop"><a href="#NSTimer和RunLoop" class="headerlink" title="NSTimer和RunLoop"></a>NSTimer和RunLoop</h2><pre><code>timer不是一种实时的机制，会存在延迟，而且延迟的程度跟当前线
程的执行情况有关。
NSTimer其实也是一种资源，如果看过多线程变成指引文档的话，
我们会发现所有的source如果要起作用，就得加到runloop中去。
同理timer这种资源要想起作用，那肯定也需要加到runloop中才
会又效喽。如果一个runloop里面不包含任何资源的话，运行该
runloop时会立马退出。你可能会说那我们APP的主线程的
runloop我们没有往其中添加任何资源，为什么它还好好的运行。
RunLoop 是用GCD的 dispatch_source_t 实现的 Timer。 
当调用 NSObject 的 performSelecter:afterDelay: 后，
实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 
中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用 
performSelector:onThread: 时，实际上其会创建一个 
Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 
该方法也会失效。
CADisplayLink 是一个和屏幕刷新率（每秒刷新60次）一致的定
时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实
际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个
长任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉。
</code></pre>
<h2 id="动画和RunLoop"><a href="#动画和RunLoop" class="headerlink" title="动画和RunLoop"></a>动画和RunLoop</h2><pre><code>CAAnimation是由RunloopObserver触发回调来重绘
实际上这些背后关联的Layer图层才是真正用来在屏幕上显示和做动
画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触
摸的具体功能，以及Core Animation底层方法的高级接口。
UIView 的 Layer 在系统内部，被维护着三份同样的树形数据结
构，分别是：
1.图层树（这里是代码可以操纵的，设置属性的最终值会立刻在这里更新）； 
2.呈现树（是一个中间层，系统就在这一层上更改属性，进行各种渲
染操作。比如一个动画是更改alpha值从0到1，那么在逻辑树上此
属性会被立刻更新为最终属性1，而在动画树上会根据设置的动画时
间从0逐步变化到1）；
3.渲染树（其属性值就是当前正被显示在屏幕上的属性值）；
隐式动画是系统框架自动完成的。Core Animation在每个
runloop周期中自动开始一次新的事务，即使你不显式的用
[CATransaction begin]开始一次事务，任何在一次runloop
循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。
Core Animation提供的显式动画类型，既可以直接对退曾属性做
动画，也可以覆盖默认的图层行为。
我们经常使用的CABasicAnimation，
CAKeyframeAnimation，CATransitionAnimation，
CAAnimationGroup等都是显式动画类型，这些CAAnimation类
型可以直接提交到CALayer上。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift99Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift99Block/" class="post-title-link" itemprop="url">Block理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:47:23" itemprop="dateCreated datePublished" datetime="2018-08-14T19:47:23+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>本质：带有自动变量值的匿名函数
block的实质是一个oc对象，它有自己的isa指针、invoke变
量 ，是NSObject的子类，可以接收消息
1._NSConcreteGlobalBlock,全局的静态block，不会访问外部的变量。
就是说如果你的block没有调用其他 的外部变量，那你的block类型就是这
种。例如：你仅仅在你的block里面写一个NSLog(&quot;hello world&quot;);
2._NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销
毁。这个block就是你声明的时候不用copy修饰，并且你的block访问了外部
变量。
3._NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时
会被销毁。
</code></pre>
<h2 id="写法："><a href="#写法：" class="headerlink" title="写法："></a>写法：</h2><pre><code>void (^block)(void) = ^&#123;
    NSLog(@&quot;无参无返回值&quot;);
&#125;;
void (^xiaoming1aa)() = ^(NSString *c)&#123;
    NSLog(@&quot;带参数&quot;);
&#125;;
NSString *(^xiaming2)() = ^NSString *(NSString *dd) &#123;
    return @&quot;带参数与返回&quot;;
&#125;;
@property (nonatomic, copy)
void(^myBlock)();//无参无返回值
@property (nonatomic, copy)
void(^myBlock1)(NSString *);//带参数
@property (nonatomic, copy)
NSString *(^myBlock2)(NSString *);//带参数与返回
</code></pre>
<h2 id="block为什么不能修改外部变量"><a href="#block为什么不能修改外部变量" class="headerlink" title="block为什么不能修改外部变量"></a>block为什么不能修改外部变量</h2><pre><code> 默认情况下，在block中访问的外部变量是复制过去的，
 复制过去的是值，即：写操作不对原变量生效。
</code></pre>
<h2 id="block都做了什么？"><a href="#block都做了什么？" class="headerlink" title="__block都做了什么？"></a>__block都做了什么？</h2><pre><code>Block不允许修改外部变量的值，这里所说的外部变量的值，
指的是栈中指针的内存地址。__block 所起到的作用就是
只要观察到该变量被 block 所持有，就将“外部变量”
在栈中的内存地址放到了堆中。
进而在block内部也可以修改外部变量的值
这也保证了原对象不被销毁，但与此同时，也会导致循环引用问题
</code></pre>
<h2 id="block为什么为引起循环引用"><a href="#block为什么为引起循环引用" class="headerlink" title="block为什么为引起循环引用"></a>block为什么为引起循环引用</h2><pre><code>因为block在拷贝到堆上的时候，会retain其引用的外部变量，
那么如果block中如果引用了他的宿主对象，
那很有可能引起循环引用
循环引用发生的条件就是持有这个block的对象，
被block里边加入的对象持有
</code></pre>
<h2 id="如何解决循环引用"><a href="#如何解决循环引用" class="headerlink" title="如何解决循环引用"></a>如何解决循环引用</h2><pre><code>使用__weak修饰self，使其在block中不被持有，打破循环引用。
__weak typeof(self) weakSelf = self;
</code></pre>
<h2 id="Block为什么要用copy修饰"><a href="#Block为什么要用copy修饰" class="headerlink" title="Block为什么要用copy修饰"></a>Block为什么要用copy修饰</h2><pre><code>针对block的三种类型，
也就是copy修饰的block。他的生命 周期就是随着对象的销毁而结束的。只要
对象不销毁，我们就可以调用的到在堆中的block。这就是为什么我们要用
copy来修饰block。因为不用copy修饰的访问外部变量的block，只在他所在
的函数被调用的那一瞬间可以使用。之后就消失了。
</code></pre>
<h2 id="block执行过程中对象被释放"><a href="#block执行过程中对象被释放" class="headerlink" title="block执行过程中对象被释放"></a>block执行过程中对象被释放</h2><pre><code>在block执行开始时self对象还未被释放，而执行过程中，
self被释放了，此时访问self时，就会发生错误。
对于这种场景，应该在block中对 对象使用__strong修饰，
使得在block期间对 对象持有，block执行结束后，解除其持有。
注：此方法只能保证在block执行期间对象不被释放，
如果对象在block执行执行之前已经被释放了，该方法也无效。
</code></pre>
<h2 id="什么情况下不回发生循环引用"><a href="#什么情况下不回发生循环引用" class="headerlink" title="什么情况下不回发生循环引用"></a>什么情况下不回发生循环引用</h2><pre><code>通用情况:在block本身不被self持有,而被别的对象持有,
同时不产生循环引用的时候,就不需要使用weakself了
UIView动画block，AFN的block
UIView的调用的是类方法，当前控制器不可能强引用一个类 ，
所以循环无法形成 --&gt; 动画block不会造成循环引用的原因。
</code></pre>
<h2 id="函数和block区别"><a href="#函数和block区别" class="headerlink" title="函数和block区别"></a>函数和block区别</h2><pre><code>函数里面只能访问全局变量，而Block代码块不光能访问全局变量，
还拥有当前栈内存和堆内存变量的可读性
（当然通过__block访问指示符修饰的局部变量还可以在block代码块里面进行修改）。
从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，
而block实际上是程序运行过程中在栈内存动态创建的对象，
可以向其发送copy消息将block对象拷贝到堆内存，
以延长其生命周期。
</code></pre>
<h2 id="如何区分block位置"><a href="#如何区分block位置" class="headerlink" title="如何区分block位置"></a>如何区分block位置</h2><pre><code>要点一:
    当block在函数内部，
    且定义的时候就使用了函数内部的变量，
    那么这个block是存储在栈上的。 
要点二:
    当block定义在函数体外面，
    或者定义在函数体内部且当时函数执行的时候，
    block体中并没有需要使用函数内部的局部变量时，
    也就是block在函数执行的时候只是静静地待在一边定义了一下
    而不使用函数体的内容，
    那么block将会被编译器存储为全局block。 
要点三:
    全局block存储在堆中，
    对全局block使用copy操作会返回原函数指针；
    而对栈中的block使用copy操作，
    会产生两个不同的block地址，
    也就是两个匿名函数的入口地址。 
要点四:
    ARC机制优化会将stack的block,
    转为heap的block进行调用。
</code></pre>
<h2 id="delegate为什么用weak-它和block区别"><a href="#delegate为什么用weak-它和block区别" class="headerlink" title="delegate为什么用weak 它和block区别"></a>delegate为什么用weak 它和block区别</h2><pre><code>weak是为了解决循环引用的问题
代理和block的共同特性是回调机制，不同的是，代理的方法比较多，比较分
散，使用block的代码比较集中统一；代理运行成本比较低，一对一的关系，
block需要将使用的数据从栈内存拷贝到堆内存中，对象的话就是加计数，代理
制是保存一个对象指针，直接回调；block写法简单，注重传输，但是需要注意
循环引用
总结：公共接口，方法比较多的时候用delegate进行解耦，异步和简单的回调用block
</code></pre>
<h2 id="在block中对weakSelf再进行—strong的操作，然后以百万级的数量去调用某个方法，与直接用weakSelf去调用有什么区别"><a href="#在block中对weakSelf再进行—strong的操作，然后以百万级的数量去调用某个方法，与直接用weakSelf去调用有什么区别" class="headerlink" title="在block中对weakSelf再进行—strong的操作，然后以百万级的数量去调用某个方法，与直接用weakSelf去调用有什么区别"></a>在block中对weakSelf再进行—strong的操作，然后以百万级的数量去调用某个方法，与直接用weakSelf去调用有什么区别</h2><pre><code>在block中调用self会引起循环引用，但是在block中需要对
weakSelf进行strong,保证代码在执行到block中，self不会被
释放，当block执行完后，会自动释放该strongSelf
进行大量调用会引起内存问题
</code></pre>
<h2 id="block嵌套block还用——strong两遍吗"><a href="#block嵌套block还用——strong两遍吗" class="headerlink" title="block嵌套block还用——strong两遍吗"></a>block嵌套block还用——strong两遍吗</h2><pre><code>只要在最后把外层的block执行一次, 内层的block才会真正地被
加载进内存, 循环引用问题再次出现. 出现循环引用的原因其实也
不难理解, 因为strongPerson说白了也是一个强引用, 它与一般
强引用的区别在于, 它只会在被定义的block中对对象进行强引用, 
在block过后就会把对象释放掉, 所以在第2层block中继续用
strongPerson出现循环引用跟一般造成循环引用的原因其实是一
样的, 解决方法也是如出一辙, 而且可以继续嵌套下去, 此处的警
告同样是结果没被使用:
加上修饰符strong时，当别处把变量释放掉，但调用该变量的
block如果仍然没有执行结束，那么系统就会等待block执行完成后
再释放，对该变量在block中的使用起到了保护作用。当block执行
结束后会自动释放掉。
</code></pre>
<h2 id="block捕获进去静态变量，局部变量，全局变量以后，在block内部以什么形式存在"><a href="#block捕获进去静态变量，局部变量，全局变量以后，在block内部以什么形式存在" class="headerlink" title="block捕获进去静态变量，局部变量，全局变量以后，在block内部以什么形式存在"></a>block捕获进去静态变量，局部变量，全局变量以后，在block内部以什么形式存在</h2><pre><code>在执行Block语法的时候，Block语法表达式所使用的自动变量的值
是被保存进了Block的结构体实例中，也就是Block自身中
Block仅仅捕获了val的值，并没有捕获val的内存地址。
</code></pre>
<h2 id="block-和-delegate使用优先级"><a href="#block-和-delegate使用优先级" class="headerlink" title="block 和 delegate使用优先级"></a>block 和 delegate使用优先级</h2><pre><code>block 和 delegate 都可以通知外面。block 更轻型，使用更
简单，能够直接访问上下文，这样类中不需要存储临时数据，使用 
block 的代码通常会在同一个地方，这样读代码也连贯。
delegate 更重一些，需要实现接口，它的方法分离开来，很多时
候需要存储一些临时数据，另外相关的代码会被分离到各处，没有 
block 好读。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift103%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift103%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E9%A1%BA%E5%BA%8F/" class="post-title-link" itemprop="url">iOS事件响应顺序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:44:31" itemprop="dateCreated datePublished" datetime="2018-08-14T19:44:31+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>只有继承了UIResponder的类才能响应touch事件，
响应顺序，优先是最上层的view响应事件，
如果该view有视图控制器的话会是下一个响应者，否者就是该
view的父视图，这样至上而下传递事件。直到单例UIWindow
对象，最后是单例UIApplication对象以终止，UIApplication
的下一个响应者是nil，已结束整个响应循环。
事件在传递过程中视图可以决定是否需要对该事件进行响应。
</code></pre>
<h2 id="1-事件的产生"><a href="#1-事件的产生" class="headerlink" title="1. 事件的产生"></a>1. 事件的产生</h2><pre><code>发生事件后，系统会将该事件加入到一个由UIApplication
管理的事件队列中。
UIApplication会从事件队列中取出最前面的事件，
并将该事件分发下去处理。通常，先发送事件给应用程序
的主窗口（keywindow）。
keywindow会在视图层次结构中找到一个最合适的视图来处理事件。
</code></pre>
<h2 id="事件分发（Event-Delivery）"><a href="#事件分发（Event-Delivery）" class="headerlink" title="事件分发（Event Delivery）"></a>事件分发（Event Delivery）</h2><pre><code>第一响应者（First responder）指的是当前接受触摸的响应者
对象（通常是一个UIView对象），即表示当前该对象正在与用户
交互，它是响应者链的开端。整个响应者链和事件分发的使命都是
找出第一响应者。

UIWindow对象以消息的形式将事件发送给第一响应者，
使其有机会首先处理事件。如果第一响应者没有进行处理，
系统就将事件（通过消息）传递给响应者链中的下一个响应者
，看看它是否可以进行处理。
事件的传递先从父控件传递到子控件（UIApplication
-&gt;window-&gt;寻找处理事件最合适的view）。
如果父view不能接受触摸事件，那么子view也不能接收到
触摸事件。
</code></pre>
<h3 id="如何找到最合适的view来处理事件"><a href="#如何找到最合适的view来处理事件" class="headerlink" title="如何找到最合适的view来处理事件"></a>如何找到最合适的view来处理事件</h3><pre><code>iOS系统检测到手指触摸(Touch)操作时会将其打包成一
个UIEvent对象，并放入当前活动Application的事件队列，
单例的UIApplication会从事件队列中取出触摸事件并传递给单
例的UIWindow来处理，UIWindow对象首先会使用
hitTest:withEvent:方法寻找此次Touch操作初始点所在的视图
(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为
hit-test view。
UIWindow实例对象会首先在它的内容视图上调用
hitTest:withEvent:，此方法会在其视图层级结构中的每个视图
上调用pointInside:withEvent:（该方法用来判断点击事件发
生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视
图），如果pointInside:withEvent:返回YES，则继续逐级调
用，直到找到touch操作发生的位置，这个视图也就是要找的hit-
test view。
</code></pre>
<h3 id="hitTest-withEvent-方法的处理流程如下"><a href="#hitTest-withEvent-方法的处理流程如下" class="headerlink" title="hitTest:withEvent:方法的处理流程如下:"></a>hitTest:withEvent:方法的处理流程如下:</h3><pre><code>view会调用hitTest:withEvent:方法，
hitTest:withEvent:方法底层会调用
pointInside:withEvent:方法判断触摸点是不是在这个view的
坐标系上。如果在坐标系上，会分发事件给这个view的子view。然
后每个字view重复以上步骤，直至最底层的一个合适的view。
如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。
</code></pre>
<h2 id="事件的响应"><a href="#事件的响应" class="headerlink" title="事件的响应"></a>事件的响应</h2><pre><code>事件响应会先从底层最合适的view开始，然后随着上一步找到的链
一层一层响应touch事件。默认touch事件会传递给上一层。如果到
了viewcontroller的view，就会传递给viewcontroller。如
果viewcontroller不能处理，就会传递给UIWindow。如果
UIWindow无法处理，就会传递给UIApplication。如果
UIApplication无法处理，就会传递给
UIApplicationDelegate。如果UIApplicationDelegate不
能处理，则会丢弃该事件。
</code></pre>
<h2 id="如果一个button有一部分超出父控件的范围了，这部分无法响应点击"><a href="#如果一个button有一部分超出父控件的范围了，这部分无法响应点击" class="headerlink" title="如果一个button有一部分超出父控件的范围了，这部分无法响应点击"></a>如果一个button有一部分超出父控件的范围了，这部分无法响应点击</h2><pre><code>当我去点击View-C的时候，hit-Testing实际上是这样检测的
1.首先，视图会先从View-A开始检查，发现触摸点在View-A，
所以检查View-A的子视图View-B。
2.发现触摸点在View-B内，好棒！看看View-B内的子
视图View-C。
3.发现触摸点在View-C内，但View-C没有子视图了，
所以View-C是此次触摸事件的hit-TestView了。
那么UIView中其实提供了两个方法来确定hit-TestView
1.- (UIView *)hitTest:(CGPoint)point 
withEvent:(UIEvent *)event;
2.- (BOOL)pointInside:(CGPoint)point 
withEvent:(UIEvent *)event;
//这个就是我们上面重写的方法
注意其实在每次递归去调用hitTest:(CGPoint)point
withEvent:(UIEvent *)event之前，都会调用
pointInside:withEvent:来确定该触摸点是否在该View内。
所以当我们重写pointInside:(CGPoint)point 
withEvent:(UIEvent *)event后，其实我们的点击后调
用hitTest来递归的找hit-TestView的区域从这样：
</code></pre>
<h2 id="去点手机屏幕，runloop都干了什么，怎么去通知到响应事件的（runloop的唤醒和休眠，调用NSNotification底层的东西）"><a href="#去点手机屏幕，runloop都干了什么，怎么去通知到响应事件的（runloop的唤醒和休眠，调用NSNotification底层的东西）" class="headerlink" title="去点手机屏幕，runloop都干了什么，怎么去通知到响应事件的（runloop的唤醒和休眠，调用NSNotification底层的东西）"></a>去点手机屏幕，runloop都干了什么，怎么去通知到响应事件的（runloop的唤醒和休眠，调用NSNotification底层的东西）</h2><pre><code>Core Foundation和Foundation为Mach端口提供了高级API。
在内核基础上封装的CFMachPort / NSMachPort可以用做
runloop源
而这个源，正是我们经常在调用栈里看到的source0与source1
苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统
事件，其回调函数为 
__IOHIDEventSystemClientQueueCallback()
当我们触发了事件（触摸/锁屏/摇晃等）后
由IOKit.framework生成一个 IOHIDEvent事件
而IOKit是苹果的硬件驱动框架
由它进行底层接口的抽象封装与系统进行交互传递硬件感应的事件
它专门处理用户交互设备，由IOHIDServices和IOHIDDisplays
两部分组成
其中IOHIDServices是专门处理用户交互的，它会将事件封装成
IOHIDEvents对象，详细请看这里
然后这些事件又由SpringBoard接收，它只接收收按键(锁屏/静音
等)，触摸，加速，接近传感器等几种 Event
接着用mach port转发给需要的App进程
随后苹果注册的那个 Source1 就会触发回调，并调用 
_UIApplicationHandleEventQueue()进行应用内部的分发
_UIApplicationHandleEventQueue()把IOHIDEvent处理包
装成UIEvent进行处理分发，我们平时的UIGesture/处理屏幕旋
转/发送给 UIWindow/UIButton 点击、touchesBegin/
Move/End/Cancel这些事件，都是在这个回调中完成
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift100KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift100KVC/" class="post-title-link" itemprop="url">KVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:39:46" itemprop="dateCreated datePublished" datetime="2018-08-14T19:39:46+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。
键值编码必需的方法在非正式协议NSKeyValueCoding中声明，
默认在NSObject中实现。
</code></pre>
<h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><pre><code>-(id)  valueForKey: (NSString *) key
返回表示属性的键字符串所对应的值。如果不能取得值
，则将引起接收器调用方法valueForUndefinedKey:。
-(void)setValue: (id) value  forKey: (NSString*) key
</code></pre>
<h2 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h2><pre><code>1.接收器中如果有key访问器
（或getKey、isKey、_key、_getKey、setKey）则使用它。
2.没有访问器时，使用接收器的类方法
accessInstanceVariablesDirectly来查询。返回YES时，如果存在实例
变量key（或_key、isKey、_isKey等）则返回或设置其值。使用引用计数管
理方式时，实例变量如果为对象，则旧值会被自动释放，新值被保存并代入。
+(BOOL)accessInstanceVariablesDirectly
通常定义为返回YES，可以在子类中改变。该类方法返回YES时，使用键值编码
可以访问该类的实例变量。返回NO时不可以访问。只要该方法返回YES，实例变
量的可视属性即使有@private修饰，也可以访问。
3.既没有访问器也没有实例变量时，将引起接收器调用方法
valueForUndefinedKey:或setValue:forUndefinedKey:。
-(id) valueForUndefinedKey: (NSStirng *) key
不能取得键字符串对应的值时，从方法valueForKey：中调用该方法。默认情
况下，该方法的执行会触发NSUndefinedKeyException。不过，通过在子类
中修改定义，就可以返回其他对象。
- (void) setValue:(id)value forUndefinedKey:(NSString *) key
不能设置键字符串key对应的属性值时，从方法setValue:forKey中调用该方
法。默认情况下，该方法的执行会触发异常NSUndefinedKeyException。不
过，通过在子类中修改定义，可以返回其他对象。
4.   如果该返回值不是对象，则返回被适当的对象包装的值；设置值时也应先
包装成相应的对象。
属性为对象时，该对象还可能持有属性。这时候可以用“.”连接表示键的字符
串，这种表示方式称为键路径。只要能找到对象，点和键多长都没有关系。
- (id)valueForKeyPath:(NSString *) keyPath
以点切分键路径，并使用第一个键向接收器发送valueForKey：方法。然后，
再使用键路径的下一个键，向得到的对象发送valueForKey：方法，如此反复
操作，返回最后获得的对象。
- (void)setValue:(id) value forKeyPath:(NSString *) keyPath
与valueForKeyPath：方法一样取出对象，这里只对路径中的最后一个键调用
setValue：forKey：方法，并设定属性值为value。
</code></pre>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="KVC提供了验证Key对应的Value是否可用的方法："><a href="#KVC提供了验证Key对应的Value是否可用的方法：" class="headerlink" title="KVC提供了验证Key对应的Value是否可用的方法："></a>KVC提供了验证Key对应的Value是否可用的方法：</h3><pre><code>(BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;  
</code></pre>
<h3 id="KVC对数值和结构体型属性的支持"><a href="#KVC对数值和结构体型属性的支持" class="headerlink" title="KVC对数值和结构体型属性的支持"></a>KVC对数值和结构体型属性的支持</h3><h2 id="NSMutableDictionary的setObject和setValue的区别，哪一个add-nil对象会crash"><a href="#NSMutableDictionary的setObject和setValue的区别，哪一个add-nil对象会crash" class="headerlink" title="NSMutableDictionary的setObject和setValue的区别，哪一个add nil对象会crash"></a>NSMutableDictionary的setObject和setValue的区别，哪一个add nil对象会crash</h2><pre><code>1, setObject：forkey：中value是不能够为nil的，不然会报错。
setValue：forKey：中value能够为nil，但是当value为nil的时候，会自动调用removeObject：forKey方法
2, setValue：forKey：中key的参数只能够是NSString类型，而setObject：forKey：的可以是任何类型
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">365</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
