<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一般是求值问题，核心是穷举找状态转移方程 剪绳子最大乘积、大数求余 推论一： 将绳子 以相等的长度等分为多段 ，得到的乘积最大。 推论二： 尽可能将绳子以长度 3 等分为多段时，乘积最大。 最优3等分，次优，剩下个2。最差，剩下个1，将最后一个3，分成2 + 2 快速幂解析 当我们计算出来 x^2 之后就可以只进行三次乘法就可以了，相对于之前的 7 次乘法，时间大大减少了。 正则表达式匹配   表">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="http://example.com/2020/09/06/M_Swift148%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="一般是求值问题，核心是穷举找状态转移方程 剪绳子最大乘积、大数求余 推论一： 将绳子 以相等的长度等分为多段 ，得到的乘积最大。 推论二： 尽可能将绳子以长度 3 等分为多段时，乘积最大。 最优3等分，次优，剩下个2。最差，剩下个1，将最后一个3，分成2 + 2 快速幂解析 当我们计算出来 x^2 之后就可以只进行三次乘法就可以了，相对于之前的 7 次乘法，时间大大减少了。 正则表达式匹配   表">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-06T09:30:42.000Z">
<meta property="article:modified_time" content="2020-09-06T09:30:42.000Z">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/09/06/M_Swift148%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>动态规划 | Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift148%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          动态规划
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:42" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:42+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <pre><code>一般是求值问题，核心是穷举找状态转移方程
剪绳子最大乘积、大数求余
推论一： 将绳子 以相等的长度等分为多段 ，得到的乘积最大。
推论二： 尽可能将绳子以长度 3 等分为多段时，乘积最大。
最优3等分，次优，剩下个2。最差，剩下个1，将最后一个3，分成2 + 2
快速幂解析
当我们计算出来 x^2 之后就可以只进行三次乘法就可以了，相对于之前的 7 次乘法，时间大大减少了。
正则表达式匹配  
表示数值的字符串  
把数字翻译成字符串 
最长不含重复字符的子字符串  
n个骰子的点数  
股票买卖问题
打家劫舍问题
nSum问题
高楼扔鸡蛋问题
子集背包问题
完全背包问题
汉洛塔
三个人分别点了三家外卖，又一个外卖小哥配送，他有多少种配送方式
写个算法，输出2~100的素数
赛马题，网上能搜到
问一个有关花开通知蜜蜂，花关通知蜜蜂的问题；
要求想一个时间复杂度为O1的解法，来解决一个2的平方的算法题（答 无限空间换时间的策略）如何计算x^n
ACID银行家算法
一个不多于5位数的整数，反序处理problem；
一个多边形分割方法
从篮子里如何取苹果的一个算法;
火星文字
基本计算器
分治
</code></pre>
<h2 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h2><pre><code>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
</code></pre>
<p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br>并每次 向右 或者 向下 移动一格<br>class Solution {<br>    public int maxValue(int[][] grid) {<br>        int m = grid.length, n = grid[0].length;<br>        for(int i = 0; i &lt; m; i++) {<br>            for(int j = 0; j &lt; n; j++) {<br>                if(i == 0 &amp;&amp; j == 0) continue;<br>                if(i == 0) grid[i][j] += grid[i][j - 1] ;<br>                else if(j == 0) grid[i][j] += grid[i - 1][j];<br>                else grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]);<br>            }<br>        }<br>        return grid[m - 1][n - 1];<br>    }<br>}<br>递归<br>    斐波那契数列<br>斐波那契数列<br>递归法：<br>    function Fibonacci(int n) {<br>        if(n &lt; 0){<br>            return 0;<br>        }<br>        if(n == 0){<br>            return 0;<br>        }else if(n == 1){<br>            return 1;<br>        }else return Fibonacci(n-1)+ Fibonacci(n-2);<br>    }<br>动态规划：<br>class Solution {<br>    public int fib(int n) {<br>        int a = 0, b = 1, sum;<br>        for(int i = 0; i &lt; n; i++){<br>            sum = (a + b) % 1000000007;<br>            a = b;<br>            b = sum;<br>        }<br>        return a;<br>    }<br>}<br>    青蛙跳台阶问题（本质是求斐波那契数列）<br>问用递归写一个阶乘算法</p>
<p>n个骰子的点数<br>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>使用动态规划解决问题一般分为三步：<br>表示状态<br>找出状态转移方程<br>边界处理</p>
<h2 id="掷骰子"><a href="#掷骰子" class="headerlink" title="掷骰子"></a>掷骰子</h2><p>首先用数组的第一维来表示阶段，也就是投掷完了几枚骰子。<br>然后用第二维来表示投掷完这些骰子后，可能出现的点数。<br>数组的值就表示，该阶段各个点数出现的次数。<br>class Solution {<br>public:<br>    vector<double> twoSum(int n) {<br>        int dp[15][70];<br>        memset(dp, 0, sizeof(dp));<br>        for (int i = 1; i &lt;= 6; i ++) {<br>            dp[1][i] = 1;<br>        }<br>        for (int i = 2; i &lt;= n; i ++) {<br>            for (int j = i; j &lt;= 6*i; j ++) {<br>                for (int cur = 1; cur &lt;= 6; cur ++) {<br>                    if (j - cur &lt;= 0) {<br>                        break;<br>                    }<br>                    dp[i][j] += dp[i-1][j-cur];<br>                }<br>            }<br>        }<br>        int all = pow(6, n);<br>        vector<double> ret;<br>        for (int i = n; i &lt;= 6 * n; i ++) {<br>            ret.push_back(dp[n][i] * 1.0 / all);<br>        }<br>        return ret;<br>    }<br>};<br>使用随机数<br>使得n-1点数概率数组和1点数概率数组元素两两相乘，并将乘积结果加到n点数概率数组上。<br>基本思路如上，然后我们可以根据动态规划的套路：<br>1.构造dp数组：tmp[]为n个骰子的点数概率数组，pre[]为n-1个骰子的点数概率数组，一个骰子的点数概率数组显然是6个六分之一,不需要另设数组。<br>2.初始化dp数组：pre[]={1/6d,1/6d,1/6d,1/6d,1/6d,1/6d}<br>3.构造状态转移方程:tmp[x+y]+=pre[x]<em>num[y];<br>    public double[] twoSum(int n) {<br>        double pre[]={1/6d,1/6d,1/6d,1/6d,1/6d,1/6d};<br>        for(int i=2;i&lt;=n;i++){<br>            double tmp[]=new double[5</em>i+1];<br>            for(int j=0;j&lt;pre.length;j++)<br>                for(int x=0;x&lt;6;x++)<br>                    tmp[j+x]+=pre[j]/6;<br>            pre=tmp;<br>        }<br>        return pre;<br>    }</p>
<h2 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h2><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。<br>方法一： 集合 Set + 遍历</p>
<p>遍历五张牌，遇到大小王（即 0直接跳过。<br>判别重复： 利用 Set 实现遍历判重， Set<br>获取最大 / 最小的牌： 借助辅助变量 ma 和 mi ，遍历统计即可。<br>class Solution {<br>    public boolean isStraight(int[] nums) {<br>        Set<Integer> repeat = new HashSet&lt;&gt;();<br>        int max = 0, min = 14;<br>        for(int num : nums) {<br>            if(num == 0) continue; // 跳过大小王<br>            max = Math.max(max, num); // 最大牌<br>            min = Math.min(min, num); // 最小牌<br>            if(repeat.contains(num)) return false; // 若有重复，提前返回 false<br>            repeat.add(num); // 添加此牌至 Set<br>        }<br>        return max - min &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子<br>    }<br>}<br>方法二：排序 + 遍历<br>class Solution {<br>    public boolean isStraight(int[] nums) {<br>        int joker = 0;<br>        Arrays.sort(nums); // 数组排序<br>        for(int i = 0; i &lt; 4; i++) {<br>            if(nums[i] == 0) joker++; // 统计大小王数量<br>            else if(nums[i] == nums[i + 1]) return false; // 若有重复，提前返回 false<br>        }<br>        return nums[4] - nums[joker] &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子<br>    }<br>}</p>
<h2 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>class Solution {<br>    public int maxProfit(int[] prices) {<br>        int cost = Integer.MAX_VALUE, profit = 0;<br>        for(int price : prices) {<br>            cost = Math.min(cost, price);<br>            profit = Math.max(profit, price - cost);<br>        }<br>        return profit;<br>    }<br>}</p>
<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>class Solution {<br>    public int nthUglyNumber(int n) {<br>        int a = 0, b = 0, c = 0;<br>        int[] dp = new int[n];<br>        dp[0] = 1;<br>        for(int i = 1; i &lt; n; i++) {<br>            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;<br>            dp[i] = Math.min(Math.min(n2, n3), n5);<br>            if(dp[i] == n2) a++;<br>            if(dp[i] == n3) b++;<br>            if(dp[i] == n5) c++;<br>        }<br>        return dp[n - 1];<br>    }<br>}</p>
<h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2><p>动态规划<br>遍历数组时计算当前最大值，不断更新<br>class Solution {<br>    public int maxProduct(int[] nums) {<br>        int max = Integer.MIN_VALUE, imax = 1, imin = 1;<br>        for(int i=0; i&lt;nums.length; i++){<br>            if(nums[i] &lt; 0){<br>              int tmp = imax;<br>              imax = imin;<br>              imin = tmp;<br>            }<br>            imax = Math.max(imax<em>nums[i], nums[i]);<br>            imin = Math.min(imin</em>nums[i], nums[i]);</p>
<pre><code>        max = Math.max(max, imax);
    &#125;
    return max;
&#125;
</code></pre>
<p>}</p>
<h2 id="实现一个基本的计算器来计算一个简单的字符串表达式的值。"><a href="#实现一个基本的计算器来计算一个简单的字符串表达式的值。" class="headerlink" title="实现一个基本的计算器来计算一个简单的字符串表达式的值。"></a>实现一个基本的计算器来计算一个简单的字符串表达式的值。</h2><p>先把乘除法的值计算出来，最终将所有的运算简化成只有加法。<br>将表达式（中缀）转化为后缀<br>将后缀计算出结果<br>class Solution {<br>    public int calculate(String s) {<br>        Stack<Integer> numStack = new Stack&lt;&gt;();</p>
<pre><code>    char lastOp = &#39;+&#39;;
    char[] arr = s.toCharArray();
    for(int i = 0; i &lt; arr.length; i ++)&#123;
        if(arr[i] == &#39; &#39;) continue;

        if(Character.isDigit(arr[i]))&#123;
            int tempNum = arr[i] - &#39;0&#39;;
            while(++i &lt; arr.length &amp;&amp; Character.isDigit(arr[i]))&#123;
                tempNum = tempNum * 10 + (arr[i] - &#39;0&#39;);
            &#125; i--;

            if(lastOp == &#39;+&#39;) numStack.push(tempNum);
            else if(lastOp == &#39;-&#39;) numStack.push(-tempNum);
            else numStack.push(res(lastOp, numStack.pop(), tempNum));
        &#125; else lastOp = arr[i];
    &#125;

    int ans = 0;
    for(int num : numStack) ans += num;
    return ans;
&#125;

private int res(char op, int a, int b)&#123;
    if(op == &#39;*&#39;) return a * b;
    else if(op == &#39;/&#39;) return a / b;
    else if(op == &#39;+&#39;) return a + b; //其实加减运算可以忽略
    else return a - b;
&#125;
</code></pre>
<p>}</p>
<h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>class LRUCache {<br>    // key -&gt; Node(key, val)<br>    private HashMap&lt;Integer, Node&gt; map;<br>    // Node(k1, v1) &lt;-&gt; Node(k2, v2)…<br>    private DoubleList cache;<br>    // 最大容量<br>    private int cap;</p>
<pre><code>public LRUCache(int capacity) &#123;
    this.cap = capacity;
    map = new HashMap&lt;&gt;();
    cache = new DoubleList();
&#125;

public int get(int key) &#123;
    if (!map.containsKey(key))
        return -1;
    int val = map.get(key).val;
    // 利用 put 方法把该数据提前
    put(key, val);
    return val;
&#125;

public void put(int key, int val) &#123;
    // 先把新节点 x 做出来
    Node x = new Node(key, val);
    
    if (map.containsKey(key)) &#123;
        // 删除旧的节点，新的插到头部
        cache.remove(map.get(key));
        cache.addFirst(x);
        // 更新 map 中对应的数据
        map.put(key, x);
    &#125; else &#123;
        if (cap == cache.size()) &#123;
            // 删除链表最后一个数据
            Node last = cache.removeLast();
            map.remove(last.key);
        &#125;
        // 直接添加到头部
        cache.addFirst(x);
        map.put(key, x);
    &#125;
&#125;
</code></pre>
<p>}</p>
<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><pre><code>输入一个字符串，打印出该字符串中字符的所有排列。
输入：s = &quot;abc&quot;
输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]
    回溯法
     对于一个长度为 n 的字符串（假设字符互不重复）n×(n−1)×(n−2)…×2×1 种方案
 根据字符串排列的特点，考虑深度优先搜索所有排列方案。
重复方案与剪枝： 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。
     * 回溯算法框架：解决一个问题，实际上就是一个决策树的遍历过程：
 * 1. 路径：做出的选择
 * 2. 选择列表：当前可以做的选择
 * 3. 结束条件：到达决策树底层，无法再做选择的条件
字符串的排列可以抽象为一棵决策树：
    List&lt;String&gt; res = new LinkedList&lt;&gt;();
    char[] c;
    public String[] permutation(String s) &#123;
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    &#125;
    void dfs(int x) &#123;
        if(x == c.length - 1) &#123;
            res.add(String.valueOf(c)); // 添加排列方案
            return;
        &#125;
        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
        for(int i = x; i &lt; c.length; i++) &#123;
            if(set.contains(c[i])) continue; // 重复，因此剪枝
            set.add(c[i]);
            swap(i, x); // 交换，将 c[i] 固定在第 x 位 
            dfs(x + 1); // 开启固定第 x + 1 位字符
            swap(i, x); // 恢复交换
        &#125;
    &#125;
    void swap(int a, int b) &#123;
        char tmp = c[a];
        c[a] = c[b];
        c[b] = tmp;
    &#125;
</code></pre>
<h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><p>List&lt;List<Integer>&gt; res = new LinkedList&lt;&gt;();</p>
<p>/* 主函数，输入一组不重复的数字，返回它们的全排列 */<br>List&lt;List<Integer>&gt; permute(int[] nums) {<br>    // 记录「路径」<br>    LinkedList<Integer> track = new LinkedList&lt;&gt;();<br>    backtrack(nums, track);<br>    return res;<br>}</p>
<p>// 路径：记录在 track 中<br>// 选择列表：nums 中不存在于 track 的那些元素<br>// 结束条件：nums 中的元素全都在 track 中出现<br>void backtrack(int[] nums, LinkedList<Integer> track) {<br>    // 触发结束条件<br>    if (track.size() == nums.length) {<br>        res.add(new LinkedList(track));<br>        return;<br>    }</p>
<pre><code>for (int i = 0; i &lt; nums.length; i++) &#123;
    // 排除不合法的选择
    if (track.contains(nums[i]))
        continue;
    // 做选择
    track.add(nums[i]);
    // 进入下一层决策树
    backtrack(nums, track);
    // 取消选择
    track.removeLast();
&#125;
</code></pre>
<p>}</p>
<h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h2><p>给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。<br>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。<br>vector&lt;vector<string>&gt; res;</p>
<p>/* 输入棋盘边长 n，返回所有合法的放置 */<br>vector&lt;vector<string>&gt; solveNQueens(int n) {<br>    // ‘.’ 表示空，’Q’ 表示皇后，初始化空棋盘。<br>    vector<string> board(n, string(n, ‘.’));<br>    backtrack(board, 0);<br>    return res;<br>}</p>
<p>// 路径：board 中小于 row 的那些行都已经成功放置了皇后<br>// 选择列表：第 row 行的所有列都是放置皇后的选择<br>// 结束条件：row 超过 board 的最后一行<br>void backtrack(vector<string>&amp; board, int row) {<br>    // 触发结束条件<br>    if (row == board.size()) {<br>        res.push_back(board);<br>        return;<br>    }</p>
<pre><code>int n = board[row].size();
for (int col = 0; col &lt; n; col++) &#123;
    // 排除不合法选择
    if (!isValid(board, row, col)) 
        continue;
    // 做选择
    board[row][col] = &#39;Q&#39;;
    // 进入下一行决策
    backtrack(board, row + 1);
    // 撤销选择
    board[row][col] = &#39;.&#39;;
&#125;
</code></pre>
<p>}<br>/* 是否可以在 board[row][col] 放置皇后？ */<br>bool isValid(vector<string>&amp; board, int row, int col) {<br>    int n = board.size();<br>    // 检查列是否有皇后互相冲突<br>    for (int i = 0; i &lt; n; i++) {<br>        if (board[i][col] == ‘Q’)<br>            return false;<br>    }<br>    // 检查右上方是否有皇后互相冲突<br>    for (int i = row - 1, j = col + 1;<br>            i &gt;= 0 &amp;&amp; j &lt; n; i–, j++) {<br>        if (board[i][j] == ‘Q’)<br>            return false;<br>    }<br>    // 检查左上方是否有皇后互相冲突<br>    for (int i = row - 1, j = col - 1;<br>            i &gt;= 0 &amp;&amp; j &gt;= 0; i–, j–) {<br>        if (board[i][j] == ‘Q’)<br>            return false;<br>    }<br>    return true;<br>}</p>
<p>int openLock(String[] deadends, String target) {<br>    // 记录需要跳过的死亡密码<br>    Set<String> deads = new HashSet&lt;&gt;();<br>    for (String s : deadends) deads.add(s);<br>    // 记录已经穷举过的密码，防止走回头路<br>    Set<String> visited = new HashSet&lt;&gt;();<br>    Queue<String> q = new LinkedList&lt;&gt;();<br>    // 从起点开始启动广度优先搜索<br>    int step = 0;<br>    q.offer(“0000”);<br>    visited.add(“0000”);</p>
<pre><code>while (!q.isEmpty()) &#123;
    int sz = q.size();
    /* 将当前队列中的所有节点向周围扩散 */
    for (int i = 0; i &lt; sz; i++) &#123;
        String cur = q.poll();

        /* 判断是否到达终点 */
        if (deads.contains(cur))
            continue;
        if (cur.equals(target))
            return step;

        /* 将一个节点的未遍历相邻节点加入队列 */
        for (int j = 0; j &lt; 4; j++) &#123;
            String up = plusOne(cur, j);
            if (!visited.contains(up)) &#123;
                q.offer(up);
                visited.add(up);
            &#125;
            String down = minusOne(cur, j);
            if (!visited.contains(down)) &#123;
                q.offer(down);
                visited.add(down);
            &#125;
        &#125;
    &#125;
    /* 在这里增加步数 */
    step++;
&#125;
// 如果穷举完都没找到目标密码，那就是找不到了
return -1;
</code></pre>
<p>}</p>
<h2 id="给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。"><a href="#给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。" class="headerlink" title="给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。"></a>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</h2><p>输入: [10,2]<br>输出: 210<br>想法<br>为了构建最大数字，我们希望越高位的数字越大越好。<br>当数字是多位时，我们构建s1，s2，将s1+s2 和s2 + s1 进行比较，哪个大哪个放前面<br>class Solution {<br>    private class LargerNumberComparator implements Comparator<String> {<br>        @Override<br>        public int compare(String a, String b) {<br>            String order1 = a + b;<br>            String order2 = b + a;<br>           return order2.compareTo(order1);<br>        }<br>    }</p>
<pre><code>public String largestNumber(int[] nums) &#123;
    // Get input integers as strings.
    String[] asStrs = new String[nums.length];
    for (int i = 0; i &lt; nums.length; i++) &#123;
        asStrs[i] = String.valueOf(nums[i]);
    &#125;

    // Sort strings according to custom comparator.
    Arrays.sort(asStrs, new LargerNumberComparator());

    // If, after being sorted, the largest number is `0`, the entire number
    // is zero.
    if (asStrs[0].equals(&quot;0&quot;)) &#123;
        return &quot;0&quot;;
    &#125;

    // Build largest number from sorted array.
    String largestNumberStr = new String();
    for (String numAsStr : asStrs) &#123;
        largestNumberStr += numAsStr;
    &#125;

    return largestNumberStr;
&#125;
</code></pre>
<p>}</p>
<h2 id="摆动排序"><a href="#摆动排序" class="headerlink" title="摆动排序"></a>摆动排序</h2><p>输入: nums = [1, 5, 1, 1, 6, 4]<br>输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]</p>
<ol>
<li><p>解法1：排序<br>首先，我们可以很容易想到一种简单的解法：将数组进行排序，然后从中间位置进行等分（如果数组长度为奇数，则将中间的元素分到前面），然后将两个数组进行穿插。<br>但是这一解法有一个问题，例如，对于数组[1, 2, 2, 3]，按照这种做法求得的结果仍为[1, 2, 2, 3]<br>为了方便阅读，我们在下文中定义较小的子数组为数组A，较大的子数组为数组B。显然，出现上述现象是因为nums中存在重复元素。实际上，由于穿插之后，相邻元素必来自不同子数组，所以A或B内部出现重复元素是不会出现上述现象的。所以，出现上述情况其实是因为数组A和数组B出现了相同元素，我们用r来表示这一元素。而且我们可以很容易发现，如果A和B都存在r，那么r一定是A的最大值，B的最小值，这意味着r一定出现在A的尾部，B的头部。其实，如果这一数字的个数较少，不会出现这一现象，只有当这一数字个数达到原数组元素总数的一半，才会在穿插后的出现在相邻位置。<br>class Solution {</p>
<p> /**</p>
<ul>
<li>先排序再穿插</li>
<li>O(nlogn)+O(n)=O(nlogn)</li>
<li>@param nums</li>
<li>/<br>public void wiggleSort(int[] nums) {<br>  //排序<br>  Arrays.sort(nums);<br>  int len=nums.length,i = 0;<br>  int[] smaller=new int[len%2==0?len/2:(len/2+1)],bigger=new int[len/2];<br>  //复制<br>  System.arraycopy(nums,0,smaller,0,smaller.length);<br>  System.arraycopy(nums,smaller.length,bigger,0,len/2);<br>  //穿插<br>  for (; i &lt; len / 2; i++) {<pre><code>  nums[2*i]=smaller[smaller.length-1-i];
  nums[2*i+1]=bigger[len/2-1-i];
</code></pre>
  }<br>  if (len%2!=0) nums[2*i]=smaller[smaller.length-1-i];<br>}<br>}<h2 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="计算右侧小于当前元素的个数"></a>计算右侧小于当前元素的个数</h2>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。<br>输入：[5,2,6,1]<br>输出：[2,1,1,0]<br>解释：<br>5 的右侧有 2 个更小的元素 (2 和 1)<br>2 的右侧仅有 1 个更小的元素 (1)<br>6 的右侧有 1 个更小的元素 (1)<br>1 的右侧有 0 个更小的元素<br>方法一：离散化树状数组<br>class Solution {<br>private int[] c;<br>private int[] a;</li>
</ul>
<p> public List<Integer> countSmaller(int[] nums) {</p>
<pre><code> List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;(); 
 discretization(nums);
 init(nums.length + 5);
 for (int i = nums.length - 1; i &gt;= 0; --i) &#123;
     int id = getId(nums[i]);
     resultList.add(query(id - 1));
     update(id);
 &#125;
 Collections.reverse(resultList);
 return resultList;
</code></pre>
<p> }</p>
<p> private void init(int length) {</p>
<pre><code> c = new int[length];
 Arrays.fill(c, 0);
</code></pre>
<p> }</p>
<p> private int lowBit(int x) {</p>
<pre><code> return x &amp; (-x);
</code></pre>
<p> }</p>
<p> private void update(int pos) {</p>
<pre><code> while (pos &lt; c.length) &#123;
     c[pos] += 1;
     pos += lowBit(pos);
 &#125;
</code></pre>
<p> }</p>
<p> private int query(int pos) {</p>
<pre><code> int ret = 0;
 while (pos &gt; 0) &#123;
     ret += c[pos];
     pos -= lowBit(pos);
 &#125;

 return ret;
</code></pre>
<p> }</p>
<p> private void discretization(int[] nums) {</p>
<pre><code> Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
 for (int num : nums) &#123;
     set.add(num);
 &#125;
 int size = set.size();
 a = new int[size];
 int index = 0;
 for (int num : set) &#123;
     a[index++] = num;
 &#125;
 Arrays.sort(a);
</code></pre>
<p> }</p>
<p> private int getId(int x) {</p>
<pre><code> return Arrays.binarySearch(a, x) + 1;
</code></pre>
<p> }<br>}</p>
<h2 id="小偷问题"><a href="#小偷问题" class="headerlink" title="小偷问题"></a>小偷问题</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>方法一：动态规划 + 滚动数组<br>class Solution {<br> public int rob(int[] nums) {</p>
<pre><code> if (nums == null || nums.length == 0) &#123;
     return 0;
 &#125;
 int length = nums.length;
 if (length == 1) &#123;
     return nums[0];
 &#125;
 int[] dp = new int[length];
 dp[0] = nums[0];
 dp[1] = Math.max(nums[0], nums[1]);
 for (int i = 2; i &lt; length; i++) &#123;
     dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
 &#125;
 return dp[length - 1];
</code></pre>
<p> }<br>}</p>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p>动态规划<br>public class Solution {<br> public int lengthOfLIS(int[] nums) {</p>
<pre><code> if (nums.length == 0) &#123;
     return 0;
 &#125;
 int[] dp = new int[nums.length];
 dp[0] = 1;
 int maxans = 1;
 for (int i = 1; i &lt; dp.length; i++) &#123;
     int maxval = 0;
     for (int j = 0; j &lt; i; j++) &#123;
         if (nums[i] &gt; nums[j]) &#123;
             maxval = Math.max(maxval, dp[j]);
         &#125;
     &#125;
     dp[i] = maxval + 1;
     maxans = Math.max(maxans, dp[i]);
 &#125;
 return maxans;
</code></pre>
<p> }<br>}<br>贪心 + 二分查找<br>class Solution {<br>public:<br> int lengthOfLIS(vector<int>&amp; nums) {</p>
<pre><code> int len = 1, n = (int)nums.size();
 if (n == 0) return 0;
 vector&lt;int&gt; d(n + 1, 0);
 d[len] = nums[0];
 for (int i = 1; i &lt; n; ++i) &#123;
     if (nums[i] &gt; d[len]) d[++len] = nums[i];
     else&#123;
         int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
         while (l &lt;= r) &#123;
             int mid = (l + r) &gt;&gt; 1;
             if (d[mid] &lt; nums[i]) &#123;
                 pos = mid;
                 l = mid + 1;
             &#125;
             else r = mid - 1;
         &#125;
         d[pos + 1] = nums[i];
     &#125;
 &#125;
 return len;
</code></pre>
<p> }<br>};</p>
<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br>方法一、搜索回溯 [超出时间限制]<br>public class Solution {</p>
</li>
</ol>
<p>  public int coinChange(int[] coins, int amount) {<br>    return coinChange(0, coins, amount);<br>  }</p>
<p>  private int coinChange(int idxCoin, int[] coins, int amount) {<br>    if (amount == 0)<br>      return 0;<br>    if (idxCoin &lt; coins.length &amp;&amp; amount &gt; 0) {<br>      int maxVal = amount / coins[idxCoin];<br>      int minCost = Integer.MAX_VALUE;<br>      for (int x = 0; x &lt;= maxVal; x++) {<br>        if (amount &gt;= x * coins[idxCoin]) {<br>          int res = coinChange(idxCoin + 1, coins, amount - x * coins[idxCoin]);<br>          if (res != -1)<br>            minCost = Math.min(minCost, res + x);<br>        }<br>      }<br>      return (minCost == Integer.MAX_VALUE)? -1: minCost;<br>    }<br>    return -1;<br>  }<br>}<br>方法二、动态规划-自上而下 [通过]<br>public class Solution {</p>
<p>  public int coinChange(int[] coins, int amount) {<br>    if (amount &lt; 1) return 0;<br>    return coinChange(coins, amount, new int[amount]);<br>  }</p>
<p>  private int coinChange(int[] coins, int rem, int[] count) {<br>    if (rem &lt; 0) return -1;<br>    if (rem == 0) return 0;<br>    if (count[rem - 1] != 0) return count[rem - 1];<br>    int min = Integer.MAX_VALUE;<br>    for (int coin : coins) {<br>      int res = coinChange(coins, rem - coin, count);<br>      if (res &gt;= 0 &amp;&amp; res &lt; min)<br>        min = 1 + res;<br>    }<br>    count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;<br>    return count[rem - 1];<br>  }<br>}<br>方法三、动态规划：自下而上 [通过]<br>public class Solution {<br>  public int coinChange(int[] coins, int amount) {<br>    int max = amount + 1;<br>    int[] dp = new int[amount + 1];<br>    Arrays.fill(dp, max);<br>    dp[0] = 0;<br>    for (int i = 1; i &lt;= amount; i++) {<br>      for (int j = 0; j &lt; coins.length; j++) {<br>        if (coins[j] &lt;= i) {<br>          dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);<br>        }<br>      }<br>    }<br>    return dp[amount] &gt; amount ? -1 : dp[amount];<br>  }<br>}</p>
<h2 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a>矩阵中的最长递增路径</h2><p>本文面向高阶读者者。它引入了以下概念：深度优先搜索，记忆化，动态规划和拓扑排序。本文解释了动态规划和拓扑排序的关系。</p>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>输出: 5</p>
<p>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。<br>我们将问题抽象在一个无向无权图中，每个单词作为节点，差距只有一个字母的两个单词之间连一条边。问题变成找到从起点到终点的最短路径，如果存在的话。因此可以使用广度优先搜索方法。<br>方法 1：广度优先搜索<br>class Solution {<br>  public int ladderLength(String beginWord, String endWord, List<String> wordList) {</p>
<pre><code>// Since all words are of same length.
int L = beginWord.length();

// Dictionary to hold combination of words that can be formed,
// from any given word. By changing one letter at a time.
Map&lt;String, List&lt;String&gt;&gt; allComboDict = new HashMap&lt;&gt;();

wordList.forEach(
    word -&gt; &#123;
      for (int i = 0; i &lt; L; i++) &#123;
        // Key is the generic word
        // Value is a list of words which have the same intermediate generic word.
        String newWord = word.substring(0, i) + &#39;*&#39; + word.substring(i + 1, L);
        List&lt;String&gt; transformations = allComboDict.getOrDefault(newWord, new ArrayList&lt;&gt;());
        transformations.add(word);
        allComboDict.put(newWord, transformations);
      &#125;
    &#125;);

// Queue for BFS
Queue&lt;Pair&lt;String, Integer&gt;&gt; Q = new LinkedList&lt;&gt;();
Q.add(new Pair(beginWord, 1));

// Visited to make sure we don&#39;t repeat processing same word.
Map&lt;String, Boolean&gt; visited = new HashMap&lt;&gt;();
visited.put(beginWord, true);

while (!Q.isEmpty()) &#123;
  Pair&lt;String, Integer&gt; node = Q.remove();
  String word = node.getKey();
  int level = node.getValue();
  for (int i = 0; i &lt; L; i++) &#123;

    // Intermediate words for current word
    String newWord = word.substring(0, i) + &#39;*&#39; + word.substring(i + 1, L);

    // Next states are all the words which share the same intermediate state.
    for (String adjacentWord : allComboDict.getOrDefault(newWord, new ArrayList&lt;&gt;())) &#123;
      // If at any point if we find what we are looking for
      // i.e. the end word - we can return with the answer.
      if (adjacentWord.equals(endWord)) &#123;
        return level + 1;
      &#125;
      // Otherwise, add it to the BFS Queue. Also mark it visited
      if (!visited.containsKey(adjacentWord)) &#123;
        visited.put(adjacentWord, true);
        Q.add(new Pair(adjacentWord, level + 1));
      &#125;
    &#125;
  &#125;
&#125;

return 0;
</code></pre>
<p>  }<br>}</p>
<h2 id="计算网格中岛屿的数量"><a href="#计算网格中岛屿的数量" class="headerlink" title="计算网格中岛屿的数量"></a>计算网格中岛屿的数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。<br>输入:<br>[<br>[‘1’,’1’,’1’,’1’,’0’],<br>[‘1’,’1’,’0’,’1’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’0’,’0’,’0’]<br>]<br>输出: 1<br>方法一：深度优先搜索<br>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。</p>
<h2 id="找出那个只出现了一次的元素"><a href="#找出那个只出现了一次的元素" class="headerlink" title="找出那个只出现了一次的元素"></a>找出那个只出现了一次的元素</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>方法一：位运算<br>class Solution {<br>    public int singleNumber(int[] nums) {<br>        int single = 0;<br>        for (int num : nums) {<br>            single ^= num;<br>        }<br>        return single;<br>    }<br>}</p>
<p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。<br>如果小数部分为循环小数，则将循环的部分括在括号内。<br>不需要复杂的数学知识，只需要数学的基本知识。了解长除法的运算规则。<br>注意边界情况！列出所有你可以想到的测试数据并验证你的代码。<br>长除法：核心思想是当余数出现循环的时候，对应的商也会循环。<br>需要用一个哈希表记录余数出现在小数部分的位置，当你发现已经出现的余数，就可以将重复出现的小数部分用括号括起来。</p>
<h2 id="找到若干个完全平方数"><a href="#找到若干个完全平方数" class="headerlink" title="找到若干个完全平方数"></a>找到若干个完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。<br>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.<br>class Solution {</p>
<p>  public int numSquares(int n) {<br>    int dp[] = new int[n + 1];<br>    Arrays.fill(dp, Integer.MAX_VALUE);<br>    // bottom case<br>    dp[0] = 0;</p>
<pre><code>// pre-calculate the square numbers.
int max_square_index = (int) Math.sqrt(n) + 1;
int square_nums[] = new int[max_square_index];
for (int i = 1; i &lt; max_square_index; ++i) &#123;
  square_nums[i] = i * i;
&#125;

for (int i = 1; i &lt;= n; ++i) &#123;
  for (int s = 1; s &lt; max_square_index; ++s) &#123;
    if (i &lt; square_nums[s])
      break;
    dp[i] = Math.min(dp[i], dp[i - square_nums[s]] + 1);
  &#125;
&#125;
return dp[n];
</code></pre>
<p>  }<br>}</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/06/M_Swift147%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="prev" title="字符串">
      <i class="fa fa-chevron-left"></i> 字符串
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/06/M_Swift149%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="next" title="位运算">
      位运算 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-number">1.</span> <span class="nav-text">礼物的最大价值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%B7%E9%AA%B0%E5%AD%90"><span class="nav-number">2.</span> <span class="nav-text">掷骰子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="nav-number">3.</span> <span class="nav-text">扑克牌中的顺子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="nav-number">4.</span> <span class="nav-text">股票的最大利润</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%91%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">丑数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">6.</span> <span class="nav-text">乘积最大子数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%E6%9D%A5%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%E3%80%82"><span class="nav-number">7.</span> <span class="nav-text">实现一个基本的计算器来计算一个简单的字符串表达式的值。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LRU%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">LRU算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">9.</span> <span class="nav-text">字符串的排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-number">10.</span> <span class="nav-text">全排列问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">n皇后问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E7%BB%84%E9%9D%9E%E8%B4%9F%E6%95%B4%E6%95%B0%EF%BC%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%AE%83%E4%BB%AC%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E4%B9%8B%E7%BB%84%E6%88%90%E4%B8%80%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B4%E6%95%B0%E3%80%82"><span class="nav-number">12.</span> <span class="nav-text">给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F"><span class="nav-number">13.</span> <span class="nav-text">摆动排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text">计算右侧小于当前元素的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E5%81%B7%E9%97%AE%E9%A2%98"><span class="nav-number">15.</span> <span class="nav-text">小偷问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">16.</span> <span class="nav-text">最长上升子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">17.</span> <span class="nav-text">零钱兑换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="nav-number">18.</span> <span class="nav-text">矩阵中的最长递增路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E7%BD%91%E6%A0%BC%E4%B8%AD%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">19.</span> <span class="nav-text">计算网格中岛屿的数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E9%82%A3%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%BA%86%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">20.</span> <span class="nav-text">找出那个只出现了一次的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E8%8B%A5%E5%B9%B2%E4%B8%AA%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">21.</span> <span class="nav-text">找到若干个完全平方数</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">288</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
