<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="drawRect和layouSubviews 的区别1   layoutSubviews方便数据计算，2   drawRect方便视图重绘。layoutSubviews在以下情况下会被调用：addSubview、改变view的大小、滚动一个UIScrollView、旋转Screen会触发父UIView上的layoutSubviews，调用setLayoutSubviews。drawRect在以下情">
<meta property="og:type" content="article">
<meta property="og:title" content="UI相关">
<meta property="og:url" content="http://example.com/2020/09/06/M_Swift140%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%861/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="drawRect和layouSubviews 的区别1   layoutSubviews方便数据计算，2   drawRect方便视图重绘。layoutSubviews在以下情况下会被调用：addSubview、改变view的大小、滚动一个UIScrollView、旋转Screen会触发父UIView上的layoutSubviews，调用setLayoutSubviews。drawRect在以下情">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-06T09:30:03.000Z">
<meta property="article:modified_time" content="2020-09-06T09:30:03.000Z">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/09/06/M_Swift140%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%861/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>UI相关 | Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift140%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%861/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          UI相关
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:03" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:03+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="drawRect和layouSubviews-的区别"><a href="#drawRect和layouSubviews-的区别" class="headerlink" title="drawRect和layouSubviews 的区别"></a>drawRect和layouSubviews 的区别</h2><p>1   layoutSubviews方便数据计算，<br>2   drawRect方便视图重绘。<br>layoutSubviews在以下情况下会被调用：<br>addSubview、改变view的大小、滚动一个UIScrollView、<br>旋转Screen会触发父UIView上的layoutSubviews，调用setLayoutSubviews。<br>drawRect在以下情况下会被调用：（必须有大小）<br>loadView，viewDidLoad，sizeToFit<br>直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:<br>强制layout刷新,调用setNeedsLayout来代替</p>
<h2 id="setNeedsLayout与layoutIfNeeded的区别"><a href="#setNeedsLayout与layoutIfNeeded的区别" class="headerlink" title="setNeedsLayout与layoutIfNeeded的区别"></a>setNeedsLayout与layoutIfNeeded的区别</h2><p>UIView的setNeedsDisplay和setNeedsLayout两个方法都是异步执行的。<br>而setNeedsDisplay会自动调用drawRect方法，这样可以拿到<br>UIGraphicsGetCurrentContext进行绘制；而setNeedsLayout会默认调用<br>layoutSubViews，给当前的视图做了标记；layoutIfNeeded<br>查找是否有标记，如果有标记及立刻刷新。<br>只有setNeedsLayout和layoutIfNeeded这二者合起来使用，才会起到立刻刷新的效果。</p>
<h2 id="Core-Graphics的更底层的是什么；"><a href="#Core-Graphics的更底层的是什么；" class="headerlink" title="Core Graphics的更底层的是什么；"></a>Core Graphics的更底层的是什么；</h2><p>　1）获取上下文<br>　2）绘制路径<br>　3）添加路径到上下文<br>　4）修改图形状态参数<br>　5）渲染上下文<br>　CGContextRef、CGPathRef、UIBezierPath</p>
<h2 id="iOS-保持界面流畅的技巧"><a href="#iOS-保持界面流畅的技巧" class="headerlink" title="iOS 保持界面流畅的技巧"></a>iOS 保持界面流畅的技巧</h2><p>1.预排版，提前计算<br>在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。<br>尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式<br>2.预渲染，提前绘制<br>例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了<br>避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。<br>3.异步绘制<br>4.全局并发线程<br>5.高效的图片异步加载</p>
<h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h2 id="消息转发的流程"><a href="#消息转发的流程" class="headerlink" title="消息转发的流程"></a>消息转发的流程</h2><p>（动态添加） 首先是征询接收者所属的类,看其是否能动态添加调用的方法,来处理当前这个未知的选择子;<br>-(BOOL)resolveInstanceMethod:(SEL)selector<br>（重定向-备援接收者）寻找是否在其他对象内有该方法实现,并将该消息转发给这个对象</p>
<ul>
<li>(id)forwardingTargetForSelector:(SEL)aSelector<br>生成方法签名，然后系统用这个方法签名生成NSInvocation对象。</li>
<li>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector<br>改变选择子</li>
<li>(void)forwardInvocation:(NSInvocation *)Invocation<br>抛出异常</li>
<li>(void)doesNotRecognizeSelector:(SEL)aSelector方法<h2 id="runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）"><a href="#runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）"></a>runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</h2>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,<br>以及参数类型,其实selector本质就是方法名称,<br>通过这个方法名称就可以在方法列表中找到对应的方法实现.<h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2>在runtime中所有类都存在一个哈希表中，在table的buckets中存储</li>
</ul>
<ol>
<li>加载所有类到类的gdb_objc_realized_classes表中</li>
<li>对所有类做重映射</li>
<li>将所有SEL都注册到namedSelectors表中</li>
<li>修复函数指针遗留</li>
<li>将所有Protocol添加到protocol_map表中</li>
<li>将所有Protocol重映射</li>
<li>初始化所有非懒加载的类，进行rw，ro操作 </li>
<li>便利所有懒加载类，执行初始化</li>
<li>处理所有Category包括Class和MetaClass</li>
<li>初始化所有未初始化类<h2 id="msgSend参数都有哪些；"><a href="#msgSend参数都有哪些；" class="headerlink" title="msgSend参数都有哪些；"></a>msgSend参数都有哪些；</h2><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="NSObject内存分配、ISA指针的内存大小"><a href="#NSObject内存分配、ISA指针的内存大小" class="headerlink" title="NSObject内存分配、ISA指针的内存大小"></a>NSObject内存分配、ISA指针的内存大小</h2>在64位架构下，如果他的第一位是0 。则代表他是一个 isa<br>指针,表示当前对象的类对象的地址，如果是1，则不仅代表一个 isa<br>指针,类对象的地址，里面还存储内存管理相关的内容，第二位代表是否有关联对象，<br>0代表没有，1代表有（has_assoc）,第三位,代表当前对象是否含有C++代码<br>（has_cxx_dtor）,3-15表示当前对象的类对象内存地址,16-31<br>,也是，32-35位也是，也就是说，13+16+4 = 33位<h2 id="子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool"><a href="#子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool" class="headerlink" title="子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool"></a>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool</h2>在子线程你创建了 Pool 的话，产生的 Autorelease 对象就会交给 pool 去管理。<br>如果你没有创建 Pool ，但是产生了 Autorelease 对象，就会调用 autoreleaseNoPage<br>方法。在这个方法中，会自动帮你创建一个 hotpage（hotPage 可以理解为当前正在使用的<br>AutoreleasePoolPage，如果你还是不理解，可以先看看 Autoreleasepool<br>的源代码，再来看这个问题 ），并调用 page-&gt;add(obj)将对象添加到<br>AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！<h2 id="dealloc调用流程"><a href="#dealloc调用流程" class="headerlink" title="dealloc调用流程"></a>dealloc调用流程</h2></li>
<li>直接调用 objc_destructInstance()。</li>
<li>之后调用C的 free() 函数。</li>
<li>objc_destructInstance() 调用流程<br>1&gt;.先判断 hasCxxDtor，是否有析构函数（析构器），<br>要调用 object_cxxDestruct() ，释放（清除成员变量）。<br>2&gt;.再判断hasAssocitatedObjects，如果有的话，<br>要调用object_remove_associations()， 移除当前对象的关联对象。<br>3&gt;.然后调用 clearDeallocating()。 </li>
<li>clearDeallocating() 调用流程<br>0&gt;. 判断isa是否优化过，从arm64架构开始，对isa进行了优化，<br>变成了一个共用体（union）结构，所以结果一般是优化过了。<br>判断是否有弱引用或者引用计数<br>1&gt;.执行 clearDeallocating_slow()。<br>2&gt;.再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。<br>3&gt;.接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。<br>4&gt;.至此为止，Dealloc 的执行流程结束。<h2 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h2>启用Zombie Object进行悬挂指针的检测。<br>应用Product -&gt; Analysis进行内存泄露的初步检测。<br>可以在xcode的build setting中打开implicit retain of ‘self’<br>within blocks，xcode编译器会给出警告，逐个排查警告。<br>应用Leak Instrument进行内存泄露查找。<br>在以上方法不奏效的情况下，通过查看dealloc是否调用查看某个class是否泄露的问题</li>
</ol>
<h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><p>内存泄漏（memory leak）：是指申请的内存空间使用完毕之后未回收。<br>一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，<br>最终导致程序crash。（因此，开发中我们要尽量避免内存泄漏的出现）<br>内存溢出（out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用。<br>通俗理解就是内存不够用了，通常在运行大型应用或游戏时，应用或游戏所需要<br>的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。最终导致机器重启或者程序crash。<br>第一种：静态分析方法（Analyze）<br>第二种：动态分析方法（Instrument工具库里的Leaks）。一般推荐使用第二种。</p>
<h2 id="举例一些I-O操作的例子"><a href="#举例一些I-O操作的例子" class="headerlink" title="举例一些I/O操作的例子"></a>举例一些I/O操作的例子</h2><p>1）阻塞IO<br>2）非阻塞IO<br>3）IO复用（select和poll）<br>4）信号驱动IO（sigio）<br>5）异步IO（aio_）</p>
<h2 id="如何开辟一块内存；"><a href="#如何开辟一块内存；" class="headerlink" title="如何开辟一块内存；"></a>如何开辟一块内存；</h2><p>其实结论就是 实际分配内存是按照16字节对齐的 内存大小都是16 的倍数。</p>
<h2 id="怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手"><a href="#怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手" class="headerlink" title="怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手"></a>怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手</h2><p>复用机制<br>少使用xib<br>不要阻塞线程<br>图片优化<br>合理使用数组字典优化查找速度<br>懒加载<br>缓存<br>一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。可以用单例来处理，避免日期格式转换<br>选择正确的数据格式，json、xml、二进制数据流<br>少使用webView<br>优化tableView<br>选择正确的数据持久化</p>
<h2 id="问堆和栈的区别。"><a href="#问堆和栈的区别。" class="headerlink" title="问堆和栈的区别。"></a>问堆和栈的区别。</h2><p>（答对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。）</p>
<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop概念及数据结构、事件循环机制"><a href="#RunLoop概念及数据结构、事件循环机制" class="headerlink" title="RunLoop概念及数据结构、事件循环机制"></a>RunLoop概念及数据结构、事件循环机制</h2><p>CFRunLoop<br>CFRunLoopMode<br>Source/Timer/Observer<br>source0<br>需要手动唤醒线程<br>source1<br>具备唤醒线程的能力<br>CFRunLoopObserver<br>观测时间点<br>kCFRunLoopEntry<br>kCFRunLoopBeforeTimers<br>CommonMode的特性<br>NSRunLoopCommonModes<br>commonMode不是实际存在的一种mode<br>是同步Source/Timer/Observer到多个Mode中的一种技术方案<br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个<br>Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个<br>Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出<br>Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的<br>Source/Timer/Observer，让其互不影响。</p>
<h2 id="RunLoop和多线程"><a href="#RunLoop和多线程" class="headerlink" title="RunLoop和多线程"></a>RunLoop和多线程</h2><p>在异步线程中下载很多图片,如果失败了,该如何处理?请结合RunLoop来谈谈解决方案<br>在异步线程中启动一个RunLoop重新发送网络请求,下载图片<br>如果程序启动就需要执行一个耗时操作，你会怎么做？<br>开启一个异步的子线程，并启动它的RunLoop来执行该耗时操作</p>
<h2 id="你在开发过程中怎么使用RunLoop？什么应用场景？"><a href="#你在开发过程中怎么使用RunLoop？什么应用场景？" class="headerlink" title="你在开发过程中怎么使用RunLoop？什么应用场景？"></a>你在开发过程中怎么使用RunLoop？什么应用场景？</h2><p>开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来的消息，处理其他事件）<br>在子线程中开启一个定时器<br>在子线程中进行一些长期监控<br>可以控制定时器在特定模式下运行<br>可以让某些事件（行为，任务）在特定模式下执行<br>可以添加observer监听RunLoop的状态，比如监听点击事件的处理（比如在所有点击事件前做一些处理）<br>1）NSTimer<br>2）ImageView显示：控制方法在特定的模式下可用<br>3）PerformSelector<br>4）常驻线程：在子线程中开启一个runloop<br>5）自动释放池</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="GCD、NSOperation、NSThread区别优缺点"><a href="#GCD、NSOperation、NSThread区别优缺点" class="headerlink" title="GCD、NSOperation、NSThread区别优缺点"></a>GCD、NSOperation、NSThread区别优缺点</h2><p>第一种：pthread<br>    a.特点：<br>        1）一套通用的多线程API<br>        2）适用于Unix\Linux\Windows等系统<br>        3）跨平台\可移植<br>        4）使用难度大<br>    b.使用语言：c语言<br>    c.使用频率：几乎不用<br>    d.线程生命周期：由程序员进行管理<br>第二种：NSThread<br>    a.特点：<br>        1）使用更加面向对象<br>        2）简单易用，可直接操作线程对象<br>        b.使用语言：OC语言<br>        c.使用频率：偶尔使用<br>        d.线程生命周期：由程序员进行管理<br>第三种：GCD<br>    a.特点：<br>        1）旨在替代NSThread等线程技术<br>        2）充分利用设备的多核（自动）<br>    b.使用语言：C语言<br>    c.使用频率：经常使用<br>    d.线程生命周期：自动管理<br>第四种：NSOperation<br>    a.特点：<br>        1）基于GCD（底层是GCD）<br>        2）比GCD多了一些更简单实用的功能<br>        3）使用更加面向对象<br>    b.使用语言：OC语言<br>    c.使用频率：经常使用<br>    d.线程生命周期：自动管理</p>
<h2 id="如何让多个网络请求完成后执行下一步"><a href="#如何让多个网络请求完成后执行下一步" class="headerlink" title="如何让多个网络请求完成后执行下一步"></a>如何让多个网络请求完成后执行下一步</h2><p>  dispatch_group_t</p>
<h2 id="多个网络请求顺序执行后执行下一步"><a href="#多个网络请求顺序执行后执行下一步" class="headerlink" title="多个网络请求顺序执行后执行下一步"></a>多个网络请求顺序执行后执行下一步</h2><pre><code>dispatch_semaphore_wait
</code></pre>
<h2 id="异步操作两组数据时-执行完第一组之后-才能执行第二组"><a href="#异步操作两组数据时-执行完第一组之后-才能执行第二组" class="headerlink" title="异步操作两组数据时, 执行完第一组之后, 才能执行第二组"></a>异步操作两组数据时, 执行完第一组之后, 才能执行第二组</h2><pre><code>dispatch_barrier_async
</code></pre>
<h2 id="你知道哪些锁、使用场景"><a href="#你知道哪些锁、使用场景" class="headerlink" title="你知道哪些锁、使用场景"></a>你知道哪些锁、使用场景</h2><p>@synchronized 一个对象层面的锁，锁住了整个对象，底层使用了互斥递归<br>锁来实现<br>pathread_mutex 互斥锁（c语言）和信号量的实现原理类似，也是阻塞线程并进入睡眠<br>，需要进行上下文切换。<br>NSLock 对象锁-简单的互斥锁（内部封装了一个 pthread_mutex）<br>NSCondition （封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件<br>NSCondition和NSLock、@synchronized等是不同的是，<br>NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。<br>这是非常强大。<br>NSConditionLock （借助 NSCondition 来实现，本质是生产者-消费者模型）<br>也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。<br>NSRecursiveLock 递归锁有时候“加锁代码”中存在递归调用，递归开始前加<br>dispatch_semaphore GCD中信号量，也可以解决资源抢占问题,<br>支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；<br>每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，<br>直到信号量大于0开始执行<br>OSSpinLock 自旋锁(不建议使用)<br>自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取<br>锁就需要等待a线程释放锁。在没有获得锁的期间，b线程会一直处于忙等的状<br>态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太<br>划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。</p>
<h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><p>相同点：都能保证同一时间只有一个线程访问共享资源。<br>都能保证线程安全。<br>不同点：<br>互斥锁：如果共享数据已经有其他线程加锁了，线程会进入<br>休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的<br>线程会被唤醒。<br>自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环<br>的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会<br>立即执行。<br>自旋锁的效率高于互斥锁。<br>由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放<br>自旋锁，否则等待该自旋锁的线程会一直在哪里自旋，这就会浪<br>费CPU时间。<br>持有自旋锁的线程在sleep之前应该释放自旋锁以便其他可以获得<br>该自旋锁。内核编程中，如果持有自旋锁的代码sleep了就可能<br>导致整个系统挂起。</p>
<h2 id="runloop与autoreleasepool的关系"><a href="#runloop与autoreleasepool的关系" class="headerlink" title="runloop与autoreleasepool的关系"></a>runloop与autoreleasepool的关系</h2><p>(AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组成)<br>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），<br>除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址<br>iOS里的TaggedPointer不适用autorelesepool<br>AutoreleasePool 在 runloop 在开始时被push，在runloop休眠时(beforewaiting状态)pop</p>
<h2 id="GCD-在Runloop中的使用"><a href="#GCD-在Runloop中的使用" class="headerlink" title="GCD 在Runloop中的使用"></a>GCD 在Runloop中的使用</h2><pre><code>GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。
</code></pre>
<h2 id="GCD-Global队列创建线程进行耗时操作的风险"><a href="#GCD-Global队列创建线程进行耗时操作的风险" class="headerlink" title="GCD Global队列创建线程进行耗时操作的风险"></a>GCD Global队列创建线程进行耗时操作的风险</h2><p>dispatch_async 函数分发到全局队列不一定会新建线程执行任务，全局队列底层有一个的线程池，如果线程池满了，<br> 那么后续的任务会被 block 住，等待前面的任务执行完成，才会继续执行。如果线程池中的线程<br> 长时间不结束，后续堆积的任务会越来越多，此时就会存在 APP crash的风险。<br> 避免使用 GCD Global 队列创建 Runloop 常驻线程</p>
<h2 id="NSOperation数据结构"><a href="#NSOperation数据结构" class="headerlink" title="NSOperation数据结构"></a>NSOperation数据结构</h2><p>ddDependency操作依赖性<br>KVO 兼容属性<br>cancelAllOperations 响应取消命令<br>start;执行操作<br>NSBlockOperation：用于管理一个或多个block的并发执行。<br>NSInvocationOperation：NSInvocationOperation类是NSOperation的一个具体<br>子类，用于开启一个操作，该操作包括在指定对象上调用一个selector。</p>
<h2 id="重写NSOperation需要注意的点"><a href="#重写NSOperation需要注意的点" class="headerlink" title="重写NSOperation需要注意的点"></a>重写NSOperation需要注意的点</h2><p>1、如果需要自定义并发执行的 Operation，必须重写start、main、isExecuting、isFinished、isAsynchronous方法。<br>2、在 operation 的 main 方法里面，必须提供 autorelease pool,因为你的 operation 完成后需要销毁。<br>3、一旦你的 operation 开始了，必须通过 KVO，告诉所有的监听者，现在该operation的执行状态。<br>4、调用时，如果需要并发执行 Operation，必须调用performOperation:方法，当然，也可以改为自定义其他方法或者直接在start方法添加多线程调用。<br>5、对于自定义的 Operation 类，如果不需要并发执行，可以直接调用start</p>
<h2 id="进程中的哪些空间是线程所共有的？"><a href="#进程中的哪些空间是线程所共有的？" class="headerlink" title="进程中的哪些空间是线程所共有的？"></a>进程中的哪些空间是线程所共有的？</h2><p>  一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)</p>
<h2 id="使用GCD需要注意什么；"><a href="#使用GCD需要注意什么；" class="headerlink" title="使用GCD需要注意什么；"></a>使用GCD需要注意什么；</h2><p>dispatch_sync同步死锁（循环等待）<br>重复的获取互斥资源引发的等待（加锁）<br>开启过多线程<br>线程和RunLoop，子线程不会开启runloop</p>
<h2 id="runloop跟runtime有没有关联"><a href="#runloop跟runtime有没有关联" class="headerlink" title="runloop跟runtime有没有关联"></a>runloop跟runtime有没有关联</h2><p>个人想到的是autoreleasepool、其他的不好找<br>runloop中事件源都是由运行时runtime触发</p>
<h2 id="CPU和GPU怎么相互合作的"><a href="#CPU和GPU怎么相互合作的" class="headerlink" title="CPU和GPU怎么相互合作的"></a>CPU和GPU怎么相互合作的</h2><p>命令缓冲区包含了一个命令队列，由CPU向其中添加命令，而由GPU从中读取命令<br>，添加和读取的过程是互相独立的。命令缓冲区使得CPU和GPU可以互相独立工作<br>。当CPU需要渲染一些对象时，它可以向命令缓冲区中添加命令，而当GPU完成了上<br>一次的渲染任务后，它就可以从命令队列中再取出一个命令并执行它。</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTPS-TLS-SSL加密过程"><a href="#HTTPS-TLS-SSL加密过程" class="headerlink" title="HTTPS TLS/SSL加密过程"></a>HTTPS TLS/SSL加密过程</h2><p>1、客户端向服务器端索要并验证公钥。<br>2、双方协商生成”对话密钥”。<br>3、双方采用”对话密钥”进行加密通信。<br>其中，前两个阶段，被称为“握手阶段”。<br>TLS握手过程有单向验证和双向验证之分，简单解释一下，单向验证就是<br>server端将证书发送给客户端，客户端验证server端证书的合法性等，<br>例如百度、新浪、google等普通的https网站，双向验证则是不仅客户端会验<br>证server端的合法性，同时server端也会验证客户端的合法性，例如银行网银登陆<br>，支付宝登陆交易等。<br>1、确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>2、一个服务器生成的随机数（Sever Random），稍后用于生成”对话密钥”。<br>3、确认使用的加密方法，比如RSA公钥加密。<br>4、服务器证书（Certificate）。<br>5、支持的一些SSL/TLS扩展。</p>
<h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><p>①客户端发送报文进行SSL通信。报文中包含客户端支持的SSL的指定版本、<br>加密组件列表（加密算法及密钥长度等）。<br>②服务器应答，并在应答报文中包含SSL版本以及加密组件。<br>服务器的加密组件内容是从接受到的客户端加密组件内筛选出来的。<br>③服务器发送报文，报文中包含公开密钥证书。<br>④服务器发送报文通知客户端，最初阶段SSL握手协商部分结束。<br>⑤SSL第一次握手结束之后，客户端发送一个报文作为回应。<br>报文中包含通信加密中使用的一种被称Pre-master<br>secret的随机密码串。该密码串已经使用服务器的公钥加密。<br>⑥客户端发送报文，并提示服务器，此后的报文通信会采用<br>Pre-master secret密钥加密。<br>⑦客户端发送Finished报文。该报文包含连接至今全部报文的<br>整体校验值。这次握手协商是否能够完成成功，要以服务器是否能够正确解密该报文作为判定标准。<br>⑧服务器同样发送Change Cipher Spec报文。<br>⑨服务器同样发送Finished报文。<br>⑩服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。<br>⑪应用层协议通信，即发送HTTP响应。<br>⑫最后由客户端断开链接。断开链接时，发送close_nofify报文</p>
<h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。<br>  由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>  对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，<br>  再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>  pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，<br>  如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用<br>  pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和<br>  服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机<br>  可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，<br>  随机性增加的可不是一。</p>
<h2 id="TCP特点及与UDP区别"><a href="#TCP特点及与UDP区别" class="headerlink" title="TCP特点及与UDP区别"></a>TCP特点及与UDP区别</h2><p>基于连接（点对点）<br>传输数据前需要建立好连接，然后在传输<br>双工通信<br>TCP连接一旦建立，就可以在连接上进行双向的通信<br>基于字节流而非报文<br>将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制能够保证TCP协议的有序性和完整性，因此TCP能够提供可靠性传输</p>
<p>可靠传输<br>拥塞控制<br>慢启动，拥塞避免，拥塞发生，快速恢复四个算法<br>流量控制能力</p>
<h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><p>DNS服务器一般分三种，根DNS服务器，顶级DNS服务器，权威DNS服务器。<br>1）浏览器缓存　　<br>2）系统缓存　　<br>3）路由器缓存　　　　<br>4） ISP（互联网服务提供商）DNS缓存<br>5）根域名服务器　　　<br>6）顶级域名服务器　　<br>8）保存结果至缓存</p>
<h2 id="HTTP请求头都有哪些内容"><a href="#HTTP请求头都有哪些内容" class="headerlink" title="HTTP请求头都有哪些内容"></a>HTTP请求头都有哪些内容</h2><p>Accept: <em>/</em>(客户端能接收的资源类型)<br>Accept-Language: en-us(客户端接收的语言类型)<br>Connection: Keep-Alive(维护客户端和服务端的连接关系)<br>Host: localhost:8080(连接的目标主机和端口号)<br>Referer: <a target="_blank" rel="noopener" href="http://localhost/links.asp(%E5%91%8A%E8%AF%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%91%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%93%AA%E9%87%8C)">http://localhost/links.asp(告诉服务器我来自于哪里)</a><br>User-Agent: Mozilla/4.0(客户端版本号的名字)<br>Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)<br>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)<br>Cookie(客户端暂存服务端的信息)<br>Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间</p>
<h2 id="哪些加密算法"><a href="#哪些加密算法" class="headerlink" title="哪些加密算法"></a>哪些加密算法</h2><p>MD5加密算法<br>RSA加密算法<br>AES加密算法<br>Base64加密算法</p>
<h2 id="断点续传怎么实现"><a href="#断点续传怎么实现" class="headerlink" title="断点续传怎么实现;"></a>断点续传怎么实现;</h2><p>续传的文件就好说了，只要给一个续传的标识位置，和对应的字节流就可以了，代码如下:<br>filePath:生成的文件,用来续传用<br>content:将要写入的字节<br>position:续传的字节位置</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p> 单一职责原则<br>      CALayer：动画和视图的显示。<br>      UIView：只负责事件传递、事件响应。<br>      生成的数据模型<br>  开闭原则<br>      对修改关闭，对扩展开放。 要考虑到后续的扩展性，而不是在原有的基础上来回修改<br>  接口隔离原则<br>      使用多个专门的协议、而不是一个庞大臃肿的协议，如<br>      UITableviewDelegate + UITableViewDataSource<br>  依赖倒置原则<br>      抽象不应该依赖于具体实现、具体实现可以依赖于抽象。<br>      调用接口感觉不到内部是如何操作的<br>  里氏替换原则<br>      父类可以被子类无缝替换，且原有的功能不受任何影响 如：KVO<br>  迪米特法则<br>      一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合</p>
<h2 id="iOS有哪些常见的设计模式"><a href="#iOS有哪些常见的设计模式" class="headerlink" title="iOS有哪些常见的设计模式?"></a>iOS有哪些常见的设计模式?</h2><p>01代理委托Delegate是协议的一种<br> ,通过@protocol方式实现，常见的有tableView，textField等。<br> 02观察者 通知机制(notification)和KVO机制(Key-value Observing)<br> 03MVC<br> 04单例（Singleton）,UIApplication, NSBundle, NSNotificationCenter,<br> NSFileManager, NSUserDefault, NSURLCache等都是单例.<br> 05策略<br> 06工厂</p>
<h2 id="内存设计、磁盘设计、网络设计原则"><a href="#内存设计、磁盘设计、网络设计原则" class="headerlink" title="内存设计、磁盘设计、网络设计原则"></a>内存设计、磁盘设计、网络设计原则</h2><p>内存设计:存储的Size,淘汰策略 LRU算法<br>磁盘设计:存储方式\大小限制\淘汰策略<br>网络设计:图片请求最大并发\请求超时策略\请求优先级</p>
<h2 id="MVVM模式思想"><a href="#MVVM模式思想" class="headerlink" title="MVVM模式思想"></a>MVVM模式思想</h2><p>MVVM 即模型-视图-视图模型<br>在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，<br>ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel<br>能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，<br>ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的<br>双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。<br>优点 VIew可以独立于Model的变化和修改，一个ViewModel可以绑定到不同的View上，<br> 降低耦合，增加重用<br> 缺点 过于简单的项目不适用、大型的项目视图状态较多时构建和维护成本太大<br> 合理的运用架构模式有利于项目、团队开发工作，但是到底选择哪个设计模式，</p>
<h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><p>Flux是Facebook用来构建用户端的web应用的应用程序体系架构。<br>它通过利用数据的单向流动为React的可复用的视图组件提供了补充。<br>相比于形式化的框架它更像是一个架构思想，不需要太多新的代码你就可以马上<br>使用Flux构建你的应用。<br>一个 Flux 应用主要包含四个部分：<br>dispatcher<br>处理动作分发，维护 Store 之间的依赖关系<br>stores<br>数据和逻辑部分<br>views<br>React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互<br>actions<br>提供给 dispatcher 传递数据给 store<br>视图上添加的所有的视图组成一个视图多叉树；<br>比如某个UI发生变化后，需要反向到根节点，然后由根节点想下遍历查找需<br>要更新的结点；<br>任何一个子节点是没有权利自我更新的，需要把自我变化更<br>新的消息传递给根节点，由根节点进行更新，相当于由主动行为变成被动行为</p>
<h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：<br>   排版，绘制，UI对象操作。<br>   排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>   绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>   UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。<br>   其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主<br>   线程完成，并且有时后面的操作需要依赖前面操作的结果<br>   （例如TextView创建时可能需要提前计算出文本的大小）。ASDK<br>   所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟<br>   (例如视图的创建、属性的调整)。<br>   为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了<br>   UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如<br>   frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只<br>   通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制<br>   放入了后台线程。但是无论怎么操作，<br>   这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>   ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面<br>   更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了<br>   kCFRunLoopBeforeWaiting 和 kCFRunLoopExit<br>   事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<h2 id="AFNetworking-底层原理分析"><a href="#AFNetworking-底层原理分析" class="headerlink" title="AFNetworking 底层原理分析"></a>AFNetworking 底层原理分析</h2><p>AFNetworking是封装的NSURLSession的网络请求，由五个模块组成：<br>分别由NSURLSession,Security,Reachability,Serialization,UIKit五部分组成<br>NSURLSession：网络通信模块（核心模块） 对应 AFNetworking中的<br>AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager<br>,AFHTTPSessionManager是继承于AFURLSessionmanager的<br>Security：网络通讯安全策略模块 对应 AFSecurityPolicy<br>Reachability：网络状态监听模块 对应AFNetworkReachabilityManager<br>Seriaalization：网络通信信息序列化、反序列化模块 对应AFURLResponseSerialization<br>UIKit：对于iOS UIKit的扩展库</p>
<h2 id="SDWebImage加载图片过程，图片缓存设计"><a href="#SDWebImage加载图片过程，图片缓存设计" class="headerlink" title="SDWebImage加载图片过程，图片缓存设计"></a>SDWebImage加载图片过程，图片缓存设计</h2><p>0、首先显示占位图<br>1、在webimagecache中寻找图片对应的缓存，它是以url为数据索引先在内存中<br>查找是否有缓存；<br>2、如果没有缓存，就通过md5处理过的key来在磁盘中查找<br>对应的数据，如果找到就会把磁盘中的数据加到内存中，并显示出来；<br>3、如果内存和磁盘中都没有找到，就会向远程服务器发送请求，开始下载图片；<br>4、下载完的图片加入缓存中，并写入到磁盘中；<br>5、整个获取图片的过程是在子线程中进行，在主线程中显示。</p>
<h2 id="组建化优缺点"><a href="#组建化优缺点" class="headerlink" title="组建化优缺点"></a>组建化优缺点</h2><p>业务分层、解耦，使代码变得可维护；<br>有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；<br>便于各业务功能拆分、抽离，实现真正的功能复用；<br>分工更加明确，提高开发效率<br>复用性更好，能迅速的组成更多的App</p>
<h2 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h2><p>视图层(View&amp;ViewController)<br>业务逻辑处理(ViewModel)<br>数据层(Model&amp;Engine)<br>数据流<br>数据与数据关系<br>MVVM框架思想<br>ReactiveNative的数据流思想<br>系统UIView更新机制的思想<br>FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想</p>
<h2 id="解耦的方式"><a href="#解耦的方式" class="headerlink" title="解耦的方式"></a>解耦的方式</h2><p>1、组件化<br>2、结合MVVM架构和数据驱动UI模式对原有MVC架构进行了兼容性优化<br>3、通过AOP技术对部分业务进行拆分解耦<br>4、优化事件传递方式</p>
<h2 id="项目中用的技术以及实现；"><a href="#项目中用的技术以及实现；" class="headerlink" title="项目中用的技术以及实现；"></a>项目中用的技术以及实现；</h2><p>1.复杂cell提前缓存行高和UI的frame<br>2.网络请求库的封装<br>3.组建化简单实现<br>4.tableView嵌套滑动<br>5.地图对象的单例封装<br>6.用View代替ViewController的实现<br>7.定时器使用</p>
<h2 id="缓存机制是怎么清除数据的？"><a href="#缓存机制是怎么清除数据的？" class="headerlink" title="缓存机制是怎么清除数据的？"></a>缓存机制是怎么清除数据的？</h2><p>沙盒：iOS系统为每一个应用程序创建一个文件目录,是一个的独立,封闭,安全的空间, 一个沙盒就是一个文件目录。沙盒规定了一个程序只能在自身的沙盒中进行操作,不能去访问其他应用程序的沙盒(iOS8已经部分开放访问)<br>沙盒的作用: 用来存放非代码文件(图片, 音频, 视频, 属性列表(plist), sqlite数据库, 文本文件, 其他等等)</p>
<h2 id="如何进行安全测试；"><a href="#如何进行安全测试；" class="headerlink" title="如何进行安全测试；"></a>如何进行安全测试；</h2><p>ipa包加壳（苹果）<br>敏感信息存储位置<br>通讯网络安全<br>代码混淆</p>
<h2 id="说下生产者-消费者模型，其中的同步机制是怎么样的"><a href="#说下生产者-消费者模型，其中的同步机制是怎么样的" class="headerlink" title="说下生产者-消费者模型，其中的同步机制是怎么样的"></a>说下生产者-消费者模型，其中的同步机制是怎么样的</h2><p>产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。<br>在生产者与消费者之间在加个缓冲区，我们形象的称之为仓库，生产<br>者负责往仓库了进商品，而消费者负责从仓库里拿商品，这就构成了生产者消费者模式。<br>dispatch_semaphore_wait<br>dispatch_semaphore_signal</p>
<h1 id="开发日常"><a href="#开发日常" class="headerlink" title="开发日常"></a>开发日常</h1><h2 id="APP启动时间应从哪些方面优化？"><a href="#APP启动时间应从哪些方面优化？" class="headerlink" title="APP启动时间应从哪些方面优化？"></a>APP启动时间应从哪些方面优化？</h2><p>App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit<br>   Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，<br>   优化需以下方面入手<br>   dylib loading time<br>       核心思想是减少dylibs的引用<br>       合并现有的dylibs（最好是6个以内）<br>       使用静态库<br>   rebase/binding time<br>       核心思想是减少DATA块内的指针<br>       减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）<br>       减少c++虚函数<br>       多使用Swift结构体（推荐使用swift）<br>   ObjC setup time<br>       核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时<br>   initializer time<br>       使用initialize替代load方法<br>       减少使用c/c++的attribute((constructor))；推荐使用<br>       dispatch_once() pthread_once() std:once()等方法<br>       推荐使用swift<br>       不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁<br>       ，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁<br>       不要在初始化中创建线程</p>
<h2 id="如何降低APP包的大小"><a href="#如何降低APP包的大小" class="headerlink" title="如何降低APP包的大小"></a>如何降低APP包的大小</h2><p>可执行文件<br>编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden<br>by Default 设置为 YES，去掉异常支持，Enable C++ Exceptions、Enable<br>Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions<br>利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code<br>编写LLVM插件检测出重复代码、未被调用的代码<br>资源（图片、音频、视频 等）<br>优化的方式可以对资源进行无损的压缩<br>去除没有用到的资源： </p>
<h2 id="UILabel图层混合"><a href="#UILabel图层混合" class="headerlink" title="UILabel图层混合"></a>UILabel图层混合</h2><p>UILabel图层混合解决方法： iOS8以后设置背景色为非透明色并且设置label.layer<br>.masksToBounds=YES让label只会渲染她的实际size区域，<br>就能解决UILabel的图层混合问题<br>iOS8 之前只要设置背景色为非透明的就行<br>为什么设置了背景色但是在iOS8上仍然出现了图层混合呢？<br>UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，<br>而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变。在<br>背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，设<br>置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪 图层混合问题解决了</p>
<h2 id="日常如何检查内存泄露？"><a href="#日常如何检查内存泄露？" class="headerlink" title="日常如何检查内存泄露？"></a>日常如何检查内存泄露？</h2><p>目前我知道的方式有以下几种<br>Memory Leaks<br>Alloctions<br>Analyse<br>Debug Memory Graph<br>MLeaksFinder<br>泄露的内存主要有以下两种：<br>Laek Memory 这种是忘记 Release 操作所泄露的内存。<br>Abandon Memory 这种是循环引用，无法释放掉的内存。</p>
<h2 id="LLDB常用的调试命令？"><a href="#LLDB常用的调试命令？" class="headerlink" title="LLDB常用的调试命令？"></a>LLDB常用的调试命令？</h2><p>po：print object的缩写，表示显示对象的文本描述，如果对象不存在则打印nil。<br>p：可以用来打印基本数据类型。<br>call：执行一段代码 如：call NSLog(@”%@”, @“yang”)<br>expr：动态执行指定表达式<br>bt：打印当前线程堆栈信息 （bt all 打印所有线程堆栈信息）<br>image：常用来寻找栈地址对应代码位置 如：image lookup –address 0xxxx</p>
<h2 id="iOS-常见的崩溃类型有哪些？"><a href="#iOS-常见的崩溃类型有哪些？" class="headerlink" title="iOS 常见的崩溃类型有哪些？"></a>iOS 常见的崩溃类型有哪些？</h2><p>unrecognized selector crash<br>KVO crash<br>NSNotification crash<br>NSTimer crash<br>Container crash<br>NSString crash<br>Bad Access crash （野指针）<br>UI not on Main Thread Crash</p>
<h2 id="iOS-App-稳定性指标及监测"><a href="#iOS-App-稳定性指标及监测" class="headerlink" title="iOS App 稳定性指标及监测"></a>iOS App 稳定性指标及监测</h2><p>开发过程中，主要是通过监控内存使用及泄露，CPU使用率，FPS，启动时间等指标，<br>以及常见的UI的主线程监测，NSAssert断言等，最好能在Debug模式下，实时显<br>示在界面上，针对出现的问题及早解决。</p>
<h2 id="iOS的签名机制是怎么样的"><a href="#iOS的签名机制是怎么样的" class="headerlink" title="iOS的签名机制是怎么样的"></a>iOS的签名机制是怎么样的</h2><p>签名机制：<br>先将应用内容通过摘要算法，得到摘要<br>再用私钥对摘要进行加密得到密文<br>将源文本、密文、和私钥对应的公钥一并发布<br>验证流程：<br>查看公钥是否是私钥方的<br>然后用公钥对密文进行解密得到摘要<br>将APP用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常</p>
<h2 id="instruments它为什么能检测内存泄漏"><a href="#instruments它为什么能检测内存泄漏" class="headerlink" title="instruments它为什么能检测内存泄漏"></a>instruments它为什么能检测内存泄漏</h2><h2 id="推送的原理"><a href="#推送的原理" class="headerlink" title="推送的原理"></a>推送的原理</h2><p>1.由App向iOS设备发送一个注册通知，用户需要同意系统发送推送。<br>2.iOS向APNs远程推送服务器发送App的Bundle Id和设备的UDID。<br>3.APNs根据设备的UDID和App的Bundle Id生成deviceToken再发回给App。<br>4.App再将deviceToken发送给远程推送服务器(自己的服务器), 由服务器保存在数据库中。<br>5.当自己的服务器想发送推送时, 在远程推送服务器中输入要发送的消息并选择发给哪些用户的deviceToken，由远程推送服务器发送给APNs。<br>6.APNs根据deviceToken发送给对应的用户。</p>
<h2 id="项目上线被拒原因"><a href="#项目上线被拒原因" class="headerlink" title="项目上线被拒原因"></a>项目上线被拒原因</h2><p>设计类型的问题，图标、UI等<br>app类型设置不准确<br>第三方资源用到广告等资源</p>
<h2 id="有了解过代码如何编译的嘛"><a href="#有了解过代码如何编译的嘛" class="headerlink" title="有了解过代码如何编译的嘛"></a>有了解过代码如何编译的嘛</h2><p>LLVM编译一个源文件的过程：预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt;<br>   AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件</p>
<h2 id="针对线上版本的崩溃处理；"><a href="#针对线上版本的崩溃处理；" class="headerlink" title="针对线上版本的崩溃处理；"></a>针对线上版本的崩溃处理；</h2><p>UIKit不是线程安全的，执行UIKit操作如果不在主线程很可能造成程序Crash<br>KVO<br>避免 Foundation 类Carsh<br>容器越界（NSArray， NSDictionary,…）<br>unrecognized selector crash (这个很多时候是由于class使用错误导致)<br>第三方工具：友盟<br>dSYMTools分析</p>
<h2 id="Xcode构建过程；"><a href="#Xcode构建过程；" class="headerlink" title="Xcode构建过程；"></a>Xcode构建过程；</h2><p>解析项目文件，获取你项目中的所有文件、target 及其依赖关系、build settings，最后把它变成一个树形结构(有向图)。<br>增量构建。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/06/M_Swift139%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" rel="prev" title="UI相关">
      <i class="fa fa-chevron-left"></i> UI相关
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/06/M_Swift141%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="next" title="数据结构">
      数据结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#drawRect%E5%92%8ClayouSubviews-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">drawRect和layouSubviews 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setNeedsLayout%E4%B8%8ElayoutIfNeeded%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">setNeedsLayout与layoutIfNeeded的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Core-Graphics%E7%9A%84%E6%9B%B4%E5%BA%95%E5%B1%82%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9B"><span class="nav-number">3.</span> <span class="nav-text">Core Graphics的更底层的是什么；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS-%E4%BF%9D%E6%8C%81%E7%95%8C%E9%9D%A2%E6%B5%81%E7%95%85%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="nav-number">4.</span> <span class="nav-text">iOS 保持界面流畅的技巧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Runtime"><span class="nav-number"></span> <span class="nav-text">Runtime</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">消息转发的流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87selector-%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84-IMP-%E5%9C%B0%E5%9D%80%EF%BC%9F%EF%BC%88%E5%88%86%E5%88%AB%E8%80%83%E8%99%91%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-images-%E5%87%BD%E6%95%B0Runtime-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">map_images 函数Runtime 初始化操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#msgSend%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9B"><span class="nav-number">4.</span> <span class="nav-text">msgSend参数都有哪些；</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number"></span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NSObject%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%81ISA%E6%8C%87%E9%92%88%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.</span> <span class="nav-text">NSObject内存分配、ISA指针的内存大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B%E9%BB%98%E8%AE%A4%E4%B8%8D%E4%BC%9A%E5%BC%80%E5%90%AF-Runloop%EF%BC%8C%E9%82%A3%E5%87%BA%E7%8E%B0-Autorelease-%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%8C%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8AutoreleasePool"><span class="nav-number">2.</span> <span class="nav-text">子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dealloc%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">dealloc调用流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">4.</span> <span class="nav-text">怎么检查内存泄露</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.</span> <span class="nav-text">内存泄漏的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E4%B8%80%E4%BA%9BI-O%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">6.</span> <span class="nav-text">举例一些I&#x2F;O操作的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BC%80%E8%BE%9F%E4%B8%80%E5%9D%97%E5%86%85%E5%AD%98%EF%BC%9B"><span class="nav-number">7.</span> <span class="nav-text">如何开辟一块内存；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E5%92%8C%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%98%AF%E4%BD%A0%E8%80%83%E8%99%91%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98-%E4%BB%8E%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E7%9D%80%E6%89%8B"><span class="nav-number">8.</span> <span class="nav-text">怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">9.</span> <span class="nav-text">问堆和栈的区别。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RunLoop"><span class="nav-number"></span> <span class="nav-text">RunLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">RunLoop概念及数据结构、事件循环机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">RunLoop和多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E5%9C%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8RunLoop%EF%BC%9F%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">你在开发过程中怎么使用RunLoop？什么应用场景？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD%E3%80%81NSOperation%E3%80%81NSThread%E5%8C%BA%E5%88%AB%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">GCD、NSOperation、NSThread区别优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%AE%8C%E6%88%90%E5%90%8E%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E6%AD%A5"><span class="nav-number">2.</span> <span class="nav-text">如何让多个网络请求完成后执行下一步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E6%AD%A5"><span class="nav-number">3.</span> <span class="nav-text">多个网络请求顺序执行后执行下一步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%B8%A4%E7%BB%84%E6%95%B0%E6%8D%AE%E6%97%B6-%E6%89%A7%E8%A1%8C%E5%AE%8C%E7%AC%AC%E4%B8%80%E7%BB%84%E4%B9%8B%E5%90%8E-%E6%89%8D%E8%83%BD%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E7%BB%84"><span class="nav-number">4.</span> <span class="nav-text">异步操作两组数据时, 执行完第一组之后, 才能执行第二组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E9%94%81%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.</span> <span class="nav-text">你知道哪些锁、使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E5%92%8C%E4%BA%92%E6%96%A5%E5%AF%B9%E6%AF%94"><span class="nav-number">6.</span> <span class="nav-text">自旋和互斥对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runloop%E4%B8%8Eautoreleasepool%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.</span> <span class="nav-text">runloop与autoreleasepool的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD-%E5%9C%A8Runloop%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">GCD 在Runloop中的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD-Global%E9%98%9F%E5%88%97%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E8%A1%8C%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="nav-number">9.</span> <span class="nav-text">GCD Global队列创建线程进行耗时操作的风险</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSOperation%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">10.</span> <span class="nav-text">NSOperation数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99NSOperation%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="nav-number">11.</span> <span class="nav-text">重写NSOperation需要注意的点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E7%A9%BA%E9%97%B4%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%89%80%E5%85%B1%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">进程中的哪些空间是线程所共有的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8GCD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9B"><span class="nav-number">13.</span> <span class="nav-text">使用GCD需要注意什么；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runloop%E8%B7%9Fruntime%E6%9C%89%E6%B2%A1%E6%9C%89%E5%85%B3%E8%81%94"><span class="nav-number">14.</span> <span class="nav-text">runloop跟runtime有没有关联</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E5%92%8CGPU%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E5%90%88%E4%BD%9C%E7%9A%84"><span class="nav-number">15.</span> <span class="nav-text">CPU和GPU怎么相互合作的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number"></span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS-TLS-SSL%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">HTTPS TLS&#x2F;SSL加密过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">HTTPS过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E4%B8%89%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%8C%E6%9D%A5%E7%94%9F%E6%88%90%E2%80%9D%E4%BC%9A%E8%AF%9D%E5%AF%86%E9%92%A5"><span class="nav-number">3.</span> <span class="nav-text">为什么一定要用三个随机数，来生成”会话密钥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%89%B9%E7%82%B9%E5%8F%8A%E4%B8%8EUDP%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">TCP特点及与UDP区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">DNS解析流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9"><span class="nav-number">6.</span> <span class="nav-text">HTTP请求头都有哪些内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">哪些加密算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.</span> <span class="nav-text">断点续传怎么实现;</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">1.</span> <span class="nav-text">设计原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">iOS有哪些常见的设计模式?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%AE%BE%E8%AE%A1%E3%80%81%E7%A3%81%E7%9B%98%E8%AE%BE%E8%AE%A1%E3%80%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">3.</span> <span class="nav-text">内存设计、磁盘设计、网络设计原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVVM%E6%A8%A1%E5%BC%8F%E6%80%9D%E6%83%B3"><span class="nav-number">4.</span> <span class="nav-text">MVVM模式思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReactNative%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E6%80%9D%E6%83%B3"><span class="nav-number">5.</span> <span class="nav-text">ReactNative的数据流思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncDisplayKit"><span class="nav-number">6.</span> <span class="nav-text">AsyncDisplayKit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AFNetworking-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">7.</span> <span class="nav-text">AFNetworking 底层原理分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImage%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.</span> <span class="nav-text">SDWebImage加载图片过程，图片缓存设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%BB%BA%E5%8C%96%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">9.</span> <span class="nav-text">组建化优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E9%A1%B5%E9%9D%A2%E6%9E%B6%E6%9E%84"><span class="nav-number">10.</span> <span class="nav-text">复杂页面架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E8%80%A6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">11.</span> <span class="nav-text">解耦的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%9B"><span class="nav-number">12.</span> <span class="nav-text">项目中用的技术以及实现；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%B8%85%E9%99%A4%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">缓存机制是怎么清除数据的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%EF%BC%9B"><span class="nav-number">14.</span> <span class="nav-text">如何进行安全测试；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-number">15.</span> <span class="nav-text">说下生产者-消费者模型，其中的同步机制是怎么样的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8"><span class="nav-number"></span> <span class="nav-text">开发日常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#APP%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E5%BA%94%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">APP启动时间应从哪些方面优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8EAPP%E5%8C%85%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.</span> <span class="nav-text">如何降低APP包的大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UILabel%E5%9B%BE%E5%B1%82%E6%B7%B7%E5%90%88"><span class="nav-number">3.</span> <span class="nav-text">UILabel图层混合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%B8%B8%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">日常如何检查内存泄露？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LLDB%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">LLDB常用的调试命令？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B4%A9%E6%BA%83%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">iOS 常见的崩溃类型有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS-App-%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%8C%87%E6%A0%87%E5%8F%8A%E7%9B%91%E6%B5%8B"><span class="nav-number">7.</span> <span class="nav-text">iOS App 稳定性指标及监测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS%E7%9A%84%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-number">8.</span> <span class="nav-text">iOS的签名机制是怎么样的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#instruments%E5%AE%83%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">instruments它为什么能检测内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">推送的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E8%A2%AB%E6%8B%92%E5%8E%9F%E5%9B%A0"><span class="nav-number">11.</span> <span class="nav-text">项目上线被拒原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E4%BB%A3%E7%A0%81%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E7%9A%84%E5%98%9B"><span class="nav-number">12.</span> <span class="nav-text">有了解过代码如何编译的嘛</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E7%BA%BF%E4%B8%8A%E7%89%88%E6%9C%AC%E7%9A%84%E5%B4%A9%E6%BA%83%E5%A4%84%E7%90%86%EF%BC%9B"><span class="nav-number">13.</span> <span class="nav-text">针对线上版本的崩溃处理；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Xcode%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9B"><span class="nav-number">14.</span> <span class="nav-text">Xcode构建过程；</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">400</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
