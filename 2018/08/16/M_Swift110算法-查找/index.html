<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="字符串转化为整数首先判断字符串是否为空，返回0 考虑前面的是否是空格，使用trim()去掉，然后判断长度是否为0，是的话，返回0 判断第一个字符是不是+和-，设置变量sign记录 循环取得字符串的数字，考虑字符串中有非数字，遇到就退出，保留前面的数字 考虑溢出的情况，溢出返回Integer的最大值或最小值 public static int myAutoNumber(String str)&amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="算法-查找">
<meta property="og:url" content="http://example.com/2018/08/16/M_Swift110%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="字符串转化为整数首先判断字符串是否为空，返回0 考虑前面的是否是空格，使用trim()去掉，然后判断长度是否为0，是的话，返回0 判断第一个字符是不是+和-，设置变量sign记录 循环取得字符串的数字，考虑字符串中有非数字，遇到就退出，保留前面的数字 考虑溢出的情况，溢出返回Integer的最大值或最小值 public static int myAutoNumber(String str)&amp;#12">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-08-16T11:39:30.000Z">
<meta property="article:modified_time" content="2018-08-16T11:39:30.000Z">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2018/08/16/M_Swift110%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法-查找 | Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/16/M_Swift110%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法-查找
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-16 19:39:30" itemprop="dateCreated datePublished" datetime="2018-08-16T19:39:30+08:00">2018-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="字符串转化为整数"><a href="#字符串转化为整数" class="headerlink" title="字符串转化为整数"></a>字符串转化为整数</h2><pre><code>首先判断字符串是否为空，返回0
考虑前面的是否是空格，使用trim()去掉，然后判断长度是否为0，是的话，返回0
判断第一个字符是不是+和-，设置变量sign记录
循环取得字符串的数字，考虑字符串中有非数字，遇到就退出，保留前面的数字
考虑溢出的情况，溢出返回Integer的最大值或最小值
public static int myAutoNumber(String str)&#123;
    //首先判断空值
    if(str == null)&#123;
        return 0;
    &#125;
    //去掉空格的情况
    str = str.trim();
    if(str.length() == 0)
    return 0;
    //正负数标志
    int sign = 1;
    int index = 0;
    if(str.charAt(index) == &#39;+&#39;)
        index ++;
    else if(str.charAt(index) == &#39;-&#39;)&#123;
        index ++;
        sign = -1;
    &#125;
    //取得数字部分，遇到溢出和非数字退出
    long number = 0;
    for(; index &lt; str.length();index++)&#123;
        if(str.charAt(index) &lt; &#39;0&#39; &amp;&amp; str.charAt(index) &gt; &#39;9&#39;)&#123;
        break;
    &#125;
    number = number * 10 + (str.charAt(index) - &#39;0&#39;);
    if(number &gt;= Integer.MAX_VALUE)
        break;
    &#125;
    if(number * sign &lt;= Integer.MIN_VALUE)
    return Integer.MIN_VALUE;
    if(number * sign &gt;= Integer.MAX_VALUE)
    return Integer.MAX_VALUE;
    return (int) number * sign;
&#125;
</code></pre>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><pre><code>// 顺序存储结构的递归先序遍历
var tree = [1, 2, 3, 4, 5, , 6, , , 7];
void function preOrderTraverse(x, visit) &#123;
    visit(tree[x]);
    if (tree[2 * x + 1]) preOrderTraverse(2 * x + 1, visit);
    if (tree[2 * x + 2]) preOrderTraverse(2 * x + 2, visit);
    &#125;(0, function (value) &#123;
        console.log(value);
&#125;);

// 链式存储结构的递归先序遍历
BinaryTree.prototype.preOrderTraverse = function preOrderTraverse(visit) &#123;
visit(this.data);
if (this.leftChild) preOrderTraverse.call(this.leftChild, visit);
if (this.rightChild) preOrderTraverse.call(this.rightChild, visit);
&#125;;
非递归
// 链式存储的非递归先序遍历
// 方法1
BinaryTree.prototype.preOrder_stack = function (visit) &#123;
var stack = new Stack();
stack.push(this);
while (stack.top) &#123;
var p;
// 向左走到尽头
while ((p = stack.peek())) &#123;
    p.data &amp;&amp; visit(p.data);
    stack.push(p.leftChild);
&#125;
stack.pop();
if (stack.top) &#123;
    p = stack.pop();
    stack.push(p.rightChild);
&#125;
// 方法2
BinaryTree.prototype.preOrder_stack2 = function (visit) &#123;
var stack = new Stack();
var p = this;
while (p || stack.top) &#123;
    if (p) &#123;
        stack.push(p);
        p.data &amp;&amp; visit(p.data);
        p = p.leftChild;
    &#125; else &#123;
        p = stack.pop();
        p = p.rightChild;
    &#125;
&#125;
</code></pre>
<h2 id="查询链表第N个元素"><a href="#查询链表第N个元素" class="headerlink" title="查询链表第N个元素"></a>查询链表第N个元素</h2><pre><code>第一种方法先求出元素个数，在遍历元素个数-n个，时间复杂度为：O(N+N-、
n)=O(2N-n)。
第二种设置俩个指针，第一个先走N步，第二个开始走。俩者速度一样，时间复
杂度为O(N)。
代码如下：
/** 
* 获取单链表倒数第N个元素 
* @author xiucai 
*/  
public class SingleLinkedList_LastN &#123;  
/** 
* 第一种方法先求出元素个数，在遍历元素个数-n个 
* 时间复杂度为：O(N+N-n)=O(2N-n) 
* @param list 
* @param n 
* @return 
* @throws Exception 
*/  
public static&lt;T&gt; T getLastN1(SingleLinkedList&lt;T&gt; list,int n) throws Exception&#123;  
int count=0;  
Node&lt;T&gt; node=list.head;  
while(node.next!=null)&#123;  
count++;  
node=node.next;  
&#125;  
if(count&lt;n)  
throw new Exception(&quot;单链表元素个数小于 &quot;+n+&quot; !&quot;);  
node=list.head;  
for(int i=0;i&lt;count-n;i++)&#123;  
node=node.next;  
&#125;  
return (T)node.data;  
&#125;  

/** 
* 设置俩个指针，第一个先走N步，第二个开始走。俩者速度一样 
* 时间复杂度为O(N) 
* @param list 
* @param n 
* @return 
* @throws Exception  
*/  
public static&lt;T&gt; T getLastN2(SingleLinkedList&lt;T&gt; list,int n) throws Exception&#123;  
//fastN先走N步，slowN等fastN走N步后在开始走  
Node&lt;T&gt; fastN=list.head,slowN=list.head;  
for(int i=0;i&lt;n;i++)&#123;  
if(fastN.next==null)&#123;  
throw new Exception(&quot;单链表元素个数小于 &quot;+n+&quot; ！&quot;);  
/*try &#123; 

&#125; catch (Exception e) &#123; 
// TODO Auto-generated catch block 
e.printStackTrace(); 
&#125;*/  
&#125;  
fastN=fastN.next;  
&#125;  
while(fastN.next!=null)&#123;  
fastN=fastN.next;  
slowN=slowN.next;  
&#125;  
return (T)slowN.data;  
&#125; 
</code></pre>
<h2 id="100个球三种颜色多少种情况"><a href="#100个球三种颜色多少种情况" class="headerlink" title="100个球三种颜色多少种情况"></a>100个球三种颜色多少种情况</h2><pre><code>//假设白球1个，红球和黄球任意组合，那么有 1，98，98，1
//98 个可能，猜测，觉得应该不对
//那么98 * 98 = 9604
</code></pre>
<h2 id="集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡"><a href="#集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡" class="headerlink" title="集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡"></a>集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡</h2><pre><code>为了解决这个问题，我们可以定义一个哈希表（外部空间），其键值（Key）是
字符，而值（Value）是该字符出现的次数。
同时我们还需要从头开始扫描字符串两次：
1）第一次扫描字符串时，每扫描到一个字符就在哈希表的对应项中把次数加1。
（时间效率O(n)）
2）第二次扫描时，每扫描到一个字符就能从哈希表中得到该字符出现的次数。
这样第一个只出现一次的字符就是符合要求的输出。（时间效率O(n)）
这样算起来，总的时间复杂度仍然是O(n)，满足了题目要求，擦一擦汗，感
叹：这*装得真有点技术！
public class Solution &#123;
public int FirstNotRepeatingChar(String str) &#123;
　if(str == null || str.length() == 0)
    　return -1;
    　int[] sign = new int[256];
    　char[] array = str.toCharArray();
    　for(int i=0;i&lt;array.length;i++)&#123;
    　if(sign[array[i]] &lt; 2)
    　sign[array[i]] ++ ;
　&#125;
　for(int i=0;i&lt;array.length;i++)&#123;
    　if(sign[array[i]] == 1)
    　   return i;
    　&#125;
　   return -1;
　&#125;
&#125;
</code></pre>
<h2 id="最长无重复字符的子串"><a href="#最长无重复字符的子串" class="headerlink" title="最长无重复字符的子串"></a>最长无重复字符的子串</h2><pre><code>思路：[pre,i]表示一个无重复子串，用hash表记录子串中每个字符的出现次
数。初始pre = 0，i = 0，i从左往右扫描字符串，maxLength保存当前最
大长度。每扫描一个字符，根据对应的值来判断这个字符是否已经出现。
如果A[i]已存在, 将pre与当前字符A[i]位置的下一个位置进行比较，选择最
大者作为最新pre所指位置，然后再更新maxLength；   
如果不存在，则继续扫描，(i - pre + 1)与最大长度进行比较，更新
maxLength。   
将A[i]以及对应的位置i保存，更新字符最近出现的位置。
int longestSubstring(string A, int n) &#123;
    map&lt;char, int&gt; m; 
    //map中的键key存放字符串中出现的字符，值value存放该字符当前的位置  
    int maxLength = 0;  //保存最长字串长度  
    int pre = 0;        //记录头指针位置 
    for(int i=0; i&lt;n; i++ )&#123;  
    map&lt;char, int&gt;::iterator iter=m.find(A[i]);
    if(iter!=m.end())&#123;//如果map中已存在当前字符   m[A[i]]
    //更新当前指针位置，如果当前指针大，则使用当前指针，否则使用该指
    针下一个字符的位置
    pre = max(pre, (m[A[i]]+1));
    &#125; 
    maxLength = max(maxLength, i-pre+1);//更新最长字串的长度
    m[A[i]]=i;//修改当前字符的value，记录最新位置     
    &#125;  
    return maxLength; 
&#125;
另一种类似：
int longestSubstring(string A, int n) &#123;
    map&lt;char, int&gt; m; //表示字符串中每个字符是否出现，初始化为
    0，表示未出现  
    int start = 1,MAX = 0;  
    //遍历该字符串，每遍历一个字母时，利用map去找该字母最近一次出现
    是什么时候  
    //中间这一段便是无重复字符的字符串。  
    for (int i = 1; i &lt;= n; i++)&#123;  
    char c = A[i - 1];    
    if (m[c] &gt;= start)&#123;    
    start = m[c] + 1;   
    &#125;
    MAX = max(MAX, i - start + 1); 
    m[c] = i;   //map添加数据  mapStudent[char] = int 
    &#125;    
    return MAX;
&#125;
</code></pre>
<h2 id="二分查找法查找多少次"><a href="#二分查找法查找多少次" class="headerlink" title="二分查找法查找多少次"></a>二分查找法查找多少次</h2><h2 id="寻找距离最近的公共父视图，已知两个节点和根节点"><a href="#寻找距离最近的公共父视图，已知两个节点和根节点" class="headerlink" title="寻找距离最近的公共父视图，已知两个节点和根节点"></a>寻找距离最近的公共父视图，已知两个节点和根节点</h2><pre><code>二叉树查找
栈的push和pop的时间复杂度，实现O（1）的找出栈中最小值的算法（栈只在一端操作，以空间换时间）
</code></pre>
<h2 id="Hash碰撞冲突"><a href="#Hash碰撞冲突" class="headerlink" title="Hash碰撞冲突"></a>Hash碰撞冲突</h2><pre><code>我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么
HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样
时，这就发生了碰撞冲突。如下将介绍如何处理冲突，当然其前提是一致性
hash。
1.开放地址法
开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)
其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为
1,2,3,…m-1，称线性探测再散列。
如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为
1,-1,2,-2,4,-4,9,-9,16,-16,…k*k,-k*k(k&lt;=m/2)，称二次探测再散
列。
如果di取值可能为伪随机数列。称伪随机探测再散列。
2.再哈希法
当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺
点：计算时间增加。
比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第
二位进行哈希，再冲突，第三位，直到不冲突为止
3.链地址法（拉链法）
NSMutableArray以及NSMutableDictionary的设计不是多线程安全的，
当然这种设计的好处是处理速度快，不需要任何锁进行同步，所以我们在使用
Objective-C的这些容器的时候需要注意，在哪个线程中创建它们就在哪个线
程中对它们进行操作。不过在某些情况下，我们由于一些算法或业务需求，需要
在多个线程中共享一个NSMutableArray容器对象，这时候我们需要通过一些
同步机制来实现多线程操作的安全性。
一个对象的引用计数记录在一个hash表中的话，如何保证多线程的时候计数的
准确性？（从上到下加锁消耗太大，可以采用分治，每十个加一个锁）
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/08/16/M_Swift114UI%E7%9B%B8%E5%85%B3/" rel="prev" title="UI相关">
      <i class="fa fa-chevron-left"></i> UI相关
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/10/15/M_Swift117web%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/" rel="next" title="web百度地图使用">
      web百度地图使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B4%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">字符串转化为整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">遍历二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E9%93%BE%E8%A1%A8%E7%AC%ACN%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">3.</span> <span class="nav-text">查询链表第N个元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100%E4%B8%AA%E7%90%83%E4%B8%89%E7%A7%8D%E9%A2%9C%E8%89%B2%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">4.</span> <span class="nav-text">100个球三种颜色多少种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%80%83%E8%99%91%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E4%B8%8E%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B9%B3%E8%A1%A1"><span class="nav-number">5.</span> <span class="nav-text">集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="nav-number">6.</span> <span class="nav-text">最长无重复字符的子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E6%9F%A5%E6%89%BE%E5%A4%9A%E5%B0%91%E6%AC%A1"><span class="nav-number">7.</span> <span class="nav-text">二分查找法查找多少次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E8%B7%9D%E7%A6%BB%E6%9C%80%E8%BF%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%88%B6%E8%A7%86%E5%9B%BE%EF%BC%8C%E5%B7%B2%E7%9F%A5%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E5%92%8C%E6%A0%B9%E8%8A%82%E7%82%B9"><span class="nav-number">8.</span> <span class="nav-text">寻找距离最近的公共父视图，已知两个节点和根节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash%E7%A2%B0%E6%92%9E%E5%86%B2%E7%AA%81"><span class="nav-number">9.</span> <span class="nav-text">Hash碰撞冲突</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">288</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
