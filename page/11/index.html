<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift161iOS%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift161iOS%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">iOS常用框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:11:50" itemprop="dateCreated datePublished" datetime="2020-12-01T14:11:50+08:00">2020-12-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>界面图形框架 – UIKit<br>核心动画框架 – Core Animation<br>苹果封装的图形框架 – Core Graphics &amp; Quartz 2D<br>传统跨平台图形框架 – OpenGL ES<br>苹果最新力推的图形框架 – Metal<br>适合图片的苹果滤镜框架 – Core Image<br>适合视频的第三方滤镜方案 – GPUImage<br>游戏引擎 – Scene Kit (3D) 和 Sprite Kit (2D)<br>计算机视觉在iOS的应用 – OpenCV for iOS<br>UIKit与Core Graphics的关系</p>
<h2 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h2><p>在UIKit中，UIView类本身在绘制时自动创建一个图形环境，即Core Graphics层的CGContext类型，作为当前的图形绘制环境。在绘制时可以调用 UIGraphicsGetCurrentContext 函数获得当前的图形环境，例如：</p>
<ul>
<li>(void)drawRect:(CGRect)rect {<br>  // Drawing code<br>  NSLog(@”%s”,<strong>func</strong>);<br>  //1.获取上下文<br>  CGContextRef contextRef = UIGraphicsGetCurrentContext();<br>  //2.描述路径<br>  UIBezierPath * path = [UIBezierPath bezierPath];<br>  //起点<br>  [path moveToPoint:CGPointMake(10, 10)];<br>  //终点<br>  [path addLineToPoint:CGPointMake(100, 100)];<br>  //设置颜色<br>  [[UIColor whiteColor]setStroke];<br>  //3.添加路径<br>  CGContextAddPath(contextRef, path.CGPath);<br>  //显示路径<br>  CGContextStrokePath(contextRef);</li>
</ul>
<p>}</p>
<h2 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h2><p>Core Animation 是一套Objective-C API，实现了一个高性能的复合引擎，并提供一个简单易用的编程接口，给用户UI添加平滑运动和动态反馈能力。</p>
<p>Core Animation 是 UIKit 实现动画和变换的基础，也负责视图的复合功能。使用Core Animation可以实现定制动画和细粒度的动画控制，创建复杂的、支持动画和变换的layered 2D视图。</p>
<p>Core Animation 不属于绘制系统，但它是以硬件复合和操作显示内容的基础设施。这个基础设施的核心是layer对象，用来管理和操作显示内容。在 iOS 中 每一个视图都对应Core Animation的一个层对象，与视图一样，层之间也组织为层关系树。一个层捕获视图内容为一个被图像硬件容易操作的位图。在多数应用中层作为管理视图的方式使用，但也可以创建独立的层到一个层关系树中来显示视图不够支持的显示内容。</p>
<p>OpenGL ES的内容也可以与Core Animation内容进行集成。</p>
<p>为了使用Core Animation实现动画，可以修改 层的属性值 来触发一个action对象的执行，不同的action对象实现不同的动画。</p>
<h2 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h2><p>Core Graphics是一套C-based API， 支持向量图形，线、形状、图案、路径、剃度、位图图像和pdf 内容的绘制。</p>
<h2 id="Quartz-2D"><a href="#Quartz-2D" class="headerlink" title="Quartz 2D"></a>Quartz 2D</h2><p>Quartz 2D是Core Graphics中的2D 绘制呈现引擎。Quartz是资源和设备无关的,提供路径绘制，anti-aliased呈现，剃度填充图案，图像，透明绘制和透明层、遮蔽和阴影、颜色管理，坐标转换，字体、offscreen呈现、pdf文档创建、显示和分析等功能。</p>
<p>Quartz 2D能够与所有的图形和动画技术（如Core Animation, OpenGL ES, 和 UIKit 等）一起使用。</p>
<p>Quartz 2D采用paint模式进行绘制。<br>Quartz 2D提供的主要类包括：</p>
<p>CGContext：表示一个图形环境；<br>CGPath：使用向量图形来创建路径，并能够填充和stroke；<br>CGImage：用来表示位图；<br>CGLayer：用来表示一个能够用于重复绘制和offscreen绘制的绘制层；<br>CGPattern：用来表示Pattern，用于重复绘制；<br>CGShading和 CGGradient：用于绘制剃度；<br>CGColor 和 CGColorSpace；用来进行颜色和颜色空间管理；<br>CGFont, 用于绘制文本；<br>CGPDFContentStream、CGPDFScanner、CGPDFPage、CGPDFObject,CGPDFStream, CGPDFString等用来进行pdf文件的创建、解析和显示。</p>
<p>在调用任何OpenGL ES 功能之前必须首先初始化一个EAGLContext 对象。每一个IOS应用的每一个线程都有一个当前context，在调用OpenGL ES函数时，使用或改变此context中的状态。</p>
<p>EAGLContext 的类方法setCurrentContext: 用来设置当前线程的当前context。EAGLContext 的类方法currentContext 返回当前线程的当前context。在切换相同线程的两个上下文之前，必须调用glFlush函数来确保先前已提交的命令被提交到图形硬件中。<br>为了创建全屏幕的视图或使OpenGL ES内容与UIKit视图集成，可以使用GLKit。在使用GLKit时，GLKit提供的类GLKView类本身实现呈现目标及创建和维护一个framebuffer。<br>1） GLKView 和GLKViewController类提供一个标准的OpenGL ES视图和相关联的呈现循环。GLKView可以作为OpenGL ES内容的呈现目标，GLKViewController提供内容呈现的控制和动画。视图管理和维护一个framebuffer，应用只需在framebuffer进行绘画即可。</p>
<p>2）GLKTextureLoader 为应用提供从IOS支持的各种图像格式的源自动加载纹理图像到OpenGL ES 图像环境的方式，并能够进行适当的转换，并支持同步和异步加载方式。</p>
<p>3）数学运算库，提供向量、矩阵、四元数的实现和矩阵堆栈操作等OpenGL ES 1.1功能。</p>
<p>4）Effect效果类提供标准的公共着色效果的实现。能够配置效果和相关的顶点数据，然后创建和加载适当的着色器。GLKit 包括三个可配置着色效果类：GLKBaseEffect实现OpenGL ES 1.1规范中的关键的灯光和材料模式, GLKSkyboxEffect提供一个skybox效果的实现, GLKReflectionMapEffect 在GLKBaseEffect基础上包括反射映射支持。</p>
<p>如果想要一个 iOS 上高性能的并行计算库，答案非常简单。Metal 是唯一的选择。OpenGL 在 iOS 上是私有框架，而 Core Image (使用了 OpenGL) 对这样的任务来说既不够强大又不够灵活。</p>
<h2 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a>Core Image</h2><p>Core Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 滤镜链 将各种效果的 Filter叠加 起来形成强大的自定义效果</p>
<p>Core Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。</p>
<p>// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)<br>context = [CIContext contextWithOptions: [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextUseSoftwareRenderer]];</p>
<p>// 创建基于 GPU 的 CIContext 对象<br>context = [CIContext contextWithOptions: nil];</p>
<p>// 创建基于 GPU 的 CIContext 对象<br>EAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];<br>context = [CIContext contextWithEAGLContext:eaglctx];<br>GPUImage 在视频处理上有更好的表现。<br>GPUImage 的代码完成公开，实现透明。<br>可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift165%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift165%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/" class="post-title-link" itemprop="url">地图开发技能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:08:08" itemprop="dateCreated datePublished" datetime="2020-12-01T14:08:08+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 15:40:55" itemprop="dateModified" datetime="2021-04-12T15:40:55+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="瓦片地图"><a href="#瓦片地图" class="headerlink" title="瓦片地图"></a>瓦片地图</h2><p>瓦片的切分方式。具体参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/8006049?fr=aladdin">https://baike.baidu.com/item/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/8006049?fr=aladdin</a></p>
<h2 id="webgl教程"><a href="#webgl教程" class="headerlink" title="webgl教程"></a>webgl教程</h2><p>参考网站：<a target="_blank" rel="noopener" href="https://www.yiibai.com/webgl/webgl_graphics_basics.html">https://www.yiibai.com/webgl/webgl_graphics_basics.html</a></p>
<h2 id="墨卡托投影"><a href="#墨卡托投影" class="headerlink" title="墨卡托投影"></a>墨卡托投影</h2><p>参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A2%A8%E5%8D%A1%E6%89%98%E6%8A%95%E5%BD%B1/5477927?fr=aladdin">https://baike.baidu.com/item/%E5%A2%A8%E5%8D%A1%E6%89%98%E6%8A%95%E5%BD%B1/5477927?fr=aladdin</a></p>
<h2 id="相机："><a href="#相机：" class="headerlink" title="相机："></a>相机：</h2><p>透视投影：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/stl112514/article/details/83927643">https://blog.csdn.net/stl112514/article/details/83927643</a></p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>webgl使用矩阵实现平移，缩放。参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1005103">https://cloud.tencent.com/developer/article/1005103</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift164%E5%AD%97%E8%8A%82%E5%BA%8F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift164%E5%AD%97%E8%8A%82%E5%BA%8F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">字节序问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:08:08" itemprop="dateCreated datePublished" datetime="2020-12-01T14:08:08+08:00">2020-12-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>Little endian<br>    简写：LE<br>    常见翻译：小端序，低端序<br>    解释：将低序字节存储在起始地址。就是高位值放在存储（可以认为是内存）的高位，低位值放在存储的低位，<br>        即：顺序写入到内存中。最符合人的思维，低位高位对应内存地址的高位低位。</p>
<p>Big endian<br>    简写：BE<br>    常见翻译：大端序，高端序<br>    解释：将高序字节存储在起始地址。地址低位存储值的高位，地址高位存储值的低位。<br>        即：一个二进制数，那么从高位到低位顺序写到内存中(内存是从低位到高位的，我们写数字的时候是从高位到低位)。<br>        所以这种方式是最直观的。</p>
<p>iOS中一般是Little endian</p>
<p>比如int数据bit大端许写法如下<br>void BufferPutInt(MapBuffer *pBuffer, int val) {<br>    if (pBuffer-&gt;m_pPtr &gt;= pBuffer-&gt;m_pEnd)<br>        return;<br>    pBuffer-&gt;m_pPtr[0] =  (val &gt;&gt; 24);<br>    pBuffer-&gt;m_pPtr[1] =  (val &gt;&gt; 16);<br>    pBuffer-&gt;m_pPtr[2] =  (val &gt;&gt; 8);<br>    pBuffer-&gt;m_pPtr[3] =  (val);<br>    pBuffer-&gt;m_pPtr += 4;<br>//    MEMCPY(pBuffer-&gt;m_pPtr, &amp;val, sizeof(int));<br>//    pBuffer-&gt;m_pPtr += sizeof(int);<br>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/M_Swift153GLSL%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/M_Swift153GLSL%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">GLES语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-24 14:25:04" itemprop="dateCreated datePublished" datetime="2020-11-24T14:25:04+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 16:09:15" itemprop="dateModified" datetime="2021-04-12T16:09:15+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GLSL-着色器编程语言"><a href="#GLSL-着色器编程语言" class="headerlink" title="GLSL(着色器编程语言)"></a>GLSL(着色器编程语言)</h1><p>1、介绍<br>是一个和C语言语法比较类似的着色器变成语言<br>2、注释<br>和C语言一样<br>// this is a comment<br>/*</p>
<ul>
<li>  this is muti comment</li>
<li>/<br>备注：GLSL语言必须由ASCII码字符组成，如果包括非ascii码编译会出错<br>3、变量命名<br>GLSL的变量名必须以字母或者下划线开头，由英文字母，数字，_组成，且不能是gl_或__开头(都是系统预留的)，也不能是系统关键字<br>4、预处理指令<br>预处理指令以#开头，#号之前不能有除了空白字符之外的任何字符。每一个指令独占一行。内置的预处理指令如下：<br>#define<br>#undef<br>#if<br>#ifdef<br>#ifndef<br>#else<br>#elif<br>#endif<br>#error<br>#pragma<br>#extension<br>#version<br>#line</li>
</ul>
<p>#pragma<br>编译指示。用来控制编译器的一些行为，开发和调试时可以设置为off，默认设为on。</p>
<p>#pragma optimize(on)<br>#pragma optimize(off)</p>
<p>开发和调试时可以打开debug选项，以便获取更多的调试信息。默认设为off。<br>#pragma debug(on)<br>#pragma debug(off)</p>
<p>#extension<br>如果想使用GLGL默认不支持的操作，则必须启用对应的扩展，启用一个扩展可以使用下面的命令：</p>
<p>#extension : behavior<br>#extension all : behavior<br>其中，extension_name是扩展的名称，all是指所有的编译器支持的扩展。<br>behavior是指对该扩展的具体操作。比如启用、禁用等等。详情如下：<br>behavior                                    作用<br>require                         启用该扩展。如果不支持，则报错。<br>enable                          启用该扩展。如果不支持，则会警告。extension_name是all的时候会报错。<br>warn                            启用该扩展。但是会检测到所有使用该扩展的地方，提出警告。<br>disable                         禁用该扩展。如果该扩展不被支持，则提出警告。</p>
<p>5、预定义的变量<br>除此之外，还预定义了一些变量：<br><strong>LINE</strong> ：int类型，当前的行号，也就是在Source String中是第一行<br><strong>FILE</strong> ：int类型，当前Source String的唯一ID标识<br><strong>VERSION</strong> ：int类型，GLGL的版本<br>GL_ES ：对于嵌入式系统（Embed System，简称 ES），它的值为1，否则为0</p>
<p>6、运算符及其优先级<br>| 1 |()<br>| 从右往左 |<br>| 3 | 乘除法 | * / % | 从左往右 |<br>| 4 | 加减法 | + - | 从左往右 |<br>| 5 | 位运算 移位 | &lt;&lt; &gt;&gt; | 从左往右 |<br>| 6 | 大小关系 | &lt; &gt; &lt;= &gt;= | 从左往右 |<br>| 7 | 相等性判断 | == != | 从左往右 |<br>| 8 | 位运算 与 | &amp; | 从左往右 |<br>| 9 | 位或算 非 | ^ | 从左往右 |<br>| 10 | 位或算 或 | | | 从左往右 |<br>| 11 | 逻辑与 | &amp;&amp; | 从左往右 |<br>| 12 | 逻辑或 | || | 从左往右 |</p>
<p>7、关键词<br>列举一下GLSL中的关键词，这些全部是系统保留的，不可私自篡改。</p>
<p>attribute const uniform varying<br>break continue do for while<br>if else<br>in out inout<br>float int void bool true false<br>lowp mediump highp precision invariant<br>discard return<br>mat2 mat3 mat4<br>vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4<br>sampler2D samplerCube<br>struct</p>
<p>asm<br>class union enum typedef template this packed<br>goto switch default<br>inline noinline volatile public static extern external interface flat<br>long short double half fixed unsigned superp<br>input output<br>hvec2 hvec3 hvec4 dvec2 dvec3 dvec4 fvec2 fvec3 fvec4<br>sampler1D sampler3D<br>sampler1DShadow sampler2DShadow<br>sampler2DRect sampler3DRect sampler2DRectShadow<br>sizeof cast<br>namespace using</p>
<p>除此之外，所有的以”__”开头的变量全部是预留的，自定义的变量不能以“__”开头。</p>
<h1 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hankern/article/details/85316476">https://blog.csdn.net/hankern/article/details/85316476</a><br>1.1 Vertex Shader<br>对于发送给GPU的每一个Vertex(顶点)，都要执行一次Vertex Shader。其功能是把每个顶点在虚拟空间中的三维坐标变换为可以在屏幕上显示的二维坐标，并带有用于z-buffer的深度信息。Vertex Shader可以操作的属性有：位置、颜色、纹理坐标，但是不能创建新的顶点。</p>
<p>vertex shader主要完成以下工作：1).基于点操作的矩阵乘法位置变换；2).根据光照公式计算每点的color值；3).生成或者转换纹理坐标。<br>Vertex Shader输入数据如下：<br>1).Attributes：由 vertext array 提供的顶点数据，如空间位置，法向量，纹理坐标以及顶点颜色，它是针对每一个顶点的数据。属性只在顶点着色器中才有，片元着色器中没有属性。属性可以理解为针对每一个顶点的输入数据。OpenGL ES 2.0 规定了所有实现应该支持的最大属性个数不能少于 8 个。<br>注：Vertex Attributes 是每点的属性数据。与一个index序号绑定。外部程序可通过 glBindAttribLocation将一个attribute 名与一个index绑定起来。当然，OPENGL ES 内部会自动绑定所有attributes.外部程序只需通过 glGetAttribLocation获取指定attribute名的index。 给Attribute传值可以通过 glVertexAttribPointer函数或者glVertexAttrib4fv</p>
<p>2).Uniforms：uniforms保存由应用程序传递给着色器的只读常量数据。在顶点着色器中，这些数据通常是变换矩阵，光照参数，颜色等。由 uniform 修饰符修饰的变量属于全局变量，该全局性对顶点着色器与片元着色器均可见，也就是说，这两个着色器如果被连接到同一 个program Object，则它们共享同一份 uniform 全局变量集。因此如果在这两个着色器中都声明了同名的 uniform 变量，要保证这对同名变量完全相同：同名+同类型，因为它们实际是同一个变量。此外，uniform 变量存储在常量存储区，因此限制了 uniform 变量的个数，OpenGL ES 2.0 也规定了所有实现应该支持的最大顶点着色器 uniform 变量个数不能少于 128 个，最大的片元着色器 uniform 变量个数不能少于 16 个。</p>
<p>3).Samplers：一种特殊的 uniform，在vertex shader中是可选的，用于呈现纹理。sampler 可用于顶点着色器和片元着色器。</p>
<p>4).Shader program：由 main 声明的一段程序源码，描述在顶点上执行的操作：如坐标变换，计算光照公式来产生 per-vertex 颜色或计算纹理坐标。</p>
<p>1.2 Fragment Shader<br>Pixel Shader(像素着色器)就是众所周知的Fragment Shader(片元着色器)，它计算每个像素的颜色和其它属性。它通过应用光照值、凹凸贴图，阴影，镜面高光，半透明等处理来计算像素的颜色并输出。它也可改变像素的深度(z-buffering)或在多个渲染目标被激活的状态下输出多种颜色。一个Pixel Shader不能产生复杂的效果，因为它只在一个像素上进行操作，而不知道场景的几何形状。</p>
<p>Fragment Shader输入数据如下：<br>1).Varyings：这个在前面已经讲过了，顶点着色器阶段输出的 varying 变量在光栅化阶段被线性插值计算之后输出到片元着色器中作为它的输入，即上图中的 gl_FragCoord，gl_FrontFacing 和 gl_PointCoord。OpenGL ES 2.0 也规定了所有实现应该支持的最大 varying 变量个数不能少于 8 个。<br>2).Uniforms：前面也已经讲过，这里是用于片元着色器的常量，如雾化参数，纹理参数等；OpenGL ES 2.0 也规定了所有实现应该支持的最大的片元着色器 uniform 变量个数不能少于 16 个。<br>3).Samples：一种特殊的 uniform，用于呈现纹理。<br>4).Shader program：由 main 申明的一段程序源码，描述在片元上执行的操作。<br>FragmentShader输出为：<br>在顶点着色器阶段只有唯一的 varying 输出变量-即内建变量：gl_FragColor</p>
<h1 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jxw167/article/details/55098260">https://blog.csdn.net/jxw167/article/details/55098260</a><br> 在游戏中模型的渲染显示，当模型被加载后，在引擎底层需要DX库或者OpenGL库提供数据缓冲从而将数据传输到GPU中渲染绘制，模型都是由数据组成的，这些数据需要OpenGL图形库渲染它们时开辟一块缓冲内存进行存放，OpenGL为我们开发者提供了很多函数接口供我们使用，作为开发者熟悉这些关于缓冲数据操作的接口对于学习Shader编程也非常有帮助，市面上的Unity引擎和UE4虚幻引擎也是基于这些函数开发的，本片博客主要是为读者揭秘OpenGL中的数据缓冲原理。<br> 在OpenGL中缓冲只是一块儿内存区域的对象，当把缓冲绑定到一个特定缓冲对象时，我们就给缓冲赋予了一个特殊的意义。当我们绑定到GL_ARRAY_BUFFER的时候，这个缓冲就是一个顶点数组缓冲，我们也可以简单地绑定到GL_ELEMENT_ARRAY_BUFFER。OpenGL内部为每个目标（target）储存一个缓冲，并基于目标来处理不同的缓冲。<br> 我们使用glBufferData函数填充缓冲对象管理的内存，这个函数分配了一块内存空间，然后把数据存入其中。如果我们向它的data这个参数传递的是NULL，那么OpenGL只会帮我们分配内存，而不会填充它。如果我们先打算开辟一些内存，稍后回到这个缓冲一点一点的填充数据，有些时候会很有用。</p>
<p> 我们还可以调用glBufferSubData函数填充特定区域的缓冲，而不是一次填充整个缓冲。这个函数需要一个缓冲目标（target），一个偏移量（offset），数据的大小以及数据本身作为参数。这个函数新的功能是我们可以给它一个偏移量（offset）来指定我们打算填充缓冲的位置与起始位置之间的偏移量。这样我们就可以插入/更新指定区域的缓冲内存空间了。一定要确保修改的缓冲要有足够的内存分配，所以在调用glBufferSubData之前，调用glBufferData是必须的。注意，glBufferData函数接口在Shader编程中使用的非常广泛。它的函数接口如下所示：</p>
<p> float data[] = {<br>   0.5f, 1.0f, -0.35f<br>   …<br> };</p>
<p> glBindBuffer(GL_ARRAY_BUFFER, buffer);<br> // 获取当前绑定缓存buffer的内存地址<br> void* ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);<br> // 向缓冲中写入数据<br> memcpy(ptr, data, sizeof(data));<br> // 完成够别忘了告诉OpenGL我们不再需要它了<br> glUnmapBuffer(GL_ARRAY_BUFFER);</p>
<p>调用glUnmapBuffer函数可以告诉OpenGL我们已经用完指针了，OpenGL会知道你已经做完了。通过解映射（unmapping），指针会不再可用，如果OpenGL可以把你的数据映射到缓冲上，就会返回GL_TRUE。</p>
<p>把数据直接映射到缓冲上使用glMapBuffer很有用，因为不用把它储存在临时内存里。你可以从文件读取数据然后直接复制到缓冲的内存里。</p>
<p>使用glVertexAttribPointer函数可以指定缓冲内容的顶点数组的属性的布局(Layout)。我们已经知道，通过使用顶点属性指针我们可以交叉(Interleave)属性，也就是说我们可以把每个顶点的位置、法线、纹理坐标放在彼此挨着的地方。现在我们了解了更多的缓冲的内容，可以采取另一种方式了。我们可以做的是把每种类型的属性的所有向量数据批量保存在一个布局，而不是交叉布局。</p>
<p>当从文件加载顶点数据时你通常获取一个位置数组，一个法线数组和一个纹理坐标数组。需要花点力气才能把它们结合为交叉数据。使用 glBufferSubData 可以简单的实现分批处理方式：<br>缓冲满足的条件：</p>
<p>建构一个完整的帧缓冲必须满足以下条件：</p>
<p>我们必须往里面加入至少一个附件（颜色、深度、模板缓冲）。<br>其中至少有一个是颜色附件。<br>所有的附件都应该是已经完全做好的（已经存储在内存之中）。<br>每个缓冲都应该有同样数目的样本。</p>
<h1 id="投影相机"><a href="#投影相机" class="headerlink" title="投影相机"></a>投影相机</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/M_Swift156OpenGLES%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/M_Swift156OpenGLES%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">OpenGL常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-24 10:32:44" itemprop="dateCreated datePublished" datetime="2020-11-24T10:32:44+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 16:09:51" itemprop="dateModified" datetime="2021-04-12T16:09:51+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创建buffers"><a href="#创建buffers" class="headerlink" title="创建buffers"></a>创建buffers</h1><p>1、void glGenFramebuffers(GLsizei n,GLuint * framebuffers);<br>创建frame buffers<br>2、void glDeleteFramebuffers(GLsizei n,const GLuint * framebuffers);<br>删除frame buffers<br>n表示buffers数量,framebuffers 表示buffer的数组<br>3、void glGenRenderbuffers(GLsizei n,GLuint * renderbuffers);<br>创建render buffers<br>4、void glDeleteRenderbuffers(GLsizei n,const GLuint * renderbuffers);<br>删除 render buffers<br>5、void glFramebufferRenderbuffer(GLenum target,GLenum attachment,GLenum renderbuffertarget,GLuint renderbuffer);<br>将render buffer关联到GL_FRAMEBUFFER常量上面<br>target:取值必须为GL_FRAMEBUFFER<br>attachment:取值为GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT, or GL_STENCIL_ATTACHMENT。一般视频渲染取GL_COLOR_ATTACHMENT0<br>renderbuffertarget:取值必须为GL_RENDERBUFFER<br>renderbuffer:要关联的render buffer的id(由glGenRenderbuffers()函数生成)<br>6、GLenum glCheckFramebufferStatus(GLenum target);<br>检查frame buffer相关是否成功，再glFramebufferRenderbuffer()之后调用去检查<br>tagert:GL_FRAMEBUFFER;<br>7.glEnableVertexAttribArray()或 者glDisableVertexAttribArray()<br>//— 告 诉 OpenGL ES 在接下来的渲染中是否使用缓存中的数据<br>glEnableVertexAttribArray(GLKVertexAttribPosition);</p>
<h1 id="着色器相关函数"><a href="#着色器相关函数" class="headerlink" title="着色器相关函数"></a>着色器相关函数</h1><p>1、GLuint glCreateShader(GLenum shaderType);<br>创建着色器程序的句柄；成功返回非0整数<br>shaderType:着色器类型，顶点和片元；取值GL_VERTEX_SHADER和GL_FRAGMENT_SHADER<br>2、void glShaderSource(GLuint shader,GLsizei count,const GLchar * const *string,const GLint *length);<br>为着色器句柄添加GLSL源代码<br>shader:前面创建的着色器句柄<br>count:源代码个数<br>string:源代码字符串<br>lenght:源代码字符串长度<br>3、void glCompileShader(GLuint shader);<br>编译着色器GLSL源码<br>4、void glGetShaderiv(GLuint shader,GLenum pname,GLint *params);<br>获取着色器编译过程中的日志和检测是否编译成功<br>// 检查编译中日志,logLenght&gt;0则说明有日志<br>glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;logLenght);<br>// 检查编译是否成功,成功status==GLTRUE<br>glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;status);<br>5、GLuint glCreateProgram(void);<br>创建用于生成顶点着色器和片元着色器最终程序的句柄<br>6、void glAttachShader(GLuint program,GLuint shader);<br>添加顶点着色器和片元着色器<br>program:第五步创建的program<br>shader:为前面编译成功的着色器句柄<br>7、void glLinkProgram(GLuint program);<br>连接程序,就像C语言的连接一样，这里将顶点着色器和片元着色器连接起来<br>8、void glGetProgramiv(GLuint program,GLenum pname,GLint *params);<br>输出连接过程中的日志和检查连接是否成功<br>// 检查编译中日志,logLenght&gt;0则说明有日志<br>glGetProgramiv(filterProgram, GL_INFO_LOG_LENGTH, &amp;logLength);<br>// 检查编译是否成功,成功status==GLTRUE<br>glGetProgramiv(filterProgram, GL_LINK_STATUS, &amp;status);<br>9、void glUseProgram(GLuint program);<br>调用此函数后着色器程序才能正常使用，就相当于生成可执行程序后还得点击一下让其运行起来一样；之后才能使用第10个之后的函数<br>10、GLint glGetAttribLocation(GLuint program,const GLchar *name);<br>获取顶点着色器中的attribute修饰的变量的句柄，后面就可以通过该句柄从应用端向GLSL对应的变量传值了<br>program:对应的GLSL程序，该函数必须在GLSL程序运行后才能使用(即调用了glUseProgram()函数)<br>name:GLSL中attribute修饰的变量名<br>11、GLint glGetUniformLocation(GLuint program,const GLchar *name);<br>获取片元着色器中uniform sampler2D修饰的变量的句柄，后面就可以将该句柄和对应的纹理单元关联起来<br>program:对应的GLSL程序，该函数必须在GLSL程序运行后才能使用(即调用了glUseProgram()函数)<br>name:GLSL中uniform sampler2D修饰的变量名</p>
<h1 id="视窗有关函数"><a href="#视窗有关函数" class="headerlink" title="视窗有关函数"></a>视窗有关函数</h1><p>1、void glClearColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha);<br>设置清屏的颜色,四个参数的范围都是0-1的浮点数，表示RGBA的组合<br>2、void glClear(GLbitfield mask);<br>用前面glClearColor(),glClearDepthf(),and glClearStencil()设置的颜色清除buffers;<br>mask在这个函数中的取值要与上面三个函数一一对应，可取值如下：<br>GL_COLOR_BUFFER_BIT:color buffer，前面如果调用了glClearColor()，则设置包含该值<br>GL_DEPTH_BUFFER_BIT：depth buffer，前面如果调用了glClearDepthf()，则设置包含该值<br>GL_STENCIL_BUFFER_BIT：stencil buffer，前面如果调用了glClearStencil()，则设置包含该值<br>mask可以是上面几个值的组合,比如GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT,但前提是前面分别调用了glClearColor()和glClearDepthf()设置颜色</p>
<p>3、void glViewport(GLint x,GLint y,GLsizei width,GLsizei height);<br>以当前视图的大小为基础(当前视图的左下角为坐标原点)在开辟一个(x,y,width,height)的渲染区域，该区域将作为后面顶点坐标等的参考坐标系。</p>
<h1 id="纹理操作相关函数-应用端和opengl-es传值相关函数"><a href="#纹理操作相关函数-应用端和opengl-es传值相关函数" class="headerlink" title="纹理操作相关函数,应用端和opengl es传值相关函数"></a>纹理操作相关函数,应用端和opengl es传值相关函数</h1><p>4、void glPixelStorei(GLenum pname,GLint param);<br>设置像素的对齐方式；<br>pname:为GL_PACK_ALIGNMENT,会影响glReadPixels()函数从opengl es缓存中读取像素数据到app中的字节对齐方式<br>pname:为GL_UNPACK_ALIGNMENT，会影响glTexImage2D() 和 glTexSubImage2D()函数从app发送像素数据到opengl es的字节对齐方式<br>param:表示每次读取或者发送的像素数据是param的整数倍;举个例子，比如param为4，想要通过glTexImage2D()传输5x5像素的一张图片(25不是4的整数倍，所以需要手<br>动添加padding即添加3个字节到这个图片buf中,这样读取时才不会出错，如果param为1就没有这样的烦恼，但是可能性能会低，值越大吞吐量就越大，效率也越高。<br>那么上面两种方式的取值含义都是一样的,<br>默认值为4；取值如下：<br>1 (byte-alignment),<br>2 (rows aligned to even-numbered bytes),<br>4 (word-alignment),<br>8 (rows start on double-word boundaries).</p>
<p>5、void glDrawArrays(GLenum mode,GLint first,GLsizei count);<br>确定要绘制的几何形状；通过mode指定，可取值如下：<br>GL_POINTS:绘制点，那么顶点着色器还需要有gl_PointSize内建变量指定顶点的大小<br>GL_LINES:绘制线<br>GL_TRIANGLE_STRIP:绘制三角形，比如绘制纹理图片就是这种类型<br>它处于渲染管线的第一阶段</p>
<p>6、void glVertexAttribPointer(GLuint index,GLint size,GLenum type,GLboolean normalized,GLsizei stride,const GLvoid * pointer);<br>用一个数组的方式给GLSL中attribute修饰的属性变量赋值;<br>index:前面获取的GLSL变量的句柄<br>size:表示每几个元素表示一个attribute修饰的变量;比如对于attribute vec4 position;修饰的顶点,就表示四个数据(x,y,z,w)才能表示一个顶点坐标，如果这里size为<br>2，那么x,y有值，z，w将默认为0,依次类推。<br>type:每个元素的数据类型，取值为GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_FIXED, or GL_FLOAT<br>normalized:是否要对pointer中的数据进行归一化处理成(-1.0,1.0)范围的浮点型类型,如果已经是浮点型，这里传GL_FALSE即可。<br>stride:获取每一个元素是否需要跳字节，如果前面的type类型pointer中元素类型一致，这里传0<br>pointer:几何形状的各个顶点组成的数组;对于矩形来说，数组中顶点顺序为(左下角，右下角，左上角，右上角)<br>该赋值得用glEnableVertexAttribArray()函数启用后才会生效</p>
<p>7、void glUniform1i(GLint location,GLint v0);<br>给片段着色器中的uniform sampler2D 修饰的纹理变量赋值，只有该函数调用后,片元着色器中的texture2D()函数才能正确工作<br>location:为片元着色器中uniform sampler2D 修饰的变量句柄<br>v0的取值为纹理单元的索引；比如想让激活的GL_TEXTURE2和上面的变量关联，则v0取值为2，那么片元着色器中的texture2D()函数将从该纹理单元对应的纹理里面查找像素</p>
<p>8、void glEnableVertexAttribArray(GLuint index);<br>   void glDisableVertexAttribArray(GLuint index);<br>启用和禁用给attribute变量的赋值</p>
<p>9、void glGetIntegerv(GLenum pname,GLint * params);<br>获取指定类型的值<br>GL_ACTIVE_TEXTURE:获取设备支持的纹理单元数目<br>GL_MAX_TEXTURE_SIZE:获取设备支持的纹理能渲染的最大的长或宽大小，超过此大小则必须先压缩再传给opengl es，否则opengl es无法渲染</p>
<p>10、void glGenTextures(GLsizei n,GLuint * textures);<br>    void glDeleteTextures(GLsizei n,const GLuint * textures);<br>创建纹理Id和删除纹理Id<br>调用删除纹理Id函数会解除它与纹理类型对象的绑定</p>
<p>11、void glActiveTexture(GLenum texture);<br>选择指定的纹理单元，texture取值范围GL_TEXTUREi(i取值为0-GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1)，其中GL_TEXTURE0默认激活的<br>方式一、glActioveTexture(GL_TEXTUREi);只能到GL_TEXTURE31<br>方式二、glActioveTexture(GL_TEXTURE0+i);i可以取值到GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1</p>
<p>12、void glBindTexture(GLenum target,GLuint texture);<br>绑定纹理，当绑定完后，如果用其它texture再次与target绑定，则先前的绑定失效。或者调用glDeleteTextures()函数后，该绑定也将失效<br>target:纹理类型，可取值：GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP<br>texture:纹理id，由glGenTextures()函数生成<br>函数10和11的工作流程用伪代码表示如下：<br>GLenum curentTexutre;<br>GLESObj globalObj;<br>glActiveTexture(GLenum texture)<br>{<br>curentTexutre = texture;<br>}<br>glBindTexture(GLenum target,GLuint texture)<br>{<br>TextureUnit *texUnit = globalObj[curentTexutre];<br>switch(target)<br>{<br>case GL_TEXTURE_1D: texUnit-&gt;targetTexture1D = textureObject; break;<br>case GL_TEXTURE_2D: texUnit-&gt;targetTexture2D = textureObject; break;<br>case GL_TEXTURE_3D: texUnit-&gt;targetTexture3D = textureObject; break;<br>case GL_TEXTURE_CUBEMAP: texUnit-&gt;targetTextureCube = textureObject; break;<br>}<br>glTexImage2D(….)<br>{<br>    TextureUnit *texUnit = globalObj[curentTexutre];<br>    texUnit-&gt;targetTexture2D-&gt;TexImage2D(…);<br>    ……<br>}<br>所以如果调用glActiveTexture()之后不调用glBindTexture()函数，其实后面的glxxx()系列函数设置的参数只是对curentTexutre有效，会造成值被覆盖</p>
<p>13、void glTexParameteri(GLenum target,GLenum pname,GLint param);<br>给指定的纹理类型对象设定参数<br>warping<br>纹理坐标的范围是(0,1)当给定的纹理坐标超过这个范围时，将通过如下方式对超过的纹理坐标进行采样<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_WARP_S,GL_REPEAT) S轴方向<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_WARP_T,GL_REPEAT) T轴方向<br>GL_REPEAT,GL_MIRRODED_REPEAT    (经过试验，此这两种方式视乎无效，GL_REPEAT默认)<br>GL_CLAMP_TO_EDGE 超出的部分坐标被设置成0或者1，行程边缘色<br>filter<br>实际纹理的分辨率大小与要显示的屏幕区域的分辨率大小往往不相等，也就是要根据屏幕的实际大小对纹理进行放大和缩小，这里就需要用到filter，取值如下：<br>GL_NEAREST:最邻近插值，取最近的纹素像素<br>GL_LINEAR:线性插值，取最近的点的线性平均值 (性能消耗较大)<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR)<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR)<br>mipmaps<br>它也是一种纹理过滤算法，按我的理解它是以空间换时间的一种技巧，具体原理就是事先根据纹理生成长和宽逐渐除以2的小纹理，比如原始纹理大小128x128，<br>采用此方法后，会生成64x64 32x32 16x16 8x8 4x4 2x2 1x1的一系列纹理，如果需要20x18的纹理，则取最近的32x32 16x16进行平均<br>该方法很好的解决了如下问题：<br>1、当纹理很大，但是屏幕区域很小，渲染出现的闪烁问题，因为根据最邻近插值和线性插值都无法很快计算出合理的像素<br>它可以取的值如下：<br>GL_NEAREST_MIPMAP_NEAREST 选择最近的mipmap层，然后再用最邻近过滤插值<br>GL_LINEAR_MIPMAP_NEAREST    选择最近mipmap层，然后再用线性插值<br>GL_NEAREST_MIPMAP_LINEAR    选择最近的2层mipmap用最邻近过滤插值<br>GL_LINEAR_MIPMAP_LINEAR       选择最邻近的2层mipmap用线性插值<br>使用如下函数生成mipmaps<br>glGenerateMipmap(GLenum target);</p>
<p>14、void glTexImage2D(GLenum target,    // 纹理对象类型，取值GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z或者<br>GLint level,    // 纹理压缩等级，0代表不压缩，默认0<br>GLint internalformat,// 内部每个像素的构成格式,取值GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_RGBA.<br>GLsizei width,  // 纹理的宽，单位像素<br>GLsizei height, // 纹理的高，单位像素<br>GLint border,   // 设置为0 即可<br>GLenum format,  // data中每个像素的构成格式，必须与internalformat保持一直，取值为GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.<br>GLenum type,    // data中像素数据的组织方式,取值 GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, and GL_UNSIGNED_SHORT_5_5_5_1.<br>const GLvoid * data // 代表一张图片的像素数据<br>);<br>GL_ALPHA<br>表示data中每个像素只有一个透明通道，当它传递给opengl es时，自动将RGB填充为0。<br>GL_RGB<br>表示data中每个像素只由RGB三个数组成，当它传递给opengl es时，自动将Alpha填充为1。<br>GL_RGBA<br>表示data中每个像素只由RGBA四个数组成，传递给Opengl es时，原封不动的传递<br>GL_LUMINANCE<br>表示data中每个像素只有一个值组成，当它传递给opengl es时，自动将RGB填充为该值，alpha填充为1<br>GL_LUMINANCE_ALPHA<br>表示data中每个像素只有一个值组成，当它传递给opengl es时，自动将RGB填充为该值，alpha原封不动<br>GL_UNSIGNED_BYTE<br>表示组成每个像素的通道占用8位该值可以与前面任何格式搭配使用<br>GL_UNSIGNED_SHORT_5_6_5<br>表示RGB分别占用6 6 5位,一个像素两个字节，该值只能与前面GL_RGB搭配<br>GL_UNSIGNED_SHORT_4_4_4_4，<br>表示RGBA 分别占用4位，一个像素两个字节，该值只能与前面GL_RGB搭配GL_RGBA<br>GL_UNSIGNED_SHORT_5_5_5_1，<br>表示RGBA 分别占用 5551位，一个像素两个字节，该值只能与前面GL_RGB搭配GL_RGBA</p>
<p>15、void glTexSubImage2D(    GLenum target,<br>GLint level,<br>GLint xoffset,<br>GLint yoffset,<br>GLsizei width,<br>GLsizei height,<br>GLenum format,<br>GLenum type,<br>const GLvoid * data);<br>用法和第15个函数一样，只不过可以选取data中的部分数据传递，更加灵活</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/02/M_Swift162iOS%E5%9C%B0%E5%9B%BE%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/M_Swift162iOS%E5%9C%B0%E5%9B%BE%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">地图计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-02 09:38:22" itemprop="dateCreated datePublished" datetime="2020-11-02T09:38:22+08:00">2020-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算经纬度之间的距离"><a href="#计算经纬度之间的距离" class="headerlink" title="计算经纬度之间的距离"></a>计算经纬度之间的距离</h2><p>  /*!<br>     @brief 计算经纬度之间的距离<br>     @param a a点<br>     @param b b点<br>     @return 距离，单位：米<br>     */<br>    CLLocationDistance MAMetersBetweenMapPoints(CLLocationCoordinate2D a, CLLocationCoordinate2D b)<br>    {<br>        CLLocation *curLocation = [[CLLocation alloc] initWithLatitude:a.latitude longitude:a.longitude];<br>        CLLocation *otherLocation = [[CLLocation alloc] initWithLatitude:b.latitude longitude:b.longitude];<br>        return [curLocation distanceFromLocation:otherLocation];<br>    }</p>
<p>static const double a = 6378245.0;<br>static const double ee = 0.00669342162296594323;<br>static const double pi = M_PI;<br>static const double xPi = M_PI  * 3000.0 / 180.0;</p>
<h2 id="GPS转高德"><a href="#GPS转高德" class="headerlink" title="GPS转高德"></a>GPS转高德</h2><ul>
<li>(CLLocationCoordinate2D)transformFromWGSToGCJ:(CLLocationCoordinate2D)wgsLoc {<br>  CLLocationCoordinate2D adjustLoc;<br>  if([self isLocationOutOfChina:wgsLoc]) {<pre><code>  adjustLoc = wgsLoc;
</code></pre>
  }<br>  else {<pre><code>  double adjustLat = [self transformLatWithX:wgsLoc.longitude - 105.0 withY:wgsLoc.latitude - 35.0];
  double adjustLon = [self transformLonWithX:wgsLoc.longitude - 105.0 withY:wgsLoc.latitude - 35.0];
  long double radLat = wgsLoc.latitude / 180.0 * pi;
  long double magic = sin(radLat);
  magic = 1 - ee * magic * magic;
  long double sqrtMagic = sqrt(magic);
  adjustLat = (adjustLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);
  adjustLon = (adjustLon * 180.0) / (a / sqrtMagic * cos(radLat) * pi);
  adjustLoc.latitude = wgsLoc.latitude + adjustLat;
  adjustLoc.longitude = wgsLoc.longitude + adjustLon;
</code></pre>
  }<br>  return adjustLoc;<br>}<h2 id="GPS转百度"><a href="#GPS转百度" class="headerlink" title="GPS转百度"></a>GPS转百度</h2></li>
<li>(CLLocationCoordinate2D)transformFromWGSToBaidu:(CLLocationCoordinate2D)p {<br>  CLLocationCoordinate2D coo =[NSValue transformFromWGSToGCJ:p];<br>  return [NSValue transformFromGCJToBaidu:coo];<br>}<h2 id="百度转GPS"><a href="#百度转GPS" class="headerlink" title="百度转GPS"></a>百度转GPS</h2></li>
<li>(CLLocationCoordinate2D)transformFromBaiduToWGS:(CLLocationCoordinate2D)p {<br>   CLLocationCoordinate2D start_coor = [NSValue transformFromBaiduToGCJ:p];<br>   return [NSValue transformFromGCJToWGS:start_coor];<br>}<h2 id="百度转高德"><a href="#百度转高德" class="headerlink" title="百度转高德"></a>百度转高德</h2></li>
<li>(CLLocationCoordinate2D)transformFromBaiduToGCJ:(CLLocationCoordinate2D)p {<br>  double x = p.longitude - 0.0065, y = p.latitude - 0.006;<br>  double z = sqrt(x * x + y * y) - 0.00002 * sin(y * xPi);<br>  double theta = atan2(y, x) - 0.000003 * cos(x * xPi);<br>  CLLocationCoordinate2D geoPoint;<br>  geoPoint.latitude  = z * sin(theta);<br>  geoPoint.longitude = z * cos(theta);<br>  return geoPoint;<br>}<h2 id="高德转百度"><a href="#高德转百度" class="headerlink" title="高德转百度"></a>高德转百度</h2></li>
<li>(CLLocationCoordinate2D)transformFromGCJToBaidu:(CLLocationCoordinate2D)p {<br>  long double z = sqrt(p.longitude * p.longitude + p.latitude * p.latitude) + 0.00002 * sqrt(p.latitude * pi);<br>  long double theta = atan2(p.latitude, p.longitude) + 0.000003 * cos(p.longitude * pi);<br>  CLLocationCoordinate2D geoPoint;<br>  geoPoint.latitude  = (z * sin(theta) + 0.006);<br>  geoPoint.longitude = (z * cos(theta) + 0.0065);<br>  return geoPoint;<br>}<h2 id="高德转GPS"><a href="#高德转GPS" class="headerlink" title="高德转GPS"></a>高德转GPS</h2></li>
<li>(CLLocationCoordinate2D)transformFromGCJToWGS:(CLLocationCoordinate2D)p {<br>  double threshold = 0.00001;  // The boundary<br>  double minLat = p.latitude - 0.5;<br>  double maxLat = p.latitude + 0.5;<br>  double minLng = p.longitude - 0.5;<br>  double maxLng = p.longitude + 0.5;  double delta = 1;<br>  int maxIteration = 30;<br>  // Binary search<br>  while(true) {<pre><code>  CLLocationCoordinate2D leftBottom  = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = minLat,.longitude = minLng&#125;];
  CLLocationCoordinate2D rightBottom = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = minLat,.longitude = maxLng&#125;];
  CLLocationCoordinate2D leftUp      = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = maxLat,.longitude = minLng&#125;];
  CLLocationCoordinate2D midPoint    = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = ((minLat + maxLat) / 2),.longitude = ((minLng + maxLng) / 2)&#125;];
  delta = fabs(midPoint.latitude - p.latitude) + fabs(midPoint.longitude - p.longitude);
  
  if(maxIteration-- &lt;= 0 || delta &lt;= threshold) &#123;
      return (CLLocationCoordinate2D)&#123;.latitude = ((minLat + maxLat) / 2),.longitude = ((minLng + maxLng) / 2)&#125;;
  &#125;
  
  if(isContains(p, leftBottom, midPoint)) &#123;
      maxLat = (minLat + maxLat) / 2;
      maxLng = (minLng + maxLng) / 2;
  &#125; else if(isContains(p, rightBottom, midPoint)) &#123;
      maxLat = (minLat + maxLat) / 2;
      minLng = (minLng + maxLng) / 2;
  &#125; else if(isContains(p, leftUp, midPoint)) &#123;
      minLat = (minLat + maxLat) / 2;
      maxLng = (minLng + maxLng) / 2;
  &#125; else &#123;
      minLat = (minLat + maxLat) / 2;
      minLng = (minLng + maxLng) / 2;
  &#125;
</code></pre>
  }</li>
</ul>
<p>}</p>
<ul>
<li>(double)transformLatWithX:(double)x withY:(double)y {<br>  double lat = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt(fabs(x));<br>  lat += (20.0 * sin(6.0 * x * pi) + 20.0 *sin(2.0 * x * pi)) * 2.0 / 3.0;<br>  lat += (20.0 * sin(y * pi) + 40.0 * sin(y / 3.0 * pi)) * 2.0 / 3.0;<br>  lat += (160.0 * sin(y / 12.0 * pi) + 320 * sin(y * pi / 30.0)) * 2.0 / 3.0;<br>  return lat;<br>}</li>
<li>(double)transformLonWithX:(double)x withY:(double)y {<br>  double lon = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt(fabs(x));<br>  lon += (20.0 * sin(6.0 * x * pi) + 20.0 * sin(2.0 * x * pi)) * 2.0 / 3.0;<br>  lon += (20.0 * sin(x * pi) + 40.0 * sin(x / 3.0 * pi)) * 2.0 / 3.0;<br>  lon += (150.0 * sin(x / 12.0 * pi) + 300.0 * sin(x / 30.0 * pi)) * 2.0 / 3.0;<br>  return lon;<br>}<h2 id="判断某个点point是否在p1和p2之间"><a href="#判断某个点point是否在p1和p2之间" class="headerlink" title="判断某个点point是否在p1和p2之间"></a>判断某个点point是否在p1和p2之间</h2>static bool isContains(CLLocationCoordinate2D point, CLLocationCoordinate2D p1, CLLocationCoordinate2D p2) {<br>  return (point.latitude &gt;= MIN(p1.latitude, p2.latitude) &amp;&amp; point.latitude &lt;= MAX(p1.latitude, p2.latitude)) &amp;&amp; (point.longitude &gt;= MIN(p1.longitude,p2.longitude) &amp;&amp; point.longitude &lt;= MAX(p1.longitude, p2.longitude));<br>}</li>
</ul>
<h2 id="粗略判断是不是在中国"><a href="#粗略判断是不是在中国" class="headerlink" title="粗略判断是不是在中国"></a>粗略判断是不是在中国</h2><ul>
<li>(BOOL)isLocationOutOfChina:(CLLocationCoordinate2D)location {<br>  if (location.longitude &lt; 72.004 || location.longitude &gt; 137.8347 || location.latitude &lt; 0.8293 || location.latitude &gt; 55.8271)<pre><code>  return YES;
</code></pre>
  return NO;<br>}<h2 id="弧线计算"><a href="#弧线计算" class="headerlink" title="弧线计算"></a>弧线计算</h2>double x1 = pArc.startCoordinate.longitude;<br>double y1 = pArc.startCoordinate.latitude;<br>double x2 = pArc.passedCoordinate.longitude;<br>double y2 = pArc.passedCoordinate.latitude;<br>double x3 = pArc.endCoordinate.longitude;<br>double y3 = pArc.endCoordinate.latitude;<br>double a = 2 * (x2 - x1);<br>double b = 2 * (y2 - y1);<br>double c = x2 * x2 + y2 * y2 - x1 * x1 - y1 * y1;<br>double d = 2 * (x3 - x2);<br>double e = 2 * (y3 - y2);<br>double f = x3 * x3 + y3 * y3 - x2 * x2 - y2 * y2;<br>double x = (b * f - e * c) / (b * d - e * a);<br>double y = (d * c - a * f) / (b * d - e * a);<br>double r = sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));<br>double angle1 = acos((x1 - x) / r);<br>if (y1 - y &lt; 0)<br>  angle1 = -angle1;<br>double angle2 = acos((x2 - x) / r);<br>if (y2 - y &lt; 0)<br>  angle2 = -angle2;<br>double angle3 = acos((x3 - x) / r);<br>if (y3 - y &lt; 0)<br>  angle3 = -angle3;<br>double deltaAngle1 = angle1 - angle2;</li>
</ul>
<p>while (deltaAngle1 &gt; M_PI)<br>    deltaAngle1 -= M_PI * 2;<br>while (deltaAngle1 &lt;= -M_PI)<br>    deltaAngle1 += M_PI * 2;<br>int numPoints1 = (int) (128 * fabs(deltaAngle1) / M_PI);<br>double phase1 = deltaAngle1 / numPoints1;<br>double deltaAngle2 = angle2 - angle3;<br>while (deltaAngle2 &gt; M_PI)<br>    deltaAngle2 -= M_PI * 2;<br>while (deltaAngle2 &lt;= -M_PI)<br>    deltaAngle2 += M_PI * 2;<br>int numPoints2 = (int) (128 * fabs(deltaAngle2) / M_PI);<br>double phase2 = deltaAngle2 / numPoints2;<br>int pointCnt = numPoints1 + numPoints2 + 1;<br>CLLocationCoordinate2D coos[pointCnt];<br>pointCnt = 0;<br>coos[pointCnt] = CLLocationCoordinate2DMake(y1, x1);<br>pointCnt++;<br>for (int i = 1; i &lt; numPoints1; i++) {<br>    coos[pointCnt] = CLLocationCoordinate2DMake((y + r * sin(angle1 - phase1 * i)),(x + r * cos(angle1 - phase1 * i)));<br>    pointCnt++;<br>}<br>coos[pointCnt] = CLLocationCoordinate2DMake(y2, x2);<br>pointCnt++;<br>for (int i = 1; i &lt; numPoints2; i++) {<br>    coos[pointCnt] = CLLocationCoordinate2DMake((y + r * sin(angle2 - phase2 * i)),(x + r * cos(angle2 - phase2 * i)));<br>    pointCnt++;<br>}<br>coos[pointCnt] = CLLocationCoordinate2DMake(y3, x3);<br>pointCnt++;</p>
<h2 id="图片截图"><a href="#图片截图" class="headerlink" title="图片截图"></a>图片截图</h2><ul>
<li>(UIImage *)takeSnapshotInRect:(CGRect)rect {<br>  UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, [UIScreen mainScreen].scale);<br>  [self drawViewHierarchyInRect:self.bounds afterScreenUpdates:YES];<br>  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();<br>  UIGraphicsEndImageContext();<br>  if (CGRectEqualToRect(rect, self.bounds)) {<pre><code>  return image;
</code></pre>
  }<br>  CGFloat scale = image.scale;<br>  CGRect scaledRect = CGRectMake(rect.origin.x * scale, rect.origin.y * scale, rect.size.width * scale, rect.size.height * scale);<br>  CGImageRef rectImage = CGImageCreateWithImageInRect(image.CGImage,scaledRect);<br>  return [UIImage imageWithCGImage:rectImage];<br>}<h2 id="地图手势"><a href="#地图手势" class="headerlink" title="地图手势"></a>地图手势</h2>// 单击<br>UITapGestureRecognizer * singletapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onSingleTap:)];<br>  [singletapGesture setNumberOfTapsRequired:1];<br>  [singletapGesture setNumberOfTouchesRequired:1];<br>  [self addGestureRecognizer:singletapGesture];<br>双击<br>  UITapGestureRecognizer * doubletapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onDoubleTap:)];<br>  [doubletapGesture setNumberOfTapsRequired: 2];<br>  [doubletapGesture setNumberOfTouchesRequired: 1];<br>  [self addGestureRecognizer:doubletapGesture];<br>  [singletapGesture requireGestureRecognizerToFail:doubletapGesture];<br>长按<br>  UILongPressGestureRecognizer* longPressGr = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)];<br>  [self addGestureRecognizer:longPressGr];<br>缩放<br>  UITapGestureRecognizer *m_pZoomoutGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onZoomOut:)];<br>  [m_pZoomoutGesture setNumberOfTapsRequired:1];<br>  [m_pZoomoutGesture setNumberOfTouchesRequired:2];<br>  [self addGestureRecognizer:m_pZoomoutGesture];<br>拖拽<br>  m_pSinglePanGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(onScroll:)];<br>  [m_pSinglePanGesture setMaximumNumberOfTouches:1];<br>  [self addGestureRecognizer:m_pSinglePanGesture];<br>旋转<br>  UIPanGestureRecognizer * doublePanGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(onOverlook:)];<br>  [doublePanGesture setMinimumNumberOfTouches:2];<br>  [self addGestureRecognizer:doublePanGesture];<br>  m_pPinchGesture = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(onPinch:)];<br>  m_pPinchGesture.delegate = self;<br>  [self addGestureRecognizer:m_pPinchGesture];<br>缩放<br>  m_pRotateGesture = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(onRotate:)];<br>  m_pRotateGesture.delegate = self;<br>  [self addGestureRecognizer:m_pRotateGesture];</li>
</ul>
<h2 id="比例尺绘制"><a href="#比例尺绘制" class="headerlink" title="比例尺绘制"></a>比例尺绘制</h2><ul>
<li><p>(void)drawRect:(CGRect)rect {</p>
<p>  CGContextRef context = UIGraphicsGetCurrentContext();</p>
<p>  CGContextSetRGBStrokeColor(context, 0.0f, 0.0f, 0.0f, 1.0f); //画笔颜色<br>  CGContextSetLineWidth(context, 1.0); //线宽</p>
<p>  CGFloat scale = [UIScreen mainScreen].scale;<br>  int zoomLevel = self.zoomLevel;</p>
<p>  int iLength = (MASCALE_DISTANCES[zoomLevel] /([self.mapView metersPerPointForZoomLevel:zoomLevel] * scale));<br>  if (iLength &gt;200) {</p>
<pre><code>  iLength = 200;
</code></pre>
<p>  }<br>  int iStartX = rect.origin.x;<br>  int iStartY = rect.size.height - 12;<br>  int iEndY = rect.size.height - 9;<br>  NSString *name = MASCALE_DISTANCESNAME[zoomLevel];<br>  [name drawInRect:CGRectMake(iStartX + SCALE_NAME_STARTX, iStartY - 13, rect.size.width, rect.size.height) withFont:[UIFont systemFontOfSize:10.0]];</p>
<p>  CGPoint points[2];//坐标点<br>  points[0] = CGPointMake(iStartX, iEndY);//坐标1<br>  points[1] = CGPointMake(iStartX + iLength, iEndY);//坐标2<br>  CGContextAddLines(context, points, 2);//添加线<br>  CGContextDrawPath(context, kCGPathStroke);</p>
<p>  points[0] = CGPointMake(iStartX, iStartY); //坐标1<br>  points[1] = CGPointMake(iStartX, iEndY); //坐标2<br>  CGContextAddLines(context, points, 2); //添加线<br>  CGContextDrawPath(context, kCGPathStroke);</p>
<p>  points[0] = CGPointMake(iStartX + iLength, iStartY);//坐标1<br>  points[1] = CGPointMake(iStartX + iLength, iEndY);//坐标2<br>  CGContextAddLines(context, points, 2);//添加线<br>  CGContextDrawPath(context, kCGPathStroke);<br>}</p>
</li>
</ul>
<h2 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h2><ul>
<li>(CGFloat)lineDistance:(CGPoint)point linePoint1:(CGPoint)line1 linePoint2:(CGPoint)line2<br>{<br>  CGFloat se =  (line1.x-line2.x)<em>(line1.x-line2.x)+(line1.y-line2.y)</em>(line1.y-line2.y);//线段两点距离平方<br>  CGFloat p = ((point.x-line1.x)<em>(line2.x-line1.x)+(point.y-line1.y)</em>(line2.y-line1.y)); //向量点乘=|a|<em>|b|<em>cosA<br>  CGFloat r = p / se; //r即点到线段的投影长度与线段长度比<br>  CGFloat outx = line1.x + r * (line2.x-line1.x);<br>  CGFloat outy = line1.y+r</em>(line2.y-line1.y);<br>  CGFloat des =(point.x-outx)</em>(point.x-outx)+(point.y-outy)*(point.y-outy);<br>  return sqrt(des);<br>}</li>
</ul>
<h2 id="检查某点是否包含在多边形的范围内-判断多边形是否被点击"><a href="#检查某点是否包含在多边形的范围内-判断多边形是否被点击" class="headerlink" title="检查某点是否包含在多边形的范围内(判断多边形是否被点击"></a>检查某点是否包含在多边形的范围内(判断多边形是否被点击</h2><ul>
<li>(BOOL)PointInPoly:(CGPoint *)poly count:(int)count point:(CGPoint)pt {<br>  BOOL c = false;<br>  int i = -1, l = count;<br>  for (int j = l - 1; ++i &lt; l; j = i){<pre><code>  ((poly[i].y &lt;= pt.y &amp;&amp; pt.y &lt; poly[j].y) || (poly[j].y &lt;= pt.y &amp;&amp; pt.y &lt; poly[i].y)) &amp;&amp; (pt.x &lt; (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) &amp;&amp; (c = !c);
</code></pre>
  }<br>  return c;<br>}<h2 id="判断折线是否被点击"><a href="#判断折线是否被点击" class="headerlink" title="判断折线是否被点击"></a>判断折线是否被点击</h2>  原理：点到线的距离是否大与线的宽度<br>  MAPolylineRenderer *line = (MAPolylineRenderer *)ovlay;<br>  CLLocationCoordinate2D *coo = line.polyline.points;<br>  long count = line.polyline.pointCount;<br>  for (int i = 0; i &lt; count - 1; i++) {<pre><code>  CLLocationCoordinate2D item = coo[i];
  CLLocationCoordinate2D item1 = coo[i + 1];
  CGPoint point1 = [m_pSkMap lonlat2Pixel:item];
  CGPoint point2 = [m_pSkMap lonlat2Pixel:item1];
  CGFloat dis = [self lineDistance:point linePoint1:point1 linePoint2:point2];
  if (dis &lt; line.lineWidth * 3) &#123; // 为了防止点不上，给进行了加大处理
      return line.polyline;
  &#125;
</code></pre>
  }<h2 id="判断是否在弧形上"><a href="#判断是否在弧形上" class="headerlink" title="判断是否在弧形上"></a>判断是否在弧形上</h2>  原理：同线的点击<br>  MAArcRenderer *arcRenderer = (MAArcRenderer *)ovlay;<br>  MAArc *arc = arcRenderer.arc;<br>  int count = arc.pointCount;<br>  CLLocationCoordinate2D *coo = arc.points;<br>  for (int i = 0; i &lt; count - 1; i++) {<pre><code>  CLLocationCoordinate2D item = coo[i];
  CLLocationCoordinate2D pointCoo = [m_pSkMap pixel2LonLat:point];
  CLLocationDistance dis = MAMetersBetweenMapPoints(item,pointCoo);
  CGFloat zoom = [m_pSkMap getZoom];
 if (dis &lt; arcRenderer.lineWidth * 500 / zoom) &#123; // 为了防止点不上，给进行了加大处理
     return arc;
 &#125;
</code></pre>
 }<h2 id="判断是否在圆内"><a href="#判断是否在圆内" class="headerlink" title="判断是否在圆内"></a>判断是否在圆内</h2>  原理：点到圆心的距离小于半径<br>  MACircleRenderer *circle = (MACircleRenderer *)ovlay;<br>  CLLocationCoordinate2D coo = circle.circle.coordinate;<br>  CLLocationCoordinate2D sele = [m_pSkMap pixel2LonLat:point];<br>  double dis = MAMetersBetweenMapPoints(coo,sele);<br>  if (dis &lt; circle.circle.radius) {<pre><code>  return circle.circle;
</code></pre>
  }<h2 id="判断矩形画图标是否被点击"><a href="#判断矩形画图标是否被点击" class="headerlink" title="判断矩形画图标是否被点击"></a>判断矩形画图标是否被点击</h2>  判断点击是否在矩形图标rect内<br>  MAMarkerRenderer *mark = (MAMarkerRenderer *)ovlay;<br>  CGPoint markPoint = [m_pSkMap lonlat2Pixel:mark.marker.coordinate];<br>  CGSize imageSize = mark.imageSize;<br>  CGFloat scale = 1;<br>  if (mark.image) { // 不规则图形处理<pre><code>  scale = mark.imageSize.height / mark.imageSize.width;
  if (scale &gt; 1) &#123;
      imageSize.width = mark.imageSize.width / scale;
      imageSize.height = mark.imageSize.height / scale;
      markPoint.x = markPoint.x + imageSize.width / scale;
  &#125;else&#123;
      imageSize.width = mark.imageSize.width * scale;
      imageSize.height = mark.imageSize.height * scale;
  &#125;
</code></pre>
  }<br>  CGRect rect = CGRectMake(markPoint.x, markPoint.y, imageSize.width,imageSize.height);<br>  if (CGRectContainsPoint(rect,point)) {<pre><code>  return mark.marker;
</code></pre>
  }</li>
</ul>
<h2 id="覆盖物的拖拽："><a href="#覆盖物的拖拽：" class="headerlink" title="覆盖物的拖拽："></a>覆盖物的拖拽：</h2><pre><code>1.通过长按手势触发拖拽
2.通过判断是否点击了多边形，判断是否在拖拽覆盖物
3.计算移动的坐标数量，获取覆盖物新的坐标位置
4.修改覆盖物坐标位置
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/02/M_Swift154OpenGL%E6%9C%AF%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/M_Swift154OpenGL%E6%9C%AF%E8%AF%AD/" class="post-title-link" itemprop="url">OpenGL术语</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-02 09:26:55" itemprop="dateCreated datePublished" datetime="2020-11-02T09:26:55+08:00">2020-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>2D+透视 = 3D</p>
<h2 id="3D术语"><a href="#3D术语" class="headerlink" title="3D术语"></a>3D术语</h2><p>光栅化：实际绘制或填充每个顶点之间的像素形成过程</p>
<p>着色：沿着顶点之间改变颜色值，能够轻松创建光照照射到一个立方体的效果</p>
<p>纹理贴图：将纹理图片附着到你绘图的图像上</p>
<p>混合：颜色混合效果</p>
<p>渲染：表示计算机从模型创建最终图像的过程</p>
<p>顶点处理：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在现有的GPU中，这些工作由硬件实现的Vertex Shader（顶点着色器）完成。</p>
<p>光栅化计算：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。</p>
<p>纹理帖图：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture mapping）工作完成对多变形表面的帖图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成“真实”的图形。TMU（Texture mapping unit）即是用来完成此项工作。</p>
<p>像素处理：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel Shader（像素着色器）完成。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context是一个非常抽象的概念，我们姑且把它理解成一个包含了所有OpenGL状态的对象。如果我们把一个Context销毁了，那么OpenGL也不复存在。</p>
<h2 id="OpenGL对象"><a href="#OpenGL对象" class="headerlink" title="OpenGL对象"></a>OpenGL对象</h2><p>我们可以把OpenGL对象理解成一个状态的集合，它负责管理它下属的所有状态。当然，除了状态，OpenGL对象还会存储其他数据。注意。这些状态和上述context中的状态并不重合，只有在把一个OpenGL对象绑定到context上时，OpenGL对象的各种状态才会映射到context的状态。因此，这时如果我们改变了context的状态，那么也会影响这个对象，而相反地，依赖这些context状态的函数也会使用存储在这个对象上的数据。</p>
<p>OpenGL对象包含了下面一些类型：Buffer Objects，Vertex Array Objects，Textures，Framebuffer Objects等等。我们下面会讲到Vertex Array Objects这个对象。</p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>渲染（Rendering）：计算机从模型到创建一张图像的过程。OpenGL仅仅是其中一个渲染系统。它是一个基于光栅化的系统，其他的系统还有光线追踪（但有时也会用到OpenGL）等。</p>
<p>模型（Models）或者对象（Objects）：这里两者的含义是一样的。指从几何图元——点、线、三角形中创建的东西，由顶点指定。</p>
<p>Shaders：这是一类特殊的函数，是在图形硬件上执行的。我们可以理解成，Shader是一些为图形处理单元（GPU）编译的小程序。OpenGL包含了编译工具来把我们编写的Shader源代码编译成可以在GPU上运行的代码。在OpenGL中，我们可以使用四种shader阶段。最常见的就是vertex shaders——它们可以处理顶点数据；以及fragment shaders，它们处理光栅化后生成的fragments。vertex shaders和fragment shaders是每个OpenGL程序必不可少的部分。</p>
<p>像素（pixel）：像素是我们显示器上的最小可见元素。我们系统中的像素被存储在一个帧缓存（framebuffer）中。帧缓存是一块由图形硬件管理的内存空间，用于供给给我们的显示设备。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/29/M_Swift158iOS%20OpenGL%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/29/M_Swift158iOS%20OpenGL%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">ios OpenGL 加载图片流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-29 10:20:12" itemprop="dateCreated datePublished" datetime="2020-09-29T10:20:12+08:00">2020-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 15:54:14" itemprop="dateModified" datetime="2021-04-12T15:54:14+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-采用C的FILE方式读取图片"><a href="#1-采用C的FILE方式读取图片" class="headerlink" title="1.采用C的FILE方式读取图片"></a>1.采用C的FILE方式读取图片</h2><pre><code>FILE *fp = fopen(texfile, &quot;rb&quot;);
if(NULL == fp)&#123;
    LOGE(&quot;png can&#39;t openfile:%s\n&quot;, texfile);
    return 0;
&#125;
fseek(fp, 0, SEEK_END);
length = (int)ftell(fp);
fseek(fp, 0, SEEK_SET);
//LOGD(&quot;png file length:%s %d\n&quot;, texfile, length);
pngRawData = (unsigned char*)malloc(length);
fread(pngRawData, 1, length, fp);
fclose(fp);
</code></pre>
<h2 id="2-采用OC-CGImageRef-处理图片"><a href="#2-采用OC-CGImageRef-处理图片" class="headerlink" title="2.采用OC CGImageRef 处理图片"></a>2.采用OC CGImageRef 处理图片</h2><pre><code>CGImageRef cgImageRef = [UIImage imageWithData:[NSData dataWithBytes:data length:length]].CGImage;
GLuint width = (GLuint)CGImageGetWidth(cgImageRef);
GLuint height = (GLuint)CGImageGetHeight(cgImageRef);
CGRect rect = CGRectMake(0, 0, width, height);

CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
void *imageData = malloc(width * height * 4);
CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);
//    出现反转的问题
//    CGContextTranslateCTM(context, 0, height);
//    CGContextScaleCTM(context, 1.0f, -1.0f);
CGColorSpaceRelease(colorSpace);
CGContextClearRect(context, rect);
CGContextDrawImage(context, rect, cgImageRef);
UIGraphicsBeginImageContext(CGSizeMake(width, height));
</code></pre>
<h2 id="3-采用opengl绑定图片，获取图片id"><a href="#3-采用opengl绑定图片，获取图片id" class="headerlink" title="3.采用opengl绑定图片，获取图片id"></a>3.采用opengl绑定图片，获取图片id</h2><pre><code>GLuint textureID;
glGenTextures(1, &amp;textureID);
glBindTexture(GL_TEXTURE_2D, textureID);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

glBindTexture(GL_TEXTURE_2D, 0);

CGContextRelease(context);
free(imageData);

return textureID;
</code></pre>
<h2 id="4在使用图片是时候调用gl方法渲染图片"><a href="#4在使用图片是时候调用gl方法渲染图片" class="headerlink" title="4在使用图片是时候调用gl方法渲染图片"></a>4在使用图片是时候调用gl方法渲染图片</h2><pre><code>glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
glEnable(GL_TEXTURE_2D);
glEnableClientState(GL_TEXTURE_COORD_ARRAY);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
glBindTexture(GL_TEXTURE_2D, pLC-&gt;m_IconTex);
glVertexPointer(2, GL_FLOAT, sizeof(IconPoint), (char*)pLC-&gt;m_pIconPoints);
glTexCoordPointer(2, GL_FLOAT, sizeof(IconPoint), (char*)pLC-&gt;m_pIconPoints + 8);
glDrawArrays(GL_TRIANGLES, 0, pLC-&gt;m_iIconPointCnt);

glDisableClientState(GL_TEXTURE_COORD_ARRAY);
glDisable(GL_TEXTURE_2D);
glDisable(GL_BLEND);
</code></pre>
<h2 id="5-使用GLKView搭配OpenGL方式"><a href="#5-使用GLKView搭配OpenGL方式" class="headerlink" title="5.使用GLKView搭配OpenGL方式"></a>5.使用GLKView搭配OpenGL方式</h2><pre><code>创建一个继承于GLKView的试图
添加context
self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES1];
[EAGLContext setCurrentContext:self.context];
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/24/M_Swift155OpenGL%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/24/M_Swift155OpenGL%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">OpenGL 接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-24 15:54:35" itemprop="dateCreated datePublished" datetime="2020-09-24T15:54:35+08:00">2020-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 16:09:33" itemprop="dateModified" datetime="2021-04-12T16:09:33+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="glActiveTexture-激活纹理单元"><a href="#glActiveTexture-激活纹理单元" class="headerlink" title="glActiveTexture - 激活纹理单元"></a>glActiveTexture - 激活纹理单元</h2><p>C规范</p>
<p>void glActiveTexture（GLenum texture）;</p>
<p>参数</p>
<p>texture</p>
<p>指定要激活的纹理单元，纹理单元的数量依赖于实现，但必须至少为8。texture必须是GL_TEXTUREi之一，其中i的范围从0到（GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1）。初始值是GL_TEXTURE0。</p>
<p>描述</p>
<p>被glActiveTexture 激活的纹理将会影响其后续的纹理调用状态。</p>
<p>错误</p>
<p>如果纹理ID（texture的值）不是GL_TEXTUREi（其中i的范围从0到（GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1））中的一个值得话，就会得到一个状态错误：GL_INVALID_ENUM</p>
<p>相关Gets</p>
<p>GL_ACTIVE_TEXTURE或GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS可以用glGetXXX来得到相关的纹理ID值或GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS值。</p>
<p>eg.</p>
<p>GLint maxNum;</p>
<p>glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS,&amp;maxNum);</p>
<p>可以将GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 的值获取放在maxNum中。</p>
<p>另见</p>
<p>glTexParameter</p>
<h2 id="glAttachShader-将着色器对象附加到program对象"><a href="#glAttachShader-将着色器对象附加到program对象" class="headerlink" title="glAttachShader- 将着色器对象附加到program对象"></a>glAttachShader- 将着色器对象附加到program对象</h2><p>C规范</p>
<p>void glAttachShader（GLuint program,GLuint shader）;</p>
<p>参数</p>
<p>program</p>
<p>指定着色器对象将附加到的program对象。</p>
<p>shader</p>
<p>指定要附加的着色器对象。</p>
<p>描述</p>
<p>为了创建一个可执行文件，必须要有一种方法来指定将被链接在一起的东西的列表。那么，program对象就提供了这么一种机制。</p>
<p>要在program对象中链接的shaders必须首先附加到该program对象上。那glAttachShader方法就是用于将指定的shaders附着到指定的program对象上。这就表明shader将被包含在要被执行的program的链接操作中。</p>
<p>不管shader对象是否被附着到program对象上，在shader对象上执行的所有操作都是有效的。</p>
<p>在源代码加载到着色器对象之前或着色器对象被编译之前，将shader对象附着到program对象上都是被允许的。</p>
<p>多个同类型（例如都是vertex shader类型，或都是fragment shader类型）的shader对象不能被附着到同一个program对象上。但是，单个shader对象可以被附着到多个program对象上。</p>
<p>如果着色器对象在附加到程序对象时被删除，它将被标记为删除，并且直到调用glDetachShader才能将其从它所连接的所有程序对象中分离出来，否则删除将不会发生。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：如果program或shader不是由OpenGL所生成的值。</p>
<p>GL_INVALID_OPERATION:如果program参数传的不是program对象。</p>
<p>GL_INVALID_OPERATION：如果shader参数传的不是shader对象。</p>
<p>GL_INVALID_OPERATION：如果shader已经被添加到program对象上了，或者已经有一个同类型的shader对象添加到该program对象上的时候。</p>
<p>相关Gets</p>
<p>glGetAttachedShaders可依据一个有效的program对象来获得其所关联的shaders。</p>
<p>glIsProgram</p>
<p>glIsShader</p>
<p>另见</p>
<p>glCompileShader, glDetachShader, glLinkProgram, glShaderSource, glShaderBinary</p>
<h2 id="glBindAttribLocation-将通用顶点属性索引与命名属性变量相关联"><a href="#glBindAttribLocation-将通用顶点属性索引与命名属性变量相关联" class="headerlink" title="glBindAttribLocation - 将通用顶点属性索引与命名属性变量相关联"></a>glBindAttribLocation - 将通用顶点属性索引与命名属性变量相关联</h2><p>C规范</p>
<p>void glBindAttribLocation（GLuint program,</p>
<pre><code>                                              GLuint index,

                                              const GLchar *name）;
</code></pre>
<p>参数</p>
<p>program</p>
<p>指定要在其中建立关联的程序对象的句柄。</p>
<p>index</p>
<p>指定要绑定的通用顶点属性的索引。</p>
<p>name</p>
<p>指定一个以空终止符结尾的字符串，其中包含要绑定索引的顶点着色器属性变量的名称。</p>
<p>描述</p>
<p>glBindAttribLocation用于将程序指定的程序对象中的用户定义属性变量与通用顶点属性索引相关联。用户定义的属性变量的名称作为名称中的空终止字符串传递。要绑定到此变量的通用顶点属性索引由index指定。当程序成为当前状态的一部分时，通过通用顶点属性索引提供的值将修改由name指定的用户定义属性变量的值。</p>
<p>如果name引用矩阵属性变量，则index引用矩阵的第一列。然后，对于mat2类型的矩阵，其他矩阵列自动绑定到位置index + 1; index + 1和index + 2表示mat3类型的矩阵;对于mat4类型的矩阵，index + 1，index + 2和index + 3。</p>
<p>此命令使顶点着色器可以使用属性变量的描述性名称，而不是编号为0到GL_MAX_VERTEX_ATTRIBS -1的泛型变量。发送到每个通用属性索引的值是当前状态的一部分，就像标准顶点属性（如颜色，法线和顶点位置）一样。如果通过调用glUseProgram使不同的程序对象成为当前的程序，则跟踪通用顶点属性，使得新程序对象中的属性也将观察到相同的值，这些属性也绑定到索引。</p>
<p>可以通过调用glBindAttribLocation随时显式分配程序对象的属性变量名称到通用属性索引绑定。在调用glLinkProgram之前，属性绑定不会生效。成功链接程序对象后，通用属性的索引值保持固定（并且可以查询它们的值），直到发生下一个链接命令。</p>
<p>不允许应用程序使用此命令绑定任何标准OpenGL顶点属性，因为它们在需要时自动绑定。在程序对象链接之后发生的任何属性绑定在下次链接程序对象之前不会生效。</p>
<p>注意</p>
<p>可以在任何顶点着色器对象绑定到指定程序对象之前调用glBindAttribLocation。也允许将通用属性索引绑定到从未在顶点着色器中使用的属性变量名称。</p>
<p>如果以前绑定了name，则该信息将丢失。因此，您不能将一个用户定义的属性变量绑定到多个索引，但您可以将多个用户定义的属性变量绑定到同一索引。</p>
<p>允许应用程序将多个用户定义的属性变量绑定到相同的通用顶点属性索引。这称为aliasing（别名），仅当可执行程序中只有一个别名属性处于活动状态时，或者如果没有通过着色器的路径消耗属于同一位置的一组属性的多个属性时，才允许使用别名。允许编译器和链接器假定没有进行别名，并且可以自由地使用仅在没有别名的情况下工作的优化。不需要OpenGL实现来进行错误检查以检测别名。由于无法绑定标准属性，因此无法使用常规属性对通用属性进行别名（通用属性0除外）。</p>
<p>调用glLinkProgram时，链接器将绑定未显式绑定的活动属性。可以通过调用glGetAttribLocation来查询分配的位置。</p>
<p>调用glBindAttribLocation时，OpenGL会复制名称字符串，因此应用程序可以在函数返回后立即释放其名称字符串的副本。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：index&gt;=GL_MAX_VERTEX_ATTRIBS</p>
<p>GL_INVALID_OPERATION：name以保留前缀“gl_”开头</p>
<p>GL_INVALID_VALUE：program不是OpenGL生成的值</p>
<p>GL_INVALID_OPERATION：program不是程序对象</p>
<p>相关Gets</p>
<p>glGet 参数GL_MAX_VERTEX_ATTRIBS</p>
<p>glGetActiveAttrib 参数program</p>
<p>glGetAttribLocation 参数program和name</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glDisableVertexAttribArray，glEnableVertexAttribArray，glUseProgram，glVertexAttrib，glVertexAttribPointer</p>
<h2 id="glBindBuffer-绑定一个命名（ID）的缓冲区对象"><a href="#glBindBuffer-绑定一个命名（ID）的缓冲区对象" class="headerlink" title="glBindBuffer- 绑定一个命名（ID）的缓冲区对象"></a>glBindBuffer- 绑定一个命名（ID）的缓冲区对象</h2><p>C规范</p>
<p>void glBindBuffer（GLenum target,GLuint buffer）;</p>
<p>参数</p>
<p>target</p>
<p>指定缓冲区对象绑定的目标。 符号常量必须为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY_BUFFER。</p>
<p>buffer</p>
<p>指定缓冲区对象的名称（ID）。</p>
<p>描述</p>
<p>glBindBuffer允许您创建或使用命名缓冲区对象。 调用glBindBuffer，目标设置为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY_BUFFER，缓冲区设置为新缓冲区对象的名称，这样就将缓冲区对象名称绑定到目标了。 当缓冲区对象绑定到目标时，该目标的先前绑定将自动中断。</p>
<p>缓冲区对象名称是无符号整数。 0值保留，但每个缓冲区对象目标没有默认缓冲区对象。 相反，缓冲区设置为0可以有效地取消绑定先前绑定的任何缓冲区对象，并恢复该缓冲区对象目标的客户机内存使用情况。 缓冲区对象名称和相应的缓冲区对象内容对于当前GL渲染上下文的共享对象空间是本地的。</p>
<p>您可以使用glGenBuffers生成一组新的缓冲区对象名称。</p>
<p>usage为GL_STATIC_DRAW时第一次绑定后的缓冲区对象的状态是零大小的内存缓冲区。</p>
<p>绑定非零缓冲区对象名称时，绑定到的目标上的GL操作会影响绑定缓冲区对象，并且绑定到的目标的查询将从绑定缓冲区对象返回状态。 当绑定缓冲区对象名称零时，如在初始状态中，尝试修改或查询绑定到的目标上的状态会生成GL_INVALID_OPERATION错误。</p>
<p>当通过调用glVertexAttribPointer更改顶点数组指针状态时，当前缓冲区对象绑定（GL_ARRAY_BUFFER_BINDING，GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING中的一个）被复制到要更改的顶点属性数组的相应客户端状态。当非零缓冲区对象绑定到GL_ARRAY_BUFFER目标时，传统上被解释为指向客户端内存的指针的顶点数组指针参数被解释为在基本机器单元中测量的缓冲区对象内的偏移量（glVertexAttribPointer原本的最后一个参数是顶点属性数组的指针，当绑定VBO后，最后一个参数就是指向所绑定的VBO的一个地址了）。</p>
<p>当非零缓冲区对象绑定到GL_ELEMENT_ARRAY_BUFFER目标时，glDrawElements的indices参数（传统上被解释为指向客户端内存的指针）被解释为在基本机器单元中测量的缓冲区对象内的偏移量。</p>
<p>使用glBindBuffer创建的缓冲区对象绑定保持活动状态，直到将不同的缓冲区对象名称绑定到同一目标，或者直到使用glDeleteBuffers删除绑定的缓冲区对象为止。</p>
<p>一旦创建，命名缓冲区对象可以根据需要经常重新绑定到任何目标。 但是，GL实现可以基于其初始绑定目标来选择如何优化缓冲区对象的存储。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：target不是允许的值</p>
<p>相关Gets</p>
<p>glGet 参数GL_ARRAY_BUFFER_BINDING</p>
<p>glGet 参数GL_ELEMENT_ARRAY_BUFFER_BINDING</p>
<p>另见</p>
<p>glDeleteBuffers，glGenBuffers，glGet ，glIsBuffer</p>
<h2 id="glBindFramebuffer-绑定一个命名的帧缓冲区对象"><a href="#glBindFramebuffer-绑定一个命名的帧缓冲区对象" class="headerlink" title="glBindFramebuffer- 绑定一个命名的帧缓冲区对象"></a>glBindFramebuffer- 绑定一个命名的帧缓冲区对象</h2><p>C规范</p>
<p>void glBindFramebuffer（GLenum target,</p>
<pre><code>                                            GLuint framebuffer）;
</code></pre>
<p>参数</p>
<p>target</p>
<p>指定帧缓冲区对象绑定的目标。 符号常量必须是GL_FRAMEBUFFER。</p>
<p>framebuffer</p>
<p>指定帧缓冲区对象的名称。</p>
<p>描述</p>
<p>glBindFramebuffer允许您创建或使用命名的帧缓冲对象。 调用glBindFramebuffer并将目标设置为GL_FRAMEBUFFER，将framebuffer设置为新的绑定了帧缓冲区对象名称的帧缓冲区对象。 绑定帧缓冲区对象时，先前的绑定会自动中断。</p>
<p>帧缓冲区对象对象名称是无符号整数。 保留值零以表示由窗口系统提供的默认帧缓冲区。 帧缓冲区对象对象名称和相应的framebuffer对象内容对于当前GL渲染上下文的共享对象空间是本地的。</p>
<p>您可以使用glGenFramebuffers生成一组新的framebuffer对象名称。</p>
<p>第一次绑定后的帧缓冲对象的状态是三个附着点（GL_COLOR_ATTACHMENT0，GL_DEPTH_ATTACHMENT和GL_STENCIL_ATTACHMENT），每个附加点都以GL_NONE作为对象类型。</p>
<p>当绑定了非零帧缓冲区对象名称，但目标GL_FRAMEBUFFER上的GL操作会影响绑定的帧缓冲区对象，目标GL_FRAMEBUFFER或帧缓冲区详细信息（如GL_DEPTH_BITS）的查询将从绑定的帧缓冲区对象返回状态。 当绑定帧缓冲对象名称为0时，则处于初始状态中，尝试修改或查询目标GL_FRAMEBUFFER上的状态会生成GL_INVALID_OPERATION错误。</p>
<p>当绑定了非零帧缓冲对象名称时，所有渲染到帧缓冲区（使用glDrawArrays和glDrawElements）和从帧缓冲区读取（使用glReadPixels，glCopyTexImage2D或glCopyTexSubImage2D）都使用附加到应用程序创建的帧缓冲区对象的图像而不是 默认窗口系统提供的帧缓冲。</p>
<p>应用程序创建的帧缓冲对象（即具有非零名称的对象）与默认的窗口系统提供的帧缓冲区有几个重要的不同。首先，它们具有用于颜色缓冲器，深度缓冲器和模板缓冲器的可修改的附着点，帧缓冲器可附接的图像可以附着和分离。其次，附加图像的大小和格式完全在GL内控制，并且不受窗口系统事件的影响，例如像素格式选择，窗口大小调整和显示模式改变。第三，当渲染或从应用程序创建的帧缓冲对象读取时，像素所有权测试总是成功（即它们拥有所有像素）。第四，没有可见的颜色缓冲位平面，只有一个“屏幕外”的彩色图像附件，因此没有前后缓冲区或swap。最后，没有多重采样缓冲区，因此依赖于实现的状态变量GL_SAMPLES和GL_SAMPLE_BUFFERS的值对于应用程序创建的帧缓冲区对象都是零。</p>
<p>使用glBindFramebuffer创建的帧缓冲区对象绑定保持活动状态，直到绑定了不同的帧缓冲区对象名称，或者直到使用glDeleteFramebuffers删除绑定的帧缓冲区对象。</p>
<p>注意</p>
<p>依赖于实现的像素深度和相关状态的查询是从当前绑定的帧缓冲对象导出的。 这些包括GL_RED_BITS，GL_GREEN_BITS，GL_BLUE_BITS，GL_ALPHA_BITS，GL_DEPTH_BITS，GL_STENCIL_BITS，GL_IMPLEMENTATION_COLOR_READ_TYPE，GL_IMPLEMENTATION_COLOR_READ_FORMAT，GL_SAMPLES和GL_SAMPLE_BUFFERS。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：target不是GL_FRAMEBUFFER。</p>
<p>相关Gets</p>
<p>glGet 参数GL_FRAMEBUFFER_BINDING</p>
<p>另见</p>
<p>glDeleteFramebuffers，glFramebufferRenderbuffer，glFramebufferTexture2D，glGenFramebuffers，glGet ，glGetFramebufferAttachmentParameteriv，glIsFramebuffer</p>
<h2 id="glBindRenderbuffer-绑定一个命名的渲染缓冲区对象"><a href="#glBindRenderbuffer-绑定一个命名的渲染缓冲区对象" class="headerlink" title="glBindRenderbuffer - 绑定一个命名的渲染缓冲区对象"></a>glBindRenderbuffer - 绑定一个命名的渲染缓冲区对象</h2><p>C规范</p>
<p>void glBindRenderbuffer（GLenum target，</p>
<pre><code>                                              GLuint renderbuffer）;
</code></pre>
<p>参数</p>
<p>target</p>
<p>指定renderbuffer对象绑定到的目标。 符号常量必须为GL_RENDERBUFFER。</p>
<p>renderbuffer</p>
<p>指定渲染缓冲区对象的名称。</p>
<p>描述</p>
<p>渲染缓冲区对象是一个数据存储对象，包含可渲染内部格式的单个图像。 渲染缓冲区的图像可以附加到帧缓冲区对象，以用作渲染目标和读取源。</p>
<p>glBindRenderbuffer允许您创建或使用命名的渲染缓冲区对象。 调用glBindRenderbuffer并将目标设置为GL_RENDERBUFFER并将renderbuffer设置为绑定了渲染缓冲区对象名称的新对象缓冲区。 绑定渲染缓冲区对象时，先前的绑定会自动中断。</p>
<p>渲染缓冲区对象名称是无符号整数。 零值保留，但没有默认的渲染缓冲区对象。 相反，renderbuffer设置为0可以有效地解除先前绑定的任何渲染缓冲区对象的绑定。 渲染缓冲区对象名称和相应的渲染缓冲区对象内容对于当前GL渲染上下文的共享对象空间是本地的。</p>
<p>您可以使用glGenFramebuffers生成一组新的renderbuffer对象名称。</p>
<p>第一次绑定后立即渲染缓冲区对象的状态是零大小的内存缓冲区，格式为GL_RGBA4，零大小的红色，绿色，蓝色，alpha，深度和模板像素深度。</p>
<p>绑定非零渲染缓冲区对象名称时，目标GL_RENDERBUFFER上的GL操作会影响绑定的渲染缓冲区对象，目标GL_RENDERBUFFER的查询将从绑定的渲染缓冲区对象返回状态。 当绑定渲染缓冲区对象名称为0时，如在初始状态中，尝试修改或查询目标GL_RENDERBUFFER上的状态会生成GL_INVALID_OPERATION错误。</p>
<p>使用glBindRenderbuffer创建的renderbuffer对象绑定保持活动状态，直到绑定了另一个renderbuffer对象名称，或者直到使用glDeleteRenderbuffers删除绑定的renderbuffer对象。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：target不是GL_RENDERBUFFER。</p>
<p>相关Gets</p>
<p>glGet 参数GL_RENDERBUFFER_BINDING</p>
<p>另见</p>
<p>glDeleteRenderbuffers，glFramebufferRenderbuffer，glGenRenderbuffers，glGet，glGetRenderbufferParameteriv，glIsRenderbuffer，glRenderbufferStorage</p>
<h2 id="glBindTexture-将一个指定的纹理ID绑定到一个纹理目标上"><a href="#glBindTexture-将一个指定的纹理ID绑定到一个纹理目标上" class="headerlink" title="glBindTexture- 将一个指定的纹理ID绑定到一个纹理目标上"></a>glBindTexture- 将一个指定的纹理ID绑定到一个纹理目标上</h2><p>C规范</p>
<p>void glBindTexture(GLenum target, GLuint texture);</p>
<p>参数</p>
<p>target</p>
<pre><code>指定之前激活了的纹理要绑定到的一个目标。必须是GL_TEXTURE_2D 或GL_TEXTURE_CUBE_MAP。
</code></pre>
<p>texture</p>
<pre><code>指定纹理ID。
</code></pre>
<p>描述</p>
<p>glBindTexture可以让你创建或使用一个纹理ID。调用glBindTexture，target设置为GL_TEXTURE_2D 或GL_TEXTURE_CUBE_MAP，texture设置为已经激活了的要绑定到目标的纹理ID。当一个纹理ID绑定到目标时，这个目标之前的绑定关系就会自动解除。</p>
<p>纹理ID都是无符整型的（unsigned intege），数值０被系统保留用于表示每个纹理目标的默认纹理。纹理ID和相应的纹理内容对当前的GL渲染环境的共享对象空间来说都是本地的。</p>
<p>我们可以调用glGenTextures来创建一些列的纹理ID。</p>
<p>当一个纹理首次被绑定时，它采用指定的目标：一个纹理首次绑定到GL_TEXTURE_2D将成为二维纹理，首次绑定到GL_TEXTURE_CUBE_MAP的将成为立方体贴图纹理，紧接在第一次绑定后的二维纹理的状态等效于GL初始化时的默认GL_TEXTURE_2D的状态，对于立方体映射的纹理也是如此。</p>
<p>当一个纹理被绑定后，那GL对该纹理所绑定到的目标进行的操作也将影响绑定的纹理，而对目标的查询将是返回该纹理的状态值，也就是相当于目标变成了纹理ID的另一个索引ID。纹理ID=0会引用在初始化时绑定到它们的默认纹理。</p>
<p>由glBindTexture创建的绑定关系将一直保持激活状态，除非当前目标被另一个纹理ID绑定，或者是绑定的纹理ID通过调用glDeleteTextures删除了。</p>
<p>一旦被创建，一个纹理ID是可以重复绑定到它原来的目标上的。使用glBindTexture将一个已经存在的纹理ID绑定到一个目标上要比通过glTexImage2D重新加载纹理图像快得多。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果target不是一个被允许的值（GL_TEXTURE_2D 或GL_TEXTURE_CUBE_MAP）。</p>
<p>GL_INVALID_OPERATION ：如果texture是之前创建的，并且绑定了一个目标，而这一次调用glBindTexture绑定的目标和之前的目标不一致。</p>
<p>相关Gets</p>
<p>glGet 变量：GL_TEXTURE_BINDING_2D 或 GL_TEXTURE_BINDING_CUBE_MAP</p>
<p>另见</p>
<p>glDeleteTextures glGenTextures glGet  glGetTexParameter glIsTexture glTexImage2D glTexParameter</p>
<h2 id="glBlendColor-设置混合颜色"><a href="#glBlendColor-设置混合颜色" class="headerlink" title="glBlendColor- 设置混合颜色"></a>glBlendColor- 设置混合颜色</h2><p>C规范</p>
<p>void glBlendColor(    GLclampf red,<br>     GLclampf green,<br>     GLclampf blue,<br>     GLclampf alpha);</p>
<p>参数</p>
<p>red, green, blue, alpha</p>
<p>指定GL_BLEND_COLOR的组件</p>
<p>描述</p>
<p>GL_BLEND_COLOR可用于计算源和目标混合因子。 在存储之前，颜色分量被截断到[0,1]的范围。 有关混合操作的完整说明，请参阅glBlendFunc。 最初，GL_BLEND_COLOR设置为（0,0,0,0）。</p>
<p>相关Gets</p>
<p>glGet 参数GL_BLEND_COLOR</p>
<p>另见</p>
<p>glBlendEquation，glBlendFunc，glGetString</p>
<h2 id="glBlendEquation-指定用于RGB混合方程和Alpha混合方程的方程式"><a href="#glBlendEquation-指定用于RGB混合方程和Alpha混合方程的方程式" class="headerlink" title="glBlendEquation - 指定用于RGB混合方程和Alpha混合方程的方程式"></a>glBlendEquation - 指定用于RGB混合方程和Alpha混合方程的方程式</h2><p>C规范</p>
<p>void glBlendEquation(    GLenum mode);</p>
<p>参数</p>
<p>mode</p>
<p>指定源和目标颜色的组合方式。它必须是GL_FUNC_ADD，GL_FUNC_SUBTRACT或GL_FUNC_REVERSE_SUBTRACT。</p>
<p>描述</p>
<p>混合方程式确定新像素（“源”颜色）如何与​​帧缓冲区中已有的像素（“目标”颜色）组合。此功能将RGB混合方程和α混合方程设置为单个方程。</p>
<p>这些等式使用由glBlendFunc或glBlendFuncSeparate指定的源和目标混合因子。有关各种混合因子的说明，请参阅glBlendFunc或glBlendFuncSeparate。</p>
<p>在下面的等式中，源和目标颜色分量分别称为Rs Gs Bs As和Rd Gd Bd Ad。结果颜色称为Rr Gr Br Ar。源和目的地混合因子分别表示为sR sG sB sA和dR dG dB dA.对于这些等式，所有颜色分量被理解为具有[0,1]范围内的值。</p>
<p>Mode    RGB    Alpha<br>GL_FUNC_ADD<br>Rr = Rs<em>sR + Rd</em>dR<br>Gr = Gs<em>sG + Gd</em>dG<br>Br = Bs<em>sB + Bd</em>dB<br>Ar = As<em>sA + Ad</em>dA<br>GL_FUNC_SUBTRACT    Rr = Rs<em>sR - Rd</em>dR<br>Gr = Gs<em>sG - Gd</em>dG<br>Br = Bs<em>sB - Bd</em>dB    Ar = As<em>sA - Ad</em>dA<br>GL_FUNC_REVERSE_SUBTRACT    Rr = Rd<em>dR - Rs</em>sR<br>Gr = Gd<em>dG - Gs</em>sG<br>Br = Bd<em>dB - Bs</em>sB    Ar = Ad<em>dA - As</em>sA<br>这些方程的结果被限制在[0,1]的范围内。</p>
<p>除其他外，GL_FUNC_ADD方程对于抗锯齿和透明度非常有用。</p>
<p>默认的，RGB混合方程和α混合方程都设置为GL_FUNC_ADD。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：mode不是GL_FUNC_ADD，GL_FUNC_SUBTRACT或GL_FUNC_REVERSE_SUBTRACT之一</p>
<p>相关Gets</p>
<p>glGet 参数GL_BLEND_EQUATION_RGB</p>
<p>glGet 参数GL_BLEND_EQUATION_ALPHA</p>
<p>另见</p>
<p>glGetString，glBlendColor，glBlendEquationSeparate，glBlendFunc，glBlendFuncSeparate</p>
<h2 id="glBlendEquationSeparate-分别设置RGB混合方程和alpha混合方程"><a href="#glBlendEquationSeparate-分别设置RGB混合方程和alpha混合方程" class="headerlink" title="glBlendEquationSeparate -  分别设置RGB混合方程和alpha混合方程"></a>glBlendEquationSeparate -  分别设置RGB混合方程和alpha混合方程</h2><p>C规范</p>
<p>void glBlendEquationSeparate(    GLenum modeRGB,<br>     GLenum modeAlpha);</p>
<p>参数</p>
<p>modeRGB</p>
<p>指定RGB混合方程，如何组合源和目标颜色的红色，绿色和蓝色分量。它必须是GL_FUNC_ADD，GL_FUNC_SUBTRACT或GL_FUNC_REVERSE_SUBTRACT。</p>
<p>modeAlpha</p>
<p>指定alpha混合等式，如何组合源和目标颜色的alpha分量。它必须是GL_FUNC_ADD，GL_FUNC_SUBTRACT或GL_FUNC_REVERSE_SUBTRACT。</p>
<p>描述</p>
<p>混合方程式确定新像素（“源”颜色）如何与​​帧缓冲区中已有的像素（“目标”颜色）组合。此函数指定RGB颜色分量的一个混合方程和alpha分量的一个混合方程。</p>
<p>这些等式使用由glBlendFunc或glBlendFuncSeparate指定的源和目标混合因子。有关各种混合因子的说明，请参阅glBlendFunc或glBlendFuncSeparate。</p>
<p>在下面的等式中，源和目标颜色分量分别称为Rs Gs Bs As和Rd Gd Bd Ad。结果颜色称为Rr Gr Br Ar。源和目的地混合因子分别表示为sR sG sB sA和dR dG dB dA.对于这些等式，所有颜色分量被理解为具有[0,1]范围内的值。</p>
<p>Mode    RGB    Alpha<br>GL_FUNC_ADD<br>Rr = Rs<em>sR + Rd</em>dR<br>Gr = Gs<em>sG + Gd</em>dG<br>Br = Bs<em>sB + Bd</em>dB<br>Ar = As<em>sA + Ad</em>dA<br>GL_FUNC_SUBTRACT    Rr = Rs<em>sR - Rd</em>dR<br>Gr = Gs<em>sG - Gd</em>dG<br>Br = Bs<em>sB - Bd</em>dB    Ar = As<em>sA - Ad</em>dA<br>GL_FUNC_REVERSE_SUBTRACT    Rr = Rd<em>dR - Rs</em>sR<br>Gr = Gd<em>dG - Gs</em>sG<br>Br = Bd<em>dB - Bs</em>sB    Ar = Ad<em>dA - As</em>sA<br>这些方程的结果被限制在[0,1]的范围内。</p>
<p>除其他外，GL_FUNC_ADD方程对于抗锯齿和透明度非常有用。</p>
<p>默认的，RGB混合方程和α混合方程都设置为GL_FUNC_ADD。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：modeRGB或modeAlpha不是GL_FUNC_ADD，GL_FUNC_SUBTRACT或GL_FUNC_REVERSE_SUBTRACT之一。</p>
<p>相关Gets</p>
<p>glGet 参数GL_BLEND_EQUATION_RGB</p>
<p>glGet 参数GL_BLEND_EQUATION_ALPHA</p>
<p>另见</p>
<p>glGetString，glBlendColor，glBlendEquation，glBlendFunc，glBlendFuncSeparate</p>
<h2 id="glBlendFunc-指定像素算术"><a href="#glBlendFunc-指定像素算术" class="headerlink" title="glBlendFunc - 指定像素算术"></a>glBlendFunc - 指定像素算术</h2><p>C规范</p>
<p>void glBlendFunc(    GLenum sfactor,<br>     GLenum dfactor);</p>
<p>参数</p>
<p>sfactor</p>
<p>指定如何计算红色，绿色，蓝色和alpha源混合因子。下列符号常量被接受：GL_ZERO，GL_ONE，GL_SRC_COLOR，GL_ONE_MINUS_SRC_COLOR，GL_DST_COLOR，GL_ONE_MINUS_DST_COLOR，GL_SRC_ALPHA，GL_ONE_MINUS_SRC_ALPHA，GL_DST_ALPHA，GL_ONE_MINUS_DST_ALPHA，GL_CONSTANT_COLOR，GL_ONE_MINUS_CONSTANT_COLOR，GL_CONSTANT_ALPHA，GL_ONE_MINUS_CONSTANT_ALPHA和GL_SRC_ALPHA_SATURATE。初始值为GL_ONE。</p>
<p>dfactor</p>
<p>指定如何计算红色，绿色，蓝色和alpha目标混合因子。接受以下符号常量：GL_ZERO，GL_ONE，GL_SRC_COLOR，GL_ONE_MINUS_SRC_COLOR，GL_DST_COLOR，GL_ONE_MINUS_DST_COLOR，GL_SRC_ALPHA，GL_ONE_MINUS_SRC_ALPHA，GL_DST_ALPHA，GL_ONE_MINUS_DST_ALPHA。 GL_CONSTANT_COLOR，GL_ONE_MINUS_CONSTANT_COLOR，GL_CONSTANT_ALPHA和GL_ONE_MINUS_CONSTANT_ALPHA。初始值为GL_ZERO。</p>
<p>描述</p>
<p>可以使用将输入（源）RGBA值与帧缓冲区中已有的RGBA值（目标值）混合的函数来绘制像素。最初禁用混合。使用参数GL_BLEND调用glEnable和glDisable以启用和禁用混合。</p>
<p>glBlendFunc定义启用时的混合操作。 sfactor指定用于缩放源颜色分量的方法。 dfactor指定用于缩放目标颜色分量的方法。可能的方法如下表所述。每种方法都定义了四个比例因子，分别为红色，绿色，蓝色和alpha。在表格和随后的等式中，源和目标颜色分量被称为Rs Gs Bs As和Rd Gd Bd Ad。 glBlendColor指定的颜色称为Rc Gc Bc Ac。它们被理解为具有0到kR kG kB kA之间的整数值,其中</p>
<p>kc=2^mc-1;(mR mG mB mA是红色，绿色，蓝色和alpha位平面的数量)</p>
<p>源和目标比例因子称为sR sG sB sA和dR dG dB dA.表中描述的比例因子，记为fR fG fB fA，表示源或目标因子。所有比例因子的范围均为[0,1]。</p>
<p>混合函数<br>混合系数枚举值    fR fG fB    fA<br>GL_ZERO    0,0,0    0<br>GL_ONE    1,1,1    1<br>GL_SRC_COLOR    Rs,Gs,Bs    As<br>GL_ONE_MINUS_SRC_COLOR    1-Rs,1-Gs,1-Bs    1-As<br>GL_SRC_ALPHA    As,As,As    As<br>GL_ONE_MINUS_SRC_ALPHA    1-As,1-As,1-As    1-As<br>GL_DST_COLOR    Rd,Gd,Bd    Ad<br>GL_ONE_MINUS_DST_COLOR    1-Rd,1-Gd,1-Bd    1-Ad<br>GL_DST_ALPHA    Ad,Ad,Ad    Ad<br>GL_ONE_MINUS_DST_ALPHA    1-Ad,1-Ad,1-Ad    1-Ad<br>GL_CONSTANT_COLOR    Rc,Gc,Bc    Ac<br>GL_ONE_MINUS_CONSTANT_COLOR    1-Rc,1-Gc,1-Bc    1-Ac<br>GL_CONSTANT_ALPHA    Ac,Ac,Ac    Ac<br>GL_ONE_MINUS_CONSTANT_ALPHA    1-Ac,1-Ac,1-Ac    1-Ac<br>GL_SRC_ALPHA_SATURATE    min(As,1-Ad)    1<br>为了确定像素的混合RGBA值，系统会使用由glBlendEquation或glBlendEquationSeparate设置的方程之一。</p>
<p>未精确指定混合算法，因为混合使用不精确的整数颜色值。但是，保证应该等于1的混合因子不会修改其被乘数，并且混合因子等于0会将其被乘数减少为0。</p>
<p>注意</p>
<p>传入（源）alpha被视为材料的不透明度，范围从表示完全不透明度的1.0（kA）到0.0（0），表示完全透明。</p>
<p>最好使用混合函数（GL_SRC_ALPHA，GL_ONE_MINUS_SRC_ALPHA）实现透明度，其中基元从最远到最近排序。请注意，此透明度计算不要求帧缓冲区中存在alpha位平面。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：sfactor或dfactor不是可接受的值。</p>
<p>相关Gets</p>
<p>glGet 参数GL_BLEND_SRC_RGB或GL_BLEND_SRC_ALPHA</p>
<p>glGet 参数GL_BLEND_DST_RGB或GL_BLEND_DST_ALPHA</p>
<p>glIsEnabled 参数GL_BLEND</p>
<p>另见</p>
<p>glBlendColor，glBlendEquation，glBlendEquationSeparate，glBlendFuncSeparate，glClear，glEnable，glStencilFunc</p>
<h2 id="glBlendFuncSeparate-分别指定RGB和alpha分量的像素算术"><a href="#glBlendFuncSeparate-分别指定RGB和alpha分量的像素算术" class="headerlink" title="glBlendFuncSeparate - 分别指定RGB和alpha分量的像素算术"></a>glBlendFuncSeparate - 分别指定RGB和alpha分量的像素算术</h2><p>C规范</p>
<p>void glBlendFuncSeparate(    GLenum srcRGB,<br>     GLenum dstRGB,<br>     GLenum srcAlpha,<br>     GLenum dstAlpha);</p>
<p>参数</p>
<p>srcRGB</p>
<p>指定如何计算红色，绿色和蓝色混合因子。下列符号常量被接受：GL_ZERO，GL_ONE，GL_SRC_COLOR，GL_ONE_MINUS_SRC_COLOR，GL_DST_COLOR，GL_ONE_MINUS_DST_COLOR，GL_SRC_ALPHA，GL_ONE_MINUS_SRC_ALPHA，GL_DST_ALPHA，GL_ONE_MINUS_DST_ALPHA，GL_CONSTANT_COLOR，GL_ONE_MINUS_CONSTANT_COLOR，GL_CONSTANT_ALPHA，GL_ONE_MINUS_CONSTANT_ALPHA和GL_SRC_ALPHA_SATURATE。初始值为GL_ONE。</p>
<p>dstRGB</p>
<p>指定如何计算红色，绿色和蓝色目标混合因子。接受以下符号常量：GL_ZERO，GL_ONE，GL_SRC_COLOR，GL_ONE_MINUS_SRC_COLOR，GL_DST_COLOR，GL_ONE_MINUS_DST_COLOR，GL_SRC_ALPHA，GL_ONE_MINUS_SRC_ALPHA，GL_DST_ALPHA，GL_ONE_MINUS_DST_ALPHA。 GL_CONSTANT_COLOR，GL_ONE_MINUS_CONSTANT_COLOR，GL_CONSTANT_ALPHA和GL_ONE_MINUS_CONSTANT_ALPHA。初始值为GL_ZERO。</p>
<p>srcAlpha</p>
<p>指定如何计算alpha源混合因子。对于srcRGB，接受相同的符号常量。初始值为GL_ONE。</p>
<p>dstAlpha</p>
<p>指定如何计算alpha目标混合因子。 dstRGB接受相同的符号常量。初始值为GL_ZERO。</p>
<p>描述</p>
<p>可以使用将输入（源）RGBA值与帧缓冲区中已有的RGBA值（目标值）混合的函数来绘制像素。最初禁用混合。使用参数GL_BLEND调用glEnable和glDisable以启用和禁用混合。</p>
<p>glBlendFuncSeparate定义启用时的混合操作。 srcRGB指定用于缩放源RGB颜色分量的方法。 dstRGB指定用于缩放目标RGB颜色分量的方法。同样，srcAlpha指定用于缩放源alpha颜色分量的方法，dstAlpha指定用于缩放目标alpha分量的方法。可能的方法如下表所述。每种方法都定义了四个比例因子，分别为红色，绿色，蓝色和alpha。</p>
<p>在表格和随后的等式中，源和目标颜色分量被称为Rs Gs Bs As和Rd Gd Bd Ad。 glBlendColor指定的颜色称为Rc Gc Bc Ac。它们被理解为具有0到kR kG kB kA之间的整数值,其中</p>
<p>kc=2^mc-1;(mR mG mB mA是红色，绿色，蓝色和alpha位平面的数量)</p>
<p>源和目标比例因子称为sR sG sB sA和dR dG dB dA.表中描述的比例因子，记为fR fG fB fA，表示源或目标因子。所有比例因子的范围均为[0,1]。</p>
<p>混合函数<br>混合系数枚举值    fR fG fB    fA<br>GL_ZERO    0,0,0    0<br>GL_ONE    1,1,1    1<br>GL_SRC_COLOR    Rs,Gs,Bs    As<br>GL_ONE_MINUS_SRC_COLOR    1-Rs,1-Gs,1-Bs    1-As<br>GL_SRC_ALPHA    As,As,As    As<br>GL_ONE_MINUS_SRC_ALPHA    1-As,1-As,1-As    1-As<br>GL_DST_COLOR    Rd,Gd,Bd    Ad<br>GL_ONE_MINUS_DST_COLOR    1-Rd,1-Gd,1-Bd    1-Ad<br>GL_DST_ALPHA    Ad,Ad,Ad    Ad<br>GL_ONE_MINUS_DST_ALPHA    1-Ad,1-Ad,1-Ad    1-Ad<br>GL_CONSTANT_COLOR    Rc,Gc,Bc    Ac<br>GL_ONE_MINUS_CONSTANT_COLOR    1-Rc,1-Gc,1-Bc    1-Ac<br>GL_CONSTANT_ALPHA    Ac,Ac,Ac    Ac<br>GL_ONE_MINUS_CONSTANT_ALPHA    1-Ac,1-Ac,1-Ac    1-Ac<br>GL_SRC_ALPHA_SATURATE    min(As,1-Ad)    1<br>为了确定像素的混合RGBA值，系统会使用由glBlendEquation或glBlendEquationSeparate设置的方程之一。</p>
<p>未精确指定混合算法，因为混合使用不精确的整数颜色值。但是，保证应该等于1的混合因子不会修改其被乘数，并且混合因子等于0会将其被乘数减少为0。</p>
<p>注意</p>
<p>传入（源）alpha被视为材料的不透明度，范围从表示完全不透明度的1.0（kA）到0.0（0），表示完全透明。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：srcRGB，dstRGB，srcAlpha或dstAlpha不是可接受的值。</p>
<p>相关Gets</p>
<p>glGet 参数GL_BLEND_SRC_RGB</p>
<p>glGet 参数GL_BLEND_SRC_ALPHA</p>
<p>glGet 参数GL_BLEND_DST_RGB</p>
<p>glGet 参数GL_BLEND_DST_ALPHA</p>
<p>glIsEnabled 参数GL_BLEND</p>
<p>另见</p>
<p>glBlendColor，glBlendEquation，glBlendEquationSeparate，glBlendFunc，glClear，glEnable，glStencilFunc</p>
<h2 id="glBufferData-创建并初始化缓冲区对象的数据存储"><a href="#glBufferData-创建并初始化缓冲区对象的数据存储" class="headerlink" title="glBufferData- 创建并初始化缓冲区对象的数据存储"></a>glBufferData- 创建并初始化缓冲区对象的数据存储</h2><p>C规范</p>
<p>void glBufferData（GLenum target,GLsizeiptr size,const GLvoid * data,GLenum usage）;</p>
<p>参数</p>
<p>target</p>
<p>指定目标缓冲区对象。 符号常量必须为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY_BUFFER。</p>
<p>size</p>
<p>指定缓冲区对象的新数据存储的大小（以字节为单位）。</p>
<p>data</p>
<p>指定将复制到数据存储区以进行初始化的数据的指针，如果不复制数据，则指定NULL。</p>
<p>usage</p>
<p>指定数据存储的预期使用模式。 符号常量必须为GL_STREAM_DRAW，GL_STATIC_DRAW或GL_DYNAMIC_DRAW。</p>
<p>描述</p>
<p>glBufferData为当前绑定到target的缓冲区对象创建一个新的数据存储。 删除任何预先存在的数据存储。 使用指定的字节和usage创建新数据存储。 如果data不是NULL，则使用来自此指针的数据初始化数据存储。</p>
<p>usage是关于如何访问缓冲区对象的数据存储的GL实现的提示。这使GL实现能够做出更明智的决策，这可能会显着影响缓冲区对象的性能。 但是，它不会限制数据存储的实际使用。usage可以分为两部分：第一，访问频率（修改和使用），第二，访问的性质。 访问频率可能是以下之一：</p>
<p>STREAM</p>
<pre><code>    数据存储内容将被修改一次并最多使用几次。
</code></pre>
<p>STATIC</p>
<pre><code>    数据存储内容将被修改一次并多次使用。
</code></pre>
<p>DYNAMIC</p>
<pre><code>    数据存储内容将被重复修改并多次使用。
</code></pre>
<p>访问的性质必须是：</p>
<p>DRAW</p>
<pre><code>    数据存储内容由应用程序修改，并用作GL绘图和图像规范命令的源。
</code></pre>
<p>注意</p>
<p>如果data为NULL，则仍会创建指定大小的数据存储，但其内容仍未初始化，因此被视为未定义的。</p>
<p>客户端必须使数据元素与客户端平台的要求保持一致，并具有额外的基本级要求，即缓冲区内对包含N的数据的偏移量是N的倍数。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：target不是GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY_BUFFER。</p>
<p>GL_INVALID_ENUM ：usage不是GL_STREAM_DRAW，GL_STATIC_DRAW或GL_DYNAMIC_DRAW。</p>
<p>GL_INVALID_VALUE ：size是负数</p>
<p>GL_INVALID_OPERATION ：如果保留的缓冲区对象名称0绑定到target。</p>
<p>GL_OUT_OF_MEMORY ：如果GL无法创建具有指定大小的数据存储</p>
<p>相关Gets</p>
<p>glGetBufferParameteriv 参数 GL_BUFFER_SIZE 或GL_BUFFER_USAGE</p>
<p>另见</p>
<p>glBindBuffer，glBufferSubData​​​​​​​​​​​​​​</p>
<p>版权、</p>
<h2 id="glBufferSubData-更新缓冲区对象的数据存储的子集"><a href="#glBufferSubData-更新缓冲区对象的数据存储的子集" class="headerlink" title="glBufferSubData - 更新缓冲区对象的数据存储的子集"></a>glBufferSubData - 更新缓冲区对象的数据存储的子集</h2><p>C规范</p>
<p>void glBufferSubData(    GLenum target,<br>     GLintptr offset,<br>     GLsizeiptr size,<br>     const GLvoid * data);</p>
<p>参数</p>
<p>target</p>
<p>指定目标缓冲区对象。符号常量必须为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY_BUFFER。</p>
<p>offset</p>
<p>指定缓冲区对象的数据存储中的需要数据替换偏移量，以字节为单位进行测量。</p>
<p>size</p>
<p>指定要替换的数据存储区域的大小（以字节为单位）。<br>data</p>
<p>指定指向将复制到数据存储中的新数据的指针。</p>
<p>描述</p>
<p>glBufferSubData重新定义当前绑定到target的缓冲区对象的部分或全部数据存储。从字节偏移量offset开始并扩展为size字节的数据从data指向的存储器复制到数据存储器。如果offset和size一起定义超出缓冲区对象的数据存储边界的范围，则抛出错误。</p>
<p>注意</p>
<p>替换整个数据存储时，请考虑使用glBufferSubData而不是使用glBufferData完全重新创建数据存储。这避免了重新分配数据存储的成本。</p>
<p>考虑使用多个缓冲区对象，以避免在数据存储更新期间停止渲染管道。如果管道中的任何渲染引用glBufferSubData正在更新的缓冲区对象中的数据，特别是来自正在更新的特定区域，则在更新数据存储之前，该渲染必须从管道中消失。</p>
<p>客户端必须使数据元素与客户端平台的要求保持一致，并具有额外的基本级要求，即缓冲区内对包含N的数据的偏移量是N的倍数。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：target不是GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY_BUFFER</p>
<p>GL_INVALID_VALUE：offset或size为负，或者如果它们在一起，而定义超出缓冲区对象的已分配数据存储的内存区域。</p>
<p>GL_INVALID_OPERATION：保留的缓冲区对象名称0绑定到target</p>
<p>另见</p>
<p>glBindBuffer，glBufferData</p>
<h2 id="glCheckFramebufferStatus-返回帧缓冲区对象的帧缓冲区完整性状态"><a href="#glCheckFramebufferStatus-返回帧缓冲区对象的帧缓冲区完整性状态" class="headerlink" title="glCheckFramebufferStatus - 返回帧缓冲区对象的帧缓冲区完整性状态"></a>glCheckFramebufferStatus - 返回帧缓冲区对象的帧缓冲区完整性状态</h2><p>C规范</p>
<p>GLenum glCheckFramebufferStatus（GLenum target）;</p>
<p>参数</p>
<p>target</p>
<p>指定目标帧缓冲区对象。 符号常量必须是GL_FRAMEBUFFER。</p>
<p>描述</p>
<p>glCheckFramebufferStatus返回一个符号常量，用于标识当前绑定的帧缓冲是否为帧缓冲完成，如果不是“完成”，则返回违反帧缓冲完整性的哪个规则的标识。</p>
<p>如果帧缓冲完成，则返回GL_FRAMEBUFFER_COMPLETE。 如果帧缓冲未完成，则返回值如下：</p>
<p>GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT</p>
<pre><code>    并非所有帧缓冲附加点都是帧缓冲附件完成。 这意味着附加渲染缓冲区或纹理的至少一个附着点的附加对象不再存在，可能是具有宽度或高度为零的附加图像，或者颜色附加点附加了不可着色的图像， 或深度附着点附有非深度可渲染图像，或者模板附着点附有非模板可渲染图像。

    颜色可渲染格式包括GL_RGBA4，GL_RGB5_A1和GL_RGB565。 GL_DEPTH_COMPONENT16是唯一可深度渲染的格式。 GL_STENCIL_INDEX8是唯一的模板可渲染格式。
</code></pre>
<p>GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS</p>
<pre><code>    并非所有附加图像都具有相同的宽度和高度。
</code></pre>
<p>GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT</p>
<pre><code>    没有图像附加到帧缓冲区。
</code></pre>
<p>GL_FRAMEBUFFER_UNSUPPORTED</p>
<pre><code>    附加图像的内部格式的组合违反了依赖于实现的一组限制。
</code></pre>
<p>如果当前绑定的帧缓冲区不是帧缓冲区完成，则尝试使用帧缓冲区进行写入或读取是错误的。 这意味着渲染命令（glClear，glDrawArrays和glDrawElements）以及读取帧缓冲区（glReadPixels，glCopyTexImage2D和glCopyTexSubImage2D）的命令将在帧缓冲区未完成帧缓冲区时调用时生成错误GL_INVALID_FRAMEBUFFER_OPERATION。</p>
<p>注意</p>
<p>强烈建议（即使并不需要），应用程序调用glCheckFramebufferStatus以查看帧缓冲是否在渲染之前完成。这是因为某些实现可能不支持呈现内部格式的特定组合。 在这种情况下将会返回GL_FRAMEBUFFER_UNSUPPORTED。</p>
<p>默认的窗口系统提供的帧缓冲区总是帧缓冲完成，因此当GL_FRAMEBUFFER_BINDING为0时返回GL_FRAMEBUFFER_COMPLETE。</p>
<p>此外，如果发生错误，则返回0。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果target不是GL_FRAMEBUFFER。</p>
<p>另见</p>
<p>glBindRenderbuffer，glCopyTexImage2D，glCopyTexSubImage2D，glDrawArrays，glDrawElements，glReadPixels，glRenderbufferStorage</p>
<p>版权</p>
<h2 id="glClear-清除预设值的缓冲区"><a href="#glClear-清除预设值的缓冲区" class="headerlink" title="glClear- 清除预设值的缓冲区"></a>glClear- 清除预设值的缓冲区</h2><p>C规范</p>
<p>void glClear（GLbitfield mask）;</p>
<p>参数</p>
<p>mask</p>
<p>使用掩码的按位异或运算来表示要清除的缓冲区。 三个掩码是GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT。</p>
<p>描述</p>
<p>glClear将窗口的位平面区域设置为先前由glClearColor，glClearDepthf和glClearStencil设置的值。</p>
<p>像素的归属测试，裁剪测试，抖动和缓冲区按位掩码都会影响glClear的操作。裁剪箱限定了清除区域。glClear忽略混合函数，模板，片元着色和深度缓冲。</p>
<p>glClear采用单个参数，该参数是多个值的按位异或，指示要清除哪个缓冲区。</p>
<p>值如下：</p>
<p>GL_COLOR_BUFFER_BIT<br>                   表示当前启用了颜色写入的缓冲区。</p>
<p>GL_DEPTH_BUFFER_BIT<br>                   深度缓冲区。</p>
<p>GL_STENCIL_BUFFER_BIT<br>                   指示模板缓冲区。</p>
<p>清除每个缓冲区的值取决于该缓冲区的清除值的设置。</p>
<p>注意</p>
<p>如果不存在缓冲区，则指向该缓冲区的glClear无效。</p>
<p>错误</p>
<p>GL_INVALID_VALUE ：如果掩码中设置了除三个定义位以外的任何位。</p>
<p>相关Gets</p>
<p>glGet 参数GL_DEPTH_CLEAR_VALUE</p>
<p>glGet 参数GL_COLOR_CLEAR_VALUE</p>
<p>glGet 参数GL_STENCIL_CLEAR_VALUE</p>
<p>另见</p>
<p>glClearColor，glClearDepthf，glClearStencil，glColorMask，glDepthMask，glScissor，glStencilMask</p>
<h2 id="glClearColor-为颜色缓冲区指定清除值"><a href="#glClearColor-为颜色缓冲区指定清除值" class="headerlink" title="glClearColor- 为颜色缓冲区指定清除值"></a>glClearColor- 为颜色缓冲区指定清除值</h2><p>C规范</p>
<p>void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);</p>
<p>参数</p>
<p>red</p>
<p>green</p>
<p>blue</p>
<p>alpha</p>
<p>指定颜色缓冲区清除时的RGBA值，默认都是0</p>
<p>描述</p>
<p>glClearColor为glClear清除颜色缓冲区时指定RGBA值（也就是所有的颜色都会被替换成指定的RGBA值）。每个值的取值范围都是0.0~1.0，超出范围的将被截断。</p>
<p>相关Gets</p>
<p>glGetXXX 获取GL_COLOR_CLEAR_VALUE的值。</p>
<p>另见</p>
<p>glClear</p>
<h2 id="glClearDepthf-指定深度缓冲区的清除值"><a href="#glClearDepthf-指定深度缓冲区的清除值" class="headerlink" title="glClearDepthf - 指定深度缓冲区的清除值"></a>glClearDepthf - 指定深度缓冲区的清除值</h2><p>C规范</p>
<p>void glClearDepthf(    GLclampf depth);</p>
<p>参数</p>
<p>depth</p>
<p>指定清除深度缓冲区时使用的深度值。 初始值为1。</p>
<p>描述</p>
<p>glClearDepthf指定glClear用于清除深度缓冲区的深度值。 glClearDepthf指定的值被限制在0 1范围内。</p>
<p>相关Gets</p>
<p>glGet 参数GL_DEPTH_CLEAR_VALUE</p>
<p>另见</p>
<p>glClear</p>
<h2 id="glClearStencil-指定模板缓冲区的清除值"><a href="#glClearStencil-指定模板缓冲区的清除值" class="headerlink" title="glClearStencil - 指定模板缓冲区的清除值"></a>glClearStencil - 指定模板缓冲区的清除值</h2><p>C规范</p>
<p>void glClearStencil(    GLint s);</p>
<p>参数</p>
<p>s</p>
<p>指定清除模板缓冲区时使用的索引。 初始值为0。</p>
<p>描述</p>
<p>glClearStencil指定glClear用于清除模板缓冲区的索引。 s被设置为2^m - 1，其中m是模板缓冲区中的位数。</p>
<p>相关Gets</p>
<p>glGet 参数GL_STENCIL_CLEAR_VALUE</p>
<p>glGet 参数GL_STENCIL_BITS</p>
<p>另见</p>
<p>glClear，glStencilFunc，glStencilFuncSeparate，glStencilMask，glStencilMaskSeparate，glStencilOp，glStencilOpSeparate</p>
<h2 id="glColorMask-启用和禁用帧缓冲区颜色分量的写入"><a href="#glColorMask-启用和禁用帧缓冲区颜色分量的写入" class="headerlink" title="glColorMask - 启用和禁用帧缓冲区颜色分量的写入"></a>glColorMask - 启用和禁用帧缓冲区颜色分量的写入</h2><p>C规范</p>
<p>void glColorMask(    GLboolean red,<br>     GLboolean green,<br>     GLboolean blue,<br>     GLboolean alpha);</p>
<p>参数</p>
<p>red, green, blue, alpha</p>
<p>指定是否可以将红色，绿色，蓝色和alpha写入帧缓冲区。 初始值均为GL_TRUE，表示可以写入颜色分量。</p>
<p>描述</p>
<p>glColorMask指定是否可以写入帧缓冲区中的各个颜色分量。 例如，如果红色为GL_FALSE，则无论是否尝试绘制操作，都不会对任何颜色缓冲区中任何像素的红色分量进行任何更改。</p>
<p>无法控制对组件各个位的更改。 而是为整个颜色组件启用或禁用更改。</p>
<p>相关Gets</p>
<p>glGet 参数GL_COLOR_WRITEMASK</p>
<p>另见</p>
<p>glClear，glDepthMask，glStencilMask</p>
<h2 id="glCompileShader-编译一个着色器对象"><a href="#glCompileShader-编译一个着色器对象" class="headerlink" title="glCompileShader - 编译一个着色器对象"></a>glCompileShader - 编译一个着色器对象</h2><p>C规范</p>
<p>void glCompileShader（GLuint shader）;</p>
<p>参数</p>
<p>shader</p>
<pre><code>指定要编译的着色器对象。
</code></pre>
<p>描述</p>
<pre><code>对于支持着色器编译器的实现，glCompileShader编译已存储在shader指定的着色器对象中的源代码字符串。

编译状态将存储为着色器对象的状态的一部分。 如果着色器编译时没有错误并且可以使用，则此值将设置为GL_TRUE，否则将设置为GL_FALSE。 可以通过使用参数shader和GL_COMPILE_STATUS调用glGetShaderiv来查询状态值。

由于OpenGL ES着色语言规范指定的多种原因，着色器的编译可能会失败。 无论编译是否成功，都可以通过调用glGetShaderInfoLog从着色器对象的信息日志中获取有关编译的信息。
</code></pre>
<p>注意</p>
<pre><code>着色器编译器支持是可选的，因此必须在使用之前通过使用参数GL_SHADER_COMPILER调用glGet来查询。glShaderSource，glCompileShader，glGetShaderPrecisionFormat，glReleaseShaderCompiler等在不支持着色器编译器的实现上都将生成GL_INVALID_OPERATION。这样的实现提供了glShaderBinary替代方案，用于提供预编译的着色器二进制文件。
</code></pre>
<p>错误</p>
<p>GL_INVALID_OPERATION：不支持着色器编译器</p>
<p>GL_INVALID_VALUE：shader不是OpenGL生成的值</p>
<p>GL_INVALID_OPERATION：shader不是着色器对象</p>
<p>相关Gets</p>
<p>glGet 参数GL_SHADER_COMPILER</p>
<p>glGetShaderiv 参数shader和GL_COMPILE_STATUS</p>
<p>glGetShaderInfoLog 参数shader</p>
<p>glIsShader</p>
<p>另见</p>
<p>glCreateShader，glLinkProgram，glReleaseShaderCompiler，glShaderSource，glGetShaderPrecisionFormat</p>
<p>版权</p>
<h2 id="glCompressedTexImage2D-以压缩格式指定二维纹理图像"><a href="#glCompressedTexImage2D-以压缩格式指定二维纹理图像" class="headerlink" title="glCompressedTexImage2D - 以压缩格式指定二维纹理图像"></a>glCompressedTexImage2D - 以压缩格式指定二维纹理图像</h2><p>C规范</p>
<p>void glCompressedTexImage2D(    GLenum target,<br>     GLint level,<br>     GLenum internalformat,<br>     GLsizei width,<br>     GLsizei height,<br>     GLint border,<br>     GLsizei imageSize,<br>     const GLvoid * data);</p>
<p>参数</p>
<p>target</p>
<p>指定活动纹理单元的目标纹理。必须是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。</p>
<p>level</p>
<p>指定详细级别。 0级是基本图像级别。级别n是第n个mipmap缩小图像。</p>
<p>internalformat</p>
<p>指定存储在地址数据中的压缩图像数据的格式。</p>
<p>width</p>
<p>指定纹理图像的宽度。所有实现都支持至少64个纹素宽的2D纹理图像和至少16个纹素宽的立方体映射纹理图像。</p>
<p>height</p>
<p>指定纹理图像的高度。所有实现都支持至少64个纹素高的2D纹理图像和至少16个纹素高的立方体映射纹理图像。</p>
<p>border</p>
<p>指定边框的宽度。必须为0。</p>
<p>imageSize</p>
<p>指定从data指定的地址开始的图像数据的无符号字节数。</p>
<p>data</p>
<p>指定指向内存中压缩图像数据的指针。</p>
<p>描述</p>
<p>纹理将指定纹理图像的一部分映射到纹理处于活动状态的每个图形基元上。当前片段着色器或顶点着色器使用内置纹理查找功能时，纹理处于活动状态。</p>
<p>glCompressedTexImage2D使用来自客户端内存的压缩图像数据定义二维纹理图像或立方体贴图纹理图像。根据定义指定内部格式的扩展规范来解码纹理图像。 OpenGL ES没有定义特定的压缩纹理格式，但确实提供了一种机制来获取扩展提供的这种格式的符号常量。通过查询GL_NUM_COMPRESSED_TEXTURE_FORMATS的值可以获得支持的压缩纹理格式的数量。支持的特定压缩纹理格式列表可以通过查询GL_COMPRESSED_TEXTURE_FORMATS的值来获得。</p>
<p>注意</p>
<p>GL实现可以选择以其选择的任何内部分辨率存储纹理数组。</p>
<p>glCompressedTexImage2D指定使用glActiveTexture指定的纹理单元的二维或立方体贴图纹理。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：target不是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</p>
<p>GL_INVALID_ENUM：internalformat不是GL_COMPRESSED_TEXTURE_FORMATS中返回的受支持格式</p>
<p>GL_INVALID_VALUE：level小于0</p>
<p>GL_INVALID_VALUE：level大于log 2 max，其中max是当目标是GL_TEXTURE_2D时GL_MAX_TEXTURE_SIZE的返回值，或者当目标不是GL_TEXTURE_2D时GL_MAX_CUBE_MAP_TEXTURE_SIZE</p>
<p>GL_INVALID_VALUE：当target是GL_TEXTURE_2D时GL_MAX_TEXTURE_SIZE的宽度或高度小于或大于GL_MAX_TEXTURE_SIZE。</p>
<p>GL_INVALID_VALUE：border不为0</p>
<p>GL_INVALID_VALUE：imageSize与指定的压缩图像数据的格式，尺寸和内容不一致</p>
<p>GL_INVALID_OPERATION：特定纹理压缩扩展中指定的特定压缩内部格式不支持参数组合</p>
<p>如果数据的编码方式与定义内部压缩格式的扩展规范不一致，则会生成未定义的结果，包括异常的程序终止。</p>
<p>相关Gets</p>
<p>glGet 参数GL_NUM_COMPRESSED_TEXTURE_FORMATS和GL_COMPRESSED_TEXTURE_FORMATS</p>
<p>glGet 参数GL_MAX_TEXTURE_SIZE或GL_MAX_CUBE_MAP_TEXTURE_SIZE</p>
<p>另见</p>
<p>glActiveTexture，glCompressedTexSubImage2D，glCopyTexImage2D，glCopyTexSubImage2D，glTexImage2D，glTexSubImage2D，glTexParameter</p>
<h2 id="glCompressedTexSubImage2D-以压缩格式指定二维纹理子图像"><a href="#glCompressedTexSubImage2D-以压缩格式指定二维纹理子图像" class="headerlink" title="glCompressedTexSubImage2D -  以压缩格式指定二维纹理子图像"></a>glCompressedTexSubImage2D -  以压缩格式指定二维纹理子图像</h2><p>C规范</p>
<p>void glCompressedTexSubImage2D(    GLenum target,<br>     GLint level,<br>     GLint xoffset,<br>     GLint yoffset,<br>     GLsizei width,<br>     GLsizei height,<br>     GLenum format,<br>     GLsizei imageSize,<br>     const GLvoid * data);</p>
<p>参数</p>
<p>target</p>
<p>指定活动纹理单元的目标纹理。必须是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。</p>
<p>level</p>
<p>指定详细级别。 0级是基本图像级别。级别n是第n个mipmap缩小图像。</p>
<p>xoffset</p>
<p>指定纹理数组中x方向的纹素偏移。</p>
<p>yoffset</p>
<p>指定纹理数组内y方向的纹素偏移量。</p>
<p>width</p>
<p>指定纹理子图像的宽度。</p>
<p>height</p>
<p>指定纹理子图像的高度。</p>
<p>format</p>
<p>指定存储在地址数据中的压缩图像数据的格式。</p>
<p>imageSize</p>
<p>指定从data指定的地址开始的图像数据的无符号字节数。</p>
<p>data</p>
<p>指定指向内存中压缩图像数据的指针。</p>
<p>描述</p>
<p>纹理将指定纹理图像的一部分映射到纹理处于活动状态的每个图形基元上。当前片段着色器或顶点着色器使用内置纹理查找功能时，纹理处于活动状态。</p>
<p>glCompressedTexSubImage2D重新定义了现有二维纹理图像的连续子区域。数据引用的纹素将现有纹理数组的部分替换为x索引xoffset和xoffset + width - 1，以及y索引yoffset和yoffset + height - 1（包括0和yoffset）。该区域可能不包括纹理数组范围之外的任何纹素，如最初指定的那样。指定宽度为0的子纹理不是错误，但这样的规范没有效果。</p>
<p>format必须与glCompressedTexImage2D先前指定的扩展名指定的压缩纹理格式相同。</p>
<p>注意</p>
<p>glCompressedTexSubImage2D指定使用glActiveTexture指定的纹理单元的二维或立方体贴图纹理。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：target不是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</p>
<p>GL_INVALID_ENUM：internalformat不是GL_COMPRESSED_TEXTURE_FORMATS中返回的受支持格式</p>
<p>GL_INVALID_VALUE：level小于0</p>
<p>GL_INVALID_VALUE：level大于log 2 max，其中max是当目标是GL_TEXTURE_2D时GL_MAX_TEXTURE_SIZE的返回值，或者当目标不是GL_TEXTURE_2D时GL_MAX_CUBE_MAP_TEXTURE_SIZE</p>
<p>GL_INVALID_VALUE：xoffset &lt;0，xoffset + width&gt; w，yoffset &lt;0或yoffset + height&gt; h，其中w是宽度，h是要修改的纹理图像的高度。</p>
<p>GL_INVALID_VALUE：宽度或高度小于0。</p>
<p>GL_INVALID_VALUE：imageSize与指定的压缩图像数据的格式，尺寸和内容不一致。</p>
<p>GL_INVALID_OPERATION：纹理数组尚未由之前的glCompressedTexImage2D操作定义，其内部格式与glCompressedTexSubImage2D的格式匹配。</p>
<p>GL_INVALID_OPERATION：特定纹理压缩扩展中指定的特定压缩内部格式不支持参数组合。</p>
<p>如果数据的编码方式与定义内部压缩格式的扩展规范不一致，则会生成未定义的结果，包括异常的程序终止。</p>
<p>相关Gets</p>
<p>glGet 参数GL_NUM_COMPRESSED_TEXTURE_FORMATS和GL_COMPRESSED_TEXTURE_FORMATS</p>
<p>glGet 参数GL_MAX_TEXTURE_SIZE或GL_MAX_CUBE_MAP_TEXTURE_SIZE</p>
<p>另见</p>
<p>glActiveTexture，glCompressedTexImage2D，glCopyTexImage2D，glCopyTexSubImage2D，glTexImage2D，glTexSubImage2D，glTexParameter</p>
<h2 id="glCopyTexImage2D-将像素复制到2D纹理图像中"><a href="#glCopyTexImage2D-将像素复制到2D纹理图像中" class="headerlink" title="glCopyTexImage2D - 将像素复制到2D纹理图像中"></a>glCopyTexImage2D - 将像素复制到2D纹理图像中</h2><p>C规范</p>
<p>void glCopyTexImage2D(    GLenum target,<br>     GLint level,<br>     GLenum internalformat,<br>     GLint x,<br>     GLint y,<br>     GLsizei width,<br>     GLsizei height,<br>     GLint border);</p>
<p>参数</p>
<p>target</p>
<p>指定活动纹理单元的目标纹理。必须是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。</p>
<p>level</p>
<p>指定详细级别。 0级是基本图像级别。级别n是第n个mipmap缩小图像。</p>
<p>internalformat</p>
<p>指定存储在地址数据中的压缩图像数据的格式。</p>
<p>x，y</p>
<p>指定要复制的像素矩形区域左下角的窗口坐标。</p>
<p>width</p>
<p>指定纹理图像的宽度。所有实现都支持至少64个纹素宽的2D纹理图像和至少16个纹素宽的立方体映射纹理图像。</p>
<p>height</p>
<p>指定纹理图像的高度。所有实现都支持至少64个纹素高的2D纹理图像和至少16个纹素高的立方体映射纹理图像。</p>
<p>border</p>
<p>指定边框的宽度。必须为0。</p>
<p>描述</p>
<p>纹理将指定纹理图像的一部分映射到纹理处于活动状态的每个图元上。当前片段着色器或顶点着色器使用内置纹理查找功能时，纹理处于活动状态。</p>
<p>glCopyTexImage2D定义了二维纹理图像或立方体贴图纹理图像，其中包含来自当前帧缓冲区的像素（而不是来自客户端内存，如glTexImage2D的情况）。</p>
<p>屏幕对齐的像素矩形，左下角为（x，y），宽度为width，高度为height，定义了由level指定的mipmap级别的纹理数组。 internalformat指定纹理数组的内部格式。</p>
<p>处理矩形中的像素就像调用format设置为GL_RGBA的glReadPixels一样，但是在转换RGBA值之后，该过程就会停止。后续处理与glTexImage2D描述的处理相同，首先将R，G，B和A值截断到0 1范围，然后转换为纹理的内部格式以存储在纹素阵列中。</p>
<p>internalformat所需的组件必须是framebuffer格式中存在的组件的子集。例如，GL_RGBA帧缓冲区可用于为任何内部格式提供组件。但是，GL_RGB帧缓冲区只能用于为GL_RGB或GL_LUMINANCE基本内部格式纹理提供组件，而不能用于GL_ALPHA，GL_LUMINANCE_ALPHA或GL_RGBA纹理。</p>
<p>像素排序使得较低的x和y屏幕坐标对应于较低的s和t纹理坐标。</p>
<p>如果指定矩形内的任何像素位于与当前渲染上下文关联的帧缓冲区之外，则为这些像素获取的值未定义。</p>
<p>注意</p>
<p>GL实现可以选择以其选择的任何内部分辨率存储纹理数组。</p>
<p>高度或宽度为0的图像表示NULL纹理。</p>
<p>glCopyTexImage2D为使用glActiveTexture指定的当前纹理单元指定二维或立方体贴图纹理。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：target不是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。</p>
<p>GL_INVALID_ENUM：internalformat不是可接受的格式。</p>
<p>GL_INVALID_VALUE：target是六个立方体贴图2D图像目标之一并且width和height参数不相等。</p>
<p>GL_INVALID_VALUE：level小于0。</p>
<p>GL_INVALID_VALUE：level大于log 2 max，其中max是当目标是GL_TEXTURE_2D时GL_MAX_TEXTURE_SIZE的返回值，或者当目标不是GL_TEXTURE_2D时GL_MAX_CUBE_MAP_TEXTURE_SIZE。</p>
<p>GL_INVALID_VALUE：border不为0。</p>
<p>GL_INVALID_OPERATION：当前绑定的帧缓冲区格式不包含internalformat基本格式所需组件的超集。</p>
<p>GL_INVALID_FRAMEBUFFER_OPERATION：当前绑定的帧缓冲不是帧缓冲完成（即glCheckFramebufferStatus的返回值不是GL_FRAMEBUFFER_COMPLETE）</p>
<p>相关Gets</p>
<p>glGet 参数GL_MAX_TEXTURE_SIZE或GL_MAX_CUBE_MAP_TEXTURE_SIZE</p>
<p>另见</p>
<p>glActiveTexture，glCheckFramebufferStatus，glCompressedTexImage2D，glCompressedTexSubImage2D，</p>
<h2 id="glCopyTexSubImage2D-复制二维纹理子图像"><a href="#glCopyTexSubImage2D-复制二维纹理子图像" class="headerlink" title="glCopyTexSubImage2D -  复制二维纹理子图像"></a>glCopyTexSubImage2D -  复制二维纹理子图像</h2><p>C规范</p>
<p>void glCopyTexSubImage2D(    GLenum target,<br>     GLint level,<br>     GLint xoffset,<br>     GLint yoffset,<br>     GLint x,<br>     GLint y,<br>     GLsizei width,<br>     GLsizei height);</p>
<p>参数</p>
<p>target</p>
<p>指定活动纹理单元的目标纹理。必须是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。</p>
<p>level</p>
<p>指定详细级别。 0级是基本图像级别。级别n是第n个mipmap缩小图像。</p>
<p>x，y</p>
<p>指定要复制的像素矩形区域左下角的窗口坐标。</p>
<p>width</p>
<p>指定纹理图像的宽度。所有实现都支持至少64个纹素宽的2D纹理图像和至少16个纹素宽的立方体映射纹理图像。</p>
<p>height</p>
<p>指定纹理图像的高度。所有实现都支持至少64个纹素高的2D纹理图像和至少16个纹素高的立方体映射纹理图像。</p>
<p>xoffset</p>
<p>指定纹理数组中x方向的纹素偏移。</p>
<p>yoffset</p>
<p>指定纹理数组内y方向的纹素偏移量。</p>
<p>描述</p>
<p>纹理将指定纹理图像的一部分映射到纹理处于活动状态的每个图元上。当前片段着色器或顶点着色器使用内置纹理查找功能时，纹理处于活动状态。</p>
<p>glCopyTexSubImage2D用当前帧缓冲区中的像素（而不是客户端内存，如glTexSubImage2D的情况）替换二维纹理图像或立方体贴图纹理图像的矩形部分。</p>
<p>屏幕对齐的像素矩形，左下角为（x，y），宽度为width，高度为height，定义了由level指定的mipmap级别的纹理数组。 </p>
<p>处理矩形中的像素就像调用format设置为GL_RGBA的glReadPixels一样，但是在转换RGBA值之后，该过程就会停止。后续处理与glTexSubImage2D描述的处理相同，首先将R，G，B和A值截断到0 1范围，然后转换为纹理的内部格式以存储在纹素阵列中。</p>
<p>纹理数组中的目标矩形可能不包括最初指定的纹理数组外的任何纹理像素。指定宽度或高度为零的子纹理不是错误，但这样的规范没有效果。</p>
<p>如果指定矩形内的任何像素位于与当前渲染上下文关联的帧缓冲区之外，则为这些像素获取的值为未定义的。</p>
<p>不会对指定纹理数组的internalformat，width或height参数或指定子区域外的纹素值进行更改。</p>
<p>注意</p>
<p>glCopyTexSubImage2D为使用glActiveTexture指定的当前纹理单元指定二维或立方体贴图纹理。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：target不是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。</p>
<p>GL_INVALID_ENUM：internalformat不是可接受的格式。</p>
<p>GL_INVALID_VALUE：target是六个立方体贴图2D图像目标之一并且width和height参数不相等。</p>
<p>GL_INVALID_VALUE：level小于0。</p>
<p>GL_INVALID_OPERATION：纹理数组尚未由先前的glTexImage2D或glCopyTexImage2D操作定义。</p>
<p>GL_INVALID_OPERATION：当前绑定的帧缓冲区格式不包含internalformat基本格式所需组件的超集。</p>
<p>GL_INVALID_FRAMEBUFFER_OPERATION：当前绑定的帧缓冲不是帧缓冲完成（即glCheckFramebufferStatus的返回值不是GL_FRAMEBUFFER_COMPLETE）</p>
<p>相关Gets</p>
<p>glGet 参数GL_MAX_TEXTURE_SIZE或GL_MAX_CUBE_MAP_TEXTURE_SIZE</p>
<p>另见</p>
<p>glActiveTexture，glCheckFramebufferStatus，glCopyTexImage2D，glTexImage2D，glTexParameter，glTexSubImage2D</p>
<h2 id="glCreateProgram-创建一个program（建议不要翻译成“程序”，以免引起与APP的混淆）对象"><a href="#glCreateProgram-创建一个program（建议不要翻译成“程序”，以免引起与APP的混淆）对象" class="headerlink" title="glCreateProgram- 创建一个program（建议不要翻译成“程序”，以免引起与APP的混淆）对象"></a>glCreateProgram- 创建一个program（建议不要翻译成“程序”，以免引起与APP的混淆）对象</h2><p>C规范</p>
<p>GLuint glCreateProgram（void）;</p>
<p>描述</p>
<pre><code>glCreateProgram创建一个空program并返回一个可以被引用的非零值（program ID）。 program对象是可以附加着色器对象的对象。 这提供了一种机制来指定将链接以创建program的着色器对象。 它还提供了一种检查将用于创建program的着色器的兼容性的方法（例如，检查顶点着色器和片元着色器之间的兼容性）。 当不再需要作为program对象的一部分时，着色器对象就可以被分离了。

通过调用glCompileShader成功编译着色器对象，并且通过调用glAttachShader成功地将着色器对象附加到program 对象，并且通过调用glLinkProgram成功的链接program 对象之后，可以在program 对象中创建一个或多个可执行文件。

当调用glUseProgram时，这些可执行文件成为当前状态的一部分。 可以通过调用glDeleteProgram删除程序对象。 当program 对象不再是任何上下文的当前呈现状态的一部分时，将删除与program 对象关联的内存。
</code></pre>
<p>注意</p>
<p>与纹理对象一样，只要上下文的服务器端共享相同的地址空间，程序对象的名称空间就可以在一组上下文中共享。 如果名称空间跨上下文共享，则也会共享任何附加对象和与这些附加对象关联的数据。</p>
<p>当从不同的执行线程访问对象时，应用程序负责跨API调用提供同步。</p>
<p>错误</p>
<p>如果创建program 对象时发生错误，则此函数返回0。</p>
<p>相关Gets</p>
<p>glGet 参数GL_CURRENT_PROGRAM</p>
<p>glGetActiveAttrib 参数：有效的program对象和激活状态的属性变量的句柄。</p>
<p>glGetActiveUniform 参数：有效的program对象和激活状态的统一变量的句柄。</p>
<p>glGetAttachedShaders 参数：有效的program对象</p>
<p>glGetAttribLocation​​​​​​​ 参数：有效的program对象和属性变量的名称（在shader中的变量字符串）。</p>
<p>glGetProgramiv 参数：有效的program对象和要查询的参数符号</p>
<p>glGetProgramInfoLog 参数：有效的program对象</p>
<p>glGetUniform​​​​​​​ 参数：有效的program对象和一个统一变量地址</p>
<p>glGetUniformLocation​​​​​​​ 参数：有效的program对象和统一变量的名称（在shader中的变量字符串）。</p>
<p>glIsProgram​​​​​​​</p>
<p>另见</p>
<p>glAttachShader，glBindAttribLocation​​​​​​​，glCreateShader，glDeleteProgram，glDetachShader，glLinkProgram，glUniform​​​​​​​，glUseProgram，glValidateProgram</p>
<h2 id="glCreateShader-创建一个着色器对象"><a href="#glCreateShader-创建一个着色器对象" class="headerlink" title="glCreateShader - 创建一个着色器对象"></a>glCreateShader - 创建一个着色器对象</h2><p>C规范</p>
<p>GLuint glCreateShader（GLenum shaderType）;</p>
<p>参数</p>
<p>shaderType</p>
<pre><code>指定要创建的着色器的类型。 只能是GL_VERTEX_SHADER或GL_FRAGMENT_SHADER。
</code></pre>
<p>描述</p>
<p>glCreateShader创建一个空的着色器对象，并返回一个可以引用的非零值（shader ID）。着色器对象用于维护定义着色器的源代码字符串。shaderType指示要创建的着色器的类型。 支持两种类型的着色器。 GL_VERTEX_SHADER类型的着色器是一个用于在可编程顶点处理器上运行的着色器。 GL_FRAGMENT_SHADER类型的着色器是一个着色器，旨在在可编程片段处理器上运行。</p>
<p>创建时，着色器对象的GL_SHADER_TYPE参数设置为GL_VERTEX_SHADER或GL_FRAGMENT_SHADER，具体取决于shaderType的值。</p>
<p>注意</p>
<p>与纹理对象一样，着色器对象的名称空间可以在一组上下文中共享，只要上下文的服务器端共享相同的地址空间即可。 如果名称空间跨上下文共享，则也会共享任何附加对象和与这些附加对象关联的数据。</p>
<p>当从不同的执行线程访问对象时，应用程序需要负责跨API调用提供同步。</p>
<p>错误</p>
<p>如果创建着色器对象时发生错误，则此函数返回0。</p>
<p>GL_INVALID_ENUM：shaderType不是一个可接受的值。</p>
<p>相关Gets</p>
<p>glGetShaderiv 使用有效的着色器对象和要查询的参数</p>
<p>glGetShaderInfoLog 使用有效的着色器对象</p>
<p>glGetShaderSource  使用有效的着色器对象</p>
<p>glIsShader</p>
<p>另见</p>
<p>glAttachShader，glCompileShader，glDeleteShader，glDetachShader，glShaderSource，glShaderBinary​​​​​​​</p>
<h2 id="glCullFace-指定是否可以剔除前面或后面的多边形"><a href="#glCullFace-指定是否可以剔除前面或后面的多边形" class="headerlink" title="glCullFace - 指定是否可以剔除前面或后面的多边形"></a>glCullFace - 指定是否可以剔除前面或后面的多边形</h2><p>C规范</p>
<p>void glCullFace（GLenum mode）;</p>
<p>参数</p>
<p>mode</p>
<p>指定前面或后面的多边形是否适合剔除。接受符号常量GL_FRONT，GL_BACK和GL_FRONT_AND_BACK。初始值为GL_BACK。</p>
<p>描述</p>
<p>glCullFace指定在启用多边形剔除时是否剔除前面或后面的多边形（由模式指定）。最初禁用多边形剔除。要启用和禁用多边形剔除，请使用参数GL_CULL_FACE调用glEnable和glDisable命令。</p>
<p>glFrontFace指定顺时针和逆时针多边形中的哪一个是正面和背面的。请参阅glFrontFace。</p>
<p>注意</p>
<p>如果mode为GL_FRONT_AND_BACK，则不绘制多边形，但绘制其他图元（如点和线）。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果mode是一个不可接受的值。</p>
<p>相关Gets</p>
<p>glIsEnabled 参数GL_CULL_FACE<br>glGet 参数GL_CULL_FACE_MODE</p>
<p>另见</p>
<p>glEnable，glFrontFace</p>
<h2 id="glDeleteBuffers-删除命名缓冲区对象"><a href="#glDeleteBuffers-删除命名缓冲区对象" class="headerlink" title="glDeleteBuffers - 删除命名缓冲区对象"></a>glDeleteBuffers - 删除命名缓冲区对象</h2><p>C规范</p>
<p>void glDeleteBuffers（GLsizei n，const GLuint * buffers）;</p>
<p>参数</p>
<p>n</p>
<p>指定要删除的缓冲区对象名称的数量。</p>
<p>buffers</p>
<p>指定要删除的缓冲区对象名称的数组。</p>
<p>描述</p>
<p>glDeleteBuffers删除由数组缓冲区的元素命名的n个缓冲区对象。 删除缓冲区对象后，它就没有内容了，其名称可以被重用（例如glGenBuffers调用生成该名称（ID））。如果删除当前绑定的缓冲区对象，则绑定将恢复为0（缺少任何缓冲区对象，这将恢复为客户机内存使用情况）。</p>
<p>glDeleteBuffers默认忽略0和与现有缓冲区对象不对应的名称。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：n是负数</p>
<p>相关Gets</p>
<p>glIsBuffer</p>
<p>另见</p>
<p>glBindBuffer，glGenBuffers，glIsBuffer</p>
<h2 id="glDeleteFramebuffers-删除命名的framebuffer对象"><a href="#glDeleteFramebuffers-删除命名的framebuffer对象" class="headerlink" title="glDeleteFramebuffers - 删除命名的framebuffer对象"></a>glDeleteFramebuffers - 删除命名的framebuffer对象</h2><p>C规范</p>
<p>void glDeleteFramebuffers（GLsizei n,</p>
<pre><code>                                                 const GLuint * framebuffers）;
</code></pre>
<p>参数</p>
<p>n</p>
<p>指定要删除的帧缓冲区对象的数量。</p>
<p>framebuffers</p>
<p>指定要删除的帧缓冲区对象数组。</p>
<p>描述</p>
<p>glDeleteFramebuffers删除由数组framebuffers的元素命名的n个framebuffer对象。 删除帧缓冲区对象后，它没有附件，其名称可以被复用（例如调用glGenFramebuffers生成）。 如果删除当前绑定的帧缓冲区对象，则绑定将恢复为0（窗口系统提供的帧缓冲区）。</p>
<p>glDeleteFramebuffers默认忽略0和与现有帧缓冲对象不对应的名称。</p>
<p>错误</p>
<p>GL_INVALID_VALUE ：n是负数</p>
<p>相关Gets</p>
<p>glIsFramebuffer</p>
<p>另见</p>
<p>glBindFramebuffer，glGenFramebuffers，glIsFramebuffer</p>
<h2 id="glDeleteProgram-删除一个程序对象"><a href="#glDeleteProgram-删除一个程序对象" class="headerlink" title="glDeleteProgram- 删除一个程序对象"></a>glDeleteProgram- 删除一个程序对象</h2><p>C规范</p>
<p>void glDeleteProgram（GLuint program）;</p>
<p>参数</p>
<p>program</p>
<pre><code>指定要删除的程序对象。
</code></pre>
<p>描述</p>
<p>glDeleteProgram释放内存并使与着色器指定的着色器对象关联的ID无效。 这个命令有效地撤消了对glCreateProgram的调用的影响。</p>
<p>如果程序对象正在被用作当前渲染状态的一部分，则它将被标记为删除，但在它不再是任何渲染上下文的当前状态的一部分之前不会被删除。 如果要删除的程序对象附加了着色器对象，那么这些着色器对象将自动分离但不会被删除，除非它们已被标记为先前调用glDeleteShader而被删除。 程序的值0为0将被忽视。</p>
<p>要确定对象是否已标记为删除，请使用参数program和GL_DELETE_STATUS调用glGetProgramiv。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：program不是OpenGL生成的值。</p>
<p>相关Gets</p>
<p>glGet 参数GL_CURRENT_PROGRAM</p>
<p>glGetProgramiv 参数program和GL_DELETE_STATUS</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glCreateShader，glDetachShader，glIsProgram</p>
<h2 id="glDeleteRenderbuffers-删除命名的renderbuffer对象"><a href="#glDeleteRenderbuffers-删除命名的renderbuffer对象" class="headerlink" title="glDeleteRenderbuffers - 删除命名的renderbuffer对象"></a>glDeleteRenderbuffers - 删除命名的renderbuffer对象</h2><p>C规范</p>
<p>void glDeleteRenderbuffers（GLsizei n,</p>
<pre><code>                                                  const GLuint * renderbuffers）;
</code></pre>
<p>参数</p>
<p>n</p>
<p>指定要删除的renderbuffer对象的数量。</p>
<p>renderbuffers</p>
<p>指定要删除的renderbuffer对象数组。</p>
<p>描述</p>
<p>glDeleteRenderbuffers删除由数组renderbuffers的元素命名的n个renderbuffer对象。 删除renderbuffer对象后，它没有内容，其名称可以被复用（例如glGenRenderbuffers）。</p>
<p>如果删除当前绑定的renderbuffer对象，则绑定将恢复为0（没有任何renderbuffer对象）。 此外，如果渲染缓冲区的图像附加到帧缓冲区对象，则在删除渲染缓冲区对象时必须特别小心。 在这种情况下，如果删除的renderbuffer对象附加到当前绑定的framebuffer对象，则会自动分离它。 但是，任何其他帧缓冲对象的附着都是应用程序的责任。</p>
<p>glDeleteRenderbuffers默认忽略0和与现有renderbuffer对象不对应的名称。</p>
<p>错误</p>
<p>GL_INVALID_VALUE ： n是负数</p>
<p>相关Gets</p>
<p>glIsRenderbuffer</p>
<p>另见</p>
<p>glBindRenderbuffer，glGenRenderbuffers，glIsRenderbuffer</p>
<h2 id="glDeleteShader-删除一个着色器对象"><a href="#glDeleteShader-删除一个着色器对象" class="headerlink" title="glDeleteShader - 删除一个着色器对象"></a>glDeleteShader - 删除一个着色器对象</h2><p>C规范</p>
<p>void glDeleteShader（GLuint shader）;</p>
<p>参数</p>
<p>shader</p>
<pre><code>指定要删除的着色器对象。
</code></pre>
<p>描述</p>
<p>   glDeleteShader释放内存并使与着色器指定的着色器对象关联的ID无效。 这个命令有效地撤消了对glCreateShader的调用的影响。</p>
<pre><code>如果要删除的着色器对象附加到程序对象，它将被标记为删除，但它不会被删除，直到它不再附加到任何程序对象，对于任何渲染上下文（即，它必须与 它被附加之前的任何地方都将被删除）。shader为0将被忽视。

要确定对象是否已标记为删除，请使用参数shader和GL_DELETE_STATUS调用glGetShaderiv。
</code></pre>
<p>错误</p>
<p>GL_INVALID_VALUE：shader不是OpenGL生成的值。</p>
<p>相关Gets</p>
<p>glGetAttachedShaders 要查询的程序对象</p>
<p>glGetShaderiv 参数shader和GL_DELETE_STATUS</p>
<p>glIsShader</p>
<p>另见</p>
<p>glCreateProgram，glCreateShader，glDetachShader,glUseProgram</p>
<h2 id="glDeleteTextures-删除纹理"><a href="#glDeleteTextures-删除纹理" class="headerlink" title="glDeleteTextures - 删除纹理"></a>glDeleteTextures - 删除纹理</h2><p>C规范</p>
<p>void glDeleteTextures（GLsizei n，</p>
<p>  const GLuint *textures）;</p>
<p>参数</p>
<p>n</p>
<pre><code>指定要删除的纹理数量。
</code></pre>
<p>textures</p>
<pre><code>指定要删除的纹理(ID)数组。
</code></pre>
<p>描述</p>
<p>glDeleteTextures删除由数组纹理元素命名的n个纹理。</p>
<p>纹理被删除后，它就没有内容也没有维度了，并且其名称（ID）可以重复使用（例如，通过glGenTextures）。</p>
<p>如果当前绑定的纹理被删除，绑定将恢复为0（默认纹理）。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：如果参数n是负数。</p>
<p>相关Gets</p>
<p>glIsTexture</p>
<p>另见</p>
<p>glBindTexture glGenTextures glIsTexture</p>
<h2 id="glDepthFunc-指定用于深度缓冲区比较的值"><a href="#glDepthFunc-指定用于深度缓冲区比较的值" class="headerlink" title="glDepthFunc - 指定用于深度缓冲区比较的值"></a>glDepthFunc - 指定用于深度缓冲区比较的值</h2><p>C规范</p>
<p>void glDepthFunc(    GLenum func);</p>
<p>参数</p>
<p>func</p>
<p>指定深度比较功能。接受符号常量GL_NEVER，GL_LESS，GL_EQUAL，GL_LEQUAL，GL_GREATER，GL_NOTEQUAL，GL_GEQUAL和GL_ALWAYS。初始值为GL_LESS。</p>
<p>描述</p>
<p>glDepthFunc指定用于将每个输入像素深度值与深度缓冲区中存在的深度值进行比较的函数。仅在启用深度测试时才执行比较。 （参见GL_DEPTH_TEST的glEnable和glDisable。）</p>
<p>func指定绘制像素的条件。比较功能如下：</p>
<p>GL_NEVER</p>
<p>永远不通过。</p>
<p>GL_LESS</p>
<p>如果传入深度值小于存储的深度值（离观看者更近），则通过。</p>
<p>GL_EQUAL</p>
<p>如果传入深度值等于存储的深度值，则通过。</p>
<p>GL_LEQUAL</p>
<p>如果传入深度值小于或等于存储的深度值，则通过。</p>
<p>GL_GREATER</p>
<p>如果传入深度值大于存储的深度值，则通过。</p>
<p>GL_NOTEQUAL</p>
<p>如果传入的深度值不等于存储的深度值，则通过。</p>
<p>GL_GEQUAL</p>
<p>如果传入的深度值大于或等于存储的深度值，则通过。</p>
<p>GL_ALWAYS</p>
<p>总是通过。</p>
<p>func的初始值是GL_LESS。最初，深度测试被禁用。如果禁用深度测试或不存在深度缓冲，则就好像深度测试总是通过一样。</p>
<p>注意</p>
<p>即使存在深度缓冲区且深度掩模不为零，如果禁用深度测试，也不会更新深度缓冲区。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：func不是可接受的值</p>
<p>相关Gets</p>
<p>glGet 参数GL_DEPTH_FUNC</p>
<p>glIsEnabled 参数GL_DEPTH_TEST</p>
<p>另见</p>
<p>glDepthRangef，glEnable，glPolygonOffset</p>
<h2 id="glDepthMask-启用或禁用写入深度缓冲区"><a href="#glDepthMask-启用或禁用写入深度缓冲区" class="headerlink" title="glDepthMask - 启用或禁用写入深度缓冲区"></a>glDepthMask - 启用或禁用写入深度缓冲区</h2><p>C规范</p>
<p>void glDepthMask(    GLboolean flag);</p>
<p>参数</p>
<p>flag</p>
<p>指定是否可以写入启用深度缓冲区。 如果flag为GL_FALSE，则禁用深度缓冲区写入。 否则，它可以启用。 初始状态为启用深度缓冲区写入。</p>
<p>描述</p>
<p>glDepthMask指定是否可以写入启用深度缓冲区。 如果flag为GL_FALSE，则禁用深度缓冲区写入。 否则，它可以启用。 初始状态为启用深度缓冲区写入。</p>
<p>相关Gets</p>
<p>glGet 参数GL_DEPTH_WRITEMASK</p>
<p>另见</p>
<p>glColorMask，glDepthFunc，glDepthRangef，glStencilMask</p>
<h2 id="glDepthRangef-指定从标准化设备坐标到窗口坐标的深度值的映射"><a href="#glDepthRangef-指定从标准化设备坐标到窗口坐标的深度值的映射" class="headerlink" title="glDepthRangef - 指定从标准化设备坐标到窗口坐标的深度值的映射"></a>glDepthRangef - 指定从标准化设备坐标到窗口坐标的深度值的映射</h2><p>C规范</p>
<p>void glDepthRangef(    GLclampf nearVal,<br>     GLclampf farVal);</p>
<p>参数</p>
<p>nearVal</p>
<p>指定近剪裁平面到窗口坐标的映射。初始值为0。</p>
<p>farVal</p>
<p>指定远剪裁平面到窗口坐标的映射。初始值为1。</p>
<p>描述</p>
<p>在剪裁和除以w之后，深度坐标的范围从-1到1，对应于近剪裁平面和远剪裁平面。glDepthRangef指定此范围内的归一化深度坐标到窗口深度坐标的线性映射。无论实际的深度缓冲区实现如何，窗口坐标深度值都被视为从0到1（如颜色分量）。因此，glDepthRangef接受的值在被接受之前都被截断到该范围。</p>
<p>（0,1）的设置将近平面映射到0，将远平面映射到1.通过此映射，可以充分利用深度缓冲区范围。</p>
<p>注意</p>
<p>nearVal不必小于farVal。可以接受诸如nearVal = 1和farVal = 0的反向映射。</p>
<p>相关Gets</p>
<p>glGet 参数GL_DEPTH_RANGE</p>
<p>另见</p>
<p>glDepthFunc，glPolygonOffset，glViewport</p>
<h2 id="glDetachShader-从程序对象中分离着色器对象"><a href="#glDetachShader-从程序对象中分离着色器对象" class="headerlink" title="glDetachShader- 从程序对象中分离着色器对象"></a>glDetachShader- 从程序对象中分离着色器对象</h2><p>C规范</p>
<p>void glDetachShader(    GLuint program,<br>     GLuint shader);</p>
<p>参数</p>
<p>program</p>
<p>指定从中分离着色器对象的程序对象。</p>
<p>shader</p>
<p>指定要分离的着色器对象。</p>
<p>描述</p>
<p>glDetachShader将shader指定的着色器对象与程序指定的程序对象分离。此命令可用于撤消命令glAttachShader的效果。</p>
<p>如果通过调用glDeleteShader已将标记器标记为删除，并且它未附加到任何其他程序对象，则在分离后它将被删除。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：program或shader不是由OpenGL生成的值。</p>
<p>GL_INVALID_OPERATION：program不是程序对象。</p>
<p>GL_INVALID_OPERATION：shader不是着色器对象。</p>
<p>GL_INVALID_OPERATION：未将shader附加到程序。</p>
<p>相关Gets</p>
<p>glGetAttachedShaders 参数具有有效程序对象的句柄。</p>
<p>glGetShaderiv 参数shader和GL_DELETE_STATUS。</p>
<p>glIsProgram</p>
<p>glIsShader</p>
<p>另见</p>
<p>glAttachShader</p>
<h2 id="glEnable-启用或禁用服务器端GL功能"><a href="#glEnable-启用或禁用服务器端GL功能" class="headerlink" title="glEnable- 启用或禁用服务器端GL功能"></a>glEnable- 启用或禁用服务器端GL功能</h2><p>C规范</p>
<p>void glEnable（GLenum cap）;</p>
<p>void glDisable（GLenum cap）;</p>
<p>参数</p>
<p>cap</p>
<p>指定表示GL功能的符号常量。</p>
<p>描述</p>
<p>glEnable和glDisable启用和禁用各种功能。使用glIsEnabled或glGet确定任何功能的当前设置。除GL_DITHER(抖动)外，每个功能的初始值为GL_FALSE。GL_DITHER的初始值为GL_TRUE。</p>
<p>glEnable和glDisable都使用单个参数cap，它可以采用以下值之一：</p>
<p>GL_BLEND</p>
<pre><code>    如果启用，则将计算的片段颜色值与颜色缓冲区中的值混合。 请参阅glBlendFunc。
</code></pre>
<p>GL_CULL_FACE</p>
<pre><code>   如果启用，则根据窗口的坐标来剔除多边形。 请参阅glCullFace。
</code></pre>
<p>GL_DEPTH_TEST</p>
<pre><code>   如果启用，进行深度比较并更新深度缓冲区。 注意，即使存在深度缓冲区且深度掩码不为零，如果禁用深度测试，也将不会更新深度缓冲区。 请参阅glDepthFunc和glDepthRangef。
</code></pre>
<p>GL_DITHER</p>
<pre><code>   如果启用，则在将颜色组件或索引写入颜色缓冲区之前对其进行抖动。
</code></pre>
<p>GL_POLYGON_OFFSET_FILL</p>
<pre><code>   如果启用，则会将偏移添加到由光栅化生成的多边形片段的深度值。 请参阅glPolygonOffset。（常用于处理Z-fighting）
</code></pre>
<p>GL_SAMPLE_ALPHA_TO_COVERAGE</p>
<pre><code>   如果启用，则计算临时覆盖值，其中每个位由相应样本位置的alpha值确定。 然后，临时覆盖值与片段覆盖值进行AND运算。
</code></pre>
<p>GL_SAMPLE_COVERAGE</p>
<pre><code>   如果启用，则片段的覆盖范围与临时覆盖值进行AND运算。 如果GL_SAMPLE_COVERAGE_INVERT设置为GL_TRUE，则反转coverage值。 请参阅glSampleCoverage。
</code></pre>
<p>GL_SCISSOR_TEST</p>
<pre><code>   如果启用，则丢弃裁剪矩形之外的片段。 见glScissor。
</code></pre>
<p>GL_STENCIL_TEST</p>
<pre><code>   如果启用，将进行模板测试并更新模板缓冲区。 请参阅glStencilFunc和glStencilOp。
</code></pre>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果cap不是之前列出的值之一。</p>
<p>相关Gets</p>
<p>glIsEnabled</p>
<p>glGet</p>
<p>另见</p>
<p>glActiveTexture，glBlendFunc，glCullFace，glDepthFunc，glDepthRangef，glGet，glIsEnabled，glLineWidth，glPolygonOffset，glScissor，glStencilFunc，glStencilOp，glTexImage2D</p>
<h2 id="glEnableVertexAttribArray-启用或禁用通用顶点属性数组"><a href="#glEnableVertexAttribArray-启用或禁用通用顶点属性数组" class="headerlink" title="glEnableVertexAttribArray - 启用或禁用通用顶点属性数组"></a>glEnableVertexAttribArray - 启用或禁用通用顶点属性数组</h2><p>C规范</p>
<p>void glEnableVertexAttribArray（GLuint index）;</p>
<p>void glDisableVertexAttribArray（GLuint index）;</p>
<p>参数</p>
<p>index</p>
<p>指定要启用或禁用的通用顶点属性的索引。</p>
<p>描述</p>
<p>glEnableVertexAttribArray启用index指定的通用顶点属性数组。 glDisableVertexAttribArray禁用index指定的通用顶点属性数组。 默认情况下，禁用所有客户端功能，包括所有通用顶点属性数组。 如果启用，将访问通用顶点属性数组中的值，并在调用顶点数组命令（如glDrawArrays或glDrawElements）时用于呈现。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：如果index大于或等于GL_MAX_VERTEX_ATTRIBS。</p>
<p>相关Gets</p>
<p>glGet 参数GL_MAX_VERTEX_ATTRIBS</p>
<p>glGetVertexAttrib 参数index和GL_VERTEX_ATTRIB_ARRAY_ENABLED</p>
<p>glGetVertexAttribPointerv 参数index和GL_VERTEX_ATTRIB_ARRAY_POINTER</p>
<p>另见</p>
<p>glBindAttribLocation，glDrawArrays，glDrawElements，glGetVertexAttrib，glGetVertexAttribPointerv</p>
<p>版权</p>
<h2 id="glDrawArrays-从数组数据中渲染图元"><a href="#glDrawArrays-从数组数据中渲染图元" class="headerlink" title="glDrawArrays - 从数组数据中渲染图元"></a>glDrawArrays - 从数组数据中渲染图元</h2><p>C规范</p>
<p>void glDrawArrays（GLenum mode，</p>
<pre><code>                           GLint first,

                           GLsizei count）;
</code></pre>
<p>参数</p>
<p>mode</p>
<p>指定要渲染的图元类型。 接受符号常量GL_POINTS，GL_LINE_STRIP，GL_LINE_LOOP，GL_LINES，GL_TRIANGLE_STRIP，GL_TRIANGLE_FAN和GL_TRIANGLES。</p>
<p>first</p>
<p>指定已启用阵列中的起始索引。</p>
<p>count</p>
<p>指定要渲染的索引数。</p>
<p>描述</p>
<p>glDrawArrays指定了几个子例程调用的几何图元。你可以使用glVertexAttribPointer预先指定单独的顶点，法线和颜色数组，而不是调用GL过程来传递每个单独的顶点属性并使用它们通过单次调用glDrawArrays来构造图元序列。</p>
<p>当调用glDrawArrays时，它使用每个启用数组中的计数顺序元素来构造几何图元序列，从元素first开始。mode指定构造什么类型的图元以及数组元素如何构造这些图元。</p>
<p>要启用和禁用通用顶点属性数组，请调用glEnableVertexAttribArray和glDisableVertexAttribArray。</p>
<p>注意</p>
<p>如果glUseProgram设置的当前程序对象无效，则渲染结果未定义。 但是，这种情况不会产生错误。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：mode不是一个可接收的值</p>
<p>GL_INVALID_VALUE：count是负数</p>
<p>GL_INVALID_FRAMEBUFFER_OPERATION：如果当前绑定的帧缓冲区不是帧缓冲区完成状态（即glCheckFramebufferStatus的返回值不是GL_FRAMEBUFFER_COMPLETE）。</p>
<p>另见</p>
<p>glCheckFramebufferStatus，glEnableVertexAttribArray，glDisableVertexAttribArray，glDrawElements，glUseProgram，glVertexAttribPointer</p>
<h2 id="glDrawElements-从数组数据中渲染图元"><a href="#glDrawElements-从数组数据中渲染图元" class="headerlink" title="glDrawElements - 从数组数据中渲染图元"></a>glDrawElements - 从数组数据中渲染图元</h2><p>C规范</p>
<p>void glDrawElements（GLenum mode，</p>
<pre><code>                           GLsizei count，

                           GLenum type,

                           const GLvoid * indices）;
</code></pre>
<p>参数</p>
<p>mode</p>
<p>指定要渲染的图元类型。 接受符号常量GL_POINTS，GL_LINE_STRIP，GL_LINE_LOOP，GL_LINES，GL_TRIANGLE_STRIP，GL_TRIANGLE_FAN和GL_TRIANGLES。</p>
<p>count</p>
<p>指定要渲染的元素数。</p>
<p>type</p>
<p>指定indices中值的类型。 必须是GL_UNSIGNED_BYTE或GL_UNSIGNED_SHORT。</p>
<p>indices</p>
<p>指定指向存储索引的位置的指针。</p>
<p>描述</p>
<p>glDrawElements指定了几个子例程调用的几何图元。你可以使用glVertexAttribPointer预先指定单独的顶点，法线和颜色数组，而不是调用GL过程来传递每个单独的顶点属性并使用它们通过单次调用glDrawElements来构造图元序列。</p>
<p>当调用glDrawElements时，它使用来自启用数组的计数顺序元素，从索引开始构造几何图元序列。mode指定构造什么类型的图元以及数组元素如何构造这些图元。 如果启用了多个数组，则使用每个数组。</p>
<p>要启用和禁用通用顶点属性数组，请调用glEnableVertexAttribArray和glDisableVertexAttribArray。</p>
<p>注意</p>
<p>如果glUseProgram设置的当前程序对象无效，则渲染结果未定义。 但是，这种情况不会产生错误。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：mode不是一个可接收的值</p>
<p>GL_INVALID_ENUM：type不是GL_UNSIGNED_BYTE或GL_UNSIGNED_SHORT</p>
<p>GL_INVALID_VALUE：count是负数</p>
<p>GL_INVALID_FRAMEBUFFER_OPERATION：如果当前绑定的帧缓冲区不是帧缓冲区完成状态（即glCheckFramebufferStatus的返回值不是GL_FRAMEBUFFER_COMPLETE）。</p>
<p>另见</p>
<p>glCheckFramebufferStatus，glEnableVertexAttribArray，glDisableVertexAttribArray，glDrawArrays，glUseProgram，glVertexAttribPointer</p>
<h2 id="glEnable-启用或禁用服务器端GL功能-1"><a href="#glEnable-启用或禁用服务器端GL功能-1" class="headerlink" title="glEnable- 启用或禁用服务器端GL功能"></a>glEnable- 启用或禁用服务器端GL功能</h2><p>C规范</p>
<p>void glEnable（GLenum cap）;</p>
<p>void glDisable（GLenum cap）;</p>
<p>参数</p>
<p>cap</p>
<p>指定表示GL功能的符号常量。</p>
<p>描述</p>
<p>glEnable和glDisable启用和禁用各种功能。使用glIsEnabled或glGet确定任何功能的当前设置。除GL_DITHER(抖动)外，每个功能的初始值为GL_FALSE。GL_DITHER的初始值为GL_TRUE。</p>
<p>glEnable和glDisable都使用单个参数cap，它可以采用以下值之一：</p>
<p>GL_BLEND</p>
<pre><code>    如果启用，则将计算的片段颜色值与颜色缓冲区中的值混合。 请参阅glBlendFunc。
</code></pre>
<p>GL_CULL_FACE</p>
<pre><code>   如果启用，则根据窗口的坐标来剔除多边形。 请参阅glCullFace。
</code></pre>
<p>GL_DEPTH_TEST</p>
<pre><code>   如果启用，进行深度比较并更新深度缓冲区。 注意，即使存在深度缓冲区且深度掩码不为零，如果禁用深度测试，也将不会更新深度缓冲区。 请参阅glDepthFunc和glDepthRangef。
</code></pre>
<p>GL_DITHER</p>
<pre><code>   如果启用，则在将颜色组件或索引写入颜色缓冲区之前对其进行抖动。
</code></pre>
<p>GL_POLYGON_OFFSET_FILL</p>
<pre><code>   如果启用，则会将偏移添加到由光栅化生成的多边形片段的深度值。 请参阅glPolygonOffset。（常用于处理Z-fighting）
</code></pre>
<p>GL_SAMPLE_ALPHA_TO_COVERAGE</p>
<pre><code>   如果启用，则计算临时覆盖值，其中每个位由相应样本位置的alpha值确定。 然后，临时覆盖值与片段覆盖值进行AND运算。
</code></pre>
<p>GL_SAMPLE_COVERAGE</p>
<pre><code>   如果启用，则片段的覆盖范围与临时覆盖值进行AND运算。 如果GL_SAMPLE_COVERAGE_INVERT设置为GL_TRUE，则反转coverage值。 请参阅glSampleCoverage。
</code></pre>
<p>GL_SCISSOR_TEST</p>
<pre><code>   如果启用，则丢弃裁剪矩形之外的片段。 见glScissor。
</code></pre>
<p>GL_STENCIL_TEST</p>
<pre><code>   如果启用，将进行模板测试并更新模板缓冲区。 请参阅glStencilFunc和glStencilOp。
</code></pre>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果cap不是之前列出的值之一。</p>
<p>相关Gets</p>
<p>glIsEnabled</p>
<p>glGet</p>
<p>另见</p>
<p>glActiveTexture，glBlendFunc，glCullFace，glDepthFunc，glDepthRangef，glGet，glIsEnabled，glLineWidth，glPolygonOffset，glScissor，glStencilFunc，glStencilOp，glTexImage2D</p>
<h2 id="glEnableVertexAttribArray-启用或禁用通用顶点属性数组-1"><a href="#glEnableVertexAttribArray-启用或禁用通用顶点属性数组-1" class="headerlink" title="glEnableVertexAttribArray - 启用或禁用通用顶点属性数组"></a>glEnableVertexAttribArray - 启用或禁用通用顶点属性数组</h2><p>C规范</p>
<p>void glEnableVertexAttribArray（GLuint index）;</p>
<p>void glDisableVertexAttribArray（GLuint index）;</p>
<p>参数</p>
<p>index</p>
<p>指定要启用或禁用的通用顶点属性的索引。</p>
<p>描述</p>
<p>glEnableVertexAttribArray启用index指定的通用顶点属性数组。 glDisableVertexAttribArray禁用index指定的通用顶点属性数组。 默认情况下，禁用所有客户端功能，包括所有通用顶点属性数组。 如果启用，将访问通用顶点属性数组中的值，并在调用顶点数组命令（如glDrawArrays或glDrawElements）时用于呈现。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：如果index大于或等于GL_MAX_VERTEX_ATTRIBS。</p>
<p>相关Gets</p>
<p>glGet 参数GL_MAX_VERTEX_ATTRIBS</p>
<p>glGetVertexAttrib 参数index和GL_VERTEX_ATTRIB_ARRAY_ENABLED</p>
<p>glGetVertexAttribPointerv 参数index和GL_VERTEX_ATTRIB_ARRAY_POINTER</p>
<p>另见</p>
<p>glBindAttribLocation，glDrawArrays，glDrawElements，glGetVertexAttrib，glGetVertexAttribPointerv</p>
<p>版权</p>
<h2 id="glFinish-阻止直到所有GL命令执行完成"><a href="#glFinish-阻止直到所有GL命令执行完成" class="headerlink" title="glFinish- 阻止直到所有GL命令执行完成"></a>glFinish- 阻止直到所有GL命令执行完成</h2><p>C规范</p>
<p>void glFinish（void）;</p>
<p>描述</p>
<p>在完成所有先前调用的GL命令的效果之前，glFinish不会返回。这些效果包括GL状态的所有更改，连接状态的所有更改以及帧缓冲区内容的所有更改。</p>
<p>注意</p>
<p>glFinish需要往返服务器。</p>
<p>另见</p>
<p>glFlush</p>
<h2 id="glFlush-在有限时间内强制执行GL命令"><a href="#glFlush-在有限时间内强制执行GL命令" class="headerlink" title="glFlush  - 在有限时间内强制执行GL命令"></a>glFlush  - 在有限时间内强制执行GL命令</h2><p>C规范</p>
<p>void glFlush（void）;</p>
<p>描述</p>
<p>不同的GL实现在几个不同的位置缓冲命令，包括网络缓冲区和图形加速器本身。glFlush会清空所有这些缓冲区，促使所有已发出的命令在实际渲染引擎接受时尽快执行。尽管此执行可能无法在任何特定时间段内完成，但它确实在有限时间内完成。</p>
<p>因为任何GL程序可能通过网络或缓冲命令的加速器执行，所以每当程序依赖于完成所有先前发出的命令时，所有程序都应该调用glFlush。例如，在等待依赖于生成的图像的用户输入之前调用glFlush。</p>
<p>注意</p>
<p>glFlush可以随时返回。 它不会等到所有先前发出的GL命令的执行完成。</p>
<p>另见</p>
<p>glFinish</p>
<h2 id="glFramebufferRenderbuffer-将renderbuffer对象附加到framebuffer对象"><a href="#glFramebufferRenderbuffer-将renderbuffer对象附加到framebuffer对象" class="headerlink" title="glFramebufferRenderbuffer- 将renderbuffer对象附加到framebuffer对象"></a>glFramebufferRenderbuffer- 将renderbuffer对象附加到framebuffer对象</h2><p>C规范</p>
<p>void glFramebufferRenderbuffer（GLenum target,</p>
<pre><code>                                                            GLenum attachment,

                                                            GLenum renderbuffertarget,

                                                            GLuint renderbuffer）;
</code></pre>
<p>参数</p>
<p>target</p>
<p>指定帧缓冲目标。 符号常量必须是GL_FRAMEBUFFER。</p>
<p>attachment</p>
<p>指定renderbuffer应附加到的附着点。 必须是以下符号常量之一：GL_COLOR_ATTACHMENT0，GL_DEPTH_ATTACHMENT或GL_STENCIL_ATTACHMENT。</p>
<p>renderbuffertarget</p>
<p>指定renderbuffer目标。 符号常量必须为GL_RENDERBUFFER。</p>
<p>renderbuffer</p>
<p>指定要附加的renderbuffer对象。</p>
<p>描述</p>
<p>glFramebufferRenderbuffer将renderbuffer指定的renderbuffer附加为当前绑定的framebuffer对象的逻辑缓冲区之一。 attachment指定是否应将renderbuffer附加到framebuffer对象的颜色，深度或模板缓冲区。 渲染缓冲区不可以附加到默认（名称为0）的帧缓冲对象。</p>
<p>如果renderbuffer不为0，则指定附加点的GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE值设置为GL_RENDERBUFFER，GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME的值设置为renderbuffer。 GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL和GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE分别设置为默认值0和GL_TEXTURE_CUBE_MAP_POSITIVE_X。 先前绑定的帧缓冲区对象的附件逻辑缓冲区都将被破坏。</p>
<p>如果renderbuffer为0，则分离附加到当前绑定的framebuffer对象的附件逻辑缓冲区的当前图像（如果有的话）。 GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE的值设置为GL_NONE。 GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME的值设置为0. GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL和GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE分别设置为默认值0和GL_TEXTURE_CUBE_MAP_POSITIVE_X。</p>
<p>注意</p>
<p>如果在将图像附加到当前绑定的帧缓冲区时删除了渲染缓冲区对象，则就好像glFramebufferRenderbuffer已使用渲染缓冲区为0调用此图像附加到当前绑定的帧缓冲区对象中的附着点。 换句话说，渲染缓冲区图像与当前绑定的帧缓冲区分离。 请注意，渲染缓冲区图像不会与任何未绑定的帧缓冲区分离。从任何非绑定帧缓冲区中分离映像是应用程序的责任。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果target不是GL_FRAMEBUFFER。</p>
<p>GL_INVALID_ENUM ：如果renderbuffertarget不是GL_RENDERBUFFER且renderbuffer不是0。</p>
<p>GL_INVALID_ENUM ：attachment是不可接收的附着点。</p>
<p>GL_INVALID_OPERATION ：如果绑定了默认的帧缓冲对象名称0。</p>
<p>GL_INVALID_OPERATION ：如果renderbuffer既不是0也不是现有渲染缓冲区对象的名称。</p>
<p>相关Gets</p>
<p>glGetFramebufferAttachmentParameteriv</p>
<p>另见</p>
<p>glBindFramebuffer，glBindRenderbuffer，glCheckFramebufferStatus，glDeleteFramebuffers，glDeleteRenderbuffers，glFramebufferTexture2D，glGetFramebufferAttachmentParameteriv，glRenderbufferStorage</p>
<p>版权</p>
<h2 id="glFramebufferTexture2D-将纹理图像附加到帧缓冲对象"><a href="#glFramebufferTexture2D-将纹理图像附加到帧缓冲对象" class="headerlink" title="glFramebufferTexture2D - 将纹理图像附加到帧缓冲对象"></a>glFramebufferTexture2D - 将纹理图像附加到帧缓冲对象</h2><p>C规范</p>
<p>void glFramebufferTexture2D（GLenum target,</p>
<pre><code>                                                      GLenum attachment,

                                                      GLenum textarget,

                                                      GLuint texture,

                                                      GLint level）;
</code></pre>
<p>参数</p>
<p>target</p>
<p>指定帧缓冲目标。 符号常量必须是GL_FRAMEBUFFER。</p>
<p>attachment</p>
<p>指定应附加纹理图像的附着点。 必须是以下符号常量之一：GL_COLOR_ATTACHMENT0，GL_DEPTH_ATTACHMENT或GL_STENCIL_ATTACHMENT。</p>
<p>textarget</p>
<p>指定纹理目标。 必须是以下符号常量之一：GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。</p>
<p>texture</p>
<p>指定要附加图像的纹理对象。</p>
<p>level</p>
<p>指定要附加的纹理图像的mipmap级别，该级别必须为0。</p>
<p>描述</p>
<p>glFramebufferTexture2D将texture和level指定的纹理图像附加为当前绑定的帧缓冲区对象的逻辑缓冲区之一。 attachment指定是否应将纹理图像附加到帧缓冲对象的颜色，深度或模板缓冲区。 纹理图像不可以附加到默认（名称为0）的帧缓冲对象。</p>
<p>如果texture不为0，则指定附加点的GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE的值设置为GL_TEXTURE，GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME的值设置为texture，GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL的值设置为level。 如果纹理是立方体贴图纹理，则GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE的值设置为textarget; 否则将其设置为默认值GL_TEXTURE_CUBE_MAP_POSITIVE_X。 先前绑定的帧缓冲区对象的附件逻辑缓冲区都将被破坏。</p>
<p>如果texture为0，则分离附加到当前绑定的帧缓冲区对象的附件逻辑缓冲区的当前图像（如果有的话）。 GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE的值设置为GL_NONE。 GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME的值设置为0. GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL和GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE分别设置为默认值0和GL_TEXTURE_CUBE_MAP_POSITIVE_X。</p>
<p>注意</p>
<p>当纹理对象当前被绑定并可能被当前顶点或片段着色器采样时，需要采取特殊预防措施以避免将纹理图像附加到当前绑定的帧缓冲区。这样做可能导致在通过渲染操作写入像素和在当前绑定纹理中用作纹素时同时读取那些相同像素之间创建“反馈循环”。在这种情况下，帧缓冲区将被视为帧缓冲区完成，但在此状态下渲染的片段的值将是未定义的。纹理样本的值也可能是未定义的。</p>
<p>如果在将图像附加到当前绑定的帧缓冲区时删除纹理对象，这就好比使用纹理0调用glFramebufferTexture2D作为此图像附加到当前绑定的帧缓冲区对象中的附着点。换句话说，纹理图像与当前绑定的帧缓冲区分离了。请注意，纹理图像不会与任何未绑定的帧缓冲区分离。从任何非绑定帧缓冲区中分离映像是应用程序的责任。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：target不是GL_FRAMEBUFFER。</p>
<p>GL_INVALID_ENUM ：texture不为0时textarget不是可接收的纹理target。</p>
<p>GL_INVALID_ENUM ：attachment是不可接收的附着点。</p>
<p>GL_INVALID_VALUE ：level不是0时，texture不是0。</p>
<p>GL_INVALID_OPERATION ：如果绑定了默认的帧缓冲对象名称0。</p>
<p>GL_INVALID_OPERATION ：如果texture既不是0也不是现有纹理对象的名称。</p>
<p>GL_INVALID_OPERATION ：如果texture是现有二维纹理对象的名称，但textarget不是GL_TEXTURE_2D，或者texture是现有立方体贴图纹理对象的名称，但textarget是GL_TEXTURE_2D。</p>
<p>相关Gets</p>
<p>glGetFramebufferAttachmentParameteriv</p>
<p>另见</p>
<p>glBindFramebuffer,glBindTexture,glCheckFramebufferStatus，glDeleteFramebuffers，glDeleteTextures，glFramebufferRenderbuffer，glGenerateMipmap，glGetFramebufferAttachmentParameteriv，glTexImage2D</p>
<p>版权</p>
<h2 id="glFrontFace-定义多边形的正面和背面"><a href="#glFrontFace-定义多边形的正面和背面" class="headerlink" title="glFrontFace - 定义多边形的正面和背面"></a>glFrontFace - 定义多边形的正面和背面</h2><p>C规范</p>
<p>void glFrontFace（GLenum mode）;</p>
<p>参数</p>
<p>mode</p>
<p>指定多边形的正面方向（顶点序列是按顺时针还是逆时针）。 GL_CW和GL_CCW被接受。初始值为GL_CCW（逆时针）。</p>
<p>描述</p>
<p>在完全由不透明闭合曲面组成的场景中，背面多边形永远不可见。消除这些不可见的多边形具有加速图像渲染的明显好处。要启用和禁用背面多边形的消除，请使用参数GL_CULL_FACE调用glEnable和glDisable。</p>
<p>多边形到窗口坐标的投影被称为顺时针缠绕，如果一个假想的对象跟随从其第一个顶点，第二个顶点等到其最后一个顶点的路径，最后返回到它的第一个顶点，则移动到顺时针方向绕多边形内部。如果跟随相同路径的假想物体围绕多边形内部沿逆时针方向移动，则称多边形的绕组是逆时针方向。 glFrontFace指定窗口坐标中顺时针缠绕的多边形或窗口坐标中的逆时针缠绕是否面向前方。将GL_CCW传递给模式选择逆时针多边形作为正面; GL_CW选择顺时针多边形作为正面。默认情况下，逆时针多边形被视为面向前方。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：mode是不可接受的值</p>
<p>相关Gets</p>
<p>glGet 参数GL_FRONT_FACE</p>
<p>另见</p>
<p>glCullFace</p>
<h2 id="glGenBuffers-生成缓冲区对象名称"><a href="#glGenBuffers-生成缓冲区对象名称" class="headerlink" title="glGenBuffers- 生成缓冲区对象名称"></a>glGenBuffers- 生成缓冲区对象名称</h2><p>C规范</p>
<p>void glGenBuffers（GLsizei n,GLuint * buffers）;</p>
<p>参数</p>
<p>n</p>
<p>指定要生成的缓冲区对象名称的数量。</p>
<p>buffers</p>
<p>指定存储生成的缓冲区对象名称的数组。</p>
<p>描述</p>
<p>glGenBuffers在buffers中返回n个缓冲区对象名称。我们无法保证这些名称形成一组连续的整数; 但是能够保证的是在调用glGenBuffers之前不会立即使用这些返回的名称。</p>
<p>调用glGenBuffers返回的缓冲区对象名称不会被后续调用返回，除非它们首先使用glDeleteBuffers删除。</p>
<p>在通过调用glBindBuffer进行绑定之前，没有缓冲区对象与返回的缓冲区对象名称关联。</p>
<p>错误</p>
<p>GL_INVALID_VALUE ：n是个负数</p>
<p>相关Gets</p>
<p>glIsBuffer​​​​​​​</p>
<p>另见</p>
<p>glBindBuffer，glDeleteBuffers，glGet</p>
<h2 id="glGenFramebuffers-生成framebuffer对象名称"><a href="#glGenFramebuffers-生成framebuffer对象名称" class="headerlink" title="glGenFramebuffers- 生成framebuffer对象名称"></a>glGenFramebuffers- 生成framebuffer对象名称</h2><p>C规范</p>
<p>void glGenFramebuffers（GLsizei n,</p>
<pre><code>                                             GLuint * framebuffers）;
</code></pre>
<p>参数</p>
<p>n</p>
<p>指定要生成的帧缓冲区对象名称的数量。</p>
<p>framebuffers</p>
<p>指定存储生成的帧缓冲区对象名称的数组。</p>
<p>描述</p>
<p>glGenFramebuffers在framebuffers中返回n个帧缓冲区对象名。无法保证连续整数的名称; 但是，保证在调用glGenFramebuffers之前没有任何返回的名称被使用。</p>
<p>调用glGenFramebuffers返回的帧缓冲对象名称不会被后续调用返回，除非它们首先使用glDeleteFramebuffers删除。</p>
<p>没有帧缓冲对象与返回的帧缓冲区对象名称关联，直到它们首先通过调用glBindFramebuffer进行绑定。</p>
<p>错误</p>
<p>GL_INVALID_VALUE ：n是负数</p>
<p>相关Gets</p>
<p>glIsFramebuffer</p>
<p>另见</p>
<p>glBindFramebuffer，glDeleteFramebuffers，glIsFramebuffer</p>
<h2 id="glGenRenderbuffers-生成渲染缓冲区对象名称"><a href="#glGenRenderbuffers-生成渲染缓冲区对象名称" class="headerlink" title="glGenRenderbuffers- 生成渲染缓冲区对象名称"></a>glGenRenderbuffers- 生成渲染缓冲区对象名称</h2><p>C规范</p>
<p>void glGenRenderbuffers（GLsizei n，</p>
<pre><code>                                               GLuint * renderbuffers）;
</code></pre>
<p>参数</p>
<p>n</p>
<p>指定要生成的渲染缓冲区对象名称的数量。</p>
<p>renderbuffers</p>
<p>指定存储生成的渲染缓冲区对象名称的数组。</p>
<p>描述</p>
<p>glGenRenderbuffers在renderbuffers中返回n个渲染缓冲区对象名。 无法保证这些名称形成一组连续的整数; 但是，保证在调用glGenRenderbuffers之前没有任何返回的名称被使用。</p>
<p>调用glGenRenderbuffers返回的渲染缓冲区对象名称不会被后续调用返回，除非首先使用glDeleteRenderbuffers删除它们。</p>
<p>在通过调用glBindRenderbuffer进行绑定之前，渲染缓冲区对象不会被关联渲染缓冲区对象名称。</p>
<p>错误</p>
<p>GL_INVALID_VALUE ：n是负数。</p>
<p>相关Gets</p>
<p>glIsRenderbuffer</p>
<p>另见</p>
<p>glBindRenderbuffer，glDeleteRenderbuffers，glIsRenderbuffer</p>
<h2 id="glGenTextures-生成纹理名称（ID）"><a href="#glGenTextures-生成纹理名称（ID）" class="headerlink" title="glGenTextures- 生成纹理名称（ID）"></a>glGenTextures- 生成纹理名称（ID）</h2><p>C规范</p>
<p>void glGenTextures( GLsizei n,GLuint * textures);</p>
<p>参数</p>
<p>n</p>
<pre><code>指定要生成的纹理ID的数量。
</code></pre>
<p>textures</p>
<pre><code>指定存储生成的纹理ID的数组。
</code></pre>
<p>描述</p>
<p>glGenTextures产生ｎ个纹理ID存储在textures数组中，这个方法并不保存返回的是一串连续的整数数组，但是能保证的是：这些ID在调用glGenTextures之前都没有正在被使用。</p>
<p>生成的textures此时还是没有维度的，当他们第一次绑定纹理目标时才被指定维度（见glBindTexture）。</p>
<p>通过调用glGenTextures返回的纹理ID不会被后续调用返回，除非首先使用glDeleteTextures删除它们。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：如果参数n是负数。</p>
<p>相关Gets</p>
<p>glIsTexture​​​​​​​</p>
<p>另见</p>
<p>glBindTexture​​​​​​​ glCopyTexImage2D glDeleteTextures​​​​​​​ glGet glGetTexParameter​​​​​​​ glTexImage2D​​​​​​​  glTexParameter</p>
<p>版权</p>
<h2 id="glGenerateMipmap-为纹理对象生成一组完整的mipmap"><a href="#glGenerateMipmap-为纹理对象生成一组完整的mipmap" class="headerlink" title="glGenerateMipmap- 为纹理对象生成一组完整的mipmap"></a>glGenerateMipmap- 为纹理对象生成一组完整的mipmap</h2><p>C规范</p>
<p>void glGenerateMipmap（GLenum target）;</p>
<p>参数</p>
<p>target</p>
<pre><code>指定将生成mipmap的纹理对象绑定到的活动纹理单元的纹理目标。 必须是以下符号常量之一：GL_TEXTURE_2D或GL_TEXTURE_CUBE_MAP。
</code></pre>
<p>描述</p>
<pre><code>glGenerateMipmap计算从零级数组派生的一组完整的mipmap数组。 无论先前的内容如何，最多包括1x1维度纹理图像的数组级别都将替换为派生数组。 零级纹理图像保持不变（原图）。

派生的mipmap数组的内部格式都与零级纹理图像的内部格式相匹配。 通过将零级纹理图像的宽度和高度减半来计算派生数组的尺寸，然后将每个阵列级别的尺寸减半，直到达到1x1尺寸纹理图像。

通过重复滤波减少零电平阵列来计算导出阵列的内容。 虽然建议使用盒式过滤器，但不需要特殊的过滤算法。 可以调用glHint来表示对过滤速度或质量的偏好。
</code></pre>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果target不是GL_TEXTURE_2D或GL_TEXTURE_CUBE_MAP；</p>
<p>GL_INVALID_OPERATION：如果纹理绑定的是立方体贴图，但是6个面却不共用统一的宽高格式和类型；</p>
<p>GL_INVALID_OPERATION ：如果原图的宽高不是2^N。（纹理贴图没这个要求，但是如要生成mipmap组则要注意这个要求）</p>
<p>GL_INVALID_OPERATION ：如果零级数组以压缩内部格式存储。</p>
<p>另见</p>
<p>glBindTexture，glFramebufferTexture2D，glHint​​​​​​​，glTexImage2D，glTexParameter</p>
<p>版权</p>
<h2 id="glGet-返回所选参数的值"><a href="#glGet-返回所选参数的值" class="headerlink" title="glGet - 返回所选参数的值"></a>glGet - 返回所选参数的值</h2><p>C规范</p>
<p>void glGetBooleanv(    GLenum pname,<br>     GLboolean * params);</p>
<p>void glGetFloatv(    GLenum pname,<br>     GLfloat * params);</p>
<p>void glGetIntegerv(    GLenum pname,<br>     GLint * params);</p>
<p>参数</p>
<p>pname</p>
<p>指定要返回的参数值。接受下面列表中的符号常量。</p>
<p>params</p>
<p>返回指定参数的值。</p>
<p>描述</p>
<p>这些命令返回GL中简单状态变量的值。 pname是一个符号常量，表示要返回的状态变量，params是一个指向指定类型数组的指针，用于放置返回的数据。</p>
<p>如果params的类型与请求的状态变量值不同，则执行类型转换。如果调用glGetBooleanv，当且仅当它是0.0（或0）时，浮点（或整数）值才会转换为GL_FALSE。否则，它将转换为GL_TRUE。如果调用glGetIntegerv，则布尔值将返回GL_TRUE或GL_FALSE，并且大多数浮点值将四舍五入为最接近的整数值。但是，浮点颜色和法线将返回一个线性映射，该映射将1.0映射到最正可表示的整数值，将-1.0映射到最负可表示的整数值。如果调用glGetFloatv，则布尔值将作为GL_TRUE或GL_FALSE返回，并且整数值将转换为浮点值。pname接受以下符号常量：</p>
<p>GL_ACTIVE_TEXTURE</p>
<p>params返回一个表示活动多重纹理单元的值。初始值为GL_TEXTURE0。请参阅glActiveTexture。</p>
<p>GL_ALIASED_LINE_WIDTH_RANGE</p>
<p>params返回两个值，即别名行的最小和最大支持宽度。范围必须包括宽度1。</p>
<p>GL_ALIASED_POINT_SIZE_RANGE</p>
<p>params返回两个值，即别名点支持的最小和最大尺寸。范围必须包括1号。</p>
<p>GL_ALPHA_BITS</p>
<p>params返回一个值，即当前绑定的帧缓冲区的颜色缓冲区中的alpha位平面的数量。</p>
<p>GL_ARRAY_BUFFER_BINDING</p>
<p>params返回单个值，即当前绑定到目标GL_ARRAY_BUFFER的缓冲区对象的名称。如果没有缓冲区对象绑定到此目标，则返回0。初始值为0.请参阅glBindBuffer。</p>
<p>GL_BLEND</p>
<p>params返回一个布尔值，指示是否启用了混合。初始值为GL_FALSE。请参阅glBlendFunc。</p>
<p>GL_BLEND_COLOR</p>
<p>params返回四个值，红色，绿色，蓝色和alpha值，它们是混合颜色的组成部分。请参阅glBlendColor。</p>
<p>GL_BLEND_DST_ALPHA</p>
<p>params返回一个值，该符号常量标识alpha目标混合函数。初始值为GL_ZERO。请参阅glBlendFunc和glBlendFuncSeparate。</p>
<p>GL_BLEND_DST_RGB</p>
<p>params返回一个值，该符号常量标识RGB目标混合函数。初始值为GL_ZERO。请参阅glBlendFunc和glBlendFuncSeparate。</p>
<p>GL_BLEND_EQUATION_ALPHA</p>
<p>params返回一个值，一个符号常量，指示Alpha混合方程是GL_FUNC_ADD，GL_FUNC_SUBTRACT还是GL_FUNC_REVERSE_SUBTRACT。请参阅glBlendEquationSeparate。</p>
<p>GL_BLEND_EQUATION_RGB</p>
<p>params返回一个值，一个符号常量，指示RGB混合方程是GL_FUNC_ADD，GL_FUNC_SUBTRACT还是GL_FUNC_REVERSE_SUBTRACT。请参阅glBlendEquationSeparate。</p>
<p>GL_BLEND_SRC_ALPHA</p>
<p>params返回一个值，这是一个标识alpha源混合函数的符号常量。初始值为GL_ONE。请参阅glBlendFunc和glBlendFuncSeparate。</p>
<p>GL_BLEND_SRC_RGB</p>
<p>params返回一个值，这个符号常量标识RGB源混合函数。初始值为GL_ONE。请参阅glBlendFunc和glBlendFuncSeparate。</p>
<p>GL_BLUE_BITS</p>
<p>params返回一个值，即当前绑定的帧缓冲区的颜色缓冲区中的蓝色位平面的数量。</p>
<p>GL_COLOR_CLEAR_VALUE</p>
<p>params返回四个值：用于清除颜色缓冲区的红色，绿色，蓝色和alpha值。如果请求，整数值从内部浮点表示线性映射，使得1.0返回最正可表示的整数值，-1.0返回最负可表示的整数值。初始值为（0,0,0,0）。请参阅glClearColor。</p>
<p>GL_COLOR_WRITEMASK</p>
<p>params返回四个布尔值：红色，绿色，蓝色和alpha写入启用颜色缓冲区。初始值为（GL_TRUE，GL_TRUE，GL_TRUE，GL_TRUE）。请参阅glColorMask。</p>
<p>GL_COMPRESSED_TEXTURE_FORMATS</p>
<p>params返回长度为GL_NUM_COMPRESSED_TEXTURE_FORMATS的符号常量列表，指示哪些压缩纹理格式可用。请参阅glCompressedTexImage2D。</p>
<p>GL_CULL_FACE</p>
<p>params返回一个布尔值，指示是否启用了多边形剔除。初始值为GL_FALSE。请参阅glCullFace。</p>
<p>GL_CULL_FACE_MODE</p>
<p>params返回一个值，一个符号常量，指示要剔除哪些多边形面。初始值为GL_BACK。请参阅glCullFace。</p>
<p>GL_CURRENT_PROGRAM</p>
<p>params返回一个值，即当前活动的程序对象的名称，如果没有程序对象处于活动状态，则返回0。请参阅glUseProgram。</p>
<p>GL_DEPTH_BITS</p>
<p>params返回一个值，即当前绑定的帧缓冲区的深度缓冲区中的位平面数。</p>
<p>GL_DEPTH_CLEAR_VALUE</p>
<p>params返回一个值，该值用于清除深度缓冲区。如果请求，整数值从内部浮点表示线性映射，使得1.0返回最正可表示的整数值，-1.0返回最负可表示的整数值。初始值为1.请参阅glDepthRangef。</p>
<p>GL_DEPTH_FUNC</p>
<p>params返回一个值，表示深度比较函数的符号常量。初始值为GL_LESS。请参阅glDepthFunc。</p>
<p>GL_DEPTH_RANGE</p>
<p>params返回两个值：深度缓冲区的近和远映射限制。如果请求，整数值从内部浮点表示线性映射，使得1.0返回最正可表示的整数值，-1.0返回最负可表示的整数值。初始值为（0,1）。请参阅glDepthRangef。</p>
<p>GL_DEPTH_TEST</p>
<p>params返回一个布尔值，指示是否启用了片段的深度测试。初始值为GL_FALSE。请参阅glDepthFunc和glDepthRangef。</p>
<p>GL_DEPTH_WRITEMASK</p>
<p>params返回一个布尔值，指示深度缓冲区是否已启用写入。初始值为GL_TRUE。请参阅glDepthMask。</p>
<p>GL_DITHER</p>
<p>params返回一个布尔值，指示是否启用了片段颜色和索引的抖动。初始值为GL_TRUE。</p>
<p>GL_ELEMENT_ARRAY_BUFFER_BINDING</p>
<p>params返回单个值，即当前绑定到目标GL_ELEMENT_ARRAY_BUFFER的缓冲区对象的名称。如果没有缓冲区对象绑定到此目标，则返回0。初始值为0.请参阅glBindBuffer。</p>
<p>GL_FRAMEBUFFER_BINDING</p>
<p>params返回单个值，即当前绑定的帧缓冲区的名称。初始值为0，表示默认的帧缓冲区。请参阅glBindFramebuffer。</p>
<p>GL_FRONT_FACE</p>
<p>params返回一个值，一个符号常数，表示顺时针或逆时针多边形绕组是否被视为正面。初始值为GL_CCW。请参阅glFrontFace。</p>
<p>GL_GENERATE_MIPMAP_HINT</p>
<p>params返回一个值，一个符号常量，指示mipmap生成过滤提示的模式。初始值为GL_DONT_CARE。见glHint。</p>
<p>GL_GREEN_BITS</p>
<p>params返回一个值，即当前绑定的帧缓冲区的颜色缓冲区中的绿色位平面的数量。</p>
<p>GL_IMPLEMENTATION_COLOR_READ_FORMAT</p>
<p>params返回一个值，即实现选择的格式，其中可以从当前绑定的帧缓冲区的颜色缓冲区中读取像素，并结合GL_IMPLEMENTATION_COLOR_READ_TYPE。除了这种依赖于实现的格式/类型对之外，每个实现始终允许格式GL_RGBA和类型GL_UNSIGNED_BYTE，而不管当前绑定的渲染表面如何。请参阅glReadPixels。</p>
<p>GL_IMPLEMENTATION_COLOR_READ_TYPE</p>
<p>params返回一个值，该实现选择的类型可以从当前绑定的帧缓冲区的颜色缓冲区中读取像素，并结合GL_IMPLEMENTATION_COLOR_READ_FORMAT。除了这种依赖于实现的格式/类型对之外，每个实现始终允许格式GL_RGBA和类型GL_UNSIGNED_BYTE，而不管当前绑定的渲染表面如何。请参阅glReadPixels。</p>
<p>GL_LINE_WIDTH</p>
<p>params返回一个值，即glLineWidth指定的行宽。初始值为1。</p>
<p>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</p>
<p>params返回一个值，最大支持的纹理图像单元数，可用于从顶点着色器和片段处理器组合访问纹理贴图。如果顶点着色器和片段处理阶段都访问相同的纹理图像单元，则计数为使用两个纹理图像单元来抵抗此限制。该值必须至少为8.请参阅glActiveTexture。</p>
<p>GL_MAX_CUBE_MAP_TEXTURE_SIZE</p>
<p>params返回一个值。该值粗略估计了GL可以处理的最大立方体贴图纹理。该值必须至少为16.请参阅glTexImage2D。</p>
<p>GL_MAX_FRAGMENT_UNIFORM_VECTORS</p>
<p>params返回一个值，可以保存在片段着色器的统一变量存储中的四元素浮点数，整数或布尔矢量的最大数量。该值必须至少为16.请参阅glUniform。</p>
<p>GL_MAX_RENDERBUFFER_SIZE</p>
<p>params返回一个值。该值表示GL可以处理的最大渲染缓冲区宽度和高度。该值必须至少为1.请参阅glRenderbufferStorage。</p>
<p>GL_MAX_TEXTURE_IMAGE_UNITS</p>
<p>params返回一个值，这是支持的最大纹理图像单元，可用于从片段着色器访问纹理贴图。该值必须至少为8.请参阅glActiveTexture。</p>
<p>GL_MAX_TEXTURE_SIZE</p>
<p>params返回一个值。该值粗略估计了GL可以处理的最大纹理。该值必须至少为64.请参阅glTexImage2D。</p>
<p>GL_MAX_VARYING_VECTORS</p>
<p>params返回一个值，最大数量的四元素浮点向量可用于插入顶点和片段着色器使用的变量变量。声明为矩阵或数组的变量变量将使用多个插值器。该值必须至少为8。</p>
<p>GL_MAX_VERTEX_ATTRIBS</p>
<p>params返回一个值，即顶点着色器可访问的4分量通用顶点属性的最大数量。该值必须至少为8.请参阅glVertexAttrib。</p>
<p>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</p>
<p>params返回一个值，最大支持的纹理图像单元，可用于从顶点着色器访问纹理贴图。值可能为0.请参阅glActiveTexture。</p>
<p>GL_MAX_VERTEX_UNIFORM_VECTORS</p>
<p>params返回一个值，可以保存在顶点着色器的统一变量存储中的四元素浮点数，整数或布尔矢量的最大数量。该值必须至少为128.请参阅glUniform。</p>
<p>GL_MAX_VIEWPORT_DIMS</p>
<p>params返回两个值：视口的最大支持宽度和高度。这些必须至少与要渲染的显示器的可见尺寸一样大。请参阅glViewport。</p>
<p>GL_NUM_COMPRESSED_TEXTURE_FORMATS</p>
<p>params返回一个整数值，表示可用的压缩纹理格式的数量。最小值为0.请参阅glCompressedTexImage2D。</p>
<p>GL_NUM_SHADER_BINARY_FORMATS</p>
<p>params返回一个整数值，表示可用着色器二进制格式的数量。最小值为0.请参阅glShaderBinary。</p>
<p>GL_PACK_ALIGNMENT</p>
<p>params返回一个值，用于将像素数据写入内存的字节对齐。初始值为4.请参阅glReadPixels。</p>
<p>GL_POLYGON_OFFSET_FACTOR</p>
<p>params返回一个值，缩放因子用于确定添加到多边形光栅化时生成的每个片段的深度值的变量偏移量。初始值为0.请参阅glPolygonOffset。</p>
<p>GL_POLYGON_OFFSET_FILL</p>
<p>params返回一个布尔值，指示在填充模式下是否为多边形启用了多边形偏移。初始值为GL_FALSE。请参阅glPolygonOffset。</p>
<p>GL_POLYGON_OFFSET_UNITS</p>
<p>params返回一个值。此值乘以特定于实现的值，然后添加到栅格化多边形时生成的每个片段的深度值。初始值为0.请参阅glPolygonOffset。</p>
<p>GL_RED_BITS</p>
<p>params返回一个值，即当前绑定的帧缓冲区的颜色缓冲区中的红色位平面的数量。</p>
<p>GL_RENDERBUFFER_BINDING</p>
<p>params返回单个值，即当前绑定的renderbuffer的名称。初始值为0，表示没有绑定渲染缓冲区。请参阅glBindRenderbuffer。</p>
<p>GL_SAMPLE_ALPHA_TO_COVERAGE</p>
<p>params返回一个布尔值，指示片段覆盖值是否应与基于片段的alpha值的临时覆盖值进行AND运算。初始值为GL_FALSE。请参阅glSampleCoverage。</p>
<p>GL_SAMPLE_BUFFERS</p>
<p>params返回一个整数值，表示与当前绑定的帧缓冲区关联的样本缓冲区的数量。请参阅glSampleCoverage。</p>
<p>GL_SAMPLE_COVERAGE</p>
<p>params返回一个布尔值，指示片段覆盖值是否应与基于当前样本覆盖值的临时覆盖值进行AND运算。初始值为GL_FALSE。请参阅glSampleCoverage。</p>
<p>GL_SAMPLE_COVERAGE_INVERT</p>
<p>params返回一个布尔值，指示是否应该反转临时覆盖值。请参阅glSampleCoverage。</p>
<p>GL_SAMPLE_COVERAGE_VALUE</p>
<p>params返回单个正浮点值，表示当前样本覆盖值。请参阅glSampleCoverage。</p>
<p>GL_SAMPLES</p>
<p>params返回一个整数值，表示当前绑定的帧缓冲区的coverage掩码大小。请参阅glSampleCoverage。</p>
<p>GL_SCISSOR_BOX</p>
<p>params返回四个值：裁剪框的x和y窗口坐标，后跟宽度和高度。最初，x和y窗口坐标均为0，宽度和高度设置为窗口大小。见glScissor。</p>
<p>GL_SCISSOR_TEST</p>
<p>params返回一个布尔值，指示是否启用裁剪。初始值为GL_FALSE。见glScissor。</p>
<p>GL_SHADER_BINARY_FORMATS</p>
<p>params返回长度为GL_NUM_SHADER_BINARY_FORMATS的符号常量列表，指示哪些着色器二进制格式可用。请参阅glShaderBinary。</p>
<p>GL_SHADER_COMPILER</p>
<p>params返回一个布尔值，指示是否支持着色器编译器。 GL_FALSE表示对glShaderSource，glCompileShader或glReleaseShaderCompiler的任何调用都将导致生成GL_INVALID_OPERATION错误。</p>
<p>GL_STENCIL_BACK_FAIL</p>
<p>params返回一个值，一个符号常量，指示当模板测试失败时对后向多边形采取的操作。初始值为GL_KEEP。请参阅glStencilOpSeparate。</p>
<p>GL_STENCIL_BACK_FUNC</p>
<p>params返回一个值，一个符号常量，指示用于后向多边形的函数，以将模板参考值与模板缓冲区值进行比较。初始值为GL_ALWAYS。请参阅glStencilFuncSeparate。</p>
<p>GL_STENCIL_BACK_PASS_DEPTH_FAIL</p>
<p>params返回一个值，一个符号常量，表示当模板测试通过时对背面多边形采取的操作，但深度测试失败。初始值为GL_KEEP。请参阅glStencilOpSeparate。</p>
<p>GL_STENCIL_BACK_PASS_DEPTH_PASS</p>
<p>params返回一个值，一个符号常量，表示当模板测试通过并且深度测试通过时，对于背面多边形采取的操作。初始值为GL_KEEP。请参阅glStencilOpSeparate。</p>
<p>GL_STENCIL_BACK_REF</p>
<p>params返回一个值，该值与背面多边形的模板缓冲区内容进行比较。初始值为0.请参阅glStencilFuncSeparate。</p>
<p>GL_STENCIL_BACK_VALUE_MASK</p>
<p>params返回一个值，用于背面多边形的掩码在比较之前屏蔽模板参考值和模板缓冲区值。初始值全是1。请参阅glStencilFuncSeparate。</p>
<p>GL_STENCIL_BACK_WRITEMASK</p>
<p>params返回一个值，该值控制用于背面多边形的模板位平面的写入。初始值全是1。请参阅glStencilMask。</p>
<p>GL_STENCIL_BITS</p>
<p>params返回一个值，即当前绑定的帧缓冲区的模板缓冲区中的位平面数。</p>
<p>GL_STENCIL_CLEAR_VALUE</p>
<p>params返回一个值，即模板位平面被清除的索引。初始值为0.请参阅glClearStencil。</p>
<p>GL_STENCIL_FAIL</p>
<p>params返回一个值，一个符号常量，表示当前面的多边形和非多边形的模板测试失败时采取的操作。初始值为GL_KEEP。请参阅glStencilOp和glStencilOpSeparate。</p>
<p>GL_STENCIL_FUNC</p>
<p>params返回一个值，一个符号常量，指示用于将模板参考值与前面多边形和非多边形的模板缓冲区值进行比较的函数。初始值为GL_ALWAYS。请参阅glStencilFunc和glStencilFuncSeparate。</p>
<p>GL_STENCIL_PASS_DEPTH_FAIL</p>
<p>params返回一个值，一个符号常量，表示模板测试通过时采取的操作，但前向多边形和非多边形的深度测试失败。初始值为GL_KEEP。请参阅glStencilOp和glStencilOpSeparate。</p>
<p>GL_STENCIL_PASS_DEPTH_PASS</p>
<p>params返回一个值，一个符号常量，表示模板测试通过时采取的操作，深度测试通过前面的多边形和非多边形。初始值为GL_KEEP。请参阅glStencilOp和glStencilOpSeparate。</p>
<p>GL_STENCIL_REF</p>
<p>params返回一个值，该值与前面的多边形和非多边形的模板缓冲区的内容进行比较。初始值为0.请参阅glStencilFunc和glStencilFuncSeparate。</p>
<p>GL_STENCIL_TEST</p>
<p>params返回一个布尔值，指示是否启用了片段的模板测试。初始值为GL_FALSE。请参阅glStencilFunc和glStencilOp。</p>
<p>GL_STENCIL_VALUE_MASK</p>
<p>params返回一个值，该掩码用于在比较前面的多边形和非多边形之前屏蔽模板参考值和模板缓冲区值。初始值全是1。请参阅glStencilFunc和glStencilFuncSeparate。</p>
<p>GL_STENCIL_WRITEMASK</p>
<p>params返回一个值，该控件用于控制前面的多边形和非多边形的模板位平面的写入。初始值全是1。请参阅glStencilMask和glStencilMaskSeparate。</p>
<p>GL_SUBPIXEL_BITS</p>
<p>params返回一个值，即用于在窗口坐标中定位栅格化几何的子像素分辨率的位数估计值。该值必须至少为4。</p>
<p>GL_TEXTURE_BINDING_2D</p>
<p>params返回单个值，即当前绑定到活动多纹理单元的目标GL_TEXTURE_2D的纹理的名称。初始值为0.请参阅glBindTexture。</p>
<p>GL_TEXTURE_BINDING_CUBE_MAP</p>
<p>params返回单个值，当前绑定到活动多纹理单元的目标GL_TEXTURE_CUBE_MAP的纹理的名称。初始值为0.请参阅glBindTexture。</p>
<p>GL_UNPACK_ALIGNMENT</p>
<p>params返回一个值，用于从内存中读取像素数据的字节对齐。初始值为4.请参阅glPixelStorei。</p>
<p>GL_VIEWPORT</p>
<p>params返回四个值：视口的x和y窗口坐标，后跟其宽度和高度。最初，x和y窗口坐标都设置为0，宽度和高度设置为GL将进行渲染的窗口的宽度和高度。请参阅glViewport。</p>
<p>使用glIsEnabled也可以更轻松地查询许多布尔参数。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：pname不是前面列出的值之一</p>
<p>另见</p>
<p>glGetActiveAttrib，glGetActiveUniform，glGetAttachedShaders，glGetAttribLocation，glGetBufferParameteriv，glGetError，glGetFramebufferAttachmentParameteriv，glGetProgramiv，glGetProgramInfoLog，glGetRenderbufferParameteriv，glGetShaderiv，glGetShaderInfoLog，glGetShaderInfoLog，glGetString，glGetTexParameter，glGetUniform，glGetUniformLocation，glGetVertexAttrib，glGetVertexAttribPointerv，glIsEnabled</p>
<h2 id="glGetActiveAttrib-激活纹理单元"><a href="#glGetActiveAttrib-激活纹理单元" class="headerlink" title="glGetActiveAttrib - 激活纹理单元"></a>glGetActiveAttrib - 激活纹理单元</h2><p>C规范</p>
<p>void glGetActiveAttrib(    GLuint program,<br>     GLuint index,<br>     GLsizei bufSize,<br>     GLsizei *length,<br>     GLint *size,<br>     GLenum *type,<br>     GLchar *name);</p>
<p>参数</p>
<p>program</p>
<p>指定要查询的程序对象。</p>
<p>index</p>
<p>指定要查询的属性变量的索引。</p>
<p>bufSize</p>
<p>指定允许OpenGL在由name指示的字符缓冲区中写入的最大字符数。</p>
<p>length</p>
<p>如果传递NULL以外的值，则返回由name指示的字符串中的OpenGL实际写入的字符数（不包括空终止符）。</p>
<p>size</p>
<p>返回属性变量的尺寸大小。</p>
<p>type</p>
<p>返回属性变量的数据类型。</p>
<p>name</p>
<p>返回包含属性变量名称的以null结尾的字符串。</p>
<p>描述</p>
<p>glGetActiveAttrib返回有关程序指定的program对象中的活动属性变量的信息。可以通过使用值GL_ACTIVE_ATTRIBUTES调用glGetProgramiv来获取活动属性的数量。索引的值为0将选择第一个活动属性变量。索引的允许值范围从0到活动属性变量数减1。</p>
<p>属性变量具有任意名称，并通过编号的通用顶点属性获取其值。如果在链接操作期间确定属性变量可以在程序执行期间被访问，则该属性变量被认为是活动的。因此，程序之前应该是调用glLinkProgram的目标，但它没有必要成功链接。</p>
<p>可以通过调用值为GL_ACTIVE_ATTRIBUTE_MAX_LENGTH的glGetProgramiv来获取在程序中存储最长属性变量名所需的字符缓冲区的大小。此值应用于分配足够大小的缓冲区来存储返回的属性名称。该字符缓冲区的大小在bufSize中传递，并且在该名称中传递指向该字符缓冲区的指针。</p>
<p>glGetActiveAttrib返回index指示的属性变量的名称，将其存储在name指定的字符缓冲区中。返回的字符串将以null结尾。写入此缓冲区的实际字符数以长度形式返回，并且此计数不包括空终止字符。如果不需要返回字符串的长度，则可以在length参数中传递NULL值。</p>
<p>type参数将返回指向属性变量数据类型的指针。可以返回符号常量GL_FLOAT，GL_FLOAT_VEC2，GL_FLOAT_VEC3，GL_FLOAT_VEC4，GL_FLOAT_MAT2，GL_FLOAT_MAT3或GL_FLOAT_MAT4。 size参数将返回属性的大小，以type中返回的类型为单位。</p>
<p>此函数将返回尽可能多的有关指定活动属性变量的信息。如果没有可用信息，则长度为0，name为空字符串。如果在失败的链接操作后调用此函数，则可能发生这种情况。如果发生错误，则返回值length，size，type和name将不会被修改。</p>
<p>错误</p>
<p>GL_INVALID_VALUE:program不是OpenGL生成的值</p>
<p>GL_INVALID_OPERATION:program不是程序对象</p>
<p>GL_INVALID_VALUE:index&gt;=程序中活动属性变量的数量</p>
<p>GL_INVALID_VALUE:bufSize&lt;0</p>
<p>相关Gets</p>
<p>glGet  参数GL_MAX_VERTEX_ATTRIBS</p>
<p>glGetProgramiv 参数GL_ACTIVE_ATTRIBUTES或GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glBindAttribLocation，glGetActiveUniform，glLinkProgram，glVertexAttrib，glVertexAttribPointer</p>
<h2 id="glGetActiveUniform-返回有关活动统一变量的信息"><a href="#glGetActiveUniform-返回有关活动统一变量的信息" class="headerlink" title="glGetActiveUniform - 返回有关活动统一变量的信息"></a>glGetActiveUniform - 返回有关活动统一变量的信息</h2><p>C规范</p>
<p>void glGetActiveUniform（GLuint program,</p>
<pre><code>                                             GLuint index,

                                             GLsizei bufSize,

                                             GLsizei *length,

                                             GLint *size,

                                             GLenum *type,

                                             GLchar *name）;
</code></pre>
<p>参数</p>
<p>program</p>
<p>指定要查询的程序对象。</p>
<p>index</p>
<p>指定要查询的统一变量的索引。</p>
<p>bufSize</p>
<p>指定允许OpenGL在由name指示的字符缓冲区中写入的最大字符数。</p>
<p>length</p>
<p>如果传递NULL以外的值，则返回由name指示的字符串中的OpenGL实际写入的字符数（不包括空终止符）。</p>
<p>size</p>
<p>返回统一变量的大小。</p>
<p>type</p>
<p>返回统一变量的数据类型。</p>
<p>name</p>
<p>返回包含统一变量名称的以null结尾的字符串。</p>
<p>描述</p>
<p>glGetActiveUniform返回有关程序指定的程序对象中的活动统一变量的信息。可以通过使用值GL_ACTIVE_UNIFORMS调用glGetProgramiv来获得活动的统一变量的数量。索引的值为0的是选择第一个活动的统一变量。索引的允许值范围从0到活动统一变量的数量减1。</p>
<p>着色器可以使用内置的统一变量，用户定义的统一变量或两者。内置的统一变量具有前缀“gl_”并且引用现有的OpenGL状态或从这种状态导出的值（例如，gl_DepthRange）。用户定义的统一变量具有任意名称，并通过调用glUniform从应用程序获取它们的值。如果在链接操作期间确定可以在程序执行期间访问它，则统一变量（内置或用户定义）被认为是活动的。因此，程序之前应该是调用glLinkProgram的目标，但它没有必要成功链接。</p>
<p>在程序中存储最长的统一变量名所需的字符缓冲区的大小可以通过调用值为GL_ACTIVE_UNIFORM_MAX_LENGTH的glGetProgramiv来获得。此值应用于分配足够大小的缓冲区来存储返回的统一变量名称。该字符缓冲区的大小在bufSize中传递，并且在该名称中传递指向该字符缓冲区的指针。</p>
<p>glGetActiveUniform返回由index指示的统一变量的名称，将其存储在name指定的字符缓冲区中。返回的字符串将以null结尾。写入此缓冲区的实际字符数以长度形式返回，并且此计数不包括空终止字符。如果不需要返回字符串的长度，则可以在length参数中传递NULL值。</p>
<p>type参数将返回指向统一变量数据类型的指针。可以返回符号常数GL_FLOAT，GL_FLOAT_VEC2，GL_FLOAT_VEC3，GL_FLOAT_VEC4，GL_INT_GLEC_VEC2，GL_INT_VEC3，GL_INT_VEC4，GL_BOOL，GL_BOOL_VEC2，GL_BOOL_VEC3，GL_BOOL_VEC4，GL_FLOAT_MAT2，GL_FLOAT_MAT3，GL_FLOAT_MAT4，GL_SAMPLER_2D或GL_SAMPLER_CUBE。</p>
<p>如果数组的一个或多个元素处于活动状态，则在name中返回数组的名称，类型以type返回，并且size参数返回使用的最高数组元素索引加上1，具体由编译器确定和/或链接器。对于统一阵列，仅报告一个活动的统一变量。</p>
<p>声明为结构或结构数组的统一变量不会由此函数直接返回。相反，这些统一变量中的每一个都将被简化为包含“.”和“[]”运算符的基本组成部分，使得每个名称作为glGetUniformLocation的参数有效。</p>
<p>统一变量的大小将以size返回。除数组之外的统一变量将具有1的维度大小。结构和结构数组将如前所述减少，使得返回的每个名称将是先前列表中的数据类型。</p>
<p>活动统一变量列表可以包括内置的统一变量（以前缀“gl_”开头）以及用户定义的统一变量名称。</p>
<p>此函数将返回尽可能多的有关指定的活动统一变量的信息。如果没有可用信息，则length为0，name为空字符串（如果在失败的链接操作后调用此函数，则可能发生这种情况）。如果发生错误，则返回值length，size，type和name将不会被修改。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：program不是OpenGL生成的值。</p>
<p>GL_INVALID_OPERATION：program不是程序对象。</p>
<p>GL_INVALID_VALUE：index&gt;=程序中活动统一变量的数量。</p>
<p>GL_INVALID_VALUE：bufSize&lt;0</p>
<p>相关Gets</p>
<p>glGet 参数GL_MAX_VERTEX_UNIFORM_VECTORS或GL_MAX_FRAGMENT_UNIFORM_VECTORS</p>
<p>glGetProgramiv 参数GL_ACTIVE_UNIFORMS或GL_ACTIVE_UNIFORM_MAX_LENGTH</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glGetActiveAttrib，glGetUniform，glGetUniformLocation，glLinkProgram，glUniform，glUseProgram</p>
<h2 id="glGetAttribLocation-返回属性变量的位置"><a href="#glGetAttribLocation-返回属性变量的位置" class="headerlink" title="glGetAttribLocation - 返回属性变量的位置"></a>glGetAttribLocation - 返回属性变量的位置</h2><p>C规范</p>
<p>GLint glGetAttribLocation（GLuint program,const GLchar *name）;</p>
<p>参数</p>
<p>program</p>
<p>指定要查询的程序对象。</p>
<p>name</p>
<p>要查询其位置的属性变量的名称。</p>
<p>描述</p>
<p>glGetAttribLocation查询由program指定的先前链接的程序对象，用于name指定的属性变量，并返回绑定到该属性变量的通用顶点属性的索引。 如果name是矩阵属性变量，则返回矩阵的第一列的索引。 如果指定的属性变量不是指定程序对象中的活动属性，或者名称以保留前缀“gl_”开头，则返回-1。</p>
<p>可以通过调用glBindAttribLocation随时指定属性变量名和通用属性索引之间的关联。 在调用glLinkProgram之前，属性绑定不会生效。 成功链接程序对象后，属性变量的索引值将保持固定，直到发生下一个链接命令。 如果链接成功，则只能在链接后查询属性值。 glGetAttribLocation返回上次为指定程序对象调用glLinkProgram时实际生效的绑定。 glGetAttribLocation不返回自上次链接操作以来指定的属性绑定。</p>
<p>错误</p>
<p>GL_INVALID_OPERATION ：program不是OpenGL生成的值。</p>
<p>GL_INVALID_OPERATION ：program不是程序对象。</p>
<p>GL_INVALID_OPERATION ：program没有成功链接。</p>
<p>相关Gets</p>
<p>glGetActiveAttrib 参数program和活动的属性索引。</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glBindAttribLocation，glLinkProgram，glVertexAttrib，glVertexAttribPointer</p>
<h2 id="glGetBufferParameteriv-返回缓冲区对象的参数"><a href="#glGetBufferParameteriv-返回缓冲区对象的参数" class="headerlink" title="glGetBufferParameteriv - 返回缓冲区对象的参数"></a>glGetBufferParameteriv - 返回缓冲区对象的参数</h2><p>C规范</p>
<p>void glGetBufferParameteriv(    GLenum target,<br>     GLenum value,<br>     GLint * data);</p>
<p>参数</p>
<p>target</p>
<p>指定目标缓冲区对象。符号常量必须为GL_ARRAY_BUFFER或GL_ELEMENT_ARRAY_BUFFER。</p>
<p>value</p>
<p>指定缓冲区对象参数的符号名称。可接受的值为GL_BUFFER_SIZE或GL_BUFFER_USAGE。</p>
<p>data</p>
<p>返回请求的参数。</p>
<p>描述</p>
<p>glGetBufferParameteriv在数据中返回target指定的缓冲区对象的选定参数。value命名一个特定的缓冲区对象参数，如下所示：</p>
<p>GL_BUFFER_SIZE</p>
<p>data返回缓冲区对象的大小，以字节为单位。初始值为0。</p>
<p>GL_BUFFER_USAGE</p>
<p>data返回缓冲区对象的使用模式。初始值为GL_STATIC_DRAW。</p>
<p>注意</p>
<p>如果生成错误，则不会更改数据内容。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：target或value不是可接受的值。</p>
<p>GL_INVALID_OPERATION：保留的缓冲区对象名称0绑定到target。</p>
<p>另见</p>
<p>glBindBuffer，glBufferData</p>
<h2 id="glGetError-返回错误信息"><a href="#glGetError-返回错误信息" class="headerlink" title="glGetError- 返回错误信息"></a>glGetError- 返回错误信息</h2><p>C规范</p>
<p>GLenum glGetError(void);</p>
<p>描述</p>
<pre><code>glGetError返回错误标志的值。每个可检测的错误都分配有数字代码和符号名称。发生错误时，错误标志将设置为相应的错误代码值。在调用glGetError（返回错误代码）之前，不会记录其他错误，并将标志重置为GL_NO_ERROR。如果对glGetError的调用返回GL_NO_ERROR，则自上次调用glGetError或自GL初始化以来，没有可检测到的错误。

为了允许分布式实现，可能存在多个错误标志。如果任何单个错误标志记录了错误，则返回该标志的值，并在调用glGetError时将该标志重置为GL_NO_ERROR。如果多个标志记录了错误，glGetError将返回并清除任意错误标志值。因此，如果要重置所有错误标志，则应始终在循环中调用glGetError，直到它返回GL_NO_ERROR。

初始情况下，所有错误标志都设置为GL_NO_ERROR。
</code></pre>
<p>目前定义了以下错误：</p>
<p>GL_NO_ERROR (0)</p>
<pre><code>没有记录错误。 此符号常量的值保证为0。
</code></pre>
<p>GL_INVALID_ENUM    (1280)</p>
<pre><code>为枚举参数指定了不可接受的值。 违规命令被忽略，除了设置错误标志之外没有其他副作用。
</code></pre>
<p>GL_INVALID_VALUE    (1281)</p>
<pre><code>数字参数超出范围。 违规命令被忽略，除了设置错误标志之外没有其他副作用。
</code></pre>
<p>GL_INVALID_OPERATION    (1282)</p>
<pre><code>当前状态下不允许指定的操作。 违规命令被忽略，除了设置错误标志之外没有其他副作用。
</code></pre>
<p>GL_INVALID_FRAMEBUFFER_OPERATION    (1286)</p>
<pre><code>该命令试图渲染到帧缓冲区或从帧缓冲区读取，而当前绑定的帧缓冲区不是帧缓冲区完成状态（即glCheckFramebufferStatus的返回值不是GL_FRAMEBUFFER_COMPLETE）。 违规命令被忽略，除了设置错误标志之外没有其他副作用。
</code></pre>
<p>GL_OUT_OF_MEMORY    (1285)</p>
<pre><code>没有足够的内存来执行命令。 在记录此错误之后，GL的状态是未定义的，除了错误标志的状态。
</code></pre>
<p>设置错误标志时，仅当GL_OUT_OF_MEMORY发生时，GL操作的结果才是未定义的。 在所有其他情况下，生成错误的命令将被忽略，并且不会影响GL状态或帧缓冲区内容。 如果generate命令返回一个值，则返回0。</p>
<p>另见</p>
<p>glCheckFramebufferStatus</p>
<h2 id="glGetFramebufferAttachmentParameteriv-返回帧缓冲对象的附件参数"><a href="#glGetFramebufferAttachmentParameteriv-返回帧缓冲对象的附件参数" class="headerlink" title="glGetFramebufferAttachmentParameteriv - 返回帧缓冲对象的附件参数"></a>glGetFramebufferAttachmentParameteriv - 返回帧缓冲对象的附件参数</h2><p>C规范</p>
<p>void glGetFramebufferAttachmentParameteriv(    GLenum target,<br>     GLenum attachment,<br>     GLenum pname,<br>     GLint * params);</p>
<p>参数</p>
<p>target</p>
<p>指定目标帧缓冲区对象。符号常量必须是GL_FRAMEBUFFER。</p>
<p>attachment</p>
<p>指定帧缓冲区对象附加点的符号名称。可接受的值为GL_COLOR_ATTACHMENT0，GL_DEPTH_ATTACHMENT和GL_STENCIL_ATTACHMENT。</p>
<p>pname</p>
<p>指定帧缓冲区对象附件参数的符号名称。可接受的值为GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE，GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME，GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL和GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE。</p>
<p>params</p>
<p>返回请求的参数。</p>
<p>描述</p>
<p>glGetFramebufferAttachmentParameteriv以params形式返回当前绑定的framebuffer对象的附着点的选定附件参数。pname命名一个特定的framebuffer对象附件参数，如下所示：</p>
<p>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</p>
<p>params返回包含附加图像的对象类型，GL_RENDERBUFFER，GL_TEXTURE，或者如果没有附加图像，则返回GL_NONE。初始值为GL_NONE。</p>
<p>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</p>
<p>如果GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE的值为GL_RENDERBUFFER，则params返回包含附加图像的renderbuffer对象的名称。如果GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE的值为GL_TEXTURE，则params返回包含附加图像的纹理对象的名称。初始值为零。</p>
<p>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</p>
<p>如果GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE的值为GL_TEXTURE，则params返回包含附加图像的纹理对象的mipmap级别。初始值为零。</p>
<p>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</p>
<p>如果GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE的值为GL_TEXTURE且GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME是立方体贴图纹理的名称，则params返回包含附加图像的立方体贴图纹理对象的立方体贴图面。如果附加图像来自纹理对象但不是立方体贴图，则params返回0.初始值为GL_TEXTURE_CUBE_MAP_POSITIVE_X。</p>
<p>注意</p>
<p>如果生成错误，则不会更改params的内容。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：target不是GL_FRAMEBUFFER。</p>
<p>GL_INVALID_ENUM：attachment不是GL_COLOR_ATTACHMENT0，GL_DEPTH_ATTACHMENT或GL_STENCIL_ATTACHMENT。</p>
<p>GL_INVALID_ENUM：指定附着点处的附加对象为GL_RENDERBUFFER但pname不是GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE或GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME。</p>
<p>GL_INVALID_ENUM：指定附着点处的附加对象是GL_TEXTURE但pname不是GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE，GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME，GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL或GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE。</p>
<p>GL_INVALID_ENUM：命名附加点上没有附加对象但pname不是GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE。</p>
<p>GL_INVALID_OPERATION：绑定了默认帧缓冲区对象名称0。</p>
<p>另见</p>
<p>glBindFramebuffer，glFramebufferRenderbuffer，glFramebufferTexture2D</p>
<h2 id="glGetProgramInfoLog-返回program对象的信息日志"><a href="#glGetProgramInfoLog-返回program对象的信息日志" class="headerlink" title="glGetProgramInfoLog- 返回program对象的信息日志"></a>glGetProgramInfoLog- 返回program对象的信息日志</h2><p>C规范</p>
<p>void glGetProgramInfoLog（GLuint program，GLsizei maxLength，GLsizei *length，GLchar *infoLog）;</p>
<p>参数</p>
<p>program</p>
<pre><code>指定要查询其信息日志的程序对象。
</code></pre>
<p>maxLength</p>
<pre><code>指定用于存储返回的信息日志的字符缓冲区的大小。
</code></pre>
<p>length</p>
<pre><code>返回infoLog中返回的字符串的长度（不包括空终止符）。
</code></pre>
<p>infoLog</p>
<pre><code>指定用于返回信息日志的字符数组。
</code></pre>
<p>描述</p>
<p>glGetProgramInfoLog返回指定程序对象的信息日志。 在链接或验证程序对象时，将修改程序对象的信息日志。 返回的字符串将以空结尾。</p>
<p>glGetProgramInfoLog尽可能多地在infoLog中返回信息日志，最多可返回maxLength个字符。实际返回的字符数（不包括空终止字符）由length指定。 如果不需要返回字符串的长度，则可以在length参数中传递NULL值。 可以通过调用值为GL_INFO_LOG_LENGTH的glGetProgramiv来获取存储返回的信息日志所需的缓冲区大小。</p>
<p>程序对象的信息日志是一个字符串，其中可能包含诊断信息，警告信息以及有关上次编译操作的其他信息。 创建程序对象时，其信息日志将为长度为0的字符串。</p>
<p>注意</p>
<pre><code>程序对象的信息日志是OpenGL实现者用于传达有关链接或验证程序的信息的主要机制。 因此，即使链接或验证成功，信息日志也可以在开发过程中对应用程序开发人员有所帮助。 应用程序开发人员不应期望不同的OpenGL实现生成相同的信息日志。
</code></pre>
<p>错误</p>
<p>GL_INVALID_VALUE：program不是OpenGL生成的值。</p>
<p>GL_INVALID_OPERATION：program不是程序对象。</p>
<p>GL_INVALID_VALUE：maxLength小于0</p>
<p>相关Gets</p>
<p>glGetProgramiv参数GL_INFO_LOG_LENGTH获取信息日志的长度</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glCompileShader，glGetShaderInfoLog，glLinkProgram，glValidateProgram</p>
<p>版权</p>
<h2 id="glGetProgramiv-从program对象返回一个参数的值"><a href="#glGetProgramiv-从program对象返回一个参数的值" class="headerlink" title="glGetProgramiv- 从program对象返回一个参数的值"></a>glGetProgramiv- 从program对象返回一个参数的值</h2><p>C规范</p>
<p>void glGetProgramiv（GLuint program,GLenum pname,GLint *params）;</p>
<p>参数</p>
<p>program</p>
<p>指定要查询的program对象。</p>
<p>pname</p>
<p>指定program对象参数。 接受的符号名称为GL_DELETE_STATUS，GL_LINK_STATUS，GL_VALIDATE_STATUS，GL_INFO_LOG_LENGTH，GL_ATTACHED_SHADERS，GL_ACTIVE_ATTRIBUTES，GL_ACTIVE_UNIFORMS，GL_ACTIVE_ATTRIBUTE_MAX_LENGTH，GL_ACTIVE_UNIFORM_MAX_LENGTH。</p>
<p>params</p>
<p>返回请求的对象参数的值。</p>
<p>描述</p>
<p>glGetProgramiv以params形式返回指定的program对象的参数值。 定义了以下参数：</p>
<p>GL_DELETE_STATUS</p>
<p>如果program当前标记为删除，则params返回GL_TRUE，否则返回GL_FALSE。</p>
<p>GL_LINK_STATUS</p>
<p>如果program的最后一个链接操作成功，则params返回GL_TRUE，否则返回GL_FALSE。</p>
<p>GL_VALIDATE_STATUS</p>
<p>params返回GL_TRUE，program的最后一次验证操作成功了也返回GL_TRUE，否则返回GL_FALSE。</p>
<p>GL_INFO_LOG_LENGTH</p>
<p>params返回program信息日志中的字符数，包括空终止字符（即，存储信息日志所需的字符缓冲区的大小）。 如果程序没有信息日志，则返回值0。</p>
<p>GL_ATTACHED_SHADERS</p>
<p>params返回附加到program的着色器对象的数量。</p>
<p>GL_ACTIVE_ATTRIBUTES</p>
<p>params返回program的激活状态的属性变量数。</p>
<p>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</p>
<p>params返回program的最长激活状态的属性名称的长度，包括空终止字符（即，存储最长属性名称所需的字符缓冲区的大小）。 如果不存在活动属性，则返回0。</p>
<p>GL_ACTIVE_UNIFORMS</p>
<p>params返回program的激活状态的统一变量的数量。</p>
<p>GL_ACTIVE_UNIFORM_MAX_LENGTH</p>
<p>params返回program的最长激活状态的统一变量名称的长度，包括空终止字符（即，存储最长统一变量名称所需的字符缓冲区的大小）。 如果不存在活动的统一变量，则返回0。</p>
<p>注意</p>
<p>如果生成错误，则不会更改params的内容。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：pname不是一个可接受的值</p>
<p>GL_INVALID_VALUE ：program不是OpenGL生成的值</p>
<p>GL_INVALID_OPERATION： program没有关联program对象</p>
<p>相关Gets</p>
<p>glGetActiveAttrib 参数：program</p>
<p>glGetActiveUniform 参数：program</p>
<p>glGetAttachedShaders 参数：program</p>
<p>glGetProgramInfoLog 参数：program</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glAttachShader, glCreateProgram, glDeleteProgram, glGetShaderiv, glLinkProgram, glValidateProgram</p>
<h2 id="glGetRenderbufferParameteriv-返回renderbuffer对象的参数"><a href="#glGetRenderbufferParameteriv-返回renderbuffer对象的参数" class="headerlink" title="glGetRenderbufferParameteriv - 返回renderbuffer对象的参数"></a>glGetRenderbufferParameteriv - 返回renderbuffer对象的参数</h2><p>C规范</p>
<p>void glGetRenderbufferParameteriv(    GLenum target,<br>     GLenum pname,<br>     GLint * params);</p>
<p>参数</p>
<p>target</p>
<p>指定目标renderbuffer对象。符号常量必须为GL_RENDERBUFFER。</p>
<p>pname</p>
<p>指定renderbuffer对象参数的符号名称。可接受的值是GL_RENDERBUFFER_WIDTH，GL_RENDERBUFFER_HEIGHT，GL_RENDERBUFFER_INTERNAL_FORMAT，GL_RENDERBUFFER_RED_SIZE，GL_RENDERBUFFER_GREEN_SIZE，GL_RENDERBUFFER_BLUE_SIZE，GL_RENDERBUFFER_ALPHA_SIZE，GL_RENDERBUFFER_DEPTH_SIZE，或GL_RENDERBUFFER_STENCIL_SIZE。</p>
<p>params</p>
<p>返回请求的参数。</p>
<p>描述</p>
<p>glGetRenderbufferParameteriv以params形式返回当前绑定的renderbuffer对象的选定参数。pname命名一个特定的renderbuffer对象参数，如下所示：</p>
<p>GL_RENDERBUFFER_WIDTH</p>
<p>params返回当前绑定的渲染缓冲区图像的宽度（以像素为单位）。初始值为0。</p>
<p>GL_RENDERBUFFER_HEIGHT</p>
<p>params返回当前绑定的渲染缓冲区图像的高度（以像素为单位）。初始值为0。</p>
<p>GL_RENDERBUFFER_INTERNAL_FORMAT</p>
<p>params返回当前绑定的renderbuffer图像的内部格式。初始值为GL_RGBA4。</p>
<p>GL_RENDERBUFFER_RED_SIZE</p>
<p>params返回当前绑定的渲染缓冲区图像的红色分量的分辨率。初始值为0。</p>
<p>GL_RENDERBUFFER_GREEN_SIZE</p>
<p>params返回当前绑定的渲染缓冲区图像的绿色分量的分辨率。初始值为0。</p>
<p>GL_RENDERBUFFER_BLUE_SIZE</p>
<p>params返回当前绑定的渲染缓冲区图像的蓝色分量的分辨率。初始值为0。</p>
<p>GL_RENDERBUFFER_ALPHA_SIZE</p>
<p>params返回当前绑定的渲染缓冲区图像的alpha分量的分辨率。初始值为0。</p>
<p>GL_RENDERBUFFER_DEPTH_SIZE</p>
<p>params返回当前绑定的渲染缓冲区图像的深度分量的分辨率。初始值为0。</p>
<p>GL_RENDERBUFFER_STENCIL_SIZE</p>
<p>params返回当前绑定的渲染缓冲区图像的模板组件的分辨率。初始值为0。</p>
<p>注意</p>
<p>glGetRenderbufferParameteriv报告的组件分辨率是组件存储的实际分辨率，可能与glRenderbufferStorage的internalformat参数请求的分辨率不同。</p>
<p>如果生成错误，则不会更改params的内容。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：目标不是GL_RENDERBUFFER。</p>
<p>GL_INVALID_ENUM：pname不上述值之一。</p>
<p>GL_INVALID_OPERATION：绑定了保留的renderbuffer对象名称0。</p>
<p>另见</p>
<p>glBindRenderbuffer，glRenderbufferStorage</p>
<h2 id="glGetShaderInfoLog-返回着色器对象的信息日志"><a href="#glGetShaderInfoLog-返回着色器对象的信息日志" class="headerlink" title="glGetShaderInfoLog - 返回着色器对象的信息日志"></a>glGetShaderInfoLog - 返回着色器对象的信息日志</h2><p>C规范</p>
<p>void glGetShaderInfoLog（GLuint shader,GLsizei maxLength,GLsizei *length,GLchar *infoLog）;</p>
<p>参数</p>
<p>shader</p>
<pre><code>指定要查询其信息日志的着色器对象。
</code></pre>
<p>maxLength</p>
<pre><code>指定用于存储返回的信息日志的字符缓冲区的大小。
</code></pre>
<p>length</p>
<pre><code>返回infoLog中返回的字符串的长度（不包括空终止符）。
</code></pre>
<p>infoLog</p>
<pre><code>指定用于返回信息日志的字符数组。
</code></pre>
<p>描述</p>
<pre><code>glGetShaderInfoLog返回指定着色器对象的信息日志。 编译着色器时，将修改着色器对象的信息日志。 返回的字符串将以空结尾。

glGetShaderInfoLog尽可能多地在infoLog中返回信息日志，最多可返回maxLength个字符。实际返回的字符数（不包括空终止字符）由length指定。 如果不需要返回字符串的长度，则可以在length参数中传递NULL值。 可以通过调用值为GL_INFO_LOG_LENGTH的glGetShaderiv来获取存储返回的信息日志所需的缓冲区大小。

着色器对象的信息日志是一个字符串，其中可能包含诊断信息，警告信息以及有关上次编译操作的其他信息。 创建着色器对象时，其信息日志将为长度为0的字符串。
</code></pre>
<p>注意</p>
<pre><code>着色器对象的信息日志是OpenGL实现者用于传达有关编译过程的信息的主要机制。 因此，即使编译成功，信息日志也可以在开发过程中对应用程序开发人员有所帮助。 应用程序开发人员不应期望不同的OpenGL实现生成相同的信息日志。
</code></pre>
<p>错误</p>
<p>GL_INVALID_VALUE：shader不是OpenGL生成的值。</p>
<p>GL_INVALID_OPERATION：shader不是着色器对象。</p>
<p>GL_INVALID_VALUE：maxLength小于0</p>
<p>相关Gets</p>
<p>glGetShaderiv 参数GL_INFO_LOG_LENGTH获取信息日志的长度</p>
<p>glIsShader</p>
<p>另见</p>
<p>glCompileShader，glGetProgramInfoLog，glLinkProgram，glValidateProgram</p>
<h2 id="glGetShaderPrecisionFormat-返回不同着色器数字格式的范围和精度"><a href="#glGetShaderPrecisionFormat-返回不同着色器数字格式的范围和精度" class="headerlink" title="glGetShaderPrecisionFormat - 返回不同着色器数字格式的范围和精度"></a>glGetShaderPrecisionFormat - 返回不同着色器数字格式的范围和精度</h2><p>C规范</p>
<p>void glGetShaderPrecisionFormat(    GLenum shaderType,<br>     GLenum precisionType,<br>     GLint *range,<br>     GLint *precision);</p>
<p>参数</p>
<p>shaderType</p>
<p>指定要查询的着色器的类型。必须是GL_VERTEX_SHADER或GL_FRAGMENT_SHADER。</p>
<p>precisionType</p>
<p>指定要查询的数字格式，对应于着色器精度限定符和变量类型。必须是GL_LOW_FLOAT，GL_MEDIUM_FLOAT，GL_HIGH_FLOAT，GL_LOW_INT，GL_MEDIUM_INT或GL_HIGH_INT中的一个。</p>
<p>range</p>
<p>指定指向两元素数组的指针，其中返回log以2为底格式的最小和最大为对数的值。</p>
<p>precision</p>
<p>指定指向返回格式精度的log 2的位置的指针。</p>
<p>描述</p>
<p>glGetShaderPrecisionFormat返回具有低，中和高精度限定符的浮点和整数着色器变量格式的范围和精度限制。当minRep和maxRep是格式的最小和最大可表示值时，floor = log2⁡minRep和floor⁡=log2⁡maxRep分别作为第一个和第二个元素返回range。</p>
<p>如果大于1的最小可表示值是1 +ε，则以精度返回floor⁡ -  log2⁡ε。整数格式的ε为1，因此将返回0.浮点格式将返回大于0的值。</p>
<p>注意</p>
<p>OpenGL ES着色语言规范中描述了不同格式所需的最小范围和精度。</p>
<p>如果片段着色器不支持高精度浮点格式，则使用参数GL_FRAGMENT_SHADER和GL_HIGH_FLOAT调用glGetShaderPrecisionFormat将为range和precision返回0。对于顶点着色器，必须支持高精度浮点格式。</p>
<p>着色器编译器支持是可选的，因此必须在使用之前通过使用参数GL_SHADER_COMPILER调用glGet来查询。 glShaderSource，glCompileShader，glGetShaderPrecisionFormat和glReleaseShaderCompiler将在不支持着色器编译器的实现上生成GL_INVALID_OPERATION。这样的实现提供了glShaderBinary替代方案，用于提供预编译的着色器二进制文件。</p>
<p>如果生成错误，则不会更改range或precision的内容。</p>
<p>错误</p>
<p>GL_INVALID_OPERATION：不支持着色器编译器。</p>
<p>GL_INVALID_ENUM：shaderType或precisionType不是可接受的值。</p>
<p>相关Gets</p>
<p>glGet 参数GL_SHADER_COMPILER</p>
<p>另见</p>
<p>glCompileShader，glShaderSource</p>
<h2 id="glGetShaderSource-从着色器对象返回源代码字符串"><a href="#glGetShaderSource-从着色器对象返回源代码字符串" class="headerlink" title="glGetShaderSource - 从着色器对象返回源代码字符串"></a>glGetShaderSource - 从着色器对象返回源代码字符串</h2><p>C规范</p>
<p>void glGetShaderSource(    GLuint shader,<br>     GLsizei bufSize,<br>     GLsizei *length,<br>     GLchar *source);</p>
<p>参数</p>
<p>shader</p>
<p>指定要查询的着色器对象。</p>
<p>bufSize</p>
<p>指定用于存储返回的源代码字符串的字符缓冲区的大小。</p>
<p>length</p>
<p>返回source中返回的字符串的长度（不包括null终止符）。</p>
<p>source</p>
<p>指定用于返回源代码字符串的字符数组。</p>
<p>描述</p>
<p>glGetShaderSource返回由着色器指定的着色器对象的源代码字符串的串联。着色器对象的源代码字符串是先前调用glShaderSource的结果。函数返回的字符串将以null结尾。</p>
<p>glGetShaderSource尽可能多地在源代码中返回源代码字符串，最多可返回bufSize字符。实际返回的字符数（不包括空终止字符）由length指定。如果不需要返回字符串的长度，则可以在length参数中传递NULL值。可以通过调用值为GL_SHADER_SOURCE_LENGTH的glGetShaderiv来获取存储返回的源代码字符串所需的缓冲区大小。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：shader不是OpenGL生成的值。</p>
<p>GL_INVALID_OPERATION：shader不是着色器对象。</p>
<p>GL_INVALID_VALUE：bufSize小于0。</p>
<p>相关Gets</p>
<p>glGetShaderiv 参数GL_SHADER_SOURCE_LENGTH</p>
<p>glIsShader</p>
<p>另见</p>
<p>glCreateShader，glShaderSource</p>
<h2 id="glGetShaderiv-从着色器对象返回一个参数"><a href="#glGetShaderiv-从着色器对象返回一个参数" class="headerlink" title="glGetShaderiv - 从着色器对象返回一个参数"></a>glGetShaderiv - 从着色器对象返回一个参数</h2><p>C规范</p>
<p>void glGetShaderiv（GLuint shader,GLenum pname,GLint *params）;</p>
<p>参数</p>
<p>shader</p>
<pre><code>指定要查询的着色器对象。
</code></pre>
<p>pname</p>
<p>  指定着色器对象的参数。 可接受的符号名称为GL_SHADER_TYPE，GL_DELETE_STATUS，GL_COMPILE_STATUS，GL_INFO_LOG_LENGTH，GL_SHADER_SOURCE_LENGTH。</p>
<p>params</p>
<pre><code>返回请求的参数结果值。
</code></pre>
<p>描述</p>
<pre><code>glGetShaderiv以params形式返回特定着色器对象的参数值。 定义了以下参数：
</code></pre>
<p>GL_SHADER_TYPE</p>
<pre><code>如果着色器是顶点着色器对象，则params返回GL_VERTEX_SHADER;如果着色器是片段着色器对象，则                                  返回GL_FRAGMENT_SHADER。
</code></pre>
<p>GL_DELETE_STATUS</p>
<pre><code>如果shader当前被标记为删除，则params返回GL_TRUE，否则返回GL_FALSE。
</code></pre>
<p>GL_COMPILE_STATUS</p>
<pre><code>对于支持着色器编译器的实现，如果着色器上的最后一次编译操作成功，则params返回GL_TRUE，否则返回GL_FALSE。
</code></pre>
<p>GL_INFO_LOG_LENGTH</p>
<pre><code>对于支持着色器编译器的实现，params返回着色器信息日志的字符数，包括空终止字符（即，存储信息日志所需的字符缓冲区的大小）。 如果着色器没有信息日志，则返回值0。
</code></pre>
<p>GL_SHADER_SOURCE_LENGTH</p>
<pre><code>对于支持着色器编译器的实现，params返回构成着色器着色器源的源字符串的串联长度，包括空终止字符。 （即，存储着色器源所需的字符缓冲区的大小）。 如果不存在源代码，则返回0。
</code></pre>
<p>注意</p>
<pre><code>着色器编译器支持是可选的，因此必须在使用之前通过使用参数GL_SHADER_COMPILER调用glGet来查询。glShaderSource，glCompileShader，glGetShaderPrecisionFormat，glReleaseShaderCompiler等在不支持着色器编译器的实现上都将生成GL_INVALID_OPERATION。用glGetShaderiv去查询GL_COMPILE_STATUS，GL_INFO_LOG_LENGTH和GL_SHADER_SOURCE_LENGTH也会是返回GL_INVALID_OPERATION。这样的实现提供了glShaderBinary替代方案，用于提供预编译的着色器二进制文件。
</code></pre>
<p>如果生成错误，则不会更改params的内容。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：pname不是一个可接受的值。</p>
<p>GL_INVALID_VALUE：shader不是OpenGL生成的值。</p>
<p>GL_INVALID_OPERATION：不支持着色器编译器的情况下查询pname为GL_COMPILE_STATUS，GL_INFO_LOG_LENGTH或GL_SHADER_SOURCE_LENGTH（GL_SHADER_TYPE，GL_DELETE_STATUS不会报这个错）。</p>
<p>GL_INVALID_OPERATION：shader没有关联着色器对象。</p>
<p>相关Gets</p>
<p>glGet 参数GL_SHADER_COMPILER</p>
<p>glGetShaderInfoLog 参数shader</p>
<p>glGetShaderSource 参数shader</p>
<p>glIsShader</p>
<p>另见</p>
<p>glCompileShader，glCreateShader，glDeleteShader，glGetProgramiv，glShaderSource，glShaderBinary</p>
<p>版权</p>
<h2 id="glGetString-返回描述当前GL连接的字符串"><a href="#glGetString-返回描述当前GL连接的字符串" class="headerlink" title="glGetString- 返回描述当前GL连接的字符串"></a>glGetString- 返回描述当前GL连接的字符串</h2><p>C规范</p>
<p>const GLubyte* glGetString（GLenum name);</p>
<p>参数</p>
<p>name</p>
<pre><code>指定符号常量，GL_VENDOR，GL_RENDERER，GL_VERSION，GL_SHADING_LANGUAGE_VERSION或GL_EXTENSIONS之一。
</code></pre>
<p>描述</p>
<p>glGetString返回一个指向静态字符串的指针，该字符串描述当前GL连接的某些方面。 name可以是以下之一：</p>
<p>GL_VENDOR</p>
<pre><code>返回负责此GL实施的公司。 此名称在发行版之间不会发生变化。
</code></pre>
<p>GL_RENDERER</p>
<pre><code>返回渲染器的名称。 此名称通常特定于硬件平台的特定配置。 它不会在发行版之间发生变化。
</code></pre>
<p>GL_VERSION</p>
<pre><code>返回版本号
</code></pre>
<p>GL_SHADING_LANGUAGE_VERSION</p>
<pre><code>返回着色语言的版本号或发行版号。
</code></pre>
<p>GL_EXTENSIONS</p>
<pre><code>返回GL支持的空格分隔的扩展列表。
</code></pre>
<p>由于GL不包含对实现的性能特征的查询，因此编写一些应用程序以识别已知平台并基于这些平台的已知性能特征修改其GL使用。 字符串GL_VENDOR和GL_RENDERER一起唯一地指定平台。 它们不会在发行版之间发生变化，可以作为平台识别的算法使用。</p>
<p>某些应用程序希望使用不属于标准GL的功能。 这些特征可以实现为标准GL的扩展。 GL_EXTENSIONS字符串是一个以空格分隔的受支持的GL扩展列表。 （扩展名不包含空格字符。）</p>
<p>所有字符串都以空值终止。</p>
<p>注意</p>
<p>如果生成错误，glGetString将会返回0。</p>
<p>客户端和服务器可能支持不同的版本或扩展。 glGetString始终返回兼容的版本号或扩展列表。 版本号始终描述的是服务器。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果name不是上述值。</p>
<h2 id="glGetTexParameter-返回纹理参数值"><a href="#glGetTexParameter-返回纹理参数值" class="headerlink" title="glGetTexParameter - 返回纹理参数值"></a>glGetTexParameter - 返回纹理参数值</h2><p>C规范</p>
<p>void glGetTexParameterfv(    GLenum target,<br>     GLenum pname,<br>     GLfloat * params);<br>void glGetTexParameteriv(    GLenum target,<br>     GLenum pname,<br>     GLint * params);</p>
<p>参数</p>
<p>target</p>
<p>指定活动纹理单元的目标纹理的符号名称。 GL_TEXTURE_2D和GL_TEXTURE_CUBE_MAP被接受。</p>
<p>pname</p>
<p>指定纹理参数的符号名称。接受GL_TEXTURE_MAG_FILTER，GL_TEXTURE_MIN_FILTER，GL_TEXTURE_WRAP_S和GL_TEXTURE_WRAP_T。</p>
<p>params</p>
<p>返回纹理参数。</p>
<p>描述</p>
<p>glGetTexParameter以params形式返回指定为pname的纹理参数的值。 target定义活动纹理单元的目标纹理（GL_TEXTURE_2D或GL_TEXTURE_CUBE_MAP），以指定二维或多维数据集映射纹理。 pname接受与glTexParameter相同的符号，具有相同的解释：</p>
<p>GL_TEXTURE_MAG_FILTER</p>
<p>返回单值纹理放大过滤器，一个符号常量。初始值为GL_LINEAR。</p>
<p>GL_TEXTURE_MIN_FILTER</p>
<p>返回单值纹理缩小过滤器，一个符号常量。初始值为GL_NEAREST_MIPMAP_LINEAR。</p>
<p>GL_TEXTURE_WRAP_S</p>
<p>返回纹理坐标s的单值包装函数，即符号常量。初始值为GL_REPEAT。</p>
<p>GL_TEXTURE_WRAP_T</p>
<p>返回纹理坐标t的单值包装函数，即符号常量。初始值为GL_REPEAT。</p>
<p>注意</p>
<p>如果生成错误，则不会更改params的内容。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：target或pname不是可接受的值。</p>
<p>另见</p>
<p>glTexParameter</p>
<h2 id="glGetUniform-返回统一变量的值"><a href="#glGetUniform-返回统一变量的值" class="headerlink" title="glGetUniform - 返回统一变量的值"></a>glGetUniform - 返回统一变量的值</h2><p>C规范</p>
<p>void glGetUniformfv(    GLuint program,<br>     GLint location,<br>     GLfloat *params);</p>
<p>void glGetUniformiv(    GLuint program,<br>     GLint location,<br>     GLint *params);</p>
<p>参数</p>
<p>program</p>
<p>指定要查询的程序对象。</p>
<p>location</p>
<p>指定要查询的统一变量的位置。</p>
<p>params</p>
<p>返回指定的统一变量的值。</p>
<p>描述</p>
<p>glGetUniform以params形式返回指定统一变量的值。由location指定的统一变量的类型确定返回的值的数量。如果将着色器变量在着色器中定义为boolean，int或float，则将返回单个值。如果将其定义为vec2，ivec2或bvec2，则将返回两个值。如果将其定义为vec3，ivec3或bvec3，则将返回三个值，依此类推。要查询存储在声明为数组的统一变量中的值，请为数组的每个元素调用glGetUniform。要查询存储在声明为结构的统一变量中的值，请为结构中的每个字段调用glGetUniform。声明为矩阵的统一变量的值将按列主要顺序返回。</p>
<p>在程序对象链接之前，不知道分配给统一变量的位置。发生链接后，命令glGetUniformLocation可用于获取统一变量的位置。然后可以将此位置值传递给glGetUniform，以查询统一变量的当前值。成功链接程序对象后，统一变量的索引值保持不变，直到发生下一个链接命令。如果链接成功，则只能在链接后查询统一变量值。</p>
<p>注意</p>
<p>如果生成错误，则不会更改params的内容。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：program不是OpenGL生成的值。</p>
<p>GL_INVALID_OPERATION：program不是程序对象。</p>
<p>GL_INVALID_OPERATION：程序尚未成功链接。</p>
<p>GL_INVALID_OPERATION：location不对应于指定程序对象的有效统一变量位置。</p>
<p>相关Gets</p>
<p>glGetActiveUniform 参数program和活动统一变量的索引。</p>
<p>glGetProgramiv 参数GL_ACTIVE_UNIFORMS或GL_ACTIVE_UNIFORM_MAX_LENGTH。</p>
<p>glGetUniformLocation 参数program和统一变量的名称。</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glCreateProgram，glLinkProgram，glUniform</p>
<h2 id="glGetUniformLocation-返回统一变量的位置"><a href="#glGetUniformLocation-返回统一变量的位置" class="headerlink" title="glGetUniformLocation- 返回统一变量的位置"></a>glGetUniformLocation- 返回统一变量的位置</h2><p>C规范</p>
<p>GLint glGetUniformLocation（GLuint program,const GLchar *name）;</p>
<p>参数</p>
<p>program</p>
<p>指定要查询的程序对象。</p>
<p>name</p>
<p>要查询其位置的统一变量的名称。</p>
<p>描述</p>
<p>glGetUniformLocation返回一个整数，表示程序对象中特定统一变量的位置。 name必须是不包含空格的空终止字符串。 name必须是程序中的活动统一变量名，它不能是结构，也不能是结构数组或向量或矩阵的子组件。 如果name与程序中的活动统一变量不对应，或者name以保留前缀“gl_”开头，则此函数返回-1。</p>
<p>可以通过为结构中的每个字段调用glGetUniformLocation来查询作为结构或结构数组的统一变量。 数组元素运算符“[]”和结构字段运算符“.” 可以在name中使用，以便选择数组中的元素或结构中的字段。 使用这些运算符的结果不允许是另一个结构，结构数组或向量或矩阵的子组件。 除非name的最后一部分表示统一变量数组，否则可以使用数组的名称或使用“[0]”附加的名称来检索数组的第一个元素的位置。</p>
<p>在程序对象成功链接之前，分配给统一变量的实际位置是不知道的。发生链接后，命令glGetUniformLocation可用于获取统一变量的位置。 然后可以将此位置值传递给glUniform以设置统一变量的值或glGetUniform以查询统一变量的当前值。成功链接程序对象后，统一变量的索引值保持不变，直到发生下一个链接命令。 如果链接成功，则只能在链接后查询统一变量位置和值。</p>
<p>错误</p>
<p>GL_INVALID_VALUE ：program不是OpenGL生成的值。</p>
<p>GL_INVALID_OPERATION ：program不是程序对象。</p>
<p>GL_INVALID_OPERATION ：program没有成功链接。</p>
<p>相关Gets</p>
<p>glGetActiveUniform 参数program和活动的统一变量索引。</p>
<p>glGetProgramiv 参数program和GL_ACTIVE_UNIFORMS 或 GL_ACTIVE_UNIFORM_MAX_LENGTH</p>
<p>glGetUniform 参数program和统一变量的名称</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glLinkProgram，glUniform</p>
<h2 id="glGetVertexAttrib-返回通用顶点属性参数"><a href="#glGetVertexAttrib-返回通用顶点属性参数" class="headerlink" title="glGetVertexAttrib - 返回通用顶点属性参数"></a>glGetVertexAttrib - 返回通用顶点属性参数</h2><p>C规范</p>
<p>void glGetVertexAttribfv(    GLuint index,<br>     GLenum pname,<br>     GLfloat *params);<br>void glGetVertexAttribiv(    GLuint index,<br>     GLenum pname,<br>     GLint *params);</p>
<p>参数</p>
<p>index</p>
<p>指定要查询的通用顶点属性参数。</p>
<p>pname</p>
<p>指定要查询的顶点属性参数的符号名称。可接受的值为GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING，GL_VERTEX_ATTRIB_ARRAY_ENABLED，GL_VERTEX_ATTRIB_ARRAY_SIZE，GL_VERTEX_ATTRIB_ARRAY_STRIDE，GL_VERTEX_ATTRIB_ARRAY_TYPE，GL_VERTEX_ATTRIB_ARRAY_NORMALIZED或GL_CURRENT_VERTEX_ATTRIB。</p>
<p>params</p>
<p>返回请求的数据。</p>
<p>描述</p>
<p>glGetVertexAttrib以params形式返回通用顶点属性参数的值。要查询的通用顶点属性由index指定，要查询的参数由pname指定。接受的参数名称如下：</p>
<p>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</p>
<p>params返回单个值，当前绑定到绑定点的缓冲区对象的名称对应于通用顶点属性数组索引。如果没有绑定缓冲区对象，则返回0。初始值为0。</p>
<p>GL_VERTEX_ATTRIB_ARRAY_ENABLED</p>
<p>如果启用了索引的顶点属性数组，则params返回非零（true）的单个值，如果禁用，则返回0（false）。初始值为GL_FALSE。</p>
<p>GL_VERTEX_ATTRIB_ARRAY_SIZE</p>
<p>params返回单个值，即index的顶点属性数组的大小。大小是顶点属性数组的每个元素的值的数量，它将是1,2,3或4.初始值是4。</p>
<p>GL_VERTEX_ATTRIB_ARRAY_STRIDE</p>
<p>params返回单个值，数组步长（索引的顶点属性数组中的连续元素之间的字节数）。值为0表示数组元素按顺序存储在内存中。初始值为0。</p>
<p>GL_VERTEX_ATTRIB_ARRAY_TYPE</p>
<p>params返回单个值，一个符号常量，指示索引的顶点属性数组的数组类型。可能的值为GL_BYTE，GL_UNSIGNED_BYTE，GL_SHORT，GL_UNSIGNED_SHORT，GL_FIXED和GL_FLOAT。初始值为GL_FLOAT。</p>
<p>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</p>
<p>如果由index指示的顶点属性数组的定点数据类型在转换为浮点时被标准化，则params返回非零（true）的单个值，否则返回0（false）。初始值为GL_FALSE。</p>
<p>GL_CURRENT_VERTEX_ATTRIB</p>
<p>params返回四个值，表示index指定的通用顶点属性的当前值。初始值为（0,0,0,1）。</p>
<p>除GL_CURRENT_VERTEX_ATTRIB之外的所有参数都表示客户端状态。</p>
<p>注意</p>
<p>如果生成错误，则不会更改params的内容。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：pname不是可接受的值。</p>
<p>GL_INVALID_VALUE：index大于或等于GL_MAX_VERTEX_ATTRIBS。</p>
<p>相关Gets</p>
<p>glGet 参数GL_MAX_VERTEX_ATTRIBS。</p>
<p>glGetVertexAttribPointerv 参数index和GL_VERTEX_ATTRIB_ARRAY_POINTER。</p>
<p>另见</p>
<p>glBindAttribLocation，glBindBuffer，glDisableVertexAttribArray，glEnableVertexAttribArray，glVertexAttrib，glVertexAttrib</p>
<h2 id="glGetVertexAttribPointerv-返回指定的通用顶点属性指针的地址"><a href="#glGetVertexAttribPointerv-返回指定的通用顶点属性指针的地址" class="headerlink" title="glGetVertexAttribPointerv - 返回指定的通用顶点属性指针的地址"></a>glGetVertexAttribPointerv - 返回指定的通用顶点属性指针的地址</h2><p>C规范</p>
<p>void glGetVertexAttribPointerv(    GLuint index,<br>     GLenum pname,<br>     GLvoid **pointer);</p>
<p>参数</p>
<p>index</p>
<p>指定要返回的通用顶点属性参数。</p>
<p>pname</p>
<p>指定要返回的通用顶点属性参数的符号名称。必须是GL_VERTEX_ATTRIB_ARRAY_POINTER。</p>
<p>pointer</p>
<p>返回指针值。</p>
<p>描述</p>
<p>glGetVertexAttribPointerv返回指针信息。index是要查询的通用顶点属性，pname是指示要返回的指针的符号常量，params是指向放置返回数据的位置的指针。</p>
<p>如果在先前指定了所需指针时将非零命名缓冲区对象绑定到GL_ARRAY_BUFFER目标（请参阅glBindBuffer），则返回的指针是缓冲区对象的数据存储中的字节偏移量。</p>
<p>注意</p>
<p>返回的指针是客户端状态。</p>
<p>每个指针的初始值为0。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：pname不是可接受的值。</p>
<p>GL_INVALID_VALUE：index大于或等于GL_MAX_VERTEX_ATTRIBS。</p>
<p>相关Gets</p>
<p>glGet 参数GL_MAX_VERTEX_ATTRIBS</p>
<p>另见</p>
<p>glGetVertexAttrib，glVertexAttribPointer</p>
<h2 id="glHint-指定特定于实现的提示"><a href="#glHint-指定特定于实现的提示" class="headerlink" title="glHint - 指定特定于实现的提示"></a>glHint - 指定特定于实现的提示</h2><p>C规范</p>
<p>void glHint(    GLenum target,<br>     GLenum mode);</p>
<p>参数</p>
<p>target</p>
<p>指定一个符号常量，指示要控制的行为。接受GL_GENERATE_MIPMAP_HINT。</p>
<p>mode</p>
<p>指定表示所需行为的符号常量。接受GL_FASTEST，GL_NICEST和GL_DONT_CARE。</p>
<p>描述</p>
<p>当存在解释空间时，GL行为的某些方面可以通过提示来控制。使用两个参数指定提示。 target是指示要控制的行为的符号常量，mode是指示所需行为的另一个符号常量。每个目标的初始值为GL_DONT_CARE。模式可以是以下之一：</p>
<p>GL_FASTEST</p>
<p>应该选择最有效的选择。</p>
<p>GL_NICEST</p>
<p>应选择最正确或最高质量的选项。</p>
<p>GL_DONT_CARE</p>
<p>都可以。</p>
<p>虽然可以暗示的实现方面已经明确定义，但提示的解释取决于实现。可以使用target指定的提示方面以及建议的语义如下：</p>
<p>GL_GENERATE_MIPMAP_HINT</p>
<p>使用glGenerateMipmap生成mipmap图像时指示过滤的质量。</p>
<p>注意</p>
<p>提示的解释取决于实施。某些实现忽略glHint设置。</p>
<p>目前只是在生成mipmap的时候有用到吧。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：target或mode不是可接受的值。</p>
<p>另见</p>
<p>glGenerateMipmap</p>
<h2 id="glIsBuffer-确定名称是否对应于缓冲区对象"><a href="#glIsBuffer-确定名称是否对应于缓冲区对象" class="headerlink" title="glIsBuffer - 确定名称是否对应于缓冲区对象"></a>glIsBuffer - 确定名称是否对应于缓冲区对象</h2><p>C规范</p>
<p>GLboolean glIsBuffer（GLuint buffer）;</p>
<p>参数</p>
<p>buffer</p>
<p>指定一个值，该值可能是缓冲区对象的名称。</p>
<p>描述</p>
<p>如果buffer当前是缓冲区对象的名称，glIsBuffer将返回GL_TRUE。 如果buffer为零，或者是当前不是缓冲区对象名称的非零值，或者发生错误，则glIsBuffer返回GL_FALSE。</p>
<p>glGenBuffers返回的名称，但尚未通过调用glBindBuffer与缓冲区对象关联，不是缓冲区对象的名称。</p>
<p>另见</p>
<p>glBindBuffer，glDeleteBuffers，glGenBuffers，glGet</p>
<p>版权</p>
<h2 id="glIsEnabled-测试是否启用了某功能"><a href="#glIsEnabled-测试是否启用了某功能" class="headerlink" title="glIsEnabled - 测试是否启用了某功能"></a>glIsEnabled - 测试是否启用了某功能</h2><p>C规范</p>
<p>GLboolean glIsEnabled（GLenum cap）;</p>
<p>参数</p>
<p>cap</p>
<p>指定表示GL功能的符号常量。</p>
<p>描述</p>
<p>如果cap是启用的功能，glIsEnabled将返回GL_TRUE，否则返回GL_FALSE。 初始化时禁用除GL_DITHER之外的所有功能; GL_DITHER初始化时启用。</p>
<p>cap接受以下常量：</p>
<p>常量    另见<br>GL_BLEND    glBlendFunc<br>GL_CULL_FACE    glCullFace<br>GL_DEPTH_TEST    glDepthFunc，glDepthRangef<br>GL_DITHER    glEnable<br>GL_POLYGON_OFFSET_FILL    glPolygonOffset<br>GL_SAMPLE_ALPHA_TO_COVERAGE    glSampleCoverage<br>GL_SAMPLE_COVERAGE    glSampleCoverage<br>GL_SCISSOR_TEST    glScissor<br>GL_STENCIL_TEST     glStencilFunc，glStencilOp<br>注意</p>
<p>如果生成错误，glIsEnabled将返回0。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：cap不是上述可接受的值。</p>
<p>另见</p>
<p>glEnable，glGet</p>
<h2 id="glIsFramebuffer-确定名称是否对应于帧缓冲区对象"><a href="#glIsFramebuffer-确定名称是否对应于帧缓冲区对象" class="headerlink" title="glIsFramebuffer - 确定名称是否对应于帧缓冲区对象"></a>glIsFramebuffer - 确定名称是否对应于帧缓冲区对象</h2><p>C规范</p>
<p>GLboolean glIsFramebuffer（GLuint framebuffer）;</p>
<p>参数</p>
<p>framebuffer</p>
<p>指定一个值，该值可能是帧缓冲区对象的名称。</p>
<p>描述</p>
<p>如果framebuffer当前是帧缓冲区对象的名称，glIsFramebuffer将返回GL_TRUE。 如果framebuffer为零，或者是当前不是帧缓冲区对象名称的非零值，或者发生错误，则glIsFramebuffer返回GL_FALSE。</p>
<p>glGenFramebuffers返回的名称，但尚未通过调用glBindFramebuffer与帧缓冲区对象关联，不是帧缓冲区对象的名称。</p>
<p>另见</p>
<p>glBindFramebuffer，glDeleteFramebuffers，glGenFramebuffers</p>
<h2 id="glIsProgram-判断一个名称是否与一个program对象相对应。"><a href="#glIsProgram-判断一个名称是否与一个program对象相对应。" class="headerlink" title="glIsProgram- 判断一个名称是否与一个program对象相对应。"></a>glIsProgram- 判断一个名称是否与一个program对象相对应。</h2><p>C规范</p>
<p>GLboolean glIsProgram（GLuint program）;</p>
<p>参数</p>
<p>program</p>
<p>指定一个潜在的（可能的）program对象</p>
<p>描述</p>
<p>如果参数program是之前用glCreateProgram创建的program对象的名称并且呢尚未使用glDeleteProgram方法来删除它，那么 glIsProgram方法将会返回GL_TRUE。</p>
<p>如果参数program的值是0，或者是它不是program对象的名称所对应的非0值，或者发生了错误，那么glIsProgram方法都将返回GL_FALSE。</p>
<p>注意</p>
<p>如果program不是有效的program对象名称，那是不会生成错误的。</p>
<p>如果program对象被glDeleteProgram标记为删除了，但是仍然作为当前状态中的一部分被使用时，那参数program仍然会被当作是program对象，此时glIsProgram返回的结果将会是GL_TRUE。</p>
<p>另见</p>
<p>glCreateProgram, glDeleteProgram, glUseProgram</p>
<h2 id="glIsRenderbuffer-确定名称是否对应于renderbuffer对象"><a href="#glIsRenderbuffer-确定名称是否对应于renderbuffer对象" class="headerlink" title="glIsRenderbuffer - 确定名称是否对应于renderbuffer对象"></a>glIsRenderbuffer - 确定名称是否对应于renderbuffer对象</h2><p>C规范</p>
<p>GLboolean glIsRenderbuffer（GLuint renderbuffer）;</p>
<p>参数</p>
<p>renderbuffer</p>
<p>指定一个值，该值可能是渲染缓冲区对象的名称。</p>
<p>描述</p>
<p>如果renderbuffer当前是渲染缓冲区对象的名称，glIsRenderbuffer将返回GL_TRUE。 如果renderbuffer为零，或者是当前不是渲染缓冲区对象名称的非零值，或者发生错误，则glIsRenderbuffer返回GL_FALSE。</p>
<p>glGenRenderbuffers返回的名称，但尚未通过调用glBindRenderbuffer与渲染缓冲区对象关联，不是渲染缓冲区对象的名称。</p>
<p>另见</p>
<p>glBindRenderbuffer，glDeleteRenderbuffers，glGenRenderbuffers</p>
<h2 id="glIsShader-判断一个名称是否与一个shader对象相对应。"><a href="#glIsShader-判断一个名称是否与一个shader对象相对应。" class="headerlink" title="glIsShader- 判断一个名称是否与一个shader对象相对应。"></a>glIsShader- 判断一个名称是否与一个shader对象相对应。</h2><p>C规范</p>
<p>GLboolean glIsShader（GLuint shader）;</p>
<p>参数</p>
<p>shader</p>
<p>指定一个潜在的（可能的）shader对象。</p>
<p>描述</p>
<p>如果参数shader是由之前的glCreateShader方法创建出来的shader对象所对应的名称，并且尚未被glDeleteShader方法标记删除，那么glIsShader方法将返回GL_TRUE。</p>
<p>如果参数shader的值是0，或者是一个不是shader对象所对应的名称的非0值，或者发生了错误，那么glIsShader方法都将返回GL_FALSE。</p>
<p>注意</p>
<p>如果参数shader不是一个有效的shader对象所对应的名称，那这是不会产生错误的。</p>
<p>如果一个shader对象被glDeleteShader方法标记为删除，但是仍然被附着在一个program对象上的时候，那它仍然被当作是一个shader对象，并且glIsShader会返回GL_TRUE。（也就是说其实glDeleteShader只是标记一个shader要删除，但并不是真正的删除了，而且如果很长时间不再用它的时候才去回收它，但是如果这个shader对象附着在program对象上的时候，程序是不会回收它的，这个时候用glIsShader来判断，是会返回GL_TRUE的）。</p>
<p>另见</p>
<p>glCreateShader, glDeleteShader</p>
<h2 id="glIsTexture-确定一个ID是否与纹理相对应。"><a href="#glIsTexture-确定一个ID是否与纹理相对应。" class="headerlink" title="glIsTexture-确定一个ID是否与纹理相对应。"></a>glIsTexture-确定一个ID是否与纹理相对应。</h2><p>C规范</p>
<p>GLboolean glIsTexture(GLuint texture);</p>
<p>参数</p>
<p>texture</p>
<pre><code>指定一个可能是纹理ID的值。
</code></pre>
<p>描述</p>
<p>如果texture是一个纹理ID那么glIsTexture将返回GL_TRUE。如果texture的值是0或者非0但是不是纹理ID又或者有错误生成了glIsTexture都会返回GL_FALSE。</p>
<p>如果这个texture确实是由glGenTextures生成的，但是还没有调用glBindTexture来关联，那么我们也认为这个texture不是纹理ID</p>
<p>另见</p>
<p>glBindTexture glCopyTexImage2D glDeleteTextures glGenTextures glGet glGetTexParameter glTexImage2D glTexParameter</p>
<h2 id="glLineWidth-指定栅格化线条的宽度"><a href="#glLineWidth-指定栅格化线条的宽度" class="headerlink" title="glLineWidth - 指定栅格化线条的宽度"></a>glLineWidth - 指定栅格化线条的宽度</h2><p>C规范</p>
<p>void glLineWidth（GLfloat width）;</p>
<p>参数</p>
<p>width</p>
<p>指定栅格化线条的宽度。初始值为1。</p>
<p>描述</p>
<p>glLineWidth指定线条的栅格化宽度。</p>
<p>通过将提供的宽度四舍五入到最接近的整数来确定实际宽度。如果Δx&gt; =Δy，则在每个光栅化的列中填充i个像素，其中i是宽度的舍入值。否则，在光栅化的每一行中填充i个像素。</p>
<p>有一系列支持的线宽。仅保证宽度1是绝对支持的;其他的依赖于实现。要查询支持的宽度范围，请使用参数GL_ALIASED_LINE_WIDTH_RANGE调用glGet。</p>
<p>注意</p>
<p>查询GL_LINE_WIDTH时，始终返回glLineWidth指定的行宽。截断和四舍五入对指定值没有影响（就是查到的值还是width）。</p>
<p>线宽可能因实现的最大值而被截断。使用GL_ALIASED_LINE_WIDTH_RANGE调用glGet以确定最大宽度。</p>
<p>错误</p>
<p>GL_INVALID_VALUE ：width&lt;=0</p>
<p>相关Gets</p>
<p>glGet 参数GL_LINE_WIDTH</p>
<p>glGet 参数GL_ALIASED_LINE_WIDTH_RANGE</p>
<p>另见</p>
<p>glEnable</p>
<h2 id="glLinkProgram-连接一个program对象。"><a href="#glLinkProgram-连接一个program对象。" class="headerlink" title="glLinkProgram- 连接一个program对象。"></a>glLinkProgram- 连接一个program对象。</h2><p>C规范</p>
<p>void glLinkProgram（GLuint program）;</p>
<p>参数</p>
<p>program</p>
<p>指定要链接的program对象的句柄。</p>
<p>描述</p>
<p>glLinkProgram链接program指定的program对象。附加到program的类型为GL_VERTEX_SHADER的着色器对象用于创建将在可编程顶点处理器上运行的可执行文件。 附加到program的类型为GL_FRAGMENT_SHADER的着色器对象用于创建将在可编程片段处理器上运行的可执行文件。</p>
<p>链接操作的状态将存储为program对象状态的一部分。 如果程序对象链接没有错误并且可以使用，则此值将设置为GL_TRUE，否则将设置为GL_FALSE。 可以通过使用参数program和GL_LINK_STATUS调用glGetShaderiv来查询它。</p>
<p>作为链接操作成功的结果，属于program的所有激活的用户定义的统一变量的值将被初始化为0，并且将为每个program对象的活动统一变量分配一个可以通过调用glGetUniformLocation来查询的位置。 此外，任何尚未绑定到通用顶点属性索引的活动用户定义属性变量此时也将绑定到一个索引。</p>
<p>由于OpenGL ES着色语言规范中指定的多种原因，program对象的链接可能会失败。 以下列出了导致链接错误的一些条件:</p>
<p>顶点着色器和片元着色器不同时存在于程序对象中。<br>已超出支持的活动属性变量数。<br>已超出统一变量的存储限制。<br>已超出支持的活动统一变量的数量。<br>顶点着色器或片段着色器缺失main函数。<br>片元着色器中实际使用的易变变量未在顶点着色器中以相同的方式声明（或根本未声明）。<br>对函数或变量名的引用尚未解析。<br>使用两种不同类型或两种不同的初始值声明的全局共享变量。<br>一个或多个附加的着色器对象尚未成功编译（通过glCompileShader）或未成功加载预编译的着色器二进制文件（通过glShaderBinary）。<br>绑定通用属性矩阵导致矩阵的某些行超出允许的最大值GL_MAX_VERTEX_ATTRIBS。<br>没有足够的连续顶点属性槽来绑定属性矩阵<br>成功链接program对象后，可以通过调用glUseProgram使program对象成为当前状态的一部分。 无论链接操作是否成功，program对象的信息日志都将被覆盖。 可以通过调用glGetProgramInfoLog来检索信息日志。</p>
<p>如果链接操作成功并且由于先前调用glUseProgram而指定的program对象当前已被使用，glLinkProgram还将安装生成的可执行文件作为当前呈现状态的一部分。如果当前正在使用的program对象重新链接失败，其链接状态将设置为GL_FALSE，但可执行文件和关联状态将保持当前状态的一部分，直到后续调用glUseProgram将其从使用中删除。 从使用中删除后，在成功重新链接之前，它不能成为当前状态的一部分。</p>
<p>链接操作完成时，program对象的信息日志就被更新了，而且程序也被生成了。在链接操作之后，应用程序可以自由修改附加的着色器对象，编译附加的着色器对象，分离着色器对象，删除着色器对象以及附加其他着色器对象。 这些操作都不会影响信息日志或作为程序对象一部分的程序。</p>
<p>注意</p>
<p>如果链接操作不成功，则关于程序上的先前链接操作的任何信息都将丢失（即，失败的链接不会恢复旧的程序状态）。 即使链接操作不成功，仍然可以从程序中检索某些信息。 例如，glGetActiveAttrib和glGetActiveUniform。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：如果program或shader不是由OpenGL所生成的值。</p>
<p>GL_INVALID_OPERATION:如果program参数传的不是program对象。</p>
<p>相关Gets</p>
<p>glGet 参数：GL_CURRENT_PROGRAM</p>
<p>glGetActiveAttrib 参数：有效的program对象和激活状态的属性变量的句柄。</p>
<p>glGetActiveUniform 参数：有效的program对象和激活状态的统一变量的句柄。</p>
<p>glGetAttachedShaders 参数：有效的program对象</p>
<p>glGetAttribLocation 参数：有效的program对象和属性变量的名称（在shader中的变量字符串）。</p>
<p>glGetProgramiv 参数：有效的program对象和GL_LINK_STATUS</p>
<p>glGetProgramInfoLog 参数：有效的program对象</p>
<p>glGetUniform​​​​​​​ 参数：有效的program对象和一个统一变量地址</p>
<p>glGetUniformLocation​​​​​​​ 参数：有效的program对象和统一变量的名称（在shader中的变量字符串）。</p>
<p>glIsProgram​​​​​​​</p>
<p>另见</p>
<p>glAttachShader, glBindAttribLocation, glCompileShader, glShaderBinary, glCreateProgram, glDeleteProgram, glDetachShader, glUniform, glUseProgram, glValidateProgram</p>
<h2 id="glPixelStorei-设置像素存储模式"><a href="#glPixelStorei-设置像素存储模式" class="headerlink" title="glPixelStorei - 设置像素存储模式"></a>glPixelStorei - 设置像素存储模式</h2><p>C规范</p>
<p>void glPixelStorei（GLenum pname,</p>
<pre><code>                                   GLint param）;
</code></pre>
<p>参数</p>
<p>pname</p>
<p>指定要设置的参数的符号名称。 一个值会影响像素数据到内存的打包：GL_PACK_ALIGNMENT。 另一个影响从内存中解压缩像素数据：GL_UNPACK_ALIGNMENT。</p>
<p>param</p>
<p>指定pname设置为的值。</p>
<p>描述</p>
<p>glPixelStorei设置像素存储模式，这些模式会影响后续glReadPixels的操作以及纹理模式的解包（请参阅glTexImage2D和glTexSubImage2D）。</p>
<p>pname是一个符号常量，表示要设置的参数，param是新值。 一个存储参数会影响像素数据返回客户端内存的方式：</p>
<p>GL_PACK_ALIGNMENT</p>
<pre><code>指定内存中每个像素行开头的对齐要求。允许值为1（字节对齐），2（行与偶数字节对齐），4（字对齐）和8（行从双字边界开始）。
</code></pre>
<p>另一个存储参数会影响从客户端内存中读取像素数据的方式：</p>
<p>GL_UNPACK_ALIGNMENT</p>
<pre><code>指定内存中每个像素行开头的对齐要求。 允许值为1（字节对齐），2（行与偶数字节对齐），4（字对齐）和8（行从双字边界开始）。
</code></pre>
<p>下表给出了可以使用glPixelStorei设置的每个存储参数的类型，初始值和有效值范围。</p>
<p>pname    类型    初始值    可用值<br>GL_PACK_ALIGNMENT    整型    4    1,2,4,8<br>GL_UNPACK_ALIGNMENT    整型    4    1,2,4,8</p>
<p>如果param为0，则布尔参数设置为false，否则设置为true。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果pname不是可接受的值。</p>
<p>GL_INVALID_VALUE ：如果指定对齐不是1,2,4或8。</p>
<p>相关Gets</p>
<p>glGet 参数GL_PACK_ALIGNMENT 或GL_UNPACK_ALIGNMENT</p>
<p>另见</p>
<p>glReadPixels，glTexImage2D，glTexSubImage2D</p>
<h2 id="glPolygonOffset-设置用于计算深度值的比例和单位"><a href="#glPolygonOffset-设置用于计算深度值的比例和单位" class="headerlink" title="glPolygonOffset - 设置用于计算深度值的比例和单位"></a>glPolygonOffset - 设置用于计算深度值的比例和单位</h2><p>C规范</p>
<p>void glPolygonOffset（GLfloat factor,</p>
<pre><code>                                       GLfloat units）;
</code></pre>
<p>参数</p>
<p>factor</p>
<p>指定用于为每个多边形创建变量深度偏移的比例因子。初始值为0。</p>
<p>units</p>
<p>乘以特定于实现的值以创建恒定的深度偏移。初始值为0。</p>
<p>描述</p>
<p>启用GL_POLYGON_OFFSET_FILL后，每个片段的深度值将在从相应顶点的深度值进行插值后进行偏移。偏移的值是factor×DZ + r×units，其中DZ是相对于多边形的屏幕区域的深度变化的度量，并且r是保证给定的可解析偏移的最小值实现。注意在执行深度测试并将值写入深度缓冲区之前添加偏移量。</p>
<p>glPolygonOffset可用于渲染隐藏线图像，将贴花应用于曲面以及渲染具有突出显示边的实体。（用于解决Z-fighting）</p>
<p>相关Gets</p>
<p>glIsEnabled 参数GL_POLYGON_OFFSET_FILL。</p>
<p>glGet 参数GL_POLYGON_OFFSET_FACTOR或GL_POLYGON_OFFSET_UNITS。</p>
<p>另见</p>
<p>glDepthFunc，glEnable，glGet ，glIsEnabled </p>
<h2 id="glReadPixels-从帧缓冲区中读取一个像素块"><a href="#glReadPixels-从帧缓冲区中读取一个像素块" class="headerlink" title="glReadPixels - 从帧缓冲区中读取一个像素块"></a>glReadPixels - 从帧缓冲区中读取一个像素块</h2><p>C规范</p>
<p>void glReadPixels（GLint x,</p>
<pre><code>                                GLint y,

                                GLsizei width,

                                GLsizei height,

                                GLenum format,

                                GLenum type,

                                GLvoid * data）;
</code></pre>
<p>参数</p>
<p>x，y</p>
<p>指定从帧缓冲区读取的第一个像素的窗口坐标。 此位置是矩形像素块的左下角。</p>
<p>width,height</p>
<p>指定像素矩形的尺寸。 一个宽度和高度对应于单个像素。</p>
<p>format</p>
<p>指定像素数据的格式。 接受以下符号值：GL_ALPHA，GL_RGB和GL_RGBA。</p>
<p>type</p>
<p>指定像素数据的数据类型。 必须是GL_UNSIGNED_BYTE，GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4或GL_UNSIGNED_SHORT_5_5_5_1之一。</p>
<p>data</p>
<p>返回像素数据。</p>
<p>描述</p>
<p>glReadPixels从帧缓冲区返回像素数据，从左下角位于（x，y）的像素开始，从位置data开始返回客户端内存。使用glPixelStorei命令设置的GL_PACK_ALIGNMENT参数会影响像素数据在放入客户端内存之前的处理。</p>
<p>glReadPixels返回每个像素的值，左下角为x + i  y + j，0 &lt;= i &lt;width，0 &lt;= j &lt;height。 该像素被称为第j行中的第i个像素。 像素按行顺序从最低行返回到最高行，每行从左到右排列。</p>
<p>format指定返回像素值的格式; 可接受的值是：</p>
<p>GL_ALPHA</p>
<p>GL_RGB</p>
<p>GL_RGBA</p>
<p>从颜色缓冲区读取RGBA颜色分量。 每个颜色分量都转换为浮点，使零强度映射到0.0，全强度映射到1.0。</p>
<p>丢弃不需要的数据。 例如，GL_ALPHA丢弃红色，绿色和蓝色组件，而GL_RGB仅丢弃alpha组件。 最终值被限制在[0 1]的范围内。</p>
<p>最后，组件将转换为由类型指定合适的格式，。 当类型为GL_UNSIGNED_BYTE时，每个组件乘以2^8 - 1。 当类型为GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4或GL_UNSIGNED_SHORT_5_5_5_1时，每个分量乘以2^N-1，其中N是位域中的位数。</p>
<p>返回值按如下方式放入内存中。 如果format是GL_ALPHA，则返回单个值，并且第j行中第i个像素的数据放置在位置j*width + i中。 GL_RGB返回三个值，GL_RGBA为每个像素返回四个值，所有值对应于占据数据中连续空间的单个像素。 由glPixelStorei设置的存储参数GL_PACK_ALIGNMENT会影响数据写入内存的方式。 有关说明，请参阅glPixelStorei。</p>
<p>注意</p>
<p>如果当前绑定的帧缓冲区不是默认的帧缓冲区对象，则从附加到GL_COLOR_ATTACHMENT0附着点的彩色图像中读取颜色分量。</p>
<p>只有两个format/type参数对是可接受的。GL_RGBA / GL_UNSIGNED_BYTE是始终都可以接受的，另外的就需要查询了：通过查询GL_IMPLEMENTATION_COLOR_READ_FORMAT和GL_IMPLEMENTATION_COLOR_READ_TYPE来发现其他可接受的对。</p>
<p>位于连接到当前GL上下文的窗口之外的像素值是未定义的。</p>
<p>如果生成错误，则不会更改data内容。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果format或type不是可接受的值。</p>
<p>GL_INVALID_VALUE ：如果width或height是负数</p>
<p>GL_INVALID_OPERATION ：如果type为GL_UNSIGNED_SHORT_5_6_5且格式不是GL_RGB。</p>
<p>GL_INVALID_OPERATION ：如果type为GL_UNSIGNED_SHORT_4_4_4_4或GL_UNSIGNED_SHORT_5_5_5_1且格式不是GL_RGBA。</p>
<p>GL_INVALID_OPERATION ：如果format和type分别既不是GL_RGBA又不是GL_UNSIGNED_BYTE，也不是通过查询GL_IMPLEMENTATION_COLOR_READ_FORMAT和GL_IMPLEMENTATION_COLOR_READ_TYPE返回的格式/类型对。</p>
<p>GL_INVALID_FRAMEBUFFER_OPERATION ：如果当前绑定的帧缓冲区不是帧缓冲区完成状态（即glCheckFramebufferStatus的返回值不是GL_FRAMEBUFFER_COMPLETE）。</p>
<p>相关Gets</p>
<p>glGet 参数GL_IMPLEMENTATION_COLOR_READ_FORMAT或GL_IMPLEMENTATION_COLOR_READ_TYPE</p>
<p>glGet 参数GL_PACK_ALIGNMENT</p>
<p>另见</p>
<p>glCheckFramebufferStatus，glPixelStorei</p>
<h2 id="glReleaseShaderCompiler-（提示）释放着色器编译器分配的资源"><a href="#glReleaseShaderCompiler-（提示）释放着色器编译器分配的资源" class="headerlink" title="glReleaseShaderCompiler - （提示）释放着色器编译器分配的资源"></a>glReleaseShaderCompiler - （提示）释放着色器编译器分配的资源</h2><p>C规范</p>
<p>void glReleaseShaderCompiler（void）;</p>
<p>描述</p>
<p>对于支持着色器编译器的实现，glReleaseShaderCompiler释放着色器编译器分配的资源。这是应用程序的一个提示，即至少在一段时间内不太可能发生额外的着色器编译，并且着色器编译器消耗的资源可能会被释放并在其他地方更好地使用。</p>
<p>但是，如果在调用glReleaseShaderCompiler之后调用glCompileShader，则必须恢复着色器编译器以服务编译请求，就像从未调用过glReleaseShaderCompiler一样。</p>
<p>注意</p>
<p>着色器编译器支持是可选的，因此必须在使用之前通过使用参数GL_SHADER_COMPILER调用glGet来查询。 glShaderSource，glCompileShader，glGetShaderPrecisionFormat和glReleaseShaderCompiler将在不支持着色器编译器的实现上生成GL_INVALID_OPERATION。这样的实现提供了glShaderBinary替代方案，用于提供预编译的着色器二进制文件。</p>
<p>错误</p>
<p>GL_INVALID_OPERATION：如果实现不支持着色器编译器</p>
<p>相关Gets</p>
<p>glGet与参数GL_SHADER_COMPILER</p>
<p>另见</p>
<p>glCompileShader，glShaderSource</p>
<h2 id="glRenderbufferStorage-创建并初始化renderbuffer对象的数据存储"><a href="#glRenderbufferStorage-创建并初始化renderbuffer对象的数据存储" class="headerlink" title="glRenderbufferStorage - 创建并初始化renderbuffer对象的数据存储"></a>glRenderbufferStorage - 创建并初始化renderbuffer对象的数据存储</h2><p>C规范</p>
<p>void glRenderbufferStorage（GLenum target,</p>
<pre><code>                                                    GLenum internalformat,

                                                    GLsizei width,

                                                    GLsizei height）;
</code></pre>
<p>参数</p>
<p>target</p>
<p>指定renderbuffer目标。 符号常量必须为GL_RENDERBUFFER。</p>
<p>internalformat</p>
<p>指定渲染缓冲区的颜色可渲染，深度可渲染或模板可渲染格式。 必须是以下符号常量之一：GL_RGBA4，GL_RGB565，GL_RGB5_A1，GL_DEPTH_COMPONENT16或GL_STENCIL_INDEX8。</p>
<p>width</p>
<p>指定渲染缓冲区的宽度（以像素为单位）。</p>
<p>height</p>
<p>指定渲染缓冲区的高度（以像素为单位）。</p>
<p>描述</p>
<p>glRenderbufferStorage建立renderbuffer对象图像的数据存储，格式和尺寸。 删除渲染缓冲区的任何现有数据存储，则新数据存储的内容为未定义的。</p>
<p>实现可以基于任何glRenderbufferStorage参数（target除外）改变其内部组件分辨率的分配，但是分配和选择的内部格式不能是任何其他状态的函数，并且一旦建立就不能改变。 可以使用glGetRenderbufferParameteriv查询分配的图像的每个分量的实际分辨率。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：target不是GL_RENDERBUFFER。</p>
<p>GL_INVALID_ENUM ：internalformat不是可接受的值。</p>
<p>GL_INVALID_VALUE ：如果width或height小于零或大于GL_MAX_RENDERBUFFER_SIZE。</p>
<p>GL_OUT_OF_MEMORY ：如果实现无法创建具有请求的width和height的数据存储。</p>
<p>GL_INVALID_OPERATION ：如果绑定了保留的renderbuffer对象名称0。</p>
<p>相关Gets</p>
<p>glGetRenderbufferParameteriv</p>
<p>另见</p>
<p>glBindRenderbuffer，glDeleteRenderbuffers，glFramebufferRenderbuffer，glGenRenderbuffers，glGetRenderbufferParameteriv，glIsRenderbuffer</p>
<h2 id="glSampleCoverage-指定多重采样覆盖率参数"><a href="#glSampleCoverage-指定多重采样覆盖率参数" class="headerlink" title="glSampleCoverage - 指定多重采样覆盖率参数"></a>glSampleCoverage - 指定多重采样覆盖率参数</h2><p>C规范</p>
<p>void glSampleCoverage(    GLclampf value,<br>     GLboolean invert);</p>
<p>参数</p>
<p>value</p>
<p>指定单个浮点样本覆盖率值。该值被限制在[0,1]的范围内。初始值为1.0。</p>
<p>invert</p>
<p>指定一个布尔值，表示是否应反转coverage掩码。接受GL_TRUE和GL_FALSE。初始值为GL_FALSE。</p>
<p>描述</p>
<p>多重采样在各种依赖于实现的子像素位置处对像素进行多次采样以产生抗锯齿效果。如果启用了多重采样,将对点，线和多边形进行抗锯齿处理。</p>
<p>value用于构造临时掩模，用于确定将用于解析最终片段颜色的样本。该掩码与多重采样计算生成的覆盖掩码一致。如果设置了反转标志，则反转临时掩码（所有位翻转），然后按位与计算。</p>
<p>如果实现没有可用的多重采样缓冲区，或者禁用了多重采样，则仅使用单个样本计算像素的最终RGB颜色就会发生光栅化。</p>
<p>如果实现支持多重采样缓冲区，并且启用了多重采样，则通过组合每个像素的多个采样来生成像素的最终颜色。每个样本都包含颜色，深度和模板信息，允许对每个样本执行这些操作。</p>
<p>相关Gets</p>
<p>glGet 参数GL_SAMPLE_COVERAGE_VALUE</p>
<p>glGet 参数GL_SAMPLE_COVERAGE_INVERT</p>
<p>glIsEnabled 参数GL_SAMPLE_ALPHA_TO_COVERAGE</p>
<p>glIsEnabled 参数GL_SAMPLE_COVERAGE</p>
<p>另见</p>
<p>glEnable</p>
<h2 id="glScissor-定义一个裁剪矩形区域"><a href="#glScissor-定义一个裁剪矩形区域" class="headerlink" title="glScissor - 定义一个裁剪矩形区域"></a>glScissor - 定义一个裁剪矩形区域</h2><p>C规范</p>
<p>void glScissor(    GLint x,<br>     GLint y,<br>     GLsizei width,<br>     GLsizei height);</p>
<p>参数</p>
<p>x, y</p>
<p>指定矩形区域的左下角。最初（0,0）。</p>
<p>width, height</p>
<p>指定矩形区域的宽度和高度。首次将GL上下文附加到窗口时，width和height将被设置为该窗口的尺寸。</p>
<p>描述</p>
<p>glScissor在窗口坐标中定义了一个称为裁剪框的矩形。前两个参数x和y指定框的左下角。 width和height指定框的宽度和高度。</p>
<p>要启用和禁用裁剪测试，请使用参数GL_SCISSOR_TEST调用glEnable和glDisable。该测试最初被禁用。启用测试时，只能通过绘制命令修改位于剪刀框内的像素。窗口坐标在帧缓冲区像素的共享角上具有整数值。glScissor（0,0,1,1）只允许修改窗口中的左下角像素，而glScissor（0,0,0,0）不允许修改窗口中的任何像素。</p>
<p>当裁剪测试被禁用时，就好像裁剪盒包含了整个窗口。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：width或height为负。</p>
<p>相关Gets</p>
<p>glGet 参数GL_SCISSOR_BOX</p>
<p>glIsEnabled 参数GL_SCISSOR_TEST</p>
<p>另见</p>
<p>glEnable，glViewport</p>
<h2 id="glShaderBinary-加载预编译的着色器二进制文件"><a href="#glShaderBinary-加载预编译的着色器二进制文件" class="headerlink" title="glShaderBinary - 加载预编译的着色器二进制文件"></a>glShaderBinary - 加载预编译的着色器二进制文件</h2><p>C规范</p>
<p>void glShaderBinary(    GLsizei n,<br>     const GLuint *shaders,<br>     GLenum binaryformat,<br>     const void *binary,<br>     GLsizei length);</p>
<p>参数</p>
<p>n</p>
<p>指定着色器中存在的着色器对象句柄的数量。</p>
<p>shaders</p>
<p>指定指向将加载着色器二进制文件的着色器对象控制器数组的指针。</p>
<p>binaryformat</p>
<p>指定着色器二进制格式。</p>
<p>binary</p>
<p>指定指向客户端内存中着色器二进制数据的指针。</p>
<p>length</p>
<p>指定着色器二进制数据的长度（以字节为单位）。</p>
<p>描述</p>
<p>对于支持它们的实现，glShaderBinary加载预编译的着色器二进制文件。着色器包含n个着色器对象句柄的列表。每个句柄都引用一种独特的着色器类型（顶点着色器或片段着色器）。二进制指向客户端内存中预编译的二进制着色器代码，binaryformat表示预编译代码的格式。</p>
<p>根据定义指定二进制格式的扩展规范对二进制图像进行解码。 OpenGL ES没有定义特定的二进制格式，但确实提供了一种机制来获取扩展提供的这种格式的符号常量。可以通过查询GL_NUM_SHADER_BINARY_FORMATS的值来获取支持的着色器二进制格式的数量。支持的特定二进制格式列表可以通过查询GL_SHADER_BINARY_FORMATS的值来获得。</p>
<p>根据着色器中着色器对象的类型，glShaderBinary将单独加载二进制顶点或片段着色器，或加载包含存储在同一二进制文件中的优化顶点和片段着色器对的可执行二进制文件。</p>
<p>如果glShaderBinary失败，则不会恢复为其加载二进制文件的旧对象着色器对象。</p>
<p>注意</p>
<p>着色器二进制支持是可选的，因此必须在使用之前通过使用参数GL_NUM_SHADER_BINARY_FORMATS和GL_SHADER_BINARY_FORMATS调用glGet来查询。 glShaderBinary在不支持任何着色器二进制格式的实现上生成GL_INVALID_OPERATION错误。这样的实现提供了glShaderSource替代方案，用于提供用于编译的OpenGL ES着色语言着色器源。</p>
<p>如果支持着色器二进制格式，则实现可能需要将一组优化的顶点和片段着色器二进制文件一起编译给glLinkProgram。未指定优化可能导致glLinkProgram失败。这种限制（如果存在）将记录在定义二进制格式的扩展规范中。</p>
<p>调用glShaderBinary时，OpenGL会复制着色器二进制数据，因此应用程序可以在函数返回后立即释放其数据副本。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：binaryformat不是GL_SHADER_BINARY_FORMATS中返回的受支持格式。</p>
<p>GL_INVALID_VALUE：着色器中的任何值不是OpenGL生成的值。</p>
<p>GL_INVALID_VALUE：二进制指向的数据格式与binaryformat不匹配。</p>
<p>GL_INVALID_VALUE：n或length为负。</p>
<p>GL_INVALID_OPERATION：着色器中的任何值不是着色器对象，或者着色器中有多个顶点着色器对象句柄或多个片段着色器对象句柄。</p>
<p>相关Gets</p>
<p>glGet 参数GL_NUM_SHADER_BINARY_FORMATS和GL_SHADER_BINARY_FORMATS</p>
<p>glIsShader</p>
<p>另见</p>
<p>glCreateShader，glDeleteShader，glLinkProgram</p>
<h2 id="glShaderSource-替换着色器对象中的源代码"><a href="#glShaderSource-替换着色器对象中的源代码" class="headerlink" title="glShaderSource - 替换着色器对象中的源代码"></a>glShaderSource - 替换着色器对象中的源代码</h2><p>C规范</p>
<p>void  glShaderSource（GLuint shader，GLsizei count，const GLchar * const *string，const GLint *length）;</p>
<p>参数</p>
<p>shader</p>
<pre><code>要被替换源代码的着色器对象的句柄（ID）。
</code></pre>
<p>count</p>
<pre><code>指定字符串和长度数组中的元素数。
</code></pre>
<p>string</p>
<pre><code>指定指向包含要加载到着色器的源代码的字符串的指针数组。
</code></pre>
<p>length</p>
<pre><code>指定字符串长度的数组。
</code></pre>
<p>描述</p>
<pre><code>对于支持着色器编译器的实现，glShaderSource将着色器中的源代码设置为string指定的字符串数组中的源代码。先前存储在着色器对象中的任何源代码都将被完全替换。数组中的字符串数由count指定。 如果length为NULL，则认为每个字符串都以null结尾。如果length不是NULL，则它指向包含字符串的每个相应元素的字符串长度的数组。length数组中的每个元素可以包含相应字符串的长度（空字符不计为字符串长度的一部分）或小于0的值以表示该字符串为空终止。此时不扫描或解析源代码字符串; 它们只是复制到指定的着色器对象中。
</code></pre>
<p>注意</p>
<p>着色器编译器支持是可选的，因此必须在使用之前通过使用参数GL_SHADER_COMPILER调用glGet来查询。glShaderSource，glCompileShader，glGetShaderPrecisionFormat，glReleaseShaderCompiler等在不支持着色器编译器的实现上都将生成GL_INVALID_OPERATION。这样的实现提供了glShaderBinary替代方案，用于提供预编译的着色器二进制文件。</p>
<p>调用glShaderSource时，OpenGL会复制着色器源代码字符串，因此应用程序可以在函数返回后立即释放源代码字符串的副本。</p>
<p>错误</p>
<p>GL_INVALID_OPERATION：不支持着色器编译器</p>
<p>GL_INVALID_VALUE：shader不是OpenGL生成的值</p>
<p>GL_INVALID_OPERATION：shader不是着色器对象</p>
<p>GL_INVALID_VALUE：count比0小</p>
<p>相关Gets</p>
<p>glGet 参数GL_SHADER_COMPILER</p>
<p>glGetShaderiv 参数shader和GL_SHADER_SOURCE_LENGTH</p>
<p>glGetShaderSource 参数shader</p>
<p>glIsShader</p>
<p>另见</p>
<p>glCompileShader，glGetShaderPrecisionFormat，glCreateShader，glDeleteShader</p>
<p>glStencilFunc - 设置模板测试的前后功能和参考值</p>
<h2 id="glStencilFuncSeparate-设置模板测试的前端和-或后端功能和参考值"><a href="#glStencilFuncSeparate-设置模板测试的前端和-或后端功能和参考值" class="headerlink" title="glStencilFuncSeparate - 设置模板测试的前端和/或后端功能和参考值"></a>glStencilFuncSeparate - 设置模板测试的前端和/或后端功能和参考值</h2><p>C规范</p>
<p>void glStencilFunc(    GLenum func,<br>     GLint ref,<br>     GLuint mask);</p>
<p>void glStencilFuncSeparate(    GLenum face,<br>     GLenum func,<br>     GLint ref,<br>     GLuint mask);</p>
<p>参数</p>
<p>face</p>
<p>指定是否更新前和/或后模板状态。三个符号常量有效：GL_FRONT，GL_BACK和GL_FRONT_AND_BACK。</p>
<p>func</p>
<p>指定测试功能。八个符号常量有效：GL_NEVER，GL_LESS，GL_LEQUAL，GL_GREATER，GL_GEQUAL，GL_EQUAL，GL_NOTEQUAL和GL_ALWAYS。初始值为GL_ALWAYS。</p>
<p>ref</p>
<p>指定模板测试的参考值。 ref被截断到[0,2^n - 1]的范围，其中n是模板缓冲器中的位平面数。初始值为0。</p>
<p>mask</p>
<p>指定在测试完成时与参考值和存储的模板值进行AND运算的掩码。初始值全是1。</p>
<p>描述</p>
<p>与深度缓冲一样，模板测试可以在每个像素的基础上启用和禁用绘图。首先使用GL绘图基元绘制模板平面，然后使用模板平面渲染几何体和图像以屏蔽部分屏幕。 Stenciling通常用于多通道渲染算法以实现特殊效果，例如贴花，轮廓和构造性实体几何渲染。</p>
<p>模板测试基于参考值和模板缓冲器中的值之间的比较结果有条件地消除像素。要启用和禁用测试，请使用参数GL_STENCIL_TEST调用glEnable和glDisable。要根据模板测试的结果指定操作，请调用glStencilOp或glStencilOpSeparate。</p>
<p>可以有两组独立的func，ref和mask参数;一个影响面向后的多边形，另一个影响前面的多边形以及其他非多边形基元。 glStencilFunc将前后模板状态设置为相同的值。使用glStencilFuncSeparate将前后模板状态设置为不同的值。</p>
<p>func是一个符号常量，用于确定模板比较函数。它接受八个值中的一个，如下面的列表所示。 ref是在模板比较中使用的整数参考值。它被截断到[0,2^n - 1]的范围，其中n是模板缓冲器中的位平面数。mask与参考值和存储的模板值进行按位AND运算。</p>
<p>如果模板表示存储在相应模板缓冲区位置中的值，则以下列表显示可由func指定的每个比较函数的效果。仅当比较成功时，像素才会传递到光栅化过程中的下一个阶段（请参阅glStencilOp）。所有测试都将模板值视为[0,2^n - 1]范围内的无符号整数，其中n是模板缓冲区中的位平面数。</p>
<p>func接受以下值：</p>
<p>GL_NEVER</p>
<p>总是失败。</p>
<p>GL_LESS</p>
<p>( ref &amp; mask ) &lt; ( stencil &amp; mask ) 则通过。</p>
<p>GL_LEQUAL</p>
<p>( ref &amp; mask ) &lt;= ( stencil &amp; mask )则通过。</p>
<p>GL_GREATER</p>
<p>( ref &amp; mask ) &gt; ( stencil &amp; mask )则通过。</p>
<p>GL_GEQUAL</p>
<p> ( ref &amp; mask ) &gt;= ( stencil &amp; mask )则通过。</p>
<p>GL_EQUAL</p>
<p>( ref &amp; mask ) = ( stencil &amp; mask )则通过。</p>
<p>GL_NOTEQUAL</p>
<p>( ref &amp; mask ) != ( stencil &amp; mask )则通过。</p>
<p>GL_ALWAYS</p>
<p>总是通过。</p>
<p>注意</p>
<p>最初，模板测试被禁用。如果没有模板缓冲区，则不会发生模板修改，就好像模板测试总是通过一样。</p>
<p>glStencilFunc与调用glStencilFuncSeparate并将face设置为GL_FRONT_AND_BACK相同。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：face不是GL_FRONT，GL_BACK或GL_FRONT_AND_BACK</p>
<p>GL_INVALID_ENUM：func不是八个接受值之一。</p>
<p>相关Gets</p>
<p>glGet 参数GL_STENCIL_FUNC，GL_STENCIL_VALUE_MASK，GL_STENCIL_REF，GL_STENCIL_BACK_FUNC，GL_STENCIL_BACK_VALUE_MASK，GL_STENCIL_BACK_REF或GL_STENCIL_BITS</p>
<p>glIsEnabled 参数GL_STENCIL_TEST</p>
<p>另见</p>
<p>glBlendFunc，glDepthFunc，glEnable，glStencilMask，glStencilMaskSeparate，glStencilOp，glStencilOpSeparate</p>
<h2 id="glStencilMask-控制模板平面中各个位的正面和背面写入"><a href="#glStencilMask-控制模板平面中各个位的正面和背面写入" class="headerlink" title="glStencilMask - 控制模板平面中各个位的正面和背面写入"></a>glStencilMask - 控制模板平面中各个位的正面和背面写入</h2><p>C规范</p>
<p>void glStencilMask（GLuint mask）;</p>
<p>参数</p>
<p>mask</p>
<p>指定位掩码以启用和禁用模板平面中各个位的写入。最初，mask全是1。</p>
<p>描述</p>
<p>glStencilMask控制模板平面中各个位的写入。掩码的最低有效n位，其中n是模板缓冲区中的位数，指定掩码。如果掩码中出现1，则可以写入模板缓冲区中的相应位。出现0时，相应的位被写保护。最初，所有位都被启用以进行写入。</p>
<p>可以有两个独立的掩码writemasks;一个影响面向后的多边形，另一个影响前面的多边形以及其他非多边形基元。 glStencilMask将前后模板写入掩码设置为相同的值。使用glStencilMaskSeparate将前后模板写掩码设置为不同的值。</p>
<p>注意</p>
<p>glStencilMask与将face设置为GL_FRONT_AND_BACK时调用glStencilMaskSeparate相同。</p>
<p>相关Gets</p>
<p>glGet 参数GL_STENCIL_WRITEMASK，GL_STENCIL_BACK_WRITEMASK或GL_STENCIL_BITS</p>
<p>另见</p>
<p>glColorMask，glDepthMask，glStencilFunc，glStencilFuncSeparate，glStencilMaskSeparate，glStencilOp，glStencilOpSeparate</p>
<h2 id="glStencilFuncSeparate-控制模板平面中各个位的正面和-或背面写入"><a href="#glStencilFuncSeparate-控制模板平面中各个位的正面和-或背面写入" class="headerlink" title="glStencilFuncSeparate - 控制模板平面中各个位的正面和/或背面写入"></a>glStencilFuncSeparate - 控制模板平面中各个位的正面和/或背面写入</h2><p>C规范</p>
<p>void glStencilMaskSeparate(    GLenum face,<br>     GLuint mask);</p>
<p>参数</p>
<p>face</p>
<p>指定是否更新前和/或后模板写掩码。三个符号常量有效：GL_FRONT，GL_BACK和GL_FRONT_AND_BACK。</p>
<p>mask</p>
<p>指定位掩码以启用和禁用模板平面中各个位的写入。最初，面具全是1。</p>
<p>描述</p>
<p>glStencilMaskSeparate控制模板平面中各个位的写入。掩码的最低有效n位，其中n是模板缓冲区中的位数，指定掩码。如果掩码中出现1，则可以写入模板缓冲区中的相应位。出现0时，相应的位被写保护。最初，所有位都被启用以进行写入。</p>
<p>可以有两个独立的掩码写掩码;一个影响面向后的多边形，另一个影响前面的多边形以及其他非多边形基元。 glStencilMask将前后模板写入掩码设置为相同的值，就像调用glStencilMaskSeparate并将face设置为GL_FRONT_AND_BACK一样。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：face不是GL_FRONT，GL_BACK或GL_FRONT_AND_BACK</p>
<p>相关Gets</p>
<p>glGet 参数GL_STENCIL_WRITEMASK，GL_STENCIL_BACK_WRITEMASK或GL_STENCIL_BITS</p>
<p>另见</p>
<p>glColorMask，glColorMask，glStencilFunc，glStencilFuncSeparate，glStencilMask，glStencilOp，glStencilOpSeparate</p>
<h2 id="glStencilOp-设置正面和背面模板测试操作"><a href="#glStencilOp-设置正面和背面模板测试操作" class="headerlink" title="glStencilOp- 设置正面和背面模板测试操作"></a>glStencilOp- 设置正面和背面模板测试操作</h2><p>glStencilOpSeparate - 设置前端和/或后端模板测试操作</p>
<p>C规范</p>
<p>void glStencilOp(    GLenum sfail,<br>     GLenum dpfail,<br>     GLenum dppass);</p>
<p>void glStencilOpSeparate(    GLenum face,<br>     GLenum sfail,<br>     GLenum dpfail,<br>     GLenum dppass);</p>
<p>参数</p>
<p>face</p>
<p>指定是否更新前和/或后模板状态。三个符号常量有效：GL_FRONT，GL_BACK和GL_FRONT_AND_BACK。</p>
<p>sfail</p>
<p>指定模板测试失败时要执行的操作。接受八个符号常量：GL_KEEP，GL_ZERO，GL_REPLACE，GL_INCR，GL_INCR_WRAP，GL_DECR，GL_DECR_WRAP和GL_INVERT。初始值为GL_KEEP。</p>
<p>dpfail</p>
<p>指定模板测试通过时的模板操作，但深度测试失败。 dpfail接受与sfail相同的符号常量。初始值为GL_KEEP。</p>
<p>dppass</p>
<p>指定模板测试和深度测试通过时的模板操作，或模板测试通过时的模板操作，并且未启用深度缓冲或深度测试。 dppass接受与sfail相同的符号常量。初始值为GL_KEEP。</p>
<p>描述</p>
<p>与深度缓冲一样，模板测试可以在每个像素的基础上启用和禁用绘图。首先使用GL绘图基元绘制模板平面，然后使用模板平面渲染几何体和图像以屏蔽部分屏幕。 Stenciling通常用于多通道渲染算法以实现特殊效果，例如贴花，轮廓和构造性实体几何渲染。</p>
<p>模板测试基于参考值和模板缓冲器中的值之间的比较结果有条件地消除像素。要启用和禁用测试，请使用参数GL_STENCIL_TEST调用glEnable和glDisable。要控制它，请调用glStencilFunc或glStencilFuncSeparate。</p>
<p>可以有两组独立的sfail，dpfail和dppass参数;一个影响面向后的多边形，另一个影响前面的多边形以及其他非多边形基元。 glStencilOp将前后模板状态设置为相同的值，就像调用glStencilOpSeparate并将face设置为GL_FRONT_AND_BACK一样。</p>
<p>glStencilOp/glStencilOpSeparate接受三个参数，指示在启用模板处理时存储的模板值会发生什么。如果模板测试失败，则不会更改像素的颜色或深度缓冲区，sfail指定模板缓冲区内容会发生什么。以下八个动作是可能的。</p>
<p>GL_KEEP</p>
<p>保持当前值。</p>
<p>GL_ZERO</p>
<p>将模板缓冲区值设置为0。</p>
<p>GL_REPLACE</p>
<p>将模板缓冲区值设置为ref，由glStencilFunc指定。</p>
<p>GL_INCR</p>
<p>增加当前模板缓冲区值。截断到最大的可表示无符号值。</p>
<p>GL_INCR_WRAP</p>
<p>增加当前模板缓冲区值。当递增最大可表示无符号值时，将模板缓冲区值包含到零。</p>
<p>GL_DECR</p>
<p>减少当前的模板缓冲区值。截断到0。</p>
<p>GL_DECR_WRAP</p>
<p>减少当前的模板缓冲区值。在将模板缓冲区值减小为零时，将模板缓冲区值包装到最大可表示无符号值。</p>
<p>GL_INVERT</p>
<p>按位反转当前模板缓冲区值。</p>
<p>模板缓冲区值被视为无符号整数。递增和递减时，值被钳位为[0,2^n - 1]，其中n是查询GL_STENCIL_BITS返回的值。</p>
<p>glStencilOp/glStencilOpSeparate的另外两个参数指定模板缓冲区操作，这些操作取决于后续深度缓冲区测试是成功（dppass）还是失败（dpfail）（请参阅glDepthFunc）。使用与sfail相同的八个符号常量指定操作。请注意，如果没有深度缓冲区，或者未启用深度缓冲区，则会忽略dpfail。在这些情况下，sfail和dppass分别在模板测试失败和通过时指定模板操作。</p>
<p>注意</p>
<p>最初，模板测试被禁用。如果没有模板缓冲区，则不会发生模板修改，就好像模板测试总是通过一样。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：face不是GL_FRONT，GL_BACK或GL_FRONT_AND_BACK</p>
<p>GL_INVALID_ENUM：sfail，dpfail或dppass是除八个定义的符号常量值之外的任何值。</p>
<p>相关Gets</p>
<p>glGet 参数GL_STENCIL_FUNC，GL_STENCIL_VALUE_MASK，GL_STENCIL_REF，GL_STENCIL_BACK_FUNC，GL_STENCIL_BACK_VALUE_MASK，GL_STENCIL_BACK_REF或GL_STENCIL_BITS</p>
<p>glIsEnabled 参数GL_STENCIL_TEST</p>
<p>另见</p>
<p>glBlendFunc，glDepthFunc，glEnable，glStencilFunc，glStencilFuncSeparate，glStencilMask，glStencilMaskSeparate</p>
<h2 id="glTexImage2D-指定一个二维的纹理图片"><a href="#glTexImage2D-指定一个二维的纹理图片" class="headerlink" title="glTexImage2D- 指定一个二维的纹理图片"></a>glTexImage2D- 指定一个二维的纹理图片</h2><p>C规范</p>
<p>void glTexImage2D(GLenum target, </p>
<pre><code>                                   GLint level, 

                                   GLint internalformat, 

                                   GLsizei width, 

                                   GLsizei height, 

                                   GLint border, 

                                   GLenum format, 

                                   GLenum type, 

                                   const GLvoid * data);
</code></pre>
<p>参数</p>
<p>target</p>
<p>指定活动纹理单元的目标纹理。必须是GL_TEXTURE_2D,GL_TEXTURE_CUBE_MAP_POSITIVE_X,GL_TEXTURE_CUBE_MAP_NEGATIVE_X,GL_TEXTURE_CUBE_MAP_POSITIVE_Y,GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,GL_TEXTURE_CUBE_MAP_POSITIVE_Z,或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</p>
<p>level</p>
<pre><code>指定细节级别，0级表示基本图像，n级则表示Mipmap缩小n级之后的图像（缩小2^n）
</code></pre>
<p>internalformat</p>
<pre><code>指定纹理内部格式，必须是下列符号常量之一：GL_ALPHA，GL_LUMINANCE，GL_LUMINANCE_ALPHA，GL_RGB，GL_RGBA。
</code></pre>
<p>width height</p>
<pre><code>指定纹理图像的宽高，所有实现都支持宽高至少为64 纹素的2D纹理图像和宽高至少为16 纹素的立方体贴图纹理图像 。
</code></pre>
<p>border</p>
<pre><code>指定边框的宽度。必须为0。
</code></pre>
<p>format</p>
<pre><code>指定纹理数据的格式。必须匹配internalformat。下面的符号值被接受：GL_ALPHA，GL_RGB，GL_RGBA，GL_LUMINANCE，和GL_LUMINANCE_ALPHA。
</code></pre>
<p>type</p>
<pre><code>指定纹理数据的数据类型。下面的符号值被接受：GL_UNSIGNED_BYTE，GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4，和GL_UNSIGNED_SHORT_5_5_5_1。
</code></pre>
<p>data</p>
<pre><code>指定一个指向内存中图像数据的指针。
</code></pre>
<p>描述</p>
<pre><code>纹理将指定纹理图像的一部分映射到纹理化为活动的每个图形基元上。当前片段着色器或顶点着色器使用内置纹理查找函数时，纹理处于活动状态。

要定义纹理图像，请调用glTexImage2D。参数描述纹理图像的参数，如高度，宽度，细节级别（详见glTexParameter）以及格式。最后三个参数描述了图像在内存中的表示方式。

数据从data一系列无符号字节或短路中读取，具体取决于type。当type是GL_UNSIGNED_BYTE，每个字节被解释为一个颜色分量。当type是以下当中的一个GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4或GL_UNSIGNED_SHORT_5_5_5_1，各无符号短值被解释为包含所有组件用于单个纹素，利用根据设置在颜色分量format。颜色分量被视为一个，两个，三个或四个值的组，也是基于format。组件组被称为纹理元素（纹素）。

width × height个纹素将从内存中读取（起始位置就是data的起始地址）。默认情况下，这些纹素是从相邻的内存位置获取的，除了在读取所有width个纹素后，读指针前进到下一个四字节边界。glReadPixels使用参数GL_UNPACK_ALIGNMENT指定四字节行对齐，并且可以将其设置为一个，两个，四个或八个字节。

第一个元素对应于纹理图像的左下角。后续元素从左到右通过纹理图像的最低行中的剩余纹素进行，然后在纹理图像的连续更高行中进行。 最后一个元素对应于纹理图像的右上角。

format决定data中每个元素的组成。 它可以是以下符号值之一：
</code></pre>
<p>GL_ALPHA</p>
<pre><code>每个元素都是单个alpha分量。 GL将其转换为浮点并通过将rgb三通道赋值为0组装成RGBA元素。 然后将每个元素的值范围截断于[0,1]。
</code></pre>
<p>GL_RGB</p>
<pre><code>每个元素都是RGB三元组。 GL将其转换为浮点，并通过为alpha赋值为1将其组装成RGBA元素。 然后将每个元素的值范围截断于[0,1]。
</code></pre>
<p>GL_RGBA</p>
<pre><code>每个元素包含所有四个组件。 GL将其转换为浮点，然后将每个元素的值范围截断于[0,1]。
</code></pre>
<p>GL_LUMINANCE</p>
<pre><code>每个元素是单个亮度值。 GL将其转换为浮点，然后通过将亮度值复制三次（红色，绿色和蓝色）并将为alpha赋值为1来将其组合成RGBA元素。然后将每个元素的值范围截断于[0,1]。
</code></pre>
<p>GL_LUMINANCE_ALPHA</p>
<pre><code>每个元素是“亮度-α”对。 GL将其转换为浮点，然后通过将亮度值复制三次（红色，绿色和蓝色）将其组装成RGBA元素。 然后将每个元素的值范围截断于[0,1]。
</code></pre>
<p>  颜色组件根据type转换为浮点。当type是GL_UNSIGNED_BYTE时，每个组件除以2 8 - 1。当type为GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4或GL_UNSIGNED_SHORT_5_5_5_1时，每个分量除以2 N-1，其中N是位域中的位数。</p>
<p>注意</p>
<p>internalformat必须匹配format。纹理图像处理期间不支持格式之间的转换。 type可以用作提示来指定所需的精度，但GL实现可以选择以任何内部分辨率存储纹理数组。</p>
<p>data可能是一个空指针。在这种情况下，会分配纹理内存以适应宽度width和高度的纹理height。然后你可以下载子文本来初始化这个纹理内存。如果用户尝试将纹理图像的未初始化部分应用于基元，则图像未定义。</p>
<p>glTexImage2D是用来指定 由glActiveTexture指定的 纹理单元 是二维纹理还是立体贴图纹理的。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：如果target不是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X， GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y， GL_TEXTURE_CUBE_MAP_NEGATIVE_Y， GL_TEXTURE_CUBE_MAP_POSITIVE_Z，或 GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。</p>
<p>GL_INVALID_ENUM：如果format或type不是可接受的值。</p>
<p>GL_INVALID_VALUE：如果target是立方体贴图中的一个2维贴图，但是宽和高却不相等。（立方体贴图每个维度都是相等的）</p>
<p>GL_INVALID_VALUE：level比0小。</p>
<p>GL_INVALID_VALUE：如果level大于log以2为低⁡max的对数。（max是target为GL_TEXTURE_2D时GL_MAX_TEXTURE_SIZE的返回值，或者当target不是GL_TEXTURE_2D时GL_MAX_CUBE_MAP_TEXTURE_SIZE的返回值）</p>
<p>GL_INVALID_VALUE：当internalformat是一个不可接收的值。</p>
<p>GL_INVALID_VALUE：当height或width的值value或者当target为GL_TEXTURE_2D时value大于GL_MAX_TEXTURE_SIZE，或者当target不为GL_TEXTURE_2D时value大于GL_MAX_CUBE_MAP_TEXTURE_SIZE。</p>
<p>GL_INVALID_VALUE：当border的值不为0时。</p>
<p>GL_INVALID_OPERATION：format和internalformat不匹配。</p>
<p>GL_INVALID_OPERATION：type是GL_UNSIGNED_SHORT_5_6_5但是format不是GL_RGB。</p>
<p>GL_INVALID_OPERATION：type是GL_UNSIGNED_SHORT_4_4_4_4或者GL_UNSIGNED_SHORT_5_5_5_1但format不是GL_RGBA。</p>
<p>相关Gets</p>
<p>glGet GL_MAX_TEXTURE_SIZE 或GL_MAX_CUBE_MAP_TEXTURE_SIZE</p>
<p>另见</p>
<p>glActiveTexture,glCompressedTexImage2D,glCompressedTexSubImage2D,glCopyTexImage2D,glCopyTexSubImage2D,glPixelStorei,glTexSubImage2D,glTexParameter</p>
<h2 id="glTexParameter-设置纹理参数"><a href="#glTexParameter-设置纹理参数" class="headerlink" title="glTexParameter  - 设置纹理参数"></a>glTexParameter  - 设置纹理参数</h2><p>C规范</p>
<p>void glTexParameterf(GLenum target,GLenum pname,GLfloat param);</p>
<p>void glTexParameteri（GLenum target,GLenum pname,GLint param）；</p>
<p>void glTexParameterfv（GLenum target,GLenum pname,const GLfloat * params）；</p>
<p>void glTexParameteriv（GLenum target,GLenum pname,const GLint * params）；</p>
<p>参数</p>
<p>target</p>
<pre><code>指定之前激活了的纹理要绑定到的一个目标。必须是GL_TEXTURE_2D 或GL_TEXTURE_CUBE_MAP。
</code></pre>
<p>pname</p>
<pre><code>指定一个单值纹理参数的符号名，pname可以是下列值之一：GL_TEXTURE_MIN_FILTER GL_TEXTURE_MAG_FILTER GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T。
</code></pre>
<p>param</p>
<pre><code>指定pname的值。
</code></pre>
<p>params</p>
<pre><code>指定pname存储的值的数组的指针。
</code></pre>
<p>描述</p>
<p>纹理贴图是一种将图像应用到对象表面的技术，就像图像是贴花或玻璃纸收缩包装一样。 图像在纹理空间中创建，具有（s，t）坐标系。 纹理是二维或立方体映射的图像和一组参数，用于确定如何从图像中导出样本。</p>
<p>glTexParameter将params中的一个或多个值分配给指定为pname的纹理参数。target定义激活的纹理单元的目标纹理，可以是GL_TEXTURE_2D 或GL_TEXTURE_CUBE_MAP。pname中接受以下符号：</p>
<p>GL_TEXTURE_MIN_FILTER</p>
<pre><code>只要纹理贴图比要贴的区域大，就会使用这个纹理缩小功能。 有六个定义的缩小功能。 其中两个值使用最近的一个或最近的四个纹理元素来计算纹理值。 其他四个值用于mipmap。

mipmap是一组有序的数组，以逐渐降低的分辨率表示相同的图像。如果纹理具有2 ^ n * 2 ^ m的维度，则存在max（n，m）+ 1个mipmap。第一个mipmap就是是原始纹理，尺寸为2 ^ n * 2 ^ m。每个后续的mipmap具有维度2 ^（k-1）* 2 ^（l-1），其中2 ^ k * 2 ^ l是前一个mipmap的维度，直到k = 0或l = 0。此时，后续的mipmap具有尺寸1 * 2 ^（l - 1）或2 ^（k - 1）* 1，直到最终的mipmap，其尺寸为1 * 1。

通过调用glTexImage2D，glCompressedTexImage2D，glCopyTexImage2D设置level参数来定义mipmap的级别。0级是原始纹理; level max（n，m）是最终的1 * 1 mipmap。

params提供的缩小采样功能，可选参数如下：
</code></pre>
<p>GL_NEAREST</p>
<pre><code>临近采样，返回与纹理像素的中心最接近（在曼哈顿距离内）的纹理元素的值。
</code></pre>
<p>GL_LINEAR</p>
<pre><code>线性采样，返回最接近被纹理像素中心的四个纹理元素的加权平均值。
</code></pre>
<p>GL_NEAREST_MIPMAP_NEAREST</p>
<pre><code>选择最接近匹配纹理像素大小的mipmap，并使用GL_NEAREST标准（最接近像素中心的纹理元素）来生成纹理值。
</code></pre>
<p>GL_LINEAR_MIPMAP_NEAREST</p>
<pre><code>选择最接近匹配纹理像素大小的mipmap，并使用GL_LINEAR标准（最接近像素中心的四个纹理元素的加权平均值）来生成纹理值。
</code></pre>
<p>GL_NEAREST_MIPMAP_LINEAR</p>
<pre><code>选择与纹理像素大小最匹配的两个mipmap，并使用GL_NEAREST标准（最接近像素中心的纹理元素）从每个mipmap生成纹理值。 最终纹理值是这两个值的加权平均值。
</code></pre>
<p>GL_LINEAR_MIPMAP_LINEAR</p>
<pre><code>选择与纹理像素大小最匹配的两个mipmap，并使用GL_LINEAR标准（最接近像素中心的四个纹理元素的加权平均值）从每个mipmap生成纹理值。 最终纹理值是这两个值的加权平均值。
</code></pre>
<p>随着在缩小过程中对更多纹理元素进行采样，将会出现更少的锯齿伪像。 虽然GL_NEAREST和GL_LINEAR缩小函数可以比其他四个更快，但它们仅采样一个或四个纹理元素来确定正在渲染的像素的纹理值，并且会产生莫尔条纹或粗糙的过渡。 GL_TEXTURE_MIN_FILTER的初始值为GL_NEAREST_MIPMAP_LINEAR。</p>
<p>GL_TEXTURE_MAG_FILTER</p>
<p>当纹理化的像素映射到小于或等于一个纹理元素的区域时，使用纹理放大功能。 它将纹理放大功能设置为GL_NEAREST或GL_LINEAR（见下文）。 GL_NEAREST通常比GL_LINEAR快，但它会生成边缘更清晰的纹理图像，因为纹理元素之间的过渡不那么平滑。 GL_TEXTURE_MAG_FILTER的初始值为GL_LINEAR。</p>
<p>GL_NEAREST</p>
<pre><code>临近采样，返回与纹理像素的中心最接近（在曼哈顿距离内）的纹理元素的值。
</code></pre>
<p>GL_LINEAR</p>
<pre><code>线性采样，返回最接近被纹理像素中心的四个纹理元素的加权平均值。
</code></pre>
<p>GL_TEXTURE_WRAP_S</p>
<pre><code>将纹理坐标s的wrap参数设置为GL_CLAMP_TO_EDGE，GL_MIRRORED_REPEAT或GL_REPEAT。GL_CLAMP_TO_EDGE会是坐标截取到[1/2N,1-1/2N]其中N是截取方向上纹理的大小。GL_REPEAT会导致坐标的整数部分被忽略，GL只使用小数部分，从而创建一个重复模式。如果s的整数部分是偶数，则GL_MIRRORED_REPEAT使s坐标设置为纹理坐标的小数部分,而如果这个整数部分是奇数的话，纹理坐标则被设置为1-frac(s),其中frac(s)代表s的小数部分。初始状态下，GL_TEXTURE_WRAP_S被设置为GL_REPEAT。
</code></pre>
<p>GL_TEXTURE_WRAP_T</p>
<p>  将纹理坐标t的wrap参数设置为GL_CLAMP_TO_EDGE，GL_MIRRORED_REPEAT或GL_REPEAT。 请参阅GL_TEXTURE_WRAP_S下的讨论。初始状态下，GL_TEXTURE_WRAP_S被设置为GL_REPEAT。</p>
<p>注意</p>
<p>假设从片段着色器或顶点着色器访问纹理，并将GL_TEXTURE_MIN_FILTER设置为mipmaps的其中一个一个。如果当前定义的纹理图像的尺寸（之前已经调用了glTexImage2D，glCompressedTexImage2D或glCopyTexImage2D）不遵循mipmap的正确顺序（如上所述），或者定义的纹理图像少于所需的纹理图像，或者 纹理图像用不同的格式或类型定义，那么纹理图像单元将返回（R，G，B，A）=（0,0,0,1）。</p>
<p>同样，如果纹理图像的宽度或高度不是2的幂，并且      GL_TEXTURE_MIN_FILTER设置为mipmap的功能之一或者GL_TEXTURE_WRAP_S或GL_TEXTURE_WRAP_T未设置为GL_CLAMP_TO_EDGE，则纹理图像单元将返回（R ，G，B，A）=（0,0,0,1）。</p>
<p>glTexParameter为 通过调用glActiveTexture指定激活的纹理单元绑定纹理参数</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：target或param不是预定的值。</p>
<p>GL_INVALID_ENUM ：params应该有一个定义的符号常量值（基于pname的值）但却没有。</p>
<p>相关Gets</p>
<p>glGetTexParameter</p>
<p>另见</p>
<p>glActiveTexture，glBindTexture，glCopyTexImage2D，glCopyTexSubImage2D，glPixelStorei，glTexImage2D，glTexSubImage2D</p>
<h2 id="glTexSubImage2D-指定二维纹理子图像"><a href="#glTexSubImage2D-指定二维纹理子图像" class="headerlink" title="glTexSubImage2D - 指定二维纹理子图像"></a>glTexSubImage2D - 指定二维纹理子图像</h2><p>C规范</p>
<p>void glTexSubImage2D（GLenum target,</p>
<pre><code>                                          GLint level,

                                          GLint xoffset,

                                          GLint yoffset,

                                          GLsizei width,

                                          GLsizei height,

                                          GLenum format,

                                          GLenum type,

                                          const GLvoid * data）;
</code></pre>
<p>参数</p>
<p>target</p>
<p>指定活动纹理单元的目标纹理。 必须是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。</p>
<p>level</p>
<p>指定详细级别编号。 0级是基本图像级别。 级别n是第n个mipmap缩小图像。</p>
<p>xoffset</p>
<p>指定纹理数组中x方向的纹素偏移。</p>
<p>yoffset</p>
<p>指定纹理数组中y方向的纹素偏移。</p>
<p>width</p>
<p>指定纹理子图像的宽度。</p>
<p>height</p>
<p>指定纹理子图像的高度。</p>
<p>format</p>
<p>指定像素数据的格式。 接受以下符号值：GL_ALPHA，GL_RGB，GL_RGBA，GL_LUMINANCE和GL_LUMINANCE_ALPHA。</p>
<p>type</p>
<p>指定像素数据的数据类型。 接受以下符号值：GL_UNSIGNED_BYTE，GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4和GL_UNSIGNED_SHORT_5_5_5_1。</p>
<p>data</p>
<p>指定指向内存中图像数据的指针。</p>
<p>描述</p>
<p>纹理将指定纹理图像的一部分映射到纹理处于活动状态的每个图形基元上。 当前片段着色器或顶点着色器使用内置纹理查找功能时，纹理处于活动状态。</p>
<p>glTexSubImage2D重新定义了现有二维纹理图像的连续子区域。data引用的纹素将现有纹理数组的部分替换为x索引xoffset和xoffset + width - 1（含），y索引yoffset和yoffset + height - 1（含）。该区域可能不包括纹理数组范围之外的任何最初指定的那样的纹素。指定宽度或高度为零的子纹理不是错误的，但这样的规范是没有效果的。</p>
<p>注意</p>
<p>由glPixelStorei设置的存储参数GL_UNPACK_ALIGNMENT会影响从客户端内存中读取数据的方式。 有关说明，请参阅glPixelStorei。</p>
<p>glTexSubImage2D为当前纹理单元指定二维或立方体贴图子纹理，由glActiveTexture指定。</p>
<p>错误</p>
<p>GL_INVALID_ENUM ：如果target不是GL_TEXTURE_2D，GL_TEXTURE_CUBE_MAP_POSITIVE_X，GL_TEXTURE_CUBE_MAP_NEGATIVE_X，GL_TEXTURE_CUBE_MAP_POSITIVE_Y，GL_TEXTURE_CUBE_MAP_NEGATIVE_Y，GL_TEXTURE_CUBE_MAP_POSITIVE_Z或GL_TEXTURE_CUBE_MAP_NEGATIVE_Z。</p>
<p>GL_INVALID_ENUM ：如果format或type不是可接受的值。</p>
<p>GL_INVALID_VALUE ：level&lt;0</p>
<p>GL_INVALID_VALUE :level&gt;log以2为底，max的对数，其中max为GL_MAX_TEXTURE_SIZE返回的值</p>
<p>GL_INVALID_VALUE ：xoffset &lt; 0 , xoffset + width &gt; w , yoffset &lt; 0 , or yoffset + height &gt; h，其中w是宽度，h是要修改的纹理图像的高度。</p>
<p>GL_INVALID_VALUE ：如果width或height小于0。</p>
<p>GL_INVALID_OPERATION ：如果纹理数组尚未由之前的glTexImage2D或glCopyTexImage2D操作定义（其内部格式与glTexSubImage2D的格式匹配）。</p>
<p>GL_INVALID_OPERATION：如果type为GL_UNSIGNED_SHORT_5_6_5且格式不是GL_RGB。</p>
<p>GL_INVALID_OPERATION ：如果type为GL_UNSIGNED_SHORT_4_4_4_4或GL_UNSIGNED_SHORT_5_5_5_1且格式不是GL_RGBA。</p>
<p>相关Gets</p>
<p>glGet 参数GL_MAX_TEXTURE_SIZE  或GL_MAX_CUBE_MAP_TEXTURE_SIZE</p>
<p>另见</p>
<p>glActiveTexture，glCompressedTexImage2D，glCompressedTexSubImage2D，glCopyTexImage2D，glCopyTexSubImage2D，glPixelStorei，glTexImage2D，glTexParameter</p>
<h2 id="glUniform-指定当前程序对象的统一变量的值"><a href="#glUniform-指定当前程序对象的统一变量的值" class="headerlink" title="glUniform - 指定当前程序对象的统一变量的值"></a>glUniform - 指定当前程序对象的统一变量的值</h2><p>C规范</p>
<p>void glUniform1f(    GLint location, GLfloat v0);<br>void glUniform2f(    GLint location,  GLfloat v0, GLfloat v1);<br>void glUniform3f(    GLint location, GLfloat v0, GLfloat v1, GLfloat v2);<br>void glUniform4f(    GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);<br>void glUniform1i(    GLint location, GLint v0);<br>void glUniform2i(    GLint location,GLint v0,GLint v1);<br>void glUniform3i(    GLint location,GLint v0,GLint v1,GLint v2);<br>void glUniform4i(    GLint location,GLint v0,GLint v1,GLint v2,GLint v3);</p>
<p>void glUniform1fv(    GLint location,GLsizei count,const GLfloat *value);<br>void glUniform2fv(    GLint location,GLsizei count,const GLfloat *value);<br>void glUniform3fv(    GLint location,GLsizei count,const GLfloat *value);<br>void glUniform4fv(    GLint location,GLsizei count,const GLfloat *value);<br>void glUniform1iv(    GLint location,GLsizei count,const GLint *value);<br>void glUniform2iv(    GLint location,GLsizei count,const GLint *value);<br>void glUniform3iv(    GLint location, GLsizei count, const GLint *value);<br>void glUniform4iv(    GLint location, GLsizei count, const GLint *value);</p>
<p>void glUniformMatrix2fv(    GLint location,GLsizei countM,GLboolean transpose,const GLfloat *valueM);<br>void glUniformMatrix3fv(    GLint location,GLsizei countM,GLboolean transpose,const GLfloat *valueM);<br>void glUniformMatrix4fv(    GLint location,GLsizei countM,GLboolean transpose, const GLfloat *valueM);</p>
<p>参数</p>
<p>location</p>
<p>指定要修改的统一变量的位置。</p>
<p>v0，v1，v2，v3</p>
<p>指定要用于指定统一变量的新值。</p>
<p>count</p>
<p>指定要修改的元素数。 如果目标统一变量不是数组，则此值应为1;如果是数组，则应为1或更大。</p>
<p>value</p>
<p>指定指向将用于更新指定统一变量的count值数组的指针。</p>
<p>countM</p>
<p>指定要修改的矩阵数。 如果目标统一变量不是矩阵数组，则该值应为1;如果是矩阵数组，则应为1或更大。</p>
<p>transpose</p>
<p>指定在将值加载到统一变量时是否转置矩阵。 必须是GL_FALSE。</p>
<p>valueM</p>
<p>指定指向将用于更新指定统一变量的countM值数组的指针。</p>
<p>描述</p>
<p>glUniform修改统一变量或统一变量数组的值。要被修改值的location是由glGetUniformLocation返回的值。glUniform通过调用glUseProgram对程序对象进行操作，该程序对象是当前状态的一部分。</p>
<p>命令glUniform {1 | 2 | 3 | 4} {f | i}用于使用作为参数传递的值来更改由location指定的统一变量的值。命令中指定的数字应该与指定的统一变量的数据类型中的组件数相匹配（例如，1表示float，int，bool; 2表示vec2，ivec2，bvec2等）。后缀f表示正在传递浮点值;后缀i表示正在传递整数值，并且此类型还应与指定的统一变量的数据类型匹配。应使用此函数的i变体为定义为int，ivec2，ivec3，ivec4或这些变量的数组提供统一变量的值。f变量应该用于为float，vec2，vec3，vec4或这些类型的数组的统一变量提供值。 i或f变体可用于为bool，bvec2，bvec3，bvec4或这些的数组的均匀变量提供值。如果输入值为0或0.0f，则uniform变量将设置为false，否则将设置为true。</p>
<p>程序对象成功链接时，程序对象中定义的所有活动统一变量都初始化为0。它们保留通过调用glUniform分配给它们的值，直到程序对象上的下一个成功链接操作再次初始化为0时为止。</p>
<p>命令glUniform {1 | 2 | 3 | 4} {f | i} v可用于修改单个统一变量或统一变量数组。这些命令将个数和指针传递给要加载到统一变量或统一变量数组中的值。如果修改单个统一变量的值，则应使用1的计数，并且可以使用1或更大的计数来修改整个数组或数组的一部分。当从均匀变量数组中的任意位置m开始加载n个元素时，数组中的元素m + n-1将被替换为新值。如果m + n - 1大于统一变量数组的大小，则将忽略超出数组末尾的所有数组元素的值。命令名称中指定的数字表示每个元素的值的组件数，它应该与指定的统一变量的数据类型中的组件数相匹配（例如，1表示float，int，bool; 2表示vec2，ivec2，bvec2等）。命令名称中指定的数据类型必须与指定的统一变量的数据类型匹配，如前面对glUniform {1 | 2 | 3 | 4} {f | i}所述。</p>
<p>对于统一变量数组，数组的每个元素都被认为是命令名称中指示的类型（例如，glUniform3f或glUniform3fv可用于加载vec3类型的统一变量数组）。要修改的统一变量数组的元素数由count指定</p>
<p>命令glUniformMatrix {2 | 3 | 4} fv用于修改矩阵或矩阵数组。命令名称中的数字被解释为矩阵的维度。数字2表示2×2矩阵（即4个值），数字3表示3×3矩阵（即9个值），数字4表示4×4矩阵（即16个值）。假设每个矩阵按列主要顺序提供。 countM参数表示要传递的矩阵数。如果修改单个矩阵的值，则应使用计数1，并且可以使用大于1的计数来修改矩阵数组.</p>
<p>注意</p>
<p>glUniform1i和glUniform1iv是唯一可用于加载定义为采样器类型的统一变量的两个函数。使用任何其他函数加载采样器将导致GL_INVALID_OPERATION错误。</p>
<p>如果count\countM大于1且指示的统一变量不是数组，则会生成GL_INVALID_OPERATION错误，并且指定的统一变量将保持不变。</p>
<p>除了前面的异常之外，如果着色器中定义的统一变量的类型和大小与用于加载其值的命令名称中指定的类型和大小不匹配，则将生成GL_INVALID_OPERATION错误并生成指定的统一变量将保持不变。</p>
<p>如果location是一个非-1的值，并且它不表示当前程序对象中的有效统一变量位置，则将生成错误，并且不会对当前程序对象的统一变量存储进行任何更改。如果location等于-1，则将默认忽略传入的数据，并且不会更改指定的统一变量。</p>
<p>错误</p>
<p>GL_INVALID_OPERATION：没有当前程序对象</p>
<p>GL_INVALID_OPERATION：着色器中声明的统一变量的大小与glUniform命令指示的大小不匹配</p>
<p>GL_INVALID_OPERATION ：如果此函数的整数变量之一用于加载float，vec2，vec3，vec4或其数组的统一变量，或者如果使用此函数的某个浮点变量来加载统一int，ivec2，ivec3或ivec4类型的变量，或者这些变量的数组。</p>
<p>GL_INVALID_VALUE：count&lt;0</p>
<p>GL_INVALID_VALUE：transpose不是GL_FALSE</p>
<p>GL_INVALID_OPERATION：count大于1且指示的统一变量不是数组变量</p>
<p>GL_INVALID_OPERATION：使用glUniform1i和glUniform1iv之外的命令加载采样器</p>
<p>相关Gets</p>
<p>glGet 参数GL_CURRENT_PROGRAM</p>
<p>glGetActiveUniform 带有程序对象的句柄和活动的统一变量的索引</p>
<p>glGetUniform 程序对象的句柄和统一变量的位置</p>
<p>glGetUniformLocation 包含程序对象的句柄和统一变量的名称</p>
<p>另见</p>
<p>glLinkProgram，glUseProgram</p>
<h2 id="glUseProgram-使用程序对象作为当前渲染状态的一部分"><a href="#glUseProgram-使用程序对象作为当前渲染状态的一部分" class="headerlink" title="glUseProgram- 使用程序对象作为当前渲染状态的一部分"></a>glUseProgram- 使用程序对象作为当前渲染状态的一部分</h2><p>C规范</p>
<p>void glUseProgram（GLuint program）;</p>
<p>参数</p>
<p>program</p>
<p>指定程序对象的句柄，该程序对象的可执行文件将用作当前渲染状态的一部分。</p>
<p>描述</p>
<p>glUseProgram使用程序对象program作为当前渲染状态的一部分。通过使用glAttachShader成功将着色器对象附加到程序对象，使用glCompileShader成功编译着色器对象，并成功链接程序对象与glLinkProgram，之后就可以在程序对象中创建每个阶段的可执行文件。</p>
<p>程序对象将会包含一个可执行文件，该文件将会运行顶点（类型为GL_VERTEX_SHADER 的着色器对象）和片元（类型为GL_FRAGMENT_SHADER 的着色器对象）处理器（前提是这两个着色器都成功的编译并被链接到程序对象上了）。</p>
<p>在使用程序对象时，应用程序可以自由修改附着的着色器对象，编译附着的着色器对象，附着着色器对象以及分离或删除着色器对象。这些操作都不会影响属于当前状态的可执行文件。但是，如果链接操作成功，则重新链接当前正在使用的程序对象将安装程序对象作为当前渲染状态的一部分（请参阅glLinkProgram）。如果当前正在使用的程序对象重新链接失败，其链接状态将设置为GL_FALSE，但可执行文件和关联状态将保持当前状态的一部分，直到后续调用glUseProgram将其从使用中删除。从使用中删除后，在成功重新链接之前，它不能成为当前状态的一部分。</p>
<p>如果program为0，则当前呈现状态引用无效的程序对象，并且会使得任何glDrawArrays或glDrawElements命令的顶点和片段着色器执行的结果未定义。</p>
<p>注意</p>
<p>与纹理对象和缓冲区对象一样，只要上下文的服务器端共享相同的地址空间，程序对象的名称空间就可以在一组上下文中共享。如果名称空间跨上下文共享，则也会共享任何附着对象和与这些附着对象关联的数据。</p>
<p>当从不同的执行线程访问对象时，应用程序负责跨API调用提供同步。</p>
<p>错误</p>
<p>GL_INVALID_VALUE ：如果program是0，或者不是OpenGL生成的值。</p>
<p>GL_INVALID_OPERATION ：program不是程序对象</p>
<p>GL_INVALID_OPERATION ：如果program不能成为当前状态的一部分。</p>
<p>相关Gets</p>
<p>glGet 参数GL_CURRENT_PROGRAM</p>
<p>glGetActiveAttrib 使用有效的程序对象和活动属性变量的索引</p>
<p>glGetActiveUniform 使用有效的程序对象和活动的统一变量的索引</p>
<p>glGetAttachedShaders 使用有效的程序对象</p>
<p>glGetAttribLocation 使用有效的程序对象和属性变量的名称</p>
<p>glGetProgramiv 使用有效的程序对象和要查询的参数</p>
<p>glGetProgramInfoLog 使用有效的程序对象</p>
<p>glGetUniform 使用有效的程序对象和统一变量的位置</p>
<p>glGetUniformLocation 使用有效的程序对象和统一变量的名称</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glAttachShader，glBindAttribLocation，glBindAttribLocation，glCreateProgram，glDeleteProgram，glDeleteShader，glLinkProgram，glGetUniform ，glValidateProgram，glVertexAttrib</p>
<h2 id="glValidateProgram-验证程序对象"><a href="#glValidateProgram-验证程序对象" class="headerlink" title="glValidateProgram - 验证程序对象"></a>glValidateProgram - 验证程序对象</h2><p>C规范</p>
<p>void glValidateProgram（GLuint program）;</p>
<p>参数</p>
<p>program</p>
<p>指定要验证的程序对象的句柄。</p>
<p>描述</p>
<p>glValidateProgram检查程序中包含的可执行文件是否可以在当前的OpenGL状态下执行。验证过程生成的信息将存储在程序的信息日志中。验证信息可以由空字符串组成，或者它可以是包含有关当前程序对象如何与当前OpenGL状态的其余部分交互的信息的字符串。这为OpenGL实现者提供了一种方式，可以传达有关当前程序效率低下，次优，无法执行等原因的更多信息。</p>
<p>验证操作的状态将存储为程序对象状态的一部分。如果验证成功，则此值将设置为GL_TRUE，否则将设置为GL_FALSE。可以通过使用参数program和GL_VALIDATE_STATUS调用glGetProgramiv来查询它。如果验证成功，则保证在给定当前状态的情况下执行程序。否则，程序将保证不执行。</p>
<p>此功能通常仅在应用程序开发期间有用。存储在信息日志中的信息字符串完全取决于实现;因此，应用程序不应期望不同的OpenGL实现生成相同的信息字符串。</p>
<p>注意</p>
<p>如果当前程序对象中的任何两个活动采样器具有不同类型，但是引用相同的纹理图像单元，则glDrawArrays或glDrawElements将生成错误GL_INVALID_OPERATION。</p>
<p>应用程序在发出渲染命令时捕获这些错误可能很困难或导致性能下降（这是一个很耗时的操作，所以最好只在调试的时候调用）。因此，建议应用程序调用glValidateProgram以在应用程序开发期间检测这些问题。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：program不是OpenGL生成的值</p>
<p>GL_INVALID_OPERATION：program不是程序对象</p>
<p>相关Gets</p>
<p>glGetProgramiv 参数GL_VALIDATE_STATUS</p>
<p>glGetProgramInfoLog 参数program</p>
<p>glIsProgram</p>
<p>另见</p>
<p>glLinkProgram，glLinkProgram</p>
<h2 id="glVertexAttrib-指定通用顶点属性的值"><a href="#glVertexAttrib-指定通用顶点属性的值" class="headerlink" title="glVertexAttrib - 指定通用顶点属性的值"></a>glVertexAttrib - 指定通用顶点属性的值</h2><p>C规范</p>
<p>void glVertexAttrib1f(    GLuint index,GLfloat v0);<br>void glVertexAttrib2f(    GLuint index,GLfloat v0, GLfloat v1);<br>void glVertexAttrib3f(    GLuint index,GLfloat v0,GLfloat v1,GLfloat v2);<br>void glVertexAttrib4f(    GLuint index,GLfloat v0,GLfloat v1,GLfloat v2,GLfloat v3);<br>void glVertexAttrib1fv(    GLuint index,const GLfloat *v);<br>void glVertexAttrib2fv(    GLuint index,const GLfloat *v);<br>void glVertexAttrib3fv(    GLuint index,const GLfloat *v);<br>void glVertexAttrib4fv(    GLuint index,const GLfloat *v);</p>
<p>参数</p>
<p>index</p>
<p>指定要修改的通用顶点属性的索引。</p>
<p>v0，v1，v2，v3</p>
<p>指定要用于指定顶点属性的新值。</p>
<p>v</p>
<p>指定指向要用于通用顶点属性的值数组的指针。</p>
<p>描述</p>
<p>glVertexAttrib入口点系列允许应用程序在编号位置传递通用顶点属性。</p>
<p>通用属性定义为组织为数组的四组件值。此数组的第一个条目编号为0，并且数组的大小由依赖于实现的符号常量GL_MAX_VERTEX_ATTRIBS指定。可以使用glVertexAttrib调用修改此数组的各个元素，该调用指定要修改的元素的索引以及该元素的值。</p>
<p>这些命令可用于指定index指定的通用顶点属性的一个，两个，三个或全部四个组件。命令名称中的1表示只传递一个值，它将用于修改通用顶点属性的第一个组件。第二个和第三个组件将设置为0，第四个组件将设置为1。同样，命令名称中的2表示为前两个组件提供值，第三个组件将设置为0 ，第四个组件将设置为1.命令名称中的3表示为前三个组件提供的值，第四个组件将设置为1，而名称中的4表示提供了值对于所有四个组件。</p>
<p>字母f表示参数的类型为float。当v附加到名称时，命令可以获取指向浮点数组的指针。</p>
<p>允许OpenGL ES着色语言属性变量的类型为mat2，mat3或mat4。可以使用glVertexAttrib入口点加载这些类型的属性。矩阵必须按列主要顺序加载到连续的通用属性槽中，每个通用属性槽中有一列矩阵。</p>
<p>在顶点着色器中声明的用户定义的属性变量可以通过调用glBindAttribLocation绑定到通用属性索引。这允许应用程序在顶点着色器中使用描述性变量名称。对指定通用顶点属性的后续更改将立即反映为对顶点着色器中相应属性变量的更改。</p>
<p>顶点着色器中的通用顶点属性索引和用户定义的属性变量之间的绑定是程序对象状态的一部分，但通用顶点属性的当前值不是。每个通用顶点属性的值是当前状态的一部分，即使使用了不同的程序对象，它也会被维护。</p>
<p>应用程序可以自由修改未绑定到命名顶点着色器属性变量的通用顶点属性。这些值仅作为当前状态的一部分进行维护，顶点着色器不会访问这些值。如果在顶点着色器执行时未更新绑定到顶点着色器中的属性变量的通用顶点属性，则顶点着色器将重复使用当前顶点属性的当前值。</p>
<p>注意</p>
<p>应用程序可以将多个属性名称绑定到同一个通用顶点属性索引。这称为别名，只有在顶点着色器中只有一个别名属性变量处于活动状态时，或者如果没有通过顶点着色器的路径消耗多个别名到同一位置的属性时，才允许使用别名。不需要OpenGL实现来进行错误检查以检测别名，允许它们假设不会出现别名，并且允许它们采用仅在没有别名的情况下才能工作的优化。</p>
<p>错误</p>
<p>GL_INVALID_VALUE ：index&gt;=GL_MAX_VERTEX_ATTRIBS</p>
<p>相关Gets</p>
<p>glGet 参数GL_CURRENT_PROGRAM</p>
<p>glGetActiveAttrib 参数program和活动属性变量的索引</p>
<p>glGetAttribLocation 参数program和属性变量名</p>
<p>glGetVertexAttrib 参数GL_CURRENT_VERTEX_ATTRIB和index</p>
<p>另见</p>
<p>glBindAttribLocation，glVertexAttribPointer</p>
<h2 id="glVertexAttribPointer-定义通用顶点属性数据的数组"><a href="#glVertexAttribPointer-定义通用顶点属性数据的数组" class="headerlink" title="glVertexAttribPointer - 定义通用顶点属性数据的数组"></a>glVertexAttribPointer - 定义通用顶点属性数据的数组</h2><p>C规范</p>
<p>void glVertexAttribPointer（GLuint index,</p>
<pre><code>                                       GLint size,

                                       GLenum type,

                                       GLboolean normalized,

                                       GLsizei stride,

                                       const GLvoid * pointer）;
</code></pre>
<p>参数</p>
<p>index</p>
<p>指定要修改的通用顶点属性的索引。</p>
<p>size</p>
<p>指定每个通用顶点属性的组件数。 必须为1,2,3或4.初始值为4。</p>
<p>type</p>
<p>指定数组中每个组件的数据类型。 接受符号常量GL_BYTE，GL_UNSIGNED_BYTE，GL_SHORT，GL_UNSIGNED_SHORT，GL_FIXED或GL_FLOAT。 初始值为GL_FLOAT。</p>
<p>normalized</p>
<p>指定在访问定点数据值时是应将其标准化（GL_TRUE）还是直接转换为定点值（GL_FALSE）。</p>
<p>stride</p>
<p>指定连续通用顶点属性之间的字节偏移量。 如果stride为0，则通用顶点属性被理解为紧密打包在数组中的。 初始值为0。</p>
<p>pointer</p>
<p>指定指向数组中第一个通用顶点属性的第一个组件的指针。 初始值为0。</p>
<p>描述</p>
<p>glVertexAttribPointer指定索引index处的通用顶点属性数组的位置和数据格式，以便在渲染时使用。size指定每个属性的组件数，并且必须为1,2,3或4。type指定每个组件的数据类型，stride指定从一个属性到下一个属性的字节跨度，允许将顶点和属性打包到单个数组中或存储在单独的数组中。如果设置为GL_TRUE，则normalized表示以整数格式存储的值将被映射到范围[-1,1]（对于有符号值）或[0,1]（对于无符号值），当它们被访问并转换为 浮点。 否则，值将直接转换为浮点数而不进行标准化。</p>
<p>如果在指定通用顶点属性数组时将非零命名VBOid绑定到GL_ARRAY_BUFFER目标（请参阅glBindBuffer），则将pointer视为VBO的数据存储中的字节偏移量。 此外，VBO绑定（GL_ARRAY_BUFFER_BINDING）被保存为索引index的通用顶点属性数组客户端状态（GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING）。</p>
<p>指定通用顶点属性数组时，除了当前顶点数组VBO绑定外，还将size，type，normalized，stride和pointer保存为客户端状态。</p>
<p>要启用和禁用通用顶点属性数组，请使用index调用glEnableVertexAttribArray和glDisableVertexAttribArray。 如果启用，则在调用glDrawArrays或glDrawElements时使用通用顶点属性数组。</p>
<p>注意</p>
<p>每个通用顶点属性数组最初都被禁用，并且在调用glDrawElements或glDrawArrays时不会被访问。</p>
<p>glVertexAttribPointer通常在客户端实现。</p>
<p>错误</p>
<p>GL_INVALID_ENUM：type不是可接收的值；</p>
<p>GL_INVALID_VALUE：index大于或等于GL_MAX_VERTEX_ATTRIBS。</p>
<p>GL_INVALID_VALUE：size的值不是1,2,3,4</p>
<p>GL_INVALID_VALUE：stride是负数</p>
<p>相关Gets</p>
<p>glGet 参数GL_MAX_VERTEX_ATTRIBS</p>
<p>glGetVertexAttrib 参数index和GL_VERTEX_ATTRIB_ARRAY_ENABLED</p>
<p>glGetVertexAttrib 参数index和GL_VERTEX_ATTRIB_ARRAY_SIZE</p>
<p>glGetVertexAttrib 参数index和GL_VERTEX_ATTRIB_ARRAY_TYPE</p>
<p>glGetVertexAttrib 参数index和GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</p>
<p>glGetVertexAttrib 参数index和GL_VERTEX_ATTRIB_ARRAY_STRIDE</p>
<p>glGetVertexAttrib 参数index和GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</p>
<p>glGet 参数GL_ARRAY_BUFFER_BINDING</p>
<p>glGetVertexAttribPointerv 参数index和GL_VERTEX_ATTRIB_ARRAY_POINTER</p>
<p>另见</p>
<p>glBindAttribLocation，glBindBuffer，glEnableVertexAttribArray，glDisableVertexAttribArray，glDrawElements，glDrawArrays，glVertexAttrib</p>
<h2 id="glViewport-设置视口"><a href="#glViewport-设置视口" class="headerlink" title="glViewport- 设置视口"></a>glViewport- 设置视口</h2><p>C规范</p>
<p>void glViewport（GLint x,GLint y,GLsizei width,GLsizei height）;</p>
<p>参数</p>
<p>x, y</p>
<pre><code>指定视口矩形的左下角坐标，以像素为单位，初始值为（0，0）。
</code></pre>
<p>width, height</p>
<p>  指定视口的宽高，当一个GLContext第一次绑定到一个窗口时，width, height就会被指定为该窗口的宽高。</p>
<p>描述</p>
<p>glViewport指定x和y从标准化设备坐标到窗口坐标的一个仿射变化。设(Xnd,Ynd)是标准化设备坐标（-1.0~1.0，0.0在设备中间），则窗口坐标（Xw,Yw)可以由以下公式推出：</p>
<p>视口宽高会被默认限制到一定的范围内，视具体实现而定，可以通过glGet变量GL_MAX_VIEWPORT_DIMS得到。</p>
<p>错误</p>
<p>GL_INVALID_VALUE：width或height是负数</p>
<p>相关Gets</p>
<p>glGet 变量GL_MAX_VIEWPORT_DIMS</p>
<p>glGet 变量GL_VIEWPORT</p>
<p>另见</p>
<p>glDepthRangef</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift150%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift150%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">算法整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:49" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:49+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="手写代码问题"><a href="#手写代码问题" class="headerlink" title="手写代码问题"></a>手写代码问题</h2><p>Integer<br>contains<br>Character<br>toCharArray<br>Stack<br>Queue<br>LinkedList&lt;&gt;<br>双端队列<br>Deque<br>优先队列<br>PriorityQueue<br>Character.isLetterOrDigit<br>Character.toLowerCase(<br>equals<br>compareTo</p>
<h2 id="回溯算法解题套路框架"><a href="#回溯算法解题套路框架" class="headerlink" title="回溯算法解题套路框架"></a>回溯算法解题套路框架</h2><p>def backtrack(…):<br>    for 选择 in 选择列表:<br>        做选择<br>        backtrack(…)<br>        撤销选择</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>dp[0][0][…] = base</p>
<h1 id="进行状态转移"><a href="#进行状态转移" class="headerlink" title="进行状态转移"></a>进行状态转移</h1><p>for 状态1 in 状态1的所有取值：<br>    for 状态2 in 状态2的所有取值：<br>        for …<br>            dp[状态1][状态2][…] = 求最值(选择1，选择2…)</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>int binary_search(int[] nums, int target) {<br>    int left = 0, right = nums.length - 1;<br>    while(left &lt;= right) {<br>        int mid = left + (right - left) / 2;<br>        if (nums[mid] &lt; target) {<br>            left = mid + 1;<br>        } else if (nums[mid] &gt; target) {<br>            right = mid - 1;<br>        } else if(nums[mid] == target) {<br>            // 直接返回<br>            return mid;<br>        }<br>    }<br>    // 直接返回<br>    return -1;<br>}</p>
<h2 id="二叉树的广度优先"><a href="#二叉树的广度优先" class="headerlink" title="二叉树的广度优先"></a>二叉树的广度优先</h2><p>class Solution {<br>    Map&lt;Integer, TreeNode&gt; parent = new HashMap&lt;Integer, TreeNode&gt;();<br>    Set<Integer> visited = new HashSet<Integer>();</p>
<pre><code>public void dfs(TreeNode root) &#123;
    if (root.left != null) &#123;
        parent.put(root.left.val, root);
        dfs(root.left);
    &#125;
    if (root.right != null) &#123;
        parent.put(root.right.val, root);
        dfs(root.right);
    &#125;
&#125;

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
    dfs(root);
    while (p != null) &#123;
        visited.add(p.val);
        p = parent.get(p.val);
    &#125;
    while (q != null) &#123;
        if (visited.contains(q.val)) &#123;
            return q;
        &#125;
        q = parent.get(q.val);
    &#125;
    return null;
&#125;
</code></pre>
<p>}</p>
<h2 id="二叉树的深度优先"><a href="#二叉树的深度优先" class="headerlink" title="二叉树的深度优先"></a>二叉树的深度优先</h2><p>public class Solution {<br>    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {<br>        ArrayList<Integer> lists=new ArrayList<Integer>();<br>        if(root==null)<br>            return lists;<br>        Stack<TreeNode> stack=new Stack<TreeNode>();<br>        stack.push(root);<br>        while(!stack.isEmpty()){<br>            TreeNode tree=stack.pop();<br>　　　　　　//先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。<br>            if(tree.right!=null)<br>                stack.push(tree.right);<br>            if(tree.left!=null)<br>                stack.push(tree.left);<br>            lists.add(tree.val);<br>        }<br>        return lists;<br>    }<br>}</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>数组中重复的数字<br>线性遍历集合存储，然后看集合中是否存在<br>数组中出现次数超过一半的数字 ：哈希、排序、摩尔投票法<br>第一个只出现一次的字符 ：哈希表 的使用<br>两个数组的交集<br>复制带随机指针的链表<br>判断链表中是否有环<br>找树中两个指定节点的最近公共祖先<br>找出最长连续序列的长度：通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列<br>四数相加（HashMap存一组，另一组和HashMap进行比对）<br>最长不含重复字符的子字符串  </p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>1.二叉树的遍历 （前中后、层序遍历）<br>非递归遍历要用栈来实现<br>二叉树的广度优先搜索 （同一层用队列存储）<br>二叉树的深度优先搜索 （就是前中后遍历）<br>判断是不是二叉树的子结构，就是判断 、根、左、右，都相同<br>二叉树的镜像，本质就是遍历交换，同翻转二叉树<br>对称二叉树，就是在递归的时候判断左右根节点是不是相同<br>从上到下打印二叉树：就是把节点放到队列里，然后遍历队列打印<br>之子型打印就是判断队列里面数量基数还是偶数<br>二叉树和为某一值的路径：就是递归判断是不是减到0了且左右节点都是null了就是路径<br>二叉搜索树一定是中序遍历，跟链表组合考察，二叉搜索树的排序，就是中序遍历<br>序列化二叉树，反序列化二叉树<br>二叉树的深度，递归左右节点，最大值加1<br>二叉搜索树树的最近公共祖先：hashMap、递归祖先的左右节点<br>建立最小高度树，通过2分形式递归创建左右子树节点<br>合法二叉搜索树，判断左 右 根节点的大小关系<br>二叉树中最大路径和：递归左右节点，然后加起来最大的值<br>合并二叉树：递归合并值<br>重建二叉搜索树：<br>树的子结构 ：先序遍历树 A 中的每个节点 n，判断树 A 中 以 n  为根节点的子树 是否包含树 B<br>二叉搜索树的第k大节点  ：中序遍历，从小到大<br>平衡二叉树：任意节点的左右子树的深度相差不超过1，后序遍历 + 剪枝，或者从上到下，判断深度是否大于1<br>二叉树的最近公共祖先：后序遍历</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>必须使用被用指针指向源链表再递归<br>链表和栈组合使用<br>从尾到头打印链表：采用栈后入先出的特点进行打印<br>链表翻转：分别交换指针和值<br>删除节点：指向next的next<br>链表中倒数第k个元素：双指针，当快指针到达终点时，慢指针所在的就是k的元素<br>合并两个排序的链表：判断值，创建新的链表时先创建一个值为0的链表，返回这个链表的next<br>两个链表的第一个公共链表。跑马场套圈的原理，当a=null时把b赋给a直到a=b<br>复杂链表的复制：采用hashmap存储节点，然后再遍历复制random<br>链表相交：跑马场<br>环形链表：hashMap判断，双指针两倍的速度判断<br>回文链表：两倍速度找到中间，然后翻转另一半<br>旋转链表：先闭合链表，然后旋转后再开环<br>排序链表：归并排序，分割链表，然后再合并<br>奇偶链表：将奇节点放在一个链表里，偶链表放在另一个链表里。然后把偶链表接在奇链表的尾部。<br>链表的中间节点：快慢指针<br>排序链表：分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；合并 merge 环节： 将两个排序链表合并，转化为一个排序链表</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>一般会用到辅助栈<br>用辅助栈来确定最大最小值（辅助栈是一个递增递减的序列）保证pop后也能完整<br>用栈来实现队列：辅助栈来翻转<br>栈的压入和弹出序列先遍历，先push再判断是欧能够弹出至空<br>队列实现栈：双队列<br>汉诺塔：三个交换<br>实现一个基本的计算器：先把乘除法的值计算出来，最终将所有的运算简化成只有加法，将表达式转为后缀</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>栈实现队列：两个队列，删除时候将两个队列顺序进行交换<br>数据流的中位数：优先队列（大小堆）返回堆顶的平均数<br>滑动窗口最大值：双端队列，控制删除，那么为了维持从大到小的原则，我必须让尾部元素弹出<br>队列最大值：定义max队列，递增的队列</p>
<h2 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h2><p>寻找峰值：如果小了就是峰值，否则是最后一个元素<br>二分左右区间写法<br>在排序数组中查找数字 I<br>0-n中缺失的数字：二分<br>旋转数组的最小数字<br>在排序数组中查找数字<br>插入排序<br>归并排序<br>快速排序<br>最大最小k个数：大顶椎、小顶椎，优先排序<br>数据流中的中位数 ：大顶椎、小顶椎，优先排序</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字母异位词 排序或者通过数组存储减a后的数字，通过加减平衡<br>是否可以被拆分：集合存储拆分后的数据，遍历，然后判断<br>第一个不重复的字符串，通过HashMap，存储key和出现次数<br>字符串翻转：转成char数组，翻转数组<br>回文串验证：双指针<br>左旋转字符串：字符串切割拼接<br>翻转单词顺序：按空格分割字符串，然后倒序输出<br>最长不含重复字串：双指针+hash<br>把数字翻译成字符串：<br>替换空格：3倍字符char数组<br>字符串的排列方式：深度优先+交换<br>字符串转整数：线性判断情况<br>数据压缩：StringBuilder 线性<br>无重复子串最大长度：hash指针移动<br>最大上升子序列：额外创建数组存放字符串到当前位置最大值<br>正则表达式匹配：线性遍历，分成空正则和非空正则两种<br>表示数值的字符串 ：用hashmap存储9中状态的情况，然后遍历<br>逆波兰表达式是一种后缀表达式</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>旋转数组：一个石另外开辟数组进行复制，另一个是多次旋转数组<br>调整数字顺序使奇数位于偶数前面：双指针，遇到奇数++，遇到偶数–，然后交换<br>数组中出现次数超过一半的数字 ：哈希，排序，摩尔投票法<br>连续子数组的最大和 ：动态规划，变成线性，然后求最大值<br>1～n整数中1出现的次数：进制判读，迭代<br>数字序列中某一位的数字：与上面相似<br>排序数组和为s的两个数字：双指针<br>数组交集：hash，排序<br>首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。<br>为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集<br>波兰逆序表达式：数组栈使用<br>除自身以外数组的乘积：生成左右乘积列表<br>和为s的连续正数序列：滑动窗口，左右边界移动<br>滑动窗口的最大值 ：最小堆队列，每次替换<br>将数组中所有 0 移动到数组末尾：空间优化，第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]，所以第二次遍历把末尾的元素都赋为0即可<br>递增二维数组中的查找 ：双指针，定位到二维数组的右上角，然后横向竖向的判断大小，进行加加或者减减<br>顺时针打印矩阵：定义4个顶点的坐标位置left、right、top、bottom，到达边界时停止转换方向，遍历完毕后，四个顶点位置进行内缩<br>数组中的逆序对 ：递归、二分查找不断缩小左右边界，直至left = right<br>寻找峰值：线性扫描、递归二分查找、<br>找出最长连续序列的长度：方法一：哈希表、方法一：动态规划 + 滚动数组</p>
<h2 id="异或数字进制"><a href="#异或数字进制" class="headerlink" title="异或数字进制"></a>异或数字进制</h2><p>二进制中1的个数  n &amp;= n - 1;<br>1～n整数中1出现的次数  ：10的计算<br>数字序列中某一位的数字  ： 迭代 + 求整 / 求余<br>把数组排成最小的数  ：本质上是一个排序问题，自定义排序，快排思想不占用空间<br>把数字翻译成字符串 ：本质上是25进制，可以把这两位连起来翻译<br>丑数：只包含质因子 2、3 和 5 的数称作丑数，算dp<br>数组中数字出现的次数：分组异或<br>圆圈中最后剩下的数字  ：约瑟夫环问题：总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。<br>求1+2+…+n ：return n == 0 ? 0 : n + sumNums(n - 1);<br>不用加减乘除做加法  int c = (a &amp; b) &lt;&lt; 1;  // c = 进位 a ^= b; // a = 非进位和<br>构建乘积数组 b[i] = b[i - 1] * a[i - 1];<br>把字符串转换成整数 ： 三种情况，即 ‘+’−’’ , ‘’无符号” ；新建一个变量保存符号位，返回前判断正负即可。<br>四数相加：采用分为两组，HashMap存一组，另一组和HashMap进行比对。<br>颠倒给定的 32 位无符号整数的二进制位：解法1 取模求和、解法2 按位翻转、解法3:分治合并</p>
<h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>斐波那契数列：递归和动态规划<br>青蛙跳台阶问题 ：同斐波那契数列<br>剪绳子 ：最优3等分，次优，剩下个2。最差，剩下个1<br>深度优先搜索<br>矩阵中的路径 （不能回退）<br>广度优先搜索<br>机器人的运动范围  （不能碰触）<br>快速幂解析：分治思想（2的8次方等于 2的2次方 乘 2的2次方 乘 2的2次方 乘 2的2次方 ）<br>连续子数组的最大和：动态规划线性<br>礼物的最大价值：每次 向右 或者 向下 移动一格<br>最长不含重复字符的子字符串 ：动态+hash。dp 的更新<br>n个骰子的点数 ：找出状态转移方程，构造dp数组，一个骰子的点数概率数组显然是6个六分之一,不需要另设数组<br>扑克牌中的顺子5张：集合 Set + 遍历，排序，判断是否大于5<br>股票的最大利润  ：状态方程profit = Math.max(profit, price - cost);<br>凑零钱问题：不过是一个 N 叉树的遍历问题而已，其实很多动态规划问题就是在遍历一棵树，你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路。<br> N 皇后问题：N 叉树的遍历框架<br>乘积最大子数组：遍历数组时计算当前最大值，不断更新<br>全排列问题：做选择、进入下一层决策树、取消选择</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">338</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
