<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/34/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/34/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/31/D_Net9IOS%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/31/D_Net9IOS%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">Info.plist,pch,UIApplication,IOS程序的启动过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-31 18:07:03" itemprop="dateCreated datePublished" datetime="2016-07-31T18:07:03+08:00">2016-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Info.plist</p>
</blockquote>
<p>● 建立一个工程后,会在Supporting files文件夹下看到一个“工程名-Info.plist”的文件,该文 件对工程做一些运行期的配置,非常重要,不能删除<br>● 在旧版本Xcode创建的工程中,这个配置文件的名字就叫“Info.plist”<br>● 项目中其他Plist文件不能带有“Info”这个字眼,不然会被错认为是传说中非常重要<br>的“Info.plist”<br>● 项目中还有一个InfoPlist.strings的文件,跟Info.plist文件的本地化相关<br>● 常见属性(红色部分是用文本编辑器打开时看到的key)<br>● Localiztion native development region(CFBundleDevelopmentRegion)-本地化相关<br>● Bundle display name(CFBundleDisplayName)-程序安装后显示的名称,限制在10-12个字 符,如果超出,将被显示缩写名称<br>● Icon file(CFBundleIconFile)-app图标名称,一般为Icon.png<br>● Bundle version(CFBundleVersion)-应用程序的版本号,每次往App Store上发布一个新版<br>本时,需要增加这个版本号<br>● Main storyboard file base name(NSMainStoryboardFile)-主storyboard文件的名称<br>● Bundle identifier(CFBundleIdentifier)-项目的唯一标识,部署到真机时用到</p>
<blockquote>
<p>pch文件</p>
</blockquote>
<p>● 项目的Supporting files文件夹下面有个“工程名-Prefix.pch”文件,也是一个头文件<br>● pch头文件的内容能被项目中的其他所有源文件共享和访问<br>● 一般在pch文件中定义一些全局的宏<br>● 在pch文件中添加下列预处理指令,然后在项目中使用Log(…)来输出日志信息,就可以 在发布应用的时候,一次性将NSLog语句移除(在调试模式下,才有定义DEBUG)<br>#ifdef DEBUG<br>#define Log(…) NSLog(<strong>VA_ARGS</strong>)<br>#else<br>#define Log(…) /* */<br>#endif</p>
<blockquote>
<p>UIApplication</p>
</blockquote>
<p>● UIApplication对象是应用程序的象征<br>● 每一个应用都有自己的UIApplication对象,而且是单例的<br>● 通过[UIApplication sharedApplication]可以获得这个单例对象<br>● 一个iOS程序启动后创建的第一个对象就是UIApplication对象<br>● 利用UIApplication对象,能进行一些应用级别的操作<br> UIApplication的常用属性<br>● 设置应用程序图标右上角的红色提醒数字<br>@property(nonatomic) NSInteger applicationIconBadgeNumber;<br>● 设置联网指示器的可见性 @property(nonatomic,getter=isNetworkActivityIndicatorVisible)<br>BOOL networkActivityIndicatorVisible;<br>iOS7中的状态栏<br>● 从iOS7开始,系统提供了2种管理状态栏的方式<br>➢ 通过UIViewController管理(每一个UIViewController都可以拥有自己不同的状<br>态栏)<br>➢ 通过UIApplication管理(一个应用程序的状态栏都由它统一管理)<br>● 在iOS7中,默认情况下,状态栏都是由UIViewController管理 的,UIViewController实现下列方法就可以轻松管理状态栏的可见性和样式<br>➢ 状态栏的样式</p>
<ul>
<li>(UIStatusBarStyle)preferredStatusBarStyle;<br>➢ 状态栏的可见性</li>
<li>(BOOL)prefersStatusBarHidden;<br>利用UIApplication来管理状态栏<br>● 如果想利用UIApplication来管理状态栏,首先得修改Info.plist的设置<br>● UIApplication有个功能十分强大的openURL:方法 - (BOOL)openURL:(NSURL*)url;<br>● openURL:方法的部分功能有<br>➢ 打电话<br>UIApplication *app = [UIApplication sharedApplication]; [app openURL:[NSURL URLWithString:@”tel://10086”]];<br>➢ 发短信<br>[app openURL:[NSURL URLWithString:@”sms://10086”]];<br>➢ 发邮件<br>[app openURL:[NSURL URLWithString:@”mailto://12345@qq.com”]];<br>➢ 打开一个网页资源<br>[app openURL:[NSURL URLWithString:@”<a href="http://ios.itcast.cn&quot;]]">http://ios.itcast.cn&quot;]]</a>;<br>➢ 打开其他app程序<br>UIApplication和delegate<br>● 所有的移动操作系统都有个致命的缺点:app很容易受到打扰。比如一个来电或者锁屏 会导致app进入后台甚至被终止<br>● 还有很多其它类似的情况会导致app受到干扰,在app受到干扰时,会产生一些系统事 件,这时UIApplication会通知它的delegate对象,让delegate代理来处理这些系统事件<br>● delegate可处理的事件包括:<br>➢ 应用程序的生命周期事件(如程序启动和关闭) ➢ 系统事件(如来电)<br>➢ 内存警告<br>➢……<br>UIApplication和delegate<br>// app接收到内存警告时调用 UIApplicationDelegate协议</li>
<li>(void)applicationDidReceiveMemoryWarning:(UIApplication *)application; // app进入后台时调用(比如按了home键)</li>
<li>(void)applicationDidEnterBackground:(UIApplication *)application;<br>// app启动完毕时调用</li>
<li>(BOOL)application:(UIApplication *)application<br>didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;<br>遵守协议,实现相应的方法<br>某个对象<br>id<UIApplicationDelegate> delegate UIApplication<br>UIApplicationDelegate<br>● 每次新建完项目,都有个带有“AppDelegate”字眼的类,它就是UIApplication的代理<br>● HMAppDelegate默认已经遵守了UIApplicationDelegate协议,已经 是UIApplication的代理<blockquote>
<p>iOS程序的启动过程</p>
</blockquote>
</li>
</ul>
<p>程序加载完毕<br>程序获取焦点<br>程序进入后台<br>程序失去焦点<br>程序从后台回到前 台<br>内存警告,可能要<br>终止程序<br>程序即将退出<br>打开程序<br>执行main函数 执行UIApplicationMain函数<br>初始化UIApplication(创建和设置代 理对象,开启事件循环)<br>监听系统事件<br>结束程序<br>UIApplication代理 application:<br>didFinishLaunchingWithOptions:<br>applicationDidBecomeActive:<br>applicationDidEnterBackground:<br>applicationWillResignActive:<br>applicationWillEnter Foreground:<br>applicationDidReceiveMemory Warning:<br>applicationWillTerminate:</p>
<p>● main函数中执行了一个UIApplicationMain这个函数<br>● intUIApplicationMain(intargc,char*argv[],NSString<br><em>principalClassName, NSString <em>delegateClassName); ➢ argc、argv:直接传递给UIApplicationMain进行相关处理即可<br>➢ principalClassName:指定应用程序类名(app的象征),该类必须是UIApplication(或子 类)。如果为nil,则用UIApplication类作为默认值<br>➢ delegateClassName:指定应用程序的代理类,该类必须遵守UIApplicationDelegate协 议<br>UIApplicationMain<br>● UIApplicationMain函数会根据principalClassName创建UIApplication对象,根 据delegateClassName创建一个delegate对象,并将该delegate对象赋值给UIApplication对象 中的delegate属性<br>● 接着会建立应用程序的Main Runloop(事件循环),进行事件的处理(首先会在程序完毕后调 用delegate对象的application:didFinishLaunchingWithOptions:方法)<br>● 程序正常退出时UIApplicationMain函数才返回<br>UIWindow<br>● UIWindow是一种特殊的UIView,通常在一个app中只会有一个UIWindow<br>● iOS程序启动完毕后,创建的第一个视图控件就是UIWindow,接着创建控制器的view,<br>最后将控制器的view添加到UIWindow上,于是控制器的view就显示在屏幕上了 ● 一个iOS程序之所以能显示到屏幕上,完全是因为它有UIWindow<br>● 也就说,没有UIWindow,就看不见任何UI界面<br>UIView<br>UIWindow<br>UIViewController<br>view<br>UIWindow<br>● 添加UIView到UIWindow中两种常见方式:<br>➢ -(void)addSubview:(UIView</em>)view; 直接将view添加到UIWindow中,但并不会理会view对应的UIViewController<br>➢ @property(nonatomic,retain)UIViewController</em>rootViewController; 自动将rootViewController的view添加到UIWindow中,负责管理rootViewController<br>的生命周期<br>● 常用方法<br>➢ -(void)makeKeyWindow; 让当前UIWindow变成keyWindow(主窗口)<br>➢ -(void)makeKeyAndVisible; 让当前UIWindow变成keyWindow,并显示出来<br> UIWindow的获得<br>● [UIApplicationsharedApplication].windows 在本应用中打开的UIWindow列表,这样就可以接触应用中的任何一个UIView对象 (平时输入文字弹出的键盘,就处在一个新的UIWindow中)<br>● [UIApplicationsharedApplication].keyWindow<br>用来接收键盘以及非触摸类的消息事件的UIWindow,而且程序中每个时刻只能有一 个UIWindow是keyWindow。如果某个UIWindow内部的文本框不能输入文字,可能是因为这 个UIWindow不是keyWindow<br>● view.window 获得某个UIView所在的UIWindow</p>
<blockquote>
<p>四大对象关系图</p>
</blockquote>
<p>UIApplication<br>delegate<br>HMAppDelegate<br>window<br>UIViewController<br>view<br>UIWindow<br>rootViewController<br>xib\storyboard\代码</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/31/D_Net8UIDynamic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/31/D_Net8UIDynamic/" class="post-title-link" itemprop="url">UIDynamic</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-31 18:00:49" itemprop="dateCreated datePublished" datetime="2016-07-31T18:00:49+08:00">2016-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>简单介绍</p>
</blockquote>
<p>1.什么是UIDynamic<br>UIDynamic是从iOS 7开始引入的一种新技术，隶属于UIKit框架<br>可以认为是一种物理引擎，能模拟和仿真现实生活中的物理现象<br>如：重力、弹性碰撞等现象<br> <br>2.物理引擎的价值<br>广泛用于游戏开发，经典成功案例是“愤怒的小鸟”<br>让开发人员可以在远离物理学公式的情况下，实现炫酷的物理仿真效果<br>提高了游戏开发效率，产生更多优秀好玩的物理仿真游戏<br> <br>3.知名的2D物理引擎<br>Box2d<br>Chipmunk
 </p>
<blockquote>
<p>使用步骤</p>
</blockquote>
<p>要想使用UIDynamic来实现物理仿真效果，大致的步骤如下<br>（1）创建一个物理仿真器（顺便设置仿真范围）<br>（2）创建相应的物理仿真行为（顺便添加物理仿真元素）<br>（3）将物理仿真行为添加到物理仿真器中  开始仿真
 </p>
<blockquote>
<p>相关说明</p>
</blockquote>
<p>1.三个概念<br>（1）谁要进行物理仿真？<br>　　物理仿真元素（Dynamic Item）<br> <br>（2）执行怎样的物理仿真效果？怎样的动画效果？<br>　　物理仿真行为（Dynamic Behavior） <br> <br>（3）让物理仿真元素执行具体的物理仿真行为<br>　　物理仿真器（Dynamic Animator）<br> <br>2.物理仿真元素<br>注意：<br>不是任何对象都能做物理仿真元素<br>不是任何对象都能进行物理仿真<br> <br>物理仿真元素要素：<br>任何遵守了UIDynamicItem协议的对象<br>UIView默认已经遵守了UIDynamicItem协议，因此任何UI控件都能做物理仿真<br>UICollectionViewLayoutAttributes类默认也遵守UIDynamicItem协议<br> <br>3.物理仿真行为<br>（1）UIDynamic提供了以下几种物理仿真行为<br>UIGravityBehavior：重力行为<br>UICollisionBehavior：碰撞行为<br>UISnapBehavior：捕捉行为<br>UIPushBehavior：推动行为<br>UIAttachmentBehavior：附着行为<br>UIDynamicItemBehavior：动力元素行为<br> <br>（2）物理仿真行为须知<br>上述所有物理仿真行为都继承自UIDynamicBehavior<br>所有的UIDynamicBehavior都可以独立进行<br>组合使用多种行为时，可以实现一些比较复杂的效果<br> <br> <br>4.物理仿真器<br>（1）物理仿真器须知<br>它可以让物理仿真元素执行物理仿真行为<br>它是UIDynamicAnimator类型的对象<br> <br>（2）UIDynamicAnimator的初始化</p>
<ul>
<li>(instancetype)initWithReferenceView:(UIView *)view;<br>view参数：是一个参照视图，表示物理仿真的范围
 </li>
</ul>
<p>5.物理仿真器的说明<br>（1）UIDynamicAnimator的常见方法<br>　　- (void)addBehavior:(UIDynamicBehavior <em>)behavior;  　　//添加1个物理仿真行为<br>　　- (void)removeBehavior:(UIDynamicBehavior <em>)behavior;　　//移除1个物理仿真行为<br>　　- (void)removeAllBehaviors;  　　//移除之前添加过的所有物理仿真行为<br> <br>（2）UIDynamicAnimator的常见属性<br>　　@property (nonatomic, readonly) UIView</em> referenceView;  //参照视图 <br>　　@property (nonatomic, readonly, copy) NSArray</em> behaviors;//添加到物理仿真器中的所有物理仿真行为<br>　　@property (nonatomic, readonly, getter = isRunning) BOOL running;//是否正在进行物理仿真<br>　　@property (nonatomic, assign) id <UIDynamicAnimatorDelegate> delegate;//代理对象（能监听物理仿真器的仿真过程，比如开始和结束）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/31/D_Net7SVN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/31/D_Net7SVN/" class="post-title-link" itemprop="url">svn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-31 17:57:27" itemprop="dateCreated datePublished" datetime="2016-07-31T17:57:27+08:00">2016-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>介绍</p>
</blockquote>
<p>svn 是多人协同开发的代码管理器,是从大名鼎鼎的代码管理器 CVS 演变<br>而来,当然除了 svn 外,还有一个流行的代码管理器 git,但是企业中大多喜欢 用 svn,原因是 svn 具有很强的文档目录权限管理,而 git 在开源社区非常流行, git 没有权限管理。</p>
<blockquote>
<p>svn 服务端和客户端模型</p>
</blockquote>
<p>svn 分为客户端和服务器端 2 中,对于一般开发人员主要使用使用 svn 客户<br>端,对于项目经理或者 IT 维护组需要进行 svn 服务器端进行诸如代码备份, merge 等操作。<br>对于 iOS 开发,svn 使用有 2 种。读者个人趋向于 svn 命令行使用 当然更多推荐使用工具 Version: <a target="_blank" rel="noopener" href="http://192.168.88.8/download/softwares/svn">http://192.168.88.8/download/softwares/svn</a> 工具/Versions02.zip 网页版本: <a target="_blank" rel="noopener" href="http://192.168.88.10/svn">http://192.168.88.10/svn</a><br>不推荐大家使用 Xcode 自带的 SVN 工具<br>对于 Versions 不能加入.a 静态库的解决方案<br>编辑 vi <del>/.subversion/config<br>找到以 global-ignores 开头的行, 然后去掉里面的 *.a 即可<br>global-ignores = *.o *.lo *.la *.al .libs *.so <em>.so.[0-9]</em> *.pyc *.pyo *</del>.nib *.so *.pbxuser <em>.mode</em> <em>.perspective</em> .DS_Store xcuserdata project.xcworkspace<br>3. svn操作命令之通用参数<br>–username yang<br>–password 123456 如果没有用户名和密码就不用此参数<br>4. svn操作命令之下载checkout(co) svn checkout<br>svn checkout 是下载代码库<br>-r 18下载18号版本 例子 1.<br>svn –username yang –password 123456<br>checkout <a target="_blank" rel="noopener" href="http://1000phone.cn/stuproj/ios1212">http://1000phone.cn/stuproj/ios1212</a><br>下载完成后会在当前目录中创建 ios1212 目录<br>例子 2.<br>svn –username yang –password 123456<br>checkout <a target="_blank" rel="noopener" href="http://1000phone.cn/stuproj/ios1212">http://1000phone.cn/stuproj/ios1212</a> myios1212 svn –username yang –password 123456<br>checkout -r18 <a target="_blank" rel="noopener" href="http://1000phone.cn/stuproj/ios1212">http://1000phone.cn/stuproj/ios1212</a><br>下载完成后会在当前目录中创建 myios1212 目录<br>上述 <a target="_blank" rel="noopener" href="http://1000phone.cn/stuproj/ios1212">http://1000phone.cn/stuproj/ios1212</a> 是代码服务器网址 这里 checkout 也可以写成 co<br>5. svn操作命令之查看信息info 比如 svn info<br>svn info 是查看版本信息<br>localhost:ios1212 yang$ svn info<br>Path: .<br>URL: <a target="_blank" rel="noopener" href="http://1000phone.cn/stuproj/ios1212">http://1000phone.cn/stuproj/ios1212</a><br>Repository Root: <a target="_blank" rel="noopener" href="http://1000phone.cn/stuproj">http://1000phone.cn/stuproj</a><br>Repository UUID: 489a8e6b-8e7d-4fdf-9695-3480148b3a5a Revision: 10<br>Node Kind: directory<br>Schedule: normal<br>Last Changed Author: yang<br>Last Changed Rev: 3<br>Last Changed Date: 2012-11-19 17:28:36 +0800 (Mon, 19 Nov 2012)<br>6. svn操作命令之查看版本日志信息log svn log<br>svn log 会显示该目录下面所有的版本信息,按照时间倒序排列 如下面显示:</p>
<hr>
<p>r1123 | oyangjian | 2012-11-20 21:25:10 +0800 (二, 2012-11-20) | 4 行<br>增加了 addsvnuser<br>M common_db.php</p>
<hr>
<p>r1122 | oyangjian | 2012-11-20 21:24:35 +0800 (二, 2012-11-20) | 4 行<br>解决了乱码问题<br>M showcompileinfo.php</p>
<hr>
<p>r1121 | oyangjian | 2012-11-20 21:23:13 +0800 (二, 2012-11-20) | 4 行<br>FIX 了修改密码错误情况 M register.php<br>7. svn操作命令之增加文件add<br>用法例子(在 xcode 增加文件自动会增加,在 xcode 中写程序不用) svn add RootViewController.m<br>把 RootViewController.m 文件加入到本地的代码库中<br>8. svn操作命令之删除文件或者文件夹delete 用法例子(在 xcode 增加文件自动会增加,在 xcode 中写程序不用)<br>svn delete RootViewController.m 在本地代码库中删除 RootViewController.m 文件<br>9. svn操作命令之改名文件mv svn mv test.m Car.m<br>(在 xcode 增加文件自动会增加,在 xcode 中写程序不用) 在本地把 test.m 文件修改成 Car.m 文件<br>M M A A<br>Demo/Demo.xcodeproj/project.pbxproj<br>Demo/Demo/AppDelegate.m Demo/Demo/RootViewController.h Demo/Demo/RootViewController.m<br>注意上面的 add delete mv 都是在本地代码库中修改<br>10. svn操作命令之提交变化commit 把本地代码库中所有的修改的内容同步到服务器中 注意不同步的话,本地的修改不能反映到服务器上<br>svn –username yang –password 123456 commit<br>11. svn操作命令之同步服务器内容update 把服务器最新版本同步到本地来<br>svn update<br>12 svn操作命令之查看patch文件diff<br>查看任意 2 个版本之间的差异 svn diff –r18:29<br>13 svn操作命令之查看状态status localhost:yang1212 yang$ svn status<br>14 svn操作命令之创建目录mkdir svn –username yang –password 123456<br>mkdir <a target="_blank" rel="noopener" href="http://1000phone.cn/stuproj/ios1212/test1234">http://1000phone.cn/stuproj/ios1212/test1234</a> 在服务器 ios1212 目录上创建子目录 test1234<br>15 svn操作命令之导入项目import svn –username yang –password 123456<br>import myproject <a target="_blank" rel="noopener" href="http://1000phone.cn/stuproj/ios1212/myproject2">http://1000phone.cn/stuproj/ios1212/myproject2</a> 在本机的 myporject 目录传到服务器 ios1212 目录上并且改</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/31/D_Net5KVC%E5%92%8CKVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/31/D_Net5KVC%E5%92%8CKVO/" class="post-title-link" itemprop="url">KVC和KVO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-31 00:17:42" itemprop="dateCreated datePublished" datetime="2016-07-31T00:17:42+08:00">2016-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p> 什么是KVC?<br>//  Key Value Coding的简写, 称为键值编码<br>//  作用: 访问对象中属性的一种方式, 通过字符串为关键字访问属性</p>
</blockquote>
<blockquote>
<p>KVC的基本使用<br>//  问题: setValue:forUndefinedKey:</p>
</blockquote>
<blockquote>
<p>KeyPath的使用</p>
</blockquote>
<p>// 4.常用方法<br>//  setValuesForKeysWithDictionary:</p>
<p>//总结: 开发中常用<br>//1. setValuesForKeysWithDictionary方法<br>//2. 当对象没有对应属性出现错误怎么解决</p>
<p>//KVC常用用途把网络上字典转化为model<br>NSDictionary *dict = @{@”speed”:@(100),@”temp”:@”test”};<br>for(NSString *key in dict)<br>{<br>[car setValue:dict[key] forKey:key];<br>}</p>
<p>//设置car中engine对象的power属性<br>[car setValue:@(100) forKeyPath:@”engine.power”];</p>
<p>//把字典中各个属性的值赋给对象对应的属性或实例变量<br>[car setValuesForKeysWithDictionary:dict2];</p>
<blockquote>
<p>什么是KVO</p>
</blockquote>
<p>//  Key Value Observing的简写, 键值监听<br>//  作用: 需要监视一个属性的变化, 变化了之后做出处理</p>
<blockquote>
<p>KVO的基本使用</p>
</blockquote>
<p>// 常用<br>//  项目监听一个属性的变化, 并在界面上显示, 使用KVO<br>//  实例: 监听和显示下载进度<br>//KVO<br>//效果: 当speed有了变化之后执行self中observeValueForKeyPath方法<br>[car addObserver:self forKeyPath:@”speed” options:NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:nil];<br>监听的实现<br>-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context<br>{<br>double newSpeed = [[object valueForKeyPath:keyPath] doubleValue];</p>
<p>NSLog(@”newSpeed = %f”,newSpeed);<br>}<br>程序完成的时候要移除监听<br>-(void)dealloc<br>{<br>//移除监听<br>//[car removeObserver:self forKeyPath:@”speed”];<br>}</p>
<p>KVC 与 KVO 是 Objective C 的关键概念，个人认为必须理解的东西，下面是实例讲解。<br>Key-Value Coding (KVC)<br>KVC，即是指 NSKeyValueCoding，一个非正式的 Protocol，提供一种机制来间接访问对象的属性。KVO 就是基于 KVC 实现的关键技术之一。<br>一个对象拥有某些属性。比如说，一个 Person 对象有一个 name 和一个 address 属性。以 KVC 说法，Person 对象分别有一个 value 对应他的 name 和 address 的 key。 key 只是一个字符串，它对应的值可以是任意类型的对象。从最基础的层次上看，KVC 有两个方法：一个是设置 key 的值，另一个是获取 key 的值。如下面的例子：</p>
<p>KVO这种编码方式使用起来很简单，很适用与datamodel修改后，引发的UIVIew的变化这种情况，就像上边的例子那样，当更改属性的值后，监听对象会立即得到通知。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/31/D_Net3GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/31/D_Net3GCD/" class="post-title-link" itemprop="url">GCD</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-31 00:14:53" itemprop="dateCreated datePublished" datetime="2016-07-31T00:14:53+08:00">2016-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>什么是GCD</p>
</blockquote>
<p>Grand Central Dispach–<br>好用：1.简单<br>基于block c函数接口<br>功能强大：支持多核心编程<br>支持高级编程功能</p>
<blockquote>
<p>创建和使用</p>
</blockquote>
<p>dispatch_queue_t queue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>
<blockquote>
<p>创建和使用</p>
</blockquote>
<p>//开启一个新的线程<br>//queue<br>//三种：main——queue主线程队列<br>//globle——queue全局队列。异步任务加载这里<br>//自定义的<br>dispatch_queue_t queue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>dispatch_async(queue, ^{<br>for (int i=0; i&lt;100; i++)<br>{<br>NSLog(@”A=%d”,i);<br>}<br>});<br>dispatch_async(queue, ^{<br>for (int i=0; i&lt;100; i++)<br>{<br>NSLog(@”B=%d”,i);<br>}<br>});</p>
<blockquote>
<p>模拟网络数据下载</p>
</blockquote>
<p>[self simulaterNetworkDataDownload];</p>
<blockquote>
<p>延迟执行，延时5s执行</p>
</blockquote>
<p>[self delayRunCode];</p>
<blockquote>
<p>有的代码指向执行一次</p>
</blockquote>
<p>[self runOneCode];<br>[self runOneCode];<br>[self runOneCode];<br>[self runOneCode];</p>
<blockquote>
<p>多个任务同时执行，等待所有任务结束</p>
</blockquote>
<p>//    模拟迅雷多路下载后关机<br>[self simulaterThreadDownload];</p>
<p>}<br>-(void)simulaterThreadDownload<br>{<br>dispatch_group_t group=dispatch_group_create();</p>
<p>//任务添加<br>dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>for (int i=0; i&lt;30; i++)<br>{<br>NSLog(@” B=%d”,i);<br>[NSThread sleepForTimeInterval:0.1];<br>}<br>});<br>//先是所有任务执行完成<br>dispatch_group_notify(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>NSLog(@”所有的任务执行完成”);<br>});<br>}<br>-(void)runOneCode<br>{<br>static dispatch_once_t onceToken;<br>dispatch_once(&amp;onceToken, ^{<br>NSLog(@”这句话我只说一次”);<br>});<br>}<br>-(void)delayRunCode<br>{<br>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{<br>NSLog(@”我是一只小小小小鸟,永远永远也飞不高”);<br>});</p>
<p>}<br>-(void)simulaterNetworkDataDownload<br>{<br>_progressView=[[UIProgressView alloc]initWithFrame:CGRectMake(10, 100, 300, 20)];<br>[self.view addSubview:_progressView];<br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>for (int i=0; i&lt;100; i++)<br>{<br>注意：不要再主线程里更新UI<br>//            _progressView.progress+=0.01;</p>
<p>dispatch_async(dispatch_get_main_queue(), ^{<br>_progressView.progress+=0.01;<br>});<br>[NSThread sleepForTimeInterval:0.1];<br>}<br>NSLog(@”下载完成”);<br>});</p>
<p>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/31/D_Net4AVAudioPlayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/31/D_Net4AVAudioPlayer/" class="post-title-link" itemprop="url">AVAudioPlayer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-31 00:14:33" itemprop="dateCreated datePublished" datetime="2016-07-31T00:14:33+08:00">2016-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>创建播放器对象</p>
</blockquote>
<p>NSString *path=[[NSBundle mainBundle]pathForResource:@”lalala.mp3” ofType:nil];<br>_player =[[AVAudioPlayer alloc]initWithContentsOfURL:[NSURL fileURLWithPath:path] error:nil];<br>//预加准备<br>[_player prepareToPlay];</p>
<p>//添加一个按钮：开始播放<br>[self.view addSystemButtonWithFrame:CGRectMake(100, 100, 100, 30) title:@”播放” action:^(UIButton *button) {<br>[_player play];<br>}];</p>
<p>//添加一个按钮：停止播放<br>[self.view addSystemButtonWithFrame:CGRectMake(100, 150, 100, 30) title:@”暂停” action:^(UIButton *button) {<br>[_player pause];<br>}];<br>//滑块控件<br>_slider=[[UISlider alloc]initWithFrame:CGRectMake(100, 200, 100, 30)];<br>[self.view addSubview:_slider];<br>[_slider addTarget:self action:@selector(dealSlider:) forControlEvents:UIControlEventValueChanged];<br>_slider.value=1;<br>进度条<br>_progressView=[[UIProgressView alloc]initWithFrame:CGRectMake(50, 50, 200, 20)];<br>[self.view addSubview:_progressView];<br>[NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(dealTimer:) userInfo:nil repeats:YES];</p>
<p>}</p>
<p>-(void)dealTimer:(NSTimer *)t<br>{<br>_progressView.progress=_player.currentTime / _player.duration;<br>}<br>-(void)dealSlider:(UISlider *)s<br>{<br>_player.volume=s.value;<br>}</p>
<blockquote>
<p>网络音乐的播放</p>
</blockquote>
<p>1.使用AudioStreamer.h开源库<br>配置开源库<br>创建对象<br>{<br>AudioStreamer *_streamer;<br>}</p>
<p>NSString *urlString=@”<a target="_blank" rel="noopener" href="http://music.baidu.com/data/music/file?link=http://yinyueshiting.baidu.com/data2/music/134378654/2191061104400128.mp3?xcode=ffd5ff02dfd6ef1a480aa81e262460cd6e2eede49a06f7cb&amp;song_id=2191061&quot;">http://music.baidu.com/data/music/file?link=http://yinyueshiting.baidu.com/data2/music/134378654/2191061104400128.mp3?xcode=ffd5ff02dfd6ef1a480aa81e262460cd6e2eede49a06f7cb&amp;song_id=2191061&quot;</a>;<br>//    如果是self调用时的警告可以<br>//    __weak UIViewController *vc=self;</p>
<p>__block typeof (_streamer) t=_streamer;</p>
<p>[self.view addSystemButtonWithFrame:CGRectMake(100, 100, 100, 30) title:@”播放” action:^(UIButton *button) {<br>t =[[AudioStreamer alloc]initWithURL:[NSURL URLWithString:urlString]];<br>[t start];<br>}];</p>
<blockquote>
<p>播放本地视频文件</p>
</blockquote>
<p>//1、配置<br>//添加mediaPlayer<br>//如何播放在线视频文件</p>
<p>#import “ViewController.h”</p>
<p>#import &lt;MediaPlayer/MediaPlayer.h&gt;</p>
<p>#import “UIView+ZJQuickControl.h”</p>
<ul>
<li>(void)viewDidLoad<br>{<br>[super viewDidLoad];</li>
</ul>
<p>[self.view addSystemButtonWithFrame:CGRectMake(100, 100, 100, 30) title:@”播放” action:^(UIButton *button) {</p>
<p>NSString *path=[[NSBundle mainBundle]pathForResource:@”dzs.mp4” ofType:nil];<br>MPMoviePlayerViewController *mpvc=[[MPMoviePlayerViewController alloc]initWithContentURL:[NSURL fileURLWithPath:path]];<br>[self presentViewController:mpvc animated:YES completion:nil];<br>}];</p>
<blockquote>
<p>播放在线视频</p>
</blockquote>
<p>//<a target="_blank" rel="noopener" href="http://quiet.local/baoman.mp4">http://quiet.local/baoman.mp4</a></p>
<p>[self.view addSystemButtonWithFrame:CGRectMake(100, 100, 100, 30) title:@”播放网络mp4” action:^(UIButton *button) {</p>
<p>NSString *path=@”<a target="_blank" rel="noopener" href="http://quiet.local/baoman.mp4&quot;">http://quiet.local/baoman.mp4&quot;</a>;<br>MPMoviePlayerViewController *mpvc=[[MPMoviePlayerViewController alloc]initWithContentURL:[NSURL URLWithString:path]];<br>[self presentViewController:mpvc animated:YES completion:nil];<br>}];</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/31/D_Net2NSOperation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/31/D_Net2NSOperation/" class="post-title-link" itemprop="url">NSOperation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-31 00:10:52" itemprop="dateCreated datePublished" datetime="2016-07-31T00:10:52+08:00">2016-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>NSOperation、NSOperationQueue</p>
</blockquote>
<p>//对于NSThread的封装，提供了更为方便的使用接口<br>//支持block</p>
<blockquote>
<p>创建和使用</p>
</blockquote>
<p>//最好不要直接使用===一般继承自己的类，然后再使用<br>//<br>//NSOperation *operation1=[[NSOperation alloc] init];<br>// 使用NSBlockOperation /NSInvocationOperation<br>NSBlockOperation *bo=[NSBlockOperation blockOperationWithBlock:^{<br>for (int i=0; i&lt;100; i++)<br>{<br>NSLog(@”A=%d”,i);<br>[NSThread sleepForTimeInterval:0.1];<br>}<br>}];<br>//启动<br>//    [bo start];<br>NSBlockOperation *bo2=[NSBlockOperation blockOperationWithBlock:^{<br>for (int i=0; i&lt;100; i++)<br>{<br>NSLog(@”A=%d”,i);<br>[NSThread sleepForTimeInterval:0.1];<br>}<br>}];<br>//启动<br>//    [bo2 start];<br>//操作队列   理解为：线程池<br>//注意：如果直接执行NSBlockOperation的花会在主线程中执行<br>//如果加到NSOperationQueue就会新开1个线程执行<br>NSOperationQueue *queue=[[NSOperationQueue alloc]init];<br>[queue addOperation:bo];<br>[queue addOperation:bo2];</p>
<p>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/31/D_Net1NSThread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/31/D_Net1NSThread/" class="post-title-link" itemprop="url">NSThread</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-31 00:08:41" itemprop="dateCreated datePublished" datetime="2016-07-31T00:08:41+08:00">2016-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>什么是NSThread？</p>
</blockquote>
<p>NSThread 是ios提供的操作和使用线程的一个类<br>线程：<br>进程：理解，活着的程序，是程序执行的一个操作系统实体</p>
<blockquote>
<p>NSThread的创建线程</p>
</blockquote>
<p>//每个线程执行对应一个方法<br>NSThread *thread1=[[NSThread alloc]initWithTarget:self selector:@selector(thread1:) object:nil];<br>//启动线程<br>[thread1 start];</p>
<p>//以类方法创建线程<br>//    [NSThread detachNewThreadSelector:@selector(dealThread2:) toTarget:self withObject:nil];<br>//可以实现同时执行的效果，以前都是先执行A后执行B，现在有了多线程，可以实现同时执行</p>
<blockquote>
<p>为什么要实行线程</p>
</blockquote>
<p>//UI界面中如果直接执行耗时任务的，界面会卡死，为了能让界面执行耗时任务的时候继续反应，使用新的线程去执行耗时任务<br>//应用场合：下载网络文件，同时执行多个任务，加载大文件，加载大数据<br>//3.为什么要实行线程<br>UIButton *button=[UIButton buttonWithType:UIButtonTypeSystem];<br>button.frame=CGRectMake(100, 100, 100, 30);<br>[button setTitle:@”耗时任务” forState:UIControlStateNormal];<br>[self.view addSubview:button];<br>[button addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];<br>-(void)btnClick:(UIButton *)button<br>{<br>    //暂停5秒<br>    //    [NSThread sleepForTimeInterval:5];<br>    //    [self dealThread2:nil];<br>    //    如果直接执行的话UI界面会卡死，没有反应<br>    //开启一个新的线程执行<br>    [NSThread detachNewThreadSelector:@selector(dealThread2:) toTarget:self withObject:nil];</p>
<p>}</p>
<p>//4.监控线程的执行完成<br>//如何知道那个线程执行接收，使用block–以后要学<br>//4.监控线程的执行完成<br>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(dealThreadExit:) name:NSThreadWillExitNotification object:nil];<br>-(void)dealThreadExit:(NSNotification *)no<br>{<br>    NSLog(@”线程执行完成”);<br>    NSLog(@”ui=%@”,no.userInfo);<br>}<br>//5.线程的控制，线程同步<br>//遇到情况：多个线程访问同一块数据<br>//如何解决：<br>//a+10   1.先从内存拿出，修改，再放回去<br>//访问数据的时候加锁<br>//5.线程的控制，线程同步<br>_lock=[[NSLock alloc]init];</p>
<p>[NSThread detachNewThreadSelector:@selector(addFunc:) toTarget:self withObject:nil];<br>[NSThread detachNewThreadSelector:@selector(subFunc) toTarget:self withObject:nil];</p>
<p>[self setAddBlock:^(NSString *mmm){<br>    NSLog(@”hbbbgeregour====%@”,mmm);<br>}];</p>
<p>#pragma mark - 线程同步<br>-(void)addFunc:(NSThread *)th<br>{<br>    for(int i=0;i&lt;1000;i++)<br>    {<br>        //加锁<br>        [_lock lock];<br>        _num++;<br>        [NSThread sleepForTimeInterval:0.001];<br>        //减锁<br>        [_lock unlock];</p>
<pre><code>&#125;
NSLog(@&quot;add num=%d&quot;,_num);
if (self.addBlock)
&#123;
    self.addBlock(@&quot;add&quot;);
&#125;
</code></pre>
<p>}<br>-(void)subFunc<br>{<br>    for(int i=0;i&lt;1000;i++)<br>    {<br>        //加锁<br>        //        [_lock lock];<br>        _num–;<br>        [NSThread sleepForTimeInterval:0.001];<br>        //减锁<br>        //        [_lock unlock];</p>
<pre><code>&#125;
NSLog(@&quot;sub num=%d&quot;,_num);
</code></pre>
<p>}</p>
<p>//6.UI主线程如何操作UI？<br>//ui主线程，<br>//    工作子线程<br>//    注意：不要在子线程中直接操作UI，交给主线程UI；<br>[self howToUpDateUIInSubThread];<br>-(void)howToUpDateUIInSubThread<br>{<br>    _progress =[[UIProgressView alloc]initWithFrame:CGRectMake(10, 200, 300, 20)];<br>    [self.view addSubview:_progress];<br>    //添加一个按钮<br>    UIButton *button=[UIButton buttonWithType:UIButtonTypeSystem];<br>    button.frame=CGRectMake(100, 300, 100, 30);<br>    [button setTitle:@”下载文件” forState:UIControlStateNormal];<br>    [self.view addSubview:button];<br>    [button addTarget:self action:@selector(startDownloadClick:) forControlEvents:UIControlEventTouchUpInside];<br>}<br>-(void)startDownloadClick:(UIButton *)button<br>{<br>    [NSThread detachNewThreadSelector:@selector(download:) toTarget:self withObject:nil];<br>}<br>-(void)download:(NSThread <em>)thread<br>{<br>    for(int i=0;i&lt;1000;i++)<br>    {<br>        //更新UI<br>        //        _progress.progress+=0.01;<br>        //在主线程中执行一个方法<br>        [self performSelectorOnMainThread:@selector(upDateUI) withObject:nil waitUntilDone:NO];<br>        [NSThread sleepForTimeInterval:0.001];<br>        NSLog(@”进度为%f%%”,_progress.progress</em>100);<br>    }<br>}<br>-(void)upDateUI<br>{<br>    _progress.progress+=0.001;<br>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/31/C_UI13UITableView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/31/C_UI13UITableView/" class="post-title-link" itemprop="url">UITableView</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-31 00:00:01" itemprop="dateCreated datePublished" datetime="2016-07-31T00:00:01+08:00">2016-07-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>我们为什么要实现单元格的复用机制</p>
</blockquote>
<p>单元格每一个cell的生成都是要init alloc的，所以当我们滑动表格试图的时候会生成很多cell，无异于浪费了大量的内存<br>单元格的复用机制原理<br>一开始的时候我们创建了桌面最多能显示的单元格数，cell<br>当我们向下滚动表格试图的时候，单元格上部的内容会消失，下部的内容会出现，这个时候我们将上部分消失的单元格赋给下部分出现的单元格<br>因此我们就做到了只生成了屏幕范围可显示的单元格个数，就实现滑动表格试图时，以后不会再init alloc单元格cell了，从而实现了节省内存的原理<br>单元格的复用机制<br>-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath<br>{</p>
<p>定义一个cell标示符，用以区分不同的cell<br>以后有不同风格的cell就可以使用了<br>static NSString *cellID=@”cell”;<br>从cell复用池中拿到可用的cell<br>UITableViewCell *cell=[tableView dequeueReusableCellWithIdentifier:cellID];<br>检测，拿到一个可用的cell<br>if(cell ==nil)<br>{<br>创建新的cell<br>cell=[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:cellID];<br>}</p>
<p>&lt;3&gt;显示分组数据<br>显示每段       多少section数据<br>-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView<br>{<br>return _dataArray.count;<br>}<br>告诉表格每段要显示多少行<br>重要参数：section每次传入制定序号<br>-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section<br>{<br>NSArray *array=_dataArray[section];<br>return array.count;<br>}</p>
<blockquote>
<p>单元格行的高度</p>
</blockquote>
<p>//通过这个方法可以指定任意行的高度。<br>-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath<br>{<br>    return 44.0f;<br>}</p>
<p>单元格的背景<br>单元格的内容视图contentView</p>
<blockquote>
<p>某行选中的事件处理</p>
</blockquote>
<p>-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath<br>{}<br>//某行被取消选中了<br>-(void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath<br>{<br>NSLog(@”被取消选中了”);<br>}</p>
<blockquote>
<p>添加头部视图和尾部视图</p>
</blockquote>
<p>//    添加头部试图<br>UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 320, 100)];<br>imageView.image=[UIImage imageNamed:@”fenjing.jpg”];<br>_tableView.tableHeaderView=imageView;<br>//    添加尾部试图<br>UIImageView *footImage=[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 320, 150)];<br>footImage.image=[UIImage imageNamed:@”head2.jpg”];<br>_tableView.tableFooterView=footImage;</p>
<blockquote>
<p>表格视图的编辑(难点)</p>
</blockquote>
<p>&lt;1&gt;单元格的删除操作[重点, 必须掌握]</p>
<p>&lt;2&gt;单元格的增加操作</p>
<p>&lt;3&gt;单元格的移动操作</p>
<p>&lt;4&gt;多行选中和多行删除操作</p>
<p>2.表格视图的设置</p>
<p>&lt;1&gt;设置表格的索引</p>
<p>&lt;2&gt;设置段头和段尾</p>
<p>&lt;3&gt;表格的分割线</p>
<p>3.表格视图的搜索</p>
<p>&lt;1&gt;添加搜索条 UISearchBar–&gt;tableHeaderView</p>
<p>4.表格视图控制器</p>
<blockquote>
<p>cell的定制</p>
</blockquote>
<p>1.我们使用MVC模式实现cell的定制。<br>什么是MVC模式<br>V是：VIew视图     作用：展示数据，接收用户交互<br>C是：Controller控制器<br>作用：负责把数据从Model中拿出来放到View上。<br>根据View的操作区修改数据。<br>M是：Model模型    作用：存储和表示数据</p>
<p>理解：简单理解为每个界面分为三层——Model，VIew，Controller<br>效果：让开发变得更简单，可维护性更强，可扩展性更强，可阅读性更强<br>下面我们就具体看一下MVC模式应该怎么设计，在MVC模式下如何定制cell<br>1.Model的设计<br>这里：你要建立数据模型，存储数据（数据模型：就是oc中的类）<br>现在获取的数据本质上是原始数据，<br>以后原始数据有很多中  plist  JSON  数据库  文本文件<br>注意：不要直接使用原始数据<br>把所有的原始数据存储到数据模型Model<br>将解析数据存储到Model中<br>建立数组接收每个Model对象。</p>
<p>2.cell的定制<br>就是将cell上所有的空间全部封装成一个类。<br>在这个类里，我们创建这些控件，设置相应的坐标<br>将这些类添加到self.contentView</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/C_UI11UIScrollView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/C_UI11UIScrollView/" class="post-title-link" itemprop="url">UIScrollView</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 23:54:29" itemprop="dateCreated datePublished" datetime="2016-07-30T23:54:29+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>属性</p>
</blockquote>
<p>内容区域contentSize<br>@property(nonatomic) CGSize contentSize;<br>偏移量contentOffset<br>@property(nonatomic) CGPoint contentOffset;<br>弹簧效果bounces<br>@property(nonatomic) BOOL bounces;<br>分页效果pagingEnabled<br>@property(nonatomic,getter=isPagingEnabled) BOOL pagingEnabled;<br>允许滑动视图本身，如果设为no只能通过方法滑动，不能直接用手滑动<br>@property(nonatomic,getter=isScrollEnabled) BOOL scrollEnabled;<br>显示水平进度条showsHorizontalScrollIndicator<br>@property(nonatomic) BOOL showsHorizontalScrollIndicator;<br>显示垂直进度条showsVerticalScrollIndicator<br>@property(nonatomic) BOOL showsVerticalScrollIndicator;<br>放大和缩小的倍数<br>@property(nonatomic) CGFloat minimumZoomScale;<br>@property(nonatomic) CGFloat maximumZoomScale;</p>
<p>1缩放到某个区域，（具体出现的区域受缩放倍数的影响）</p>
<ul>
<li>(void)zoomToRect:(CGRect)rect animated:(BOOL)animated;</li>
</ul>
<p>2种通过代码滑动视图的方法，一个是设置偏移量，一个是滑动到某个区域（常用第一个）</p>
<ul>
<li>(void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;</li>
<li>(void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;</li>
</ul>
<blockquote>
<p>滚动视图的基本使用</p>
</blockquote>
<p>演示UIScrollView滚动试图基本使用<br>UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 11000, 5600)];<br>imageView.image=[UIImage imageNamed:@”1001.jpg”];<br>[self.view addSubview:imageView];<br>使用滚动试图<br>声明一个滚动试图<br>UIScrollView *scrollView=[[UIScrollView alloc]initWithFrame:self.view.bounds];<br>[self.view addSubview:scrollView];<br>imageView放到了滚动试图中<br>[scrollView addSubview:imageView];<br>滚动试图比较特殊，有两个大小。本身大小，其中内容大小<br>scrollView.contentSize=CGSizeMake(11000, 5600);<br>滚动试图常用属性<br>是否显示水平或竖直滚动条。<br>水平，横向<br>scrollView.showsHorizontalScrollIndicator=NO;<br>竖直，纵向<br>scrollView.showsVerticalScrollIndicator=NO;<br>设置分页滚动<br>scrollView.pagingEnabled=YES;<br>设置是否可以拉出空白区域，bounces蹦跳  scrollView.bounces=YES;</p>
<blockquote>
<p>滚动视图的基本原理 + 滚动视图的事件处理</p>
</blockquote>
<p>滚动试图缩放和基本原理UIScrollViewDelegate<br>scrollView.delegate=self;<br>开始拖拽<br>滚动。。。。。<br>结束拖拽<br>开始减速<br>滚动。。。。。<br>减速结束（滚动停止）；<br>【UIScrollViewDelegate】<br>代理方法<br>滑动过程中</p>
<ul>
<li>(void)scrollViewDidScroll:(UIScrollView *)scrollView;<br>开始拖动</li>
<li>(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;<br>停止拖动</li>
<li>(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;<br>开始滑动</li>
<li>(void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;<br>停止滑动</li>
<li>(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; </li>
</ul>
<blockquote>
<p>滚动视图的缩放</p>
</blockquote>
<p>设置最大最小缩放比例<br>通过代理方法，告诉滚动试图，哪个试图应该缩放<br>scrollView.maximumZoomScale=10;<br>scrollView.minimumZoomScale=0.1;<br>代理方法，告诉scrollView哪个试图应该缩放<br>当试图滚动的时候执行<br>试图缩放。<br>允许缩放的视图(一个scrollview中只能有一个可以缩放且必须设置可以缩放的范围)<br>-(UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView<br>{<br>返回被缩放的试图<br>return imageView;<br>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/33/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><span class="page-number current">34</span><a class="page-number" href="/page/35/">35</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/35/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">366</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
