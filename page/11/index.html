<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/11/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift100KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift100KVC/" class="post-title-link" itemprop="url">KVC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:39:46" itemprop="dateCreated datePublished" datetime="2018-08-14T19:39:46+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。
键值编码必需的方法在非正式协议NSKeyValueCoding中声明，
默认在NSObject中实现。
</code></pre>
<h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><pre><code>-(id)  valueForKey: (NSString *) key
返回表示属性的键字符串所对应的值。如果不能取得值
，则将引起接收器调用方法valueForUndefinedKey:。
-(void)setValue: (id) value  forKey: (NSString*) key
</code></pre>
<h2 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h2><pre><code>1.接收器中如果有key访问器
（或getKey、isKey、_key、_getKey、setKey）则使用它。
2.没有访问器时，使用接收器的类方法
accessInstanceVariablesDirectly来查询。返回YES时，如果存在实例
变量key（或_key、isKey、_isKey等）则返回或设置其值。使用引用计数管
理方式时，实例变量如果为对象，则旧值会被自动释放，新值被保存并代入。
+(BOOL)accessInstanceVariablesDirectly
通常定义为返回YES，可以在子类中改变。该类方法返回YES时，使用键值编码
可以访问该类的实例变量。返回NO时不可以访问。只要该方法返回YES，实例变
量的可视属性即使有@private修饰，也可以访问。
3.既没有访问器也没有实例变量时，将引起接收器调用方法
valueForUndefinedKey:或setValue:forUndefinedKey:。
-(id) valueForUndefinedKey: (NSStirng *) key
不能取得键字符串对应的值时，从方法valueForKey：中调用该方法。默认情
况下，该方法的执行会触发NSUndefinedKeyException。不过，通过在子类
中修改定义，就可以返回其他对象。
- (void) setValue:(id)value forUndefinedKey:(NSString *) key
不能设置键字符串key对应的属性值时，从方法setValue:forKey中调用该方
法。默认情况下，该方法的执行会触发异常NSUndefinedKeyException。不
过，通过在子类中修改定义，可以返回其他对象。
4.   如果该返回值不是对象，则返回被适当的对象包装的值；设置值时也应先
包装成相应的对象。
属性为对象时，该对象还可能持有属性。这时候可以用“.”连接表示键的字符
串，这种表示方式称为键路径。只要能找到对象，点和键多长都没有关系。
- (id)valueForKeyPath:(NSString *) keyPath
以点切分键路径，并使用第一个键向接收器发送valueForKey：方法。然后，
再使用键路径的下一个键，向得到的对象发送valueForKey：方法，如此反复
操作，返回最后获得的对象。
- (void)setValue:(id) value forKeyPath:(NSString *) keyPath
与valueForKeyPath：方法一样取出对象，这里只对路径中的最后一个键调用
setValue：forKey：方法，并设定属性值为value。
</code></pre>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="KVC提供了验证Key对应的Value是否可用的方法："><a href="#KVC提供了验证Key对应的Value是否可用的方法：" class="headerlink" title="KVC提供了验证Key对应的Value是否可用的方法："></a>KVC提供了验证Key对应的Value是否可用的方法：</h3><pre><code>(BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;  
</code></pre>
<h3 id="KVC对数值和结构体型属性的支持"><a href="#KVC对数值和结构体型属性的支持" class="headerlink" title="KVC对数值和结构体型属性的支持"></a>KVC对数值和结构体型属性的支持</h3><h2 id="NSMutableDictionary的setObject和setValue的区别，哪一个add-nil对象会crash"><a href="#NSMutableDictionary的setObject和setValue的区别，哪一个add-nil对象会crash" class="headerlink" title="NSMutableDictionary的setObject和setValue的区别，哪一个add nil对象会crash"></a>NSMutableDictionary的setObject和setValue的区别，哪一个add nil对象会crash</h2><pre><code>1, setObject：forkey：中value是不能够为nil的，不然会报错。
setValue：forKey：中value能够为nil，但是当value为nil的时候，会自动调用removeObject：forKey方法
2, setValue：forKey：中key的参数只能够是NSString类型，而setObject：forKey：的可以是任何类型
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/14/M_Swift107iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/14/M_Swift107iOS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-14 19:38:07" itemprop="dateCreated datePublished" datetime="2018-08-14T19:38:07+08:00">2018-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><pre><code>场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。
优势：解耦合、多继承
实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。
</code></pre>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><pre><code>场景：当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。
比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。
优势：解耦合
实例：Notification通知中心，注册通知中心，任何位置可以发送消息，
注册观察者的对象可以接收。
kvo，键值对改变通知的观察者，平时基本没用过。
</code></pre>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><pre><code>场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。
注意：
    单例类只能有一个实例。
    单例类必须自己创建自己的唯一实例。
    单例类必须给所有其他对象提供这一实例。
优势：在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实
例，避免对资源的多重占用比如写文件操作
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻
辑，而不关心外面怎么样来实例化。
注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。
实例：UIApplication, NSBundle, NSNotificationCenter, 
NSFileManager, NSUserDefault, NSURLCache等都是单例.
</code></pre>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><pre><code>场景：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式
“专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。”
优势：
    一个调用者想创建一个对象，只要知道其名称就可以了。
    扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
    屏蔽产品的具体实现，调用者只关心产品的接口。
缺点：
    每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统
    中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了
    系统具体类的依赖。这并不是什么好事。
实例：以 NSArray 举例，发现 + alloc 后并非生成了我们期望的类实例，而是一个__NSPlacehodlerArray 的中间对象，后面的 - init 或 - initWithXXXXX 消息都是发送给这个中间对象，再由它做工厂，生成真的对象。生成真的对象。这里的 __NSArrayI 和 __NSArrayM
</code></pre>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><pre><code>是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。
实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。
</code></pre>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><pre><code>它其实是一个 MVC 的增强版，并将表示逻辑从 Controller 移出放到一个
新的对象里，即 View Model
在 iOS 上使用 MVVM 的动机,就是让它能减少 View Controller 的复杂
性并使得表示逻辑更易于测试
</code></pre>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><pre><code>MVP全称Model-View-Presenter。
Presenter：作为model和view的中间人，从model层获取数据之后传给
view，使得View和model没有耦合。
View：这里的View与MVC中的V又有一些小差别，这个View可以是
viewcontroller、view等控件。Presenter通过向View传model数据进行交互。
</code></pre>
<h1 id="MVVM双向绑定"><a href="#MVVM双向绑定" class="headerlink" title="MVVM双向绑定"></a>MVVM双向绑定</h1><pre><code>mvvm框架的双向绑定，即当对象改变时，自动改变相关的dom元素的值，反之，当dom元素改变时，能自动更新对象的值，当然dom元素一般是指可输出的input元素。

1. 首先实现单向绑定，在指定对象的属性值发生改变时触发callback函数。
2. 单向绑定可采用ES5新增的defineProperty实现(或defineProperties)，用了ES5注定就不支持IE9以下了，为了防止递归死循环问题，原有属性需要剪切到一个私有属性中保存。
3. 循环调用defineProperty定义闭包时产生作用域的问题，为解决作用域变量对象的值会取到最后一次运行值问题，多定义一层立即调用的闭包函数将值传入。
4. 我们定义getFN和setFN函数用于在属性get和set的时候触发，它的功能是对私有属性__private的读写并触发回调函数通知UI层更新界面。
5.单向绑定实现完成后，实现反向的绑定，即UI层onchange之后触发更新数据，这个相对比较容易，在dom中通过自定义属性bindKey关联model的值变化，监听使用oninput事件，相比onchange的好处是可以实时变化不用等失焦，而且对右键粘贴、菜单粘贴，拖动文字进文本框等方式都可以触发，完全无死角，缺点是只支持IE9以上，但是在IE9以下有等价的onpropertychange可以用还是能兼容的。
6.总结，双向绑定的原理并不复杂，整体代码不超过50行，非常精简，不过还是有一些技术含量，下面是完整的代码，如果不想使用庞大的框架，可以用一下。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/10/M_Swift92%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/10/M_Swift92%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">算法之排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-10 15:20:39" itemprop="dateCreated datePublished" datetime="2018-08-10T15:20:39+08:00">2018-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>思想：每次遍历，相邻两个比较大小，修改位置
复杂度：n平方
function maopao(arr) &#123;
    for (var i = 0; i &lt; arr.length; i++) &#123;
        for (var j = 0; j &lt; arr.length; j++) &#123;
            if (arr[i] &gt; arr[j]) &#123;
                var temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre><code>思想：一次便利结束后，找到最小的，放到最前面，交换次数较冒泡排序少
排序复杂度：n平方
function xuanze(arr) &#123;
    for (var i = 0; i &lt; arr.length; i++) &#123;
        var min = i;
        for (var j = 0; j &lt; arr.length; j++) &#123;
            if (arr[j] &lt;arr[i]) &#123;
                min = j;
            &#125;
        &#125;
        if (min != i) &#123;
            var temp = arr[i];
            arr[i] = arr[min];
            arr[min] = arr[i];
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre><code>思想：每次往最小数组里插入一个数据，并保证数组是排序的
(1) 将这个序列的第一个元素R0视为一个有序序列； 
(2) 依次把 , , … ,  插入到这个有序序列中； 
(3) 将插入到有序序列中时，前 i-1 个数是有序的，将和 ~ 从后往前进行比较，确定要插入的位置。
function insertSort(arr) &#123;
    var len = arr.length;
    var preIndex,current;
    for (var i = 1; i &lt; len; i++) &#123;
        preIndex = i -1;
        current = arr[i];
        while(preIndex &gt;=0 &amp;&amp; arr[preIndex] &gt; current) &#123;
            arr[preIndex +1] = arr[preIndex];
            preIndex --;
        &#125;
        arr[preIndex +1] = current;
    &#125;
&#125;
</code></pre>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><pre><code>4.希尔排序，希尔排序也是一种插入排序
不同：希尔排序优先比较较远的元素，希尔排序的核心在于间隔序列的设定
对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素
分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对
各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是
有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，
当gap=1时，整个数列就是有序的。
function shellSort(arr) &#123;
    var len = arr.length;
    var temp,gap =1;
    while(gap &lt; len/3)&#123;
        gap = gap *3 +1;
    &#125;
    for (gap; gap&gt; 0; gap = Math.floor(gap/3)) &#123;
        for (var i = gap; i &lt; len; i++) &#123;
            temp = arr[i];
            for (var j = i - gap; j &gt;0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;
                arr[j+gap] = arr[j];
            &#125;
            arr[j+gap] = temp;
        &#125;
    &#125;
    return arr;
&#125;
</code></pre>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code>作为一种典型的分而治之思想的算法应用
将一个数组排序，可以先递归的将它分成两半分别排序，然后再将结果归并起来。
缺点：需要额外的空间
从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这
些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得
到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。
这样就得到了我们想要的排序结果
function mergeSort(arr) &#123;  //采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) &#123;
        return arr;
    &#125;
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
&#125;

function merge(left, right)
&#123;
    var result = [];

    while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;
        if (left[0] &lt;= right[0]) &#123;
            result.push(left.shift());
        &#125; else &#123;
            result.push(right.shift());
        &#125;
    &#125;

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
&#125;
</code></pre>
<h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><pre><code>分而治之思想在排序算法。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。
先是把第一个挖出来，作为基值；然后先是从右向左，对比基值，如果如果小，那么放到坑里；然后在从左往右对比基值，如果大，那么放到坑里；当换完一轮了后，把基值放到坑里；然后在根据基值，分左右两组，递归排序；
通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比
另外一部分的所有数据都要小，继续对长度较短的序列进行同样的分割，最后到
达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故
减少了比较次数，降低了排序时间。
function quickSort(arr, left, right) &#123;
    var len = arr.length,
        partitionIndex,
        left = typeof left != &#39;number&#39; ? 0 : left,
        right = typeof right != &#39;number&#39; ? len - 1 : right;

    if (left &lt; right) &#123;
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    &#125;
    return arr;
&#125;

function partition(arr, left ,right) &#123;     //分区操作
    var pivot = left,                      //设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) &#123;
        if (arr[i] &lt; arr[pivot]) &#123;
            swap(arr, i, index);
            index++;
        &#125;        
    &#125;
    swap(arr, pivot, index - 1);
    return index-1;
&#125;

function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;
</code></pre>
<h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><pre><code>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列
堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大
值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将
剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执
行，便能得到一个有序序列了

var len;    //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

function buildMaxHeap(arr) &#123;   //建立大顶堆
    len = arr.length;
    for (var i = Math.floor(len/2); i &amp;gt;= 0; i--) &#123;
        heapify(arr, i);
    &#125;
&#125;

function heapify(arr, i) &#123;     //堆调整
    var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;
        largest = left;
    &#125;

    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;
        largest = right;
    &#125;

    if (largest != i) &#123;
        swap(arr, i, largest);
        heapify(arr, largest);
    &#125;
&#125;

function swap(arr, i, j) &#123;
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
&#125;

function heapSort(arr) &#123;
    buildMaxHeap(arr);

    for (var i = arr.length-1; i &gt; 0; i--) &#123;
        swap(arr, 0, i);
        len--;
        heapify(arr, 0);
    &#125;
    return arr;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/09/M_Swift94Runtime%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/09/M_Swift94Runtime%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">理解Runtime</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 17:45:14" itemprop="dateCreated datePublished" datetime="2018-08-09T17:45:14+08:00">2018-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类结构体模型"><a href="#类结构体模型" class="headerlink" title="类结构体模型"></a>类结构体模型</h2><pre><code>// objc_object对象模型
struct objc_object &#123;
    private:
    isa_t isa;
    public:
    Class ISA();
    Class getIsa();
    // 省略其余方法
    ...
&#125;
// objc_class类模型
struct objc_class : objc_object &#123;
    Class isa  //所属类的指针
    Class super_class//指向父类的指针                                        
    const char *name //类名                                     
    long version // 版本                                 
    long info //供运行期使用的一些位标识。                             
    long instance_size //实例大小                                 
    struct objc_ivar_list *ivars//成员变量数组                      
    struct objc_method_list **methodLists//方法列表                  
    struct objc_cache *cache//指向最近使用的方法.用于方法调用的优化                            
    struct objc_protocol_list *protocols//协议的数组                     
&#125;
在objc_class结构体中定义了对象的method list，
protocal，ivar list等，表示对象的行为。
</code></pre>
<h3 id="为什么说类也是对象"><a href="#为什么说类也是对象" class="headerlink" title="为什么说类也是对象"></a>为什么说类也是对象</h3><pre><code>类被定义为objc_class结构体，objc_class结构体继承自
objc_objct,对象是用 objc_object 结构体表示的，所以类也
是对象。
oc中的类和元类也是一样，都是结构体构成的，由于类的结构体定义
继承自objc_object所以其也是一个对象，并且具有对象的isa特
征。
在应用程序中，类对象只会被创建一份。
</code></pre>
<h3 id="Meta-Class元类"><a href="#Meta-Class元类" class="headerlink" title="Meta Class元类"></a>Meta Class元类</h3><pre><code>isa指针指向Meta Class，因为Objc的类的本身也是一个
Object，为了处理这个关系，runtime就创造了Meta Class，
当给类发送[NSObject alloc]这样消息时，实际上是把这个
消息发给了Class Object
因为一个类是一个对象，它是元类(metaclass)的对象。
元类是关于类对象的描述，
就像类是普通实例对象的描述一样。实际上，元类的方法列表正
是#类方法#：该类对象响应的选择器。
</code></pre>
<h3 id="什么是isa指针"><a href="#什么是isa指针" class="headerlink" title="什么是isa指针"></a>什么是isa指针</h3><pre><code>每个对象都有一个标识对象类的isa实例变量。
运行时使用此指针来确定对象需要时的实际类。
1、 id类型是一个objc_object结构体的指针。
2、objc_object结构体包含一个Class 类型的变量isa。
3、 Class是objc_class结构体的指针。
</code></pre>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><pre><code>objc_msgSend第一个参数类型为id，大家对它都不陌生，
它是一个指向类实例的指针：
typedef struct objc_object *id;
那objc_object又是啥呢：
struct objc_object &#123; Class isa; &#125;;
objc_object结构体包含一个isa指针，根据isa指针就可以
顺藤摸瓜找到对象所属的类。
</code></pre>
<h3 id="为什么id类型可以指向OC中任意对象"><a href="#为什么id类型可以指向OC中任意对象" class="headerlink" title="为什么id类型可以指向OC中任意对象"></a>为什么id类型可以指向OC中任意对象</h3><pre><code>id类型被定义为指向对象的指针
NSObject只有一个Class对象isa，而objc_object也是只有一个Class对
象isa,也就是说id等价于NSObject*。所以id是一个一个比较灵活的对象指
针，并且是一个指向任何一个继承了Object（或者NSObject）类的对象
</code></pre>
<h3 id="为什么不能用isa判断一个类的继承关系"><a href="#为什么不能用isa判断一个类的继承关系" class="headerlink" title="为什么不能用isa判断一个类的继承关系"></a>为什么不能用isa判断一个类的继承关系</h3><pre><code>isa指针不总是指向实例对象所属的类，不能依靠它来确定
类型，而是应该用class方法来确定实例对象的类。
因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类
</code></pre>
<h2 id="类结构关系"><a href="#类结构关系" class="headerlink" title="类结构关系"></a>类结构关系</h2><pre><code>实例对象在运行时被表示成objc_object类型结构体，结构体内部
有个isa指针指向objc_class结构体。objc_class内部保存了类
的变量和方法列表以及其他一些信息，并且还有一个isa指针。这个
isa指针会指向meteClass(元类)，元类里保存了这个类的类方法
列表。
runtime中设计了meta class， 通过meta class来创建类对
象，所以类对象的isa指向对应的meta class。而meta class也
是一个对象，所有元类的isa都指向其根元类，根元类的isa指针指
向自己，通过这种设计，isa的整体结构形成了一个闭环。为了完整
性，其实元类里也有一个isa指针，这个isa指针，指向的是根元
类，根元类的isa指针指向自己
实例对象--(runtime)--&gt;objc_object--(isa)--
&gt;objc_class--(isa)--&gt;元类--isa--&gt;根元类--isa--&gt;自
己。
类和元类都有自己的继承体系，但它们都有共同的根父类
NSObject，而NSObject的父类指向nil。Root 
Class（Class）是NSObject类对象，而Root Class（Meta）
是NSObject的元类对象。对于像NSObject这样的类来说，它其实
代表的是一个类对象，本质上还是一个普通的实例对象，类对象的、
self指针应该指向的是这个类对象自身。
</code></pre>
<h3 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h3><pre><code>当我们调用某个类的方法时，如果这个类的方法列表里没有该方法，
则会去找这个类的父类的方法列表。这种机制就是通过
objc_class的第二个变量super_class指针实现的。
并且这种继承关系会扩展到元类。
</code></pre>
<h2 id="内存布局："><a href="#内存布局：" class="headerlink" title="内存布局："></a>内存布局：</h2><pre><code>类的本质时结构体，在结构体中包含一些成员变量，
如method list，ivar list等，这些都是结构体的一部分，
method protocol，property的实现这些都可以放到类中，
所有对象调用同一份即可，但对象的成员变量不可以放在一起，
因为每个对象的成员变量值都是不同的。
</code></pre>
<h3 id="为什么不能添加变量"><a href="#为什么不能添加变量" class="headerlink" title="为什么不能添加变量"></a>为什么不能添加变量</h3><pre><code>创建实例对象时，会根据其对应的Class分配内存，内存构成
是ivar+isa_t.并且实例变量不只是包含当前class的ivars，
也会包含其继承链的ivars，ivars的内存布局在编译时就已经
决定，运行时需要根据ivars内存布局创建对象，所以runtime
不能动态修改ivars，会破坏已有的内存布局。
</code></pre>
<h3 id="不能向编译后得到的类中增加实例变量"><a href="#不能向编译后得到的类中增加实例变量" class="headerlink" title="不能向编译后得到的类中增加实例变量"></a>不能向编译后得到的类中增加实例变量</h3><pre><code>因为编译后的类已经注册在runtime中，类结构体中的
objc_ivar_list实例变量的链表和instance_size
实例变量的内存大小已经确定，同时runtime会调用
class_setIvarLayout或class_WeakIvarLayout
来处理strong weak引用，所以不能向存在的类中添加实例变量
运行时创建的类时可以添加实例变量，调用class_addIvar函数
，但是得在调用objc_allocateClassPari之后，
objc_registerClassPair之前，原因同上。
</code></pre>
<h3 id="系统如何解决新增实例冲突"><a href="#系统如何解决新增实例冲突" class="headerlink" title="系统如何解决新增实例冲突"></a>系统如何解决新增实例冲突</h3><pre><code>类的结构体在编译时都是固定的，如果想修改类的结构需要重新编译
原来UIViewController的结构体中增加了
childViewControllers属性，这个时候和子类的内存偏移就
发生了冲突，只不过，runtime有检测内存地址冲突的机制，
在类生成实例变量时，会判断实例变量是否有地址冲突，
如果发生冲突则调整对象的地址偏移。
</code></pre>
<h2 id="ivars-methodLists"><a href="#ivars-methodLists" class="headerlink" title="ivars methodLists"></a>ivars methodLists</h2><pre><code>在objc_class结构体中：ivars是objc_ivar_list指针；
methodLists是指向objc_method_list指针的指针。
也就是说可以动态修改 *methodLists 的值来添加成员方法，
这也是Category实现的原理.
</code></pre>
<h2 id="IMP："><a href="#IMP：" class="headerlink" title="IMP："></a>IMP：</h2><pre><code>//结构
typedef void (*IMP)(void /* id, SEL, ... */ );
在runtime中IMP本质上就是一个函数指针
在IMP中有两个默认的参数id和SEL，id也就是方法的self
这和objc_msgSend()函数传递的参数一样；
Runtime提供很多对于IMP的操作API，我们很多Runtime函数都
是IMP操作
</code></pre>
<h2 id="Method："><a href="#Method：" class="headerlink" title="Method："></a>Method：</h2><pre><code>//结构
typedef struct method_t *Method;
struct method_t &#123; 
    SEL name;
    const char *types;
    IMP imp; 
&#125;;
用来表示方法，其中包含SEL和IMP
</code></pre>
<h2 id="Property："><a href="#Property：" class="headerlink" title="Property："></a>Property：</h2><pre><code>在runtime中定义了属性的结构体，用来表示对象中定义的属性。
@property修饰符用来修饰属性，修饰后的属性为
objc_property_t类型，其本质是property_t结构体
    struct property_t &#123;
    const char *name; 
    const char *attributes;
&#125;;
</code></pre>
<h2 id="ivar读写"><a href="#ivar读写" class="headerlink" title="ivar读写"></a>ivar读写</h2><pre><code>实例变量的isa_t指针会指向其所属的类，对象中并不会包含
method，property，protocol，ivar等信息，这些信息在编
译时都保存在只读结构体class_ro_t中。在class_ro_t中ivar
时const只读的，在image load时copy到class_rw_t中时，
是不会copy ivars的，并且class_rw_t中并没有定义ivars
的字段。
在防伪某个成员变量时，直接通过isa_t找到对应的objc_class
并通过其class_ro_t的ivar list做地址偏移，查找对应的对象
内存，正是由于这种方式，所以对象的内存地址是固定不可改变的。
</code></pre>
<h2 id="方法传参："><a href="#方法传参：" class="headerlink" title="方法传参："></a>方法传参：</h2><pre><code>当调用实例变量的方法时，会通过objc_msgSend（）发起调用。
调用是会传入self和SEL，函数内部通过isa在类的内部查找方法
列表对应的IMP，传入对应的参数并发起调用，如果调用的方法涉
及到当前对象的成员变量的访问，这是就是通过objc_msgSend()
内部，通过类的ivar list判断地址偏移，取出ivar并传入调
用的IMP中的。
调用super的方式时则调用objc_msgSendSuper()函数实现
</code></pre>
<h2 id="isa-t"><a href="#isa-t" class="headerlink" title="isa_t:"></a>isa_t:</h2><pre><code>对于对象指针也是一样，在oc1.0时，isa时一个真的指针，
指向一堆区的地址，而在oc2.0时代，一个指针长度时八个字节
也就是64位，在64位中直接存储着对象的信息。当查找对象所属
的类时，直接在isa指针中进行位运算即可，而且由于在栈区进
行操作，查找速度非常快。
例如，isa_t本质时一个结构体，如果创建结构体再用指针指向这
个结构体，内存占用是很大的，但是Tagged Pointer特性中，
直接把结构体的值都存储到指针中，这样就相当节省内存了。
苹果不允许直接访问isa指针，和Tagged Pointer也是有关
系的，因为tagged Pointer的情况下，isa并不是一个指针指
向另一块内存区，而是直接表示对象的值，所以通过直接访问
isa获取到的信息是错误的。
</code></pre>
<h2 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h2><pre><code>它是selector在Objc中的表示类型（Swift中是
Selector类）。selector是方法选择器，
可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:
typedef struct objc_selector *SEL;
从源码中看其实是一个const *的常量字符串，只代表名字而已
其实它就是个映射到方法的C字符串，你可以用 Objc 
编译器命令@selector()或者 Runtime 系统的
sel_registerName函数来获得一个SEL类型的方法选择器。
常见来两个相同的类，并定规两个相同的方法，通过@selector
获取SEL并打印，我们发现SEL都是同一个对象，地址都是相同的，
不同类的相同SEL是同一个对象。
在runtime中维护一个SEL列表，这个表不按照类存储，
只要相同SEL就算作一个，并存储到表中。
</code></pre>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><pre><code>协议存储在protocol_t结构体中，而protocol_t继承objc_object，所以也就具备对象特征
struct protocol_t : objc_object &#123;
    const char *mangledName;
    struct protocol_list_t *protocols; 
    method_list_t *instanceMethods; 
    method_list_t *classMethods;
    method_list_t *optionalInstanceMethods;
    method_list_t *optionalClassMethods;
    property_list_t *instanceProperties;
    uint32_t size; // sizeof(protocol_t) 
    uint32_t flags;
    const char **_extendedMethodTypes; 
    const char *_demangledName; 
    property_list_t *_classProperties;
&#125;;
既然具备了对象的特征，那么也有isa指针，在Protocol中所有的isa都指向同一个类Protocol。Protocol类并没有元类
</code></pre>
<h2 id="runtime如何实现weak变量的自动置nil"><a href="#runtime如何实现weak变量的自动置nil" class="headerlink" title="runtime如何实现weak变量的自动置nil"></a>runtime如何实现weak变量的自动置nil</h2><pre><code>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表
中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时
候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 
在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil
</code></pre>
<h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2><pre><code>在runtime中所有类都存在一个哈希表中，在table的buckets中存储
1. 加载所有类到类的gdb_objc_realized_classes表中
2. 对所有类做重映射
3. 将所有SEL都注册到namedSelectors表中
4. 修复函数指针遗留
5. 将所有Protocol添加到protocol_map表中
6. 将所有Protocol重映射
7. 初始化所有非懒加载的类，进行rw，ro操作 
8. 便利所有懒加载类，执行初始化
9. 处理所有Category包括Class和MetaClass
10. 初始化所有未初始化类
</code></pre>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><pre><code>Load方法是在类加载的时候调用的，是在类加载到运行时的时候调用的，
在mian函数之前，由系统调用，所以比较适合在load中调用钩子方法。只调用
一次，注意load方法是直接调用的，并没有走运行时的objc_msgSend函数
load方法顺序应该是，父类-&gt;子类-&gt;分类
</code></pre>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><pre><code>initialize是由Runtime调用的，与load不同的是，initialize方法是第
一次调用类所属方法时才会调用，如果当前类方法永远不被调用的话
initialize有可能永远不会执行。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/09/M_Swift101%E5%B8%B8%E8%A7%81UI%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/09/M_Swift101%E5%B8%B8%E8%A7%81UI%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">常见UI问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 16:50:19" itemprop="dateCreated datePublished" datetime="2018-08-09T16:50:19+08:00">2018-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="tableView卡顿"><a href="#tableView卡顿" class="headerlink" title="tableView卡顿"></a>tableView卡顿</h2><pre><code>1.最常⽤用的就是cell的重⽤用  
2.避免cell的重新布局 
3.提前计算并缓存cell的属性及内容 
4.减少cell中控件的数量量
5.不要使⽤用ClearColor，⽆无背景⾊色，透明度也不不要设置为0 
6.使⽤局部更新
7.加载⽹络数据，下载图⽚，使用异步加载，并缓存 
8.少使⽤用addView 给cell动态添加view 
9.按需加载cell，cell滚动很快时，只加载范围内的cell 
10.不要实现无用的代理理⽅方法，tableView只遵守两个协议 
11.缓存⾏⾼
12.不要做多余的绘制工作。
13.预渲染图像。
14.使⽤用正确的数据结构来存储数据。
</code></pre>
<h2 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a>应用优化</h2><pre><code>一、首页启动速度   
    启动过程中做的事情越少越好、不在UI线程上作耗时的
    操作、在合适的时机开始后台任务、尽量减小包的大小
二、页面浏览速度
    json的处理、数据压缩、内容缓存、算法的优化
三、操作流畅度优化：
    见tableVIew的优化
四、数据库的优化：
    数据库设计上面的重构、查询语句的优化、分库分表
五、服务器端和客户端的交互优化：
    客户端尽量减少请求、服务端尽量做多的逻辑
    处理、通信协议的优化
六、非技术性能优化
    产品逻辑性、代码规范、界面交互规范等
</code></pre>
<h2 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h2><pre><code>1.使用instrument
2.在程序运行期间能及时获取卡顿信息
监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事
件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,
就需要从NSRunLoop来入手.其中核心方法CFRunLoopRun简化后的主要逻辑
大概是这样的:
int32_t __CFRunLoopRun()
&#123;
    //通知即将进入runloop
    __CFRunLoopDoObservers(KCFRunLoopEntry);
    do
    &#123;
    // 通知将要处理timer和source
    __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);
    __CFRunLoopDoObservers(kCFRunLoopBeforeSources);

    __CFRunLoopDoBlocks();  //处理非延迟的主线程调用
    __CFRunLoopDoSource0(); //处理UIEvent事件        
    //GCD dispatch main queue
    CheckIfExistMessagesInMainDispatchQueue();
    // 即将进入休眠
    __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);
    // 等待内核mach_msg事件
    mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();
    // Zzz...
    // 从等待中醒来
    __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);
    // 处理因timer的唤醒
    if (wakeUpPort == timerPort)
    __CFRunLoopDoTimers();
    // 处理异步方法唤醒,如dispatch_async
    else if (wakeUpPort == mainDispatchQueuePort)
    __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()
    // UI刷新,动画显示
    else
    __CFRunLoopDoSource1();
    // 再次确保是否有同步的方法需要调用
    __CFRunLoopDoBlocks();
    &#125; while (!stop &amp;&amp; !timeout);
    //通知即将退出runloop
    __CFRunLoopDoObservers(CFRunLoopExit);
&#125;
不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和
kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,
也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.
</code></pre>
<h3 id="量化卡顿的程度"><a href="#量化卡顿的程度" class="headerlink" title="量化卡顿的程度"></a>量化卡顿的程度</h3><pre><code>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它
可以实时获得这些状态值的变化,具体的使用如下:
static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)
&#123;
MyClass *object = (__bridge MyClass*)info;
object-&gt;activity = activity;
&#125;

- (void)registerObserver
&#123;
CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;
    CFRunLoopObserverRef observer = 
    CFRunLoopObserverCreate(kCFAllocatorDefault,
    kCFRunLoopAllActivities,
    YES,
    0,
    &amp;runLoopObserverCallBack,
    &amp;context);
    CFRunLoopAddObserver(CFRunLoopGetMain(), 
    observer, kCFRunLoopCommonModes);
&#125;
只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某
个阀值,便能揪出这些性能杀手.

为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,
所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连
续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上
面两个方法添加计算的逻辑如下:
static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)
&#123;
MyClass *object = (__bridge MyClass*)info;

// 记录状态值
object-&gt;activity = activity;

// 发送信号
dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;
dispatch_semaphore_signal(semaphore);
&#125;

- (void)registerObserver
&#123;
CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;
CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,
kCFRunLoopAllActivities,
YES,
0,
&amp;runLoopObserverCallBack,
&amp;context);
CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);

// 创建信号
semaphore = dispatch_semaphore_create(0);

// 在子线程监控时长
dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;
while (YES)
&#123;
// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)
long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));
if (st != 0)
&#123;
if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)
&#123;
if (++timeoutCount &lt; 5)
continue;

NSLog(@&quot;好像有点儿卡哦&quot;);
&#125;
&#125;
timeoutCount = 0;
&#125;
&#125;);
&#125;
</code></pre>
<h3 id="记录卡顿的函数调用"><a href="#记录卡顿的函数调用" class="headerlink" title="记录卡顿的函数调用"></a>记录卡顿的函数调用</h3><pre><code>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个
第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用
于实时获取各线程的调用堆栈,使用示例如下:
PLCrashReporterConfig *config = [[PLCrashReporterConfig
alloc]initWithSignalHandlerType:
PLCrashReporterSignalHandlerTypeBSD
symbolicationStrategy:
PLCrashReporterSymbolicationStrategyAll];
PLCrashReporter *crashReporter = 
[[PLCrashReporter alloc] initWithConfiguration:config];

NSData *data = [crashReporter generateLiveReport];
PLCrashReport *reporter = [[PLCrashReport alloc]
initWithData:data error:NULL];
NSString *report = [PLCrashReportTextFormatter
stringValueForCrashReport:reporter
withTextFormat:PLCrashReportTextFormatiOS];

NSLog(@&quot;------------\n%@\n------------&quot;, report);
当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到
服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至
此这个实时卡顿监控就大功告成了!
</code></pre>
<h2 id="什么是掉帧"><a href="#什么是掉帧" class="headerlink" title="什么是掉帧"></a>什么是掉帧</h2><pre><code>掉帧一般指由于硬件不足以负荷显示器画面动态显示刷新的频率，从而帧率过低
所造成的画面出现停滞（或短时间或长时间）现象。掉帧在游戏中就是玩游戏过
程中，出现卡这种情况，图像未及时刷新造成，画面粘滞。
帧数就是在1秒钟时间里传输的图片的量，也可以理解为图形处理器每秒钟能够
刷新几次，通常用fps（Frames Per Second）表示。每一帧都是静止的图
象，快速连续地显示帧便形成了运动的假象。高的帧率可以得到更流畅、更逼真
的动画。每秒钟帧数 (fps) 愈多，所显示的动作就会愈流畅。
</code></pre>
<h2 id="APP启动流出"><a href="#APP启动流出" class="headerlink" title="APP启动流出"></a>APP启动流出</h2><pre><code>1.打开程序
2.执行main函数
3.执行UIApplicationMain函数
4.初始化UIApplication（创建和设置代理，开启RunLoop事件循环）
5.监听事件，执行AppDelegate对应函数
    程序加载完成
    程序获取焦点
    程序进入后台
    程序失去焦点
    程序从后台进入前台
    内存警告，可能要终止程序
    程序即将结束
6.结束程序
</code></pre>
<h2 id="封装SDK需要注意哪些"><a href="#封装SDK需要注意哪些" class="headerlink" title="封装SDK需要注意哪些"></a>封装SDK需要注意哪些</h2><pre><code>1.类名、宏定义、枚举、通知、类别等命名时加静态库统一特殊前缀，以避免命名冲突。
2.类别中方法名也需要加特殊前缀，以避免方法覆盖导致不必要麻烦。
3.对于项目中的c、c++中的方法，需要加前缀
4.对于开发静态库时引入的开源库，若体量过大，可外部引用，提供给接入方时
加以说明，体量小的可以对类名及类中所用枚举、通知等加前缀使用。
5.特别需要注意的是在同一个类中多个interface的情况，加前缀时一定要检
查所有的interface，避免遗漏
6.由于一些接入方引入静态库时，对app的体积有严格的控制，所以在开发静态
库时，要尽量精简代码，引入开源库时，可剔除一些不必要的部分，如能用系统
提供的方法实现的功能，尽量不去引入大型第三方库，不然打包出来的.a库可能体积增加很多。
    
</code></pre>
<h2 id="使用drawRect有什么影响"><a href="#使用drawRect有什么影响" class="headerlink" title="使用drawRect有什么影响"></a>使用drawRect有什么影响</h2><pre><code>drawRect方法依赖Core Graphics框架来进行自定义的绘制，但这种方法主
要的缺点就是它处理touch事件的方式：每次按钮被点击后，都会用
setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执
行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/09/M_Swift89Runtime%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/09/M_Swift89Runtime%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">Runtime</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 15:42:35" itemprop="dateCreated datePublished" datetime="2018-08-09T15:42:35+08:00">2018-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><pre><code>Objective-C 从三种不同的层级上与 Runtime 系统进行交互，
分别是通过 Objective-C 源代码，
通过 Foundation 框架的NSObject类定义的方法，
通过对 runtime 函数的直接调用。
RunTime简称运行时,就是系统在运行的时候的一些机制，
其中最主要的是消息机制。
每一个oc的方法，底层必然有一个与之对应的runtime方法。
</code></pre>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="获取属性列表"><a href="#获取属性列表" class="headerlink" title="获取属性列表"></a>获取属性列表</h3><pre><code>objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);
for (unsigned int i=0; i&lt;count; i++) &#123;
const char *propertyName = property_getName(propertyList[i]);
NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);
&#125;
</code></pre>
<h3 id="获取方法列表"><a href="#获取方法列表" class="headerlink" title="获取方法列表"></a>获取方法列表</h3><pre><code>Method *methodList = class_copyMethodList([self class], &amp;count);
for (unsigned int i; i&lt;count; i++) &#123;
Method method = methodList[i];
NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));
&#125;
</code></pre>
<h3 id="获取成员变量列表"><a href="#获取成员变量列表" class="headerlink" title="获取成员变量列表"></a>获取成员变量列表</h3><pre><code>Ivar *ivarList = class_copyIvarList([self class], &amp;count);
for (unsigned int i; i&lt;count; i++) &#123;
Ivar myIvar = ivarList[i];
const char *ivarName = ivar_getName(myIvar);
NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);
&#125;
</code></pre>
<h3 id="获取协议列表"><a href="#获取协议列表" class="headerlink" title="获取协议列表"></a>获取协议列表</h3><pre><code>__unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);
for (unsigned int i; i&lt;count; i++) &#123;
Protocol *myProtocal = protocolList[i];
const char *protocolName = protocol_getName(myProtocal);
NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);
&#125;
</code></pre>
<h3 id="获得类方法"><a href="#获得类方法" class="headerlink" title="获得类方法"></a>获得类方法</h3><pre><code>Class PersonClass = object_getClass([Person class]);
SEL oriSEL = @selector(test1);
Method oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);
</code></pre>
<h3 id="获取实例方法"><a href="#获取实例方法" class="headerlink" title="获取实例方法"></a>获取实例方法</h3><pre><code>Class PersonClass = object_getClass([xiaoming class]);
SEL oriSEL = @selector(test2);
Method cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);
</code></pre>
<h3 id="添加一个实例变量"><a href="#添加一个实例变量" class="headerlink" title="添加一个实例变量"></a>添加一个实例变量</h3><pre><code>/*
参数一、类名
参数二、属性名称
参数三、开辟字节长度
参数四、对其方式
参数五、参数类型 “@” 官方解释 An object (whether statically typed or typed id) （对象 静态类型或者id类型） 具体类型可参照官方文档
return: BOOL 是否添加成功
*/
BOOL isSuccess = class_addIvar(MyClass, &quot;addIvar&quot;, sizeof(NSString *), 0, &quot;@&quot;);
</code></pre>
<h3 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h3><pre><code>/*
参数一、类名
参数二、SEL 添加的方法名字
参数三、IMP指针 (IMP就是Implementation的缩写，它是指向一个方法实现的指针，每一个方法都有一个对应的IMP)
参数四、其中types参数为&quot;i@:@“，按顺序分别表示：具体类型可参照官方文档
i 返回值类型int，若是v则表示void
@ 参数id(self)
: SEL(_cmd)
@ id(str)
V@:表示返回值是void 带有SEL参数 （An object (whether statically typed or typed id)）
*/
BOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));
</code></pre>
<h3 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h3><pre><code>class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));
</code></pre>
<h3 id="交换方法"><a href="#交换方法" class="headerlink" title="交换方法"></a>交换方法</h3><pre><code>method_exchangeImplementations(oriMethod, cusMethod);
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/09/M_Swift104Category/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/09/M_Swift104Category/" class="post-title-link" itemprop="url">Category</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 15:34:47" itemprop="dateCreated datePublished" datetime="2018-08-09T15:34:47+08:00">2018-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Objective-C中category的实现原理和runtime有什么关系？"><a href="#Objective-C中category的实现原理和runtime有什么关系？" class="headerlink" title="Objective-C中category的实现原理和runtime有什么关系？"></a>Objective-C中category的实现原理和runtime有什么关系？</h2><pre><code>Objective-C 中的 Category 就是对装饰模式的一种具
体实现。它的主要作用是在不改变原有类的前提下，动态地
给这个类添加一些方法。在 Objective-C 中的具体体现为：
实例（类）方法、属性和协议。是的，在 Objective-C 
中可以用 Category 来实现协议
在runtime层，Category维护一个名为category_map的哈希表，哈希表存
储category_t对象，Category添加方法，然后调用remethodizeClass
向对应的class中添加Category的信息
将 Category 和它的主类（或元类）注册到哈希表中；
如果主类（或元类）已实现，那么重建它的方法列表。
Category 中的实例方法和属性被整合到主类中；
而类方法则被整合到元类中。
另外，对协议的处理比较特殊，Category 中的协议被同
时整合到了主类和元类中。
我们注意到，不管是哪种情况，最终都是通过调用 
static void remethodizeClass(Class cls) 
函数来重新整理类的数据的。
这个函数的主要作用是将 Category 中的方法、属性和协议
整合到类（主类或元类）中，更新类的数据字段 data() 中
method_lists（或 method_list）、properties 和
protocols 的值。进一步，我们通过
attachCategoryMethods 函数的源码可以找到真正处理
Category 方法的 attachMethodLists 函数：
</code></pre>
<h2 id="category结构体的定义"><a href="#category结构体的定义" class="headerlink" title="category结构体的定义"></a>category结构体的定义</h2><pre><code>struct category_t &#123;
    const char *name;     //类的名字（name）
    classref_t cls;       //类（cls）
    struct method_list_t *instanceMethods; 
    //category中所有给类添加的实例方法的列表（instanceMethods）
    struct method_list_t *classMethods; 
    //category中所有添加的类方法的列表（classMethods）
    struct protocol_list_t *protocols; 
    //category实现的所有协议的列表（protocols）
    struct property_list_t *instanceProperties;
    //category中添加的所有属性（instanceProperties）
&#125;
</code></pre>
<h2 id="类别（category）主要有三个作用"><a href="#类别（category）主要有三个作用" class="headerlink" title="类别（category）主要有三个作用"></a>类别（category）主要有三个作用</h2><pre><code>1.将类的实现分散到多个不同文件或多个不同框架中
2.创建对私有方法的向前引用（cocoa没有真正的私有方法）
3.向对象添加非正式协议（创建一个NSObject的类别称为“创建一个非正式协
议”）因为，NSObject是顶级父类，在NSObject中添加了该方法，也就是说
通过继承关系，所有的类中都有该方法。
</code></pre>
<h2 id="类别和Extension区别"><a href="#类别和Extension区别" class="headerlink" title="类别和Extension区别"></a>类别和Extension区别</h2><pre><code>和Category相似的还有Extension，二者的区别是Extension
在编译期就直接和原类编译在一起了，而Category是在
运行时添加到原类中。
</code></pre>
<h2 id="类别为什么不能添加实例变量"><a href="#类别为什么不能添加实例变量" class="headerlink" title="类别为什么不能添加实例变量"></a>类别为什么不能添加实例变量</h2><pre><code>category是无法添加实例变量的（因为在运行期，对象的内存布局已
经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来
说是灾难性的）。
</code></pre>
<h2 id="类别重写类中方法"><a href="#类别重写类中方法" class="headerlink" title="类别重写类中方法"></a>类别重写类中方法</h2><pre><code>1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果
category和原来类都有methodA，那么category附加完成之后，类的方法列
表里会有两个methodA
2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新
方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类
的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，
它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的
方法。
重写其原有方法，会导致Category的方法覆盖原有类的方法，
但是load方法是例外，category和原有类的load方法都会被执行。
</code></pre>
<h2 id="如何在重写后，保证原类方法会调用"><a href="#如何在重写后，保证原类方法会调用" class="headerlink" title="如何在重写后，保证原类方法会调用"></a>如何在重写后，保证原类方法会调用</h2><pre><code>可以在一个Category方法被调用后，便利方法列表，
并调用其他同名方法，但是需要注意一点是，便利过程不能
再调用自己的方法，否则会导致递归调用，为了避免这个问题，
可以在调用前判断被调用的方法IMP是否是当前方法的IMP
</code></pre>
<h2 id="如何在重写后，保证只调用原类方法"><a href="#如何在重写后，保证只调用原类方法" class="headerlink" title="如何在重写后，保证只调用原类方法"></a>如何在重写后，保证只调用原类方法</h2><pre><code>根据上面方法调用的分析，Runtime在调用方法时会优先所
有Category调用，所以可以倒叙便利方法列表，只便利第一
个方法即可，这个方法就是元类的方法。
</code></pre>
<h2 id="如何在Category中添加变量"><a href="#如何在Category中添加变量" class="headerlink" title="如何在Category中添加变量"></a>如何在Category中添加变量</h2><pre><code>关联对象来实现。我们可以看到所有的关联对象都由
AssociationsManager管理
AssociationsManager里面是由一个静态AssociationsHashMap来存储
所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。
而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不
同的），而这个map的value又是另外一个AssociationsHashMap，里面保
存了关联对象的kv对。
@interface TestObject (Category)
@property (nonatomic, strong) NSObject *object; @end
#import &lt;objc/runtime.h&gt;
#import &lt;objc/message.h&gt;
static void *const kAssociatedObjectKey = 
(void *)&amp;kAssociatedObjectKey;
@implementation TestObject (Category)
- (NSObject *)object &#123;
return objc_getAssociatedObject(
self, kAssociatedObjectKey);
&#125;
- (void)setObject:(NSObject *)object &#123;
objc_setAssociatedObject(self,
kAssociatedObjectKey, object,
OBJC_ASSOCIATION_RETAIN_NONATOMIC);
&#125;
从原码中可以看出，所有通过associated添加的属性，
都是被单独存放在一个哈希表AssociationsHashMap中，
objc_setAssociatedObject和
objc_getAssociatedObject本质上就是操作这个哈希表，
通过对哈希表进行映射来存取对象。
</code></pre>
<h2 id="在协议-和-分类-中如何使用-property"><a href="#在协议-和-分类-中如何使用-property" class="headerlink" title="在协议 和 分类 中如何使用 @property"></a>在协议 和 分类 中如何使用 @property</h2><pre><code>1、在 protocol 中使用 property 只会生成 setter 和 getter 方法
声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性
2、category 使用 @property 也是只会生成 setter 和 getter 方法
的声明,真要添加属性建议使用关联对象来实现
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/09/M_Swift109OC%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/09/M_Swift109OC%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">OC语言相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 15:34:45" itemprop="dateCreated datePublished" datetime="2018-08-09T15:34:45+08:00">2018-08-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="OC为什么说是一门动态语言"><a href="#OC为什么说是一门动态语言" class="headerlink" title="OC为什么说是一门动态语言"></a>OC为什么说是一门动态语言</h2><pre><code>Objective-C 可以通过Runtime 这个运行时机制，在运行时动态的添加变
量、方法、类等，所以说Objective-C 是一门动态的语言
Objective-C的动态性，让程序在运行时判断其该有的行为，而不是像c等静
态语言在编译构建时就确定下来。它的动态性主要体现在3个方面：
1.动态类型：如id类型。实际上静态类型因为其固定性和可预知性而使用的特
别广泛。静态类型是强类型，动态类型是弱类型，运行时决定接收者。
2.动态绑定：让代码在运行时判断需要调用什么方法，而不是在编译时。与其他
面向对象语言一样，方法调用和代码并没有在编译时连接在一起，而是在消息发
送时才进行连接。运行时决定调用哪个方法。
3.动态载入。让程序在运行时添加代码模块以及其他资源。用户可以根据需要执
行一些可执行代码和资源，而不是在启动时就加载所有组件。可执行代码中可以
含有和程序运行时整合的新类。
</code></pre>
<h2 id="类方法（静态方法）和实例方法（动态方法）区别"><a href="#类方法（静态方法）和实例方法（动态方法）区别" class="headerlink" title="类方法（静态方法）和实例方法（动态方法）区别"></a>类方法（静态方法）和实例方法（动态方法）区别</h2><pre><code>类方法必须使用类调用，存储在元类结构体里面的methodLists里面
实例方法必须使用实例对象调用，存储在类结构体里面的methodLists里面
静态方法在程序开始时生成内存,实例方法在程序运行中生成内存，
所以静态方法可以直接调用,实例方法要先成生实例,通过实例调用方法，静态速
度很快，但是多了会占内存。
静态内存是连续的,因为是在程序开始时就生成了,而实例申请的是离散的空间,
所以当然没有静态方法快，
</code></pre>
<h2 id="ios中定义属性了解"><a href="#ios中定义属性了解" class="headerlink" title="ios中定义属性了解"></a>ios中定义属性了解</h2><pre><code>@property = ivar + getter + setter
实例变量+get方法+set方法 也就是说使用@property系统会自动生成setter和getter方法，
nonatomic 非原子性操作，不提供线程安全，效率更高
nonatomic 非原子性操作，不提供线程安全，效率更高
strong 在赋值的时候调用被只想对象的retuain方法，使其引用计数加1
weak 不增加对象的引用计数，也不持有对象，对象消失后，指针自动变为nil
assign 不更改引用计数，修饰基础数据类型
copy 简历一个引用计数为1的对象，常用于NSString和block
readonly 只读属性
readwrite默认属性 可读可写
@synthesize：编译期间，让编译器自动生成setter方法和getter方法
@dynamic  不自动生成，自己手动生成
</code></pre>
<h2 id="NSString为什么要用copy修饰"><a href="#NSString为什么要用copy修饰" class="headerlink" title="NSString为什么要用copy修饰"></a>NSString为什么要用copy修饰</h2><pre><code>因为父类指针可以指向子类对象，使用copy的目的是为了让本对象的属性不受
外界影响，使用copy无论给我传入的是一个可变的对象黑市不可变的对象，我
本身持有个就是一个不可变的副本
如果我们使用的是strong，那么这个属性就有可能指向一个可变对象，如果这
个可变对象在外部被修改了，那么会影响该属性
</code></pre>
<h2 id="如何让自己的对象具有拷贝功能"><a href="#如何让自己的对象具有拷贝功能" class="headerlink" title="如何让自己的对象具有拷贝功能"></a>如何让自己的对象具有拷贝功能</h2><pre><code>需要遵守NSCopying协议，如果自定义的对象分为可变和不可变版本，那么要
同事细心啊NSCopying和NSMutableCopying协议
copy和mutableCopy区别
针对不可变对象调用copy返回该对象本身，调用mutableCopy返回一个可变对象（新的）
针对可变对象调用copy返回一个不可变对象（新的），调用mutableCopy返回
另外一个可变对象（新的）。
copy:创建的是不可变副本（NSString，NSArray，NSDictionary）
mutableCopy：创建的是可变副本（NSMutableString，
NSMutableArray，NSMutableDictionary）
深拷贝(mutableCopy)就是内容拷贝，即指拷贝对象的具体内容，而内存地址
是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不
一样，两个对象也互不影响，互不干涉;浅拷贝(copy)就是指针拷贝,即对内存
地址的复制，让目标对象指针和源对象指向同一片内存空间。
</code></pre>
<h2 id="为什么IBOutlet修饰的UIView也适用weak关键字"><a href="#为什么IBOutlet修饰的UIView也适用weak关键字" class="headerlink" title="为什么IBOutlet修饰的UIView也适用weak关键字"></a>为什么IBOutlet修饰的UIView也适用weak关键字</h2><pre><code>因为既然有外链那么试图在xib中可定存在，试图已经对他有一个强引用了，使
用storeboars创建的vc会有一个私有数组前引用所有的对象
</code></pre>
<h2 id="使用descperction注意什么"><a href="#使用descperction注意什么" class="headerlink" title="使用descperction注意什么"></a>使用descperction注意什么</h2><pre><code>千万不要在description方法中同时使用%@和self,同时使用了%@和self,
代表要调用self的description方法,因此最终会导致程序陷入死循环,循 环
调用description方法
当该方法使用NSLog(“%@”,self) 时候, 系统做了相关的优化，循坏调用3
次后就会自动退出
</code></pre>
<h2 id="什么时候会报unrecognized-selector错误"><a href="#什么时候会报unrecognized-selector错误" class="headerlink" title="什么时候会报unrecognized selector错误"></a>什么时候会报unrecognized selector错误</h2><pre><code>出现unrecognized selector类型的crash，一般是向对象发送了无法处理
的消息导致的。说白一点就是这个对象没有你调的那个方法，为什么运行的时候
才会出现，这个和OC语言动态绑定的机制有关系。
对象未实现该方法。
对象已经被释放。
</code></pre>
<h2 id="iOS常见错误"><a href="#iOS常见错误" class="headerlink" title="iOS常见错误"></a>iOS常见错误</h2><pre><code>数组越界
向容器存入nil
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/07/M_Swift89%E5%88%A4%E6%96%AD%E7%B1%BB%E7%9B%B8%E5%90%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/07/M_Swift89%E5%88%A4%E6%96%AD%E7%B1%BB%E7%9B%B8%E5%90%8C/" class="post-title-link" itemprop="url">判断类相同</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-07 17:21:40" itemprop="dateCreated datePublished" datetime="2018-08-07T17:21:40+08:00">2018-08-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>1.判断两个指针是否相等，若相等，则均指向同一对象，所以受测的对象也必定
相等。NSObject的isEqual:方法默认是比较两个对象指向的地址是否相等，
直接比较两个对象是否相等，实际上比较的是两个对象的指针是否相等。
2.判断两对象所属的类，若属于同一类
3.hash
比较得时候最好是先计算其哈希码，再进行比较。
4.isEqualToString
如果isEqual判断两个对象相等，那么hash方法也必须返回同一个值，
但是，如果两个对象的hash方法返回同一个值，
那么isEqual方法未必会认为两个方法相同
需要实现&lt;NSCopying&gt;
实现isEqual:方法的同时，要实现hash方法！ 
- (BOOL)isEqual:(id)object &#123;
if (self == object) return YES;
if (![object isKindOfClass:[Person class]]) return NO;
    return [self.name isEqualToString:[object name]];
&#125;
用于判断两个字符串是否相等的方法，当然还有isEqualToArray:   isEqualToDictionary: 
5.深度等同性判定
NSArray 的检测方式需要先比较两个数组所包含的个数是否相同，
若相同，则在每个对应未知的两个对象身上调用其“isEqual:&quot;方法。
如果对应位置上的对象均相等，那么这两个数组就相等。
6.NSSet中可变类的等同性比较
非常复杂，只写结论了：如果把一个对象放入set之后又修改其内容，
那么后面的行为将很难预料，使用过程中一定以注意，
以免得到的不是自己想要的结果
7.两个对象中的各个字段是否相等
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/07/M_Swift96Runtime%E5%B8%B8%E8%A7%81%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/07/M_Swift96Runtime%E5%B8%B8%E8%A7%81%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">Runtime常见作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-07 14:24:43" itemprop="dateCreated datePublished" datetime="2018-08-07T14:24:43+08:00">2018-08-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="动态的添加对象的成员变量和方法"><a href="#动态的添加对象的成员变量和方法" class="headerlink" title="动态的添加对象的成员变量和方法"></a>动态的添加对象的成员变量和方法</h2><pre><code>class_addMethod([self.person class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);
参数说明
&gt;(IMP)guessAnswer 意思是guessAnswer的地址指针;
&gt;&quot;v@:&quot; 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;
&gt;“v@:@@” 意思是，两个参数的没有返回值。  
</code></pre>
<h2 id="动态交换两个方法的实现"><a href="#动态交换两个方法的实现" class="headerlink" title="动态交换两个方法的实现"></a>动态交换两个方法的实现</h2><pre><code>交换方法之后，以后每次调用这两个方法都会交换方法的实现
Method m1 = class_getInstanceMethod([self.person class], @selector(sayName));
Method m2 = class_getInstanceMethod([self.person class], @selector(saySex));
method_exchangeImplementations(m1, m2);
</code></pre>
<h2 id="拦截并替换方法"><a href="#拦截并替换方法" class="headerlink" title="拦截并替换方法"></a>拦截并替换方法</h2><pre><code>我们要改变这个方法的实现，但是又不能去动它的源代码
(正如一些开源库出现问题的时候)，
这个时候runtime就派上用场了
我们先增加一个tool类，然后写一个我们自己实现的方法-change，
通过runtime把test1替换成change。
Class PersionClass = object_getClass([Person class]);
Class toolClass = object_getClass([tool class]);
////源方法的SEL和Method
SEL oriSEL = @selector(test1);
Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL);
////交换方法的SEL和Method
SEL cusSEL = @selector(change);
Method cusMethod = class_getInstanceMethod(toolClass, cusSEL);
////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况
BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));
if (addSucc) &#123;
    // 添加成功：将源方法的实现替换到交换方法的实现     
    class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));
&#125;else &#123;
    //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即
    method_exchangeImplementations(oriMethod, cusMethod);  
&#125;
</code></pre>
<h2 id="在方法上增加额外功能"><a href="#在方法上增加额外功能" class="headerlink" title="在方法上增加额外功能"></a>在方法上增加额外功能</h2><pre><code>有这样一个场景，出于某些需求，我们需要跟踪记录APP
中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮
类或者通过类别实现是一个办法，但是带来其他问题比如别人不
一定会去实例化你写的子类，或者其他类别也实现了点击方法导
致不确定会调用哪一个，runtime可以这样解决，
实现场景二、我们app经常会遇到一些cash，我们可以通过
runtime拦截替换这些方法，从而保证不会崩溃，例如如下列举
    NSArray+NSRangeException
    NSDictionary+NSRangeException
    NSMutableAttributedString+NSRangeException
    NSMutableString+NSRangeException
    NSNull+Exception
    NSObject+Swizzling
    NSString+NSRangeException
    UINavigationController+Consistent
load方法会在类第一次加载的时候被调用,调用的时间比较靠前，
适合在这个方法里做方法交换,方法交换应该被保证，
在程序中只会执行一次。
+ (void)load &#123;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^&#123;
        Class selfClass = [self class];
        SEL oriSEL = @selector(sendAction:to:forEvent:);
        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);
        SEL cusSEL = @selector(mySendAction:to:forEvent:);
        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);
        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));
        if (addSucc) &#123;
            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));
        &#125;else &#123;
            method_exchangeImplementations(oriMethod, cusMethod);
        &#125;
    &#125;);
&#125;
- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;
    [[Tool sharedManager] addCount];
    [self mySendAction:action to:target forEvent:event];
&#125;
</code></pre>
<h2 id="实现NSCoding的自动归档和解档"><a href="#实现NSCoding的自动归档和解档" class="headerlink" title="实现NSCoding的自动归档和解档"></a>实现NSCoding的自动归档和解档</h2><pre><code>- (void)encodeWithCoder:(NSCoder *)encoder
&#123;
    unsigned int count = 0;
    Ivar *ivars = class_copyIvarList([Movie class], &amp;count);
    for (int i = 0; i&lt;count; i++) &#123;
        // 取出i位置对应的成员变量
        Ivar ivar = ivars[i];
        // 查看成员变量
        const char *name = ivar_getName(ivar);
        // 归档
        NSString *key = [NSString stringWithUTF8String:name];
        id value = [self valueForKey:key];
        [encoder encodeObject:value forKey:key];
    &#125;
    free(ivars);
&#125;

- (id)initWithCoder:(NSCoder *)decoder
&#123;
    if (self = [super init]) &#123;
        unsigned int count = 0;
        Ivar *ivars = class_copyIvarList([Movie class], &amp;count);
        for (int i = 0; i&lt;count; i++) &#123;
            // 取出i位置对应的成员变量
            Ivar ivar = ivars[i];
            // 查看成员变量
            const char *name = ivar_getName(ivar);
            // 归档
            NSString *key = [NSString stringWithUTF8String:name];
            id value = [decoder decodeObjectForKey:key];
            // 设置到成员变量身上
            [self setValue:value forKey:key];
        &#125;
        free(ivars);
    &#125;
    return self;
&#125;
</code></pre>
<h2 id="实现字典转模型的自动转换"><a href="#实现字典转模型的自动转换" class="headerlink" title="实现字典转模型的自动转换"></a>实现字典转模型的自动转换</h2><pre><code>字典转模型的应用可以说是每个app必然会使用的场景,
虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有
属性，根据模型的属性名，去字典中查找key，取出对应的值，
给模型的属性赋值。
像几个出名的开源库：JSONModel,MJExtension等都是通过这
种方式实现的。
// 创建对应模型对象
id objc = [[self alloc] init];
unsigned int count = 0;
// 1.获取成员属性数组
Ivar *ivarList = class_copyIvarList(self, &amp;count);
// 2.遍历所有的成员属性名,一个一个去字典中取出对应的
value给模型属性赋值
for (int i = 0; i &lt; count; i++) &#123;
    // 2.1 获取成员属性
    Ivar ivar = ivarList[i];
    // 2.2 获取成员属性名 C -&gt; OC 字符串
    NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];
    // 2.3 _成员属性名 =&gt; 字典key
    NSString *key = [ivarName substringFromIndex:1];
    // 2.4 去字典中取出对应value给模型属性赋值
    id value = dict[key];
    // 获取成员属性类型
    NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];
&#125;
如果模型比较简单，只有NSString，NSNumber等，
这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。
if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType containsString:@&quot;NS&quot;]) &#123; 
    //  是字典对象,并且属性名对应类型是自定义类型
    // 处理类型字符串 @\&quot;User\&quot; -&gt; User
    ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];
    ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;&quot;];
    // 自定义对象,并且值是字典
    // value:user字典 -&gt; User模型
    // 获取模型(user)类对象
    Class modalClass = NSClassFromString(ivarType);
    // 字典转模型
    if (modalClass) &#123;
        // 字典转模型 user
        value = [modalClass objectWithDict:value];
    &#125;
&#125;
if ([value isKindOfClass:[NSArray class]]) &#123;
    // 判断对应类有没有实现字典数组转模型数组的协议
    if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;
        // 转换成id类型，就能调用任何对象的方法
        id idSelf = self;
        // 获取数组中字典对应的模型
        NSString *type =  [idSelf arrayContainModelClass][key];
        // 生成模型
        Class classModel = NSClassFromString(type);
        NSMutableArray *arrM = [NSMutableArray array];
        // 遍历字典数组，生成模型数组
        for (NSDictionary *dict in value) &#123;
            // 字典转模型
            id model =  [classModel objectWithDict:dict];
            [arrM addObject:model];
        &#125;
        // 把模型数组赋值给value
        value = arrM;
    &#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">266</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
