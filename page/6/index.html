<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift140%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%861/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift140%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%861/" class="post-title-link" itemprop="url">UI相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:03" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:03+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="drawRect和layouSubviews-的区别"><a href="#drawRect和layouSubviews-的区别" class="headerlink" title="drawRect和layouSubviews 的区别"></a>drawRect和layouSubviews 的区别</h2><p>1   layoutSubviews方便数据计算，<br>2   drawRect方便视图重绘。<br>layoutSubviews在以下情况下会被调用：<br>addSubview、改变view的大小、滚动一个UIScrollView、<br>旋转Screen会触发父UIView上的layoutSubviews，调用setLayoutSubviews。<br>drawRect在以下情况下会被调用：（必须有大小）<br>loadView，viewDidLoad，sizeToFit<br>直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:<br>强制layout刷新,调用setNeedsLayout来代替</p>
<h2 id="setNeedsLayout与layoutIfNeeded的区别"><a href="#setNeedsLayout与layoutIfNeeded的区别" class="headerlink" title="setNeedsLayout与layoutIfNeeded的区别"></a>setNeedsLayout与layoutIfNeeded的区别</h2><p>UIView的setNeedsDisplay和setNeedsLayout两个方法都是异步执行的。<br>而setNeedsDisplay会自动调用drawRect方法，这样可以拿到<br>UIGraphicsGetCurrentContext进行绘制；而setNeedsLayout会默认调用<br>layoutSubViews，给当前的视图做了标记；layoutIfNeeded<br>查找是否有标记，如果有标记及立刻刷新。<br>只有setNeedsLayout和layoutIfNeeded这二者合起来使用，才会起到立刻刷新的效果。</p>
<h2 id="Core-Graphics的更底层的是什么；"><a href="#Core-Graphics的更底层的是什么；" class="headerlink" title="Core Graphics的更底层的是什么；"></a>Core Graphics的更底层的是什么；</h2><p>　1）获取上下文<br>　2）绘制路径<br>　3）添加路径到上下文<br>　4）修改图形状态参数<br>　5）渲染上下文<br>　CGContextRef、CGPathRef、UIBezierPath</p>
<h2 id="iOS-保持界面流畅的技巧"><a href="#iOS-保持界面流畅的技巧" class="headerlink" title="iOS 保持界面流畅的技巧"></a>iOS 保持界面流畅的技巧</h2><p>1.预排版，提前计算<br>在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。<br>尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式<br>2.预渲染，提前绘制<br>例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了<br>避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。<br>3.异步绘制<br>4.全局并发线程<br>5.高效的图片异步加载</p>
<h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h2 id="消息转发的流程"><a href="#消息转发的流程" class="headerlink" title="消息转发的流程"></a>消息转发的流程</h2><p>（动态添加） 首先是征询接收者所属的类,看其是否能动态添加调用的方法,来处理当前这个未知的选择子;<br>-(BOOL)resolveInstanceMethod:(SEL)selector<br>（重定向-备援接收者）寻找是否在其他对象内有该方法实现,并将该消息转发给这个对象</p>
<ul>
<li>(id)forwardingTargetForSelector:(SEL)aSelector<br>生成方法签名，然后系统用这个方法签名生成NSInvocation对象。</li>
<li>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector<br>改变选择子</li>
<li>(void)forwardInvocation:(NSInvocation *)Invocation<br>抛出异常</li>
<li>(void)doesNotRecognizeSelector:(SEL)aSelector方法<h2 id="runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）"><a href="#runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）"></a>runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</h2>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,<br>以及参数类型,其实selector本质就是方法名称,<br>通过这个方法名称就可以在方法列表中找到对应的方法实现.<h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2>在runtime中所有类都存在一个哈希表中，在table的buckets中存储</li>
</ul>
<ol>
<li>加载所有类到类的gdb_objc_realized_classes表中</li>
<li>对所有类做重映射</li>
<li>将所有SEL都注册到namedSelectors表中</li>
<li>修复函数指针遗留</li>
<li>将所有Protocol添加到protocol_map表中</li>
<li>将所有Protocol重映射</li>
<li>初始化所有非懒加载的类，进行rw，ro操作 </li>
<li>便利所有懒加载类，执行初始化</li>
<li>处理所有Category包括Class和MetaClass</li>
<li>初始化所有未初始化类<h2 id="msgSend参数都有哪些；"><a href="#msgSend参数都有哪些；" class="headerlink" title="msgSend参数都有哪些；"></a>msgSend参数都有哪些；</h2><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="NSObject内存分配、ISA指针的内存大小"><a href="#NSObject内存分配、ISA指针的内存大小" class="headerlink" title="NSObject内存分配、ISA指针的内存大小"></a>NSObject内存分配、ISA指针的内存大小</h2>在64位架构下，如果他的第一位是0 。则代表他是一个 isa<br>指针,表示当前对象的类对象的地址，如果是1，则不仅代表一个 isa<br>指针,类对象的地址，里面还存储内存管理相关的内容，第二位代表是否有关联对象，<br>0代表没有，1代表有（has_assoc）,第三位,代表当前对象是否含有C++代码<br>（has_cxx_dtor）,3-15表示当前对象的类对象内存地址,16-31<br>,也是，32-35位也是，也就是说，13+16+4 = 33位<h2 id="子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool"><a href="#子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool" class="headerlink" title="子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool"></a>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool</h2>在子线程你创建了 Pool 的话，产生的 Autorelease 对象就会交给 pool 去管理。<br>如果你没有创建 Pool ，但是产生了 Autorelease 对象，就会调用 autoreleaseNoPage<br>方法。在这个方法中，会自动帮你创建一个 hotpage（hotPage 可以理解为当前正在使用的<br>AutoreleasePoolPage，如果你还是不理解，可以先看看 Autoreleasepool<br>的源代码，再来看这个问题 ），并调用 page-&gt;add(obj)将对象添加到<br>AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！<h2 id="dealloc调用流程"><a href="#dealloc调用流程" class="headerlink" title="dealloc调用流程"></a>dealloc调用流程</h2></li>
<li>直接调用 objc_destructInstance()。</li>
<li>之后调用C的 free() 函数。</li>
<li>objc_destructInstance() 调用流程<br>1&gt;.先判断 hasCxxDtor，是否有析构函数（析构器），<br>要调用 object_cxxDestruct() ，释放（清除成员变量）。<br>2&gt;.再判断hasAssocitatedObjects，如果有的话，<br>要调用object_remove_associations()， 移除当前对象的关联对象。<br>3&gt;.然后调用 clearDeallocating()。 </li>
<li>clearDeallocating() 调用流程<br>0&gt;. 判断isa是否优化过，从arm64架构开始，对isa进行了优化，<br>变成了一个共用体（union）结构，所以结果一般是优化过了。<br>判断是否有弱引用或者引用计数<br>1&gt;.执行 clearDeallocating_slow()。<br>2&gt;.再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。<br>3&gt;.接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。<br>4&gt;.至此为止，Dealloc 的执行流程结束。<h2 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h2>启用Zombie Object进行悬挂指针的检测。<br>应用Product -&gt; Analysis进行内存泄露的初步检测。<br>可以在xcode的build setting中打开implicit retain of ‘self’<br>within blocks，xcode编译器会给出警告，逐个排查警告。<br>应用Leak Instrument进行内存泄露查找。<br>在以上方法不奏效的情况下，通过查看dealloc是否调用查看某个class是否泄露的问题</li>
</ol>
<h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><p>内存泄漏（memory leak）：是指申请的内存空间使用完毕之后未回收。<br>一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，<br>最终导致程序crash。（因此，开发中我们要尽量避免内存泄漏的出现）<br>内存溢出（out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用。<br>通俗理解就是内存不够用了，通常在运行大型应用或游戏时，应用或游戏所需要<br>的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。最终导致机器重启或者程序crash。<br>第一种：静态分析方法（Analyze）<br>第二种：动态分析方法（Instrument工具库里的Leaks）。一般推荐使用第二种。</p>
<h2 id="举例一些I-O操作的例子"><a href="#举例一些I-O操作的例子" class="headerlink" title="举例一些I/O操作的例子"></a>举例一些I/O操作的例子</h2><p>1）阻塞IO<br>2）非阻塞IO<br>3）IO复用（select和poll）<br>4）信号驱动IO（sigio）<br>5）异步IO（aio_）</p>
<h2 id="如何开辟一块内存；"><a href="#如何开辟一块内存；" class="headerlink" title="如何开辟一块内存；"></a>如何开辟一块内存；</h2><p>其实结论就是 实际分配内存是按照16字节对齐的 内存大小都是16 的倍数。</p>
<h2 id="怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手"><a href="#怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手" class="headerlink" title="怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手"></a>怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手</h2><p>复用机制<br>少使用xib<br>不要阻塞线程<br>图片优化<br>合理使用数组字典优化查找速度<br>懒加载<br>缓存<br>一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。可以用单例来处理，避免日期格式转换<br>选择正确的数据格式，json、xml、二进制数据流<br>少使用webView<br>优化tableView<br>选择正确的数据持久化</p>
<h2 id="问堆和栈的区别。"><a href="#问堆和栈的区别。" class="headerlink" title="问堆和栈的区别。"></a>问堆和栈的区别。</h2><p>（答对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。）</p>
<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop概念及数据结构、事件循环机制"><a href="#RunLoop概念及数据结构、事件循环机制" class="headerlink" title="RunLoop概念及数据结构、事件循环机制"></a>RunLoop概念及数据结构、事件循环机制</h2><p>CFRunLoop<br>CFRunLoopMode<br>Source/Timer/Observer<br>source0<br>需要手动唤醒线程<br>source1<br>具备唤醒线程的能力<br>CFRunLoopObserver<br>观测时间点<br>kCFRunLoopEntry<br>kCFRunLoopBeforeTimers<br>CommonMode的特性<br>NSRunLoopCommonModes<br>commonMode不是实际存在的一种mode<br>是同步Source/Timer/Observer到多个Mode中的一种技术方案<br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个<br>Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个<br>Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出<br>Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的<br>Source/Timer/Observer，让其互不影响。</p>
<h2 id="RunLoop和多线程"><a href="#RunLoop和多线程" class="headerlink" title="RunLoop和多线程"></a>RunLoop和多线程</h2><p>在异步线程中下载很多图片,如果失败了,该如何处理?请结合RunLoop来谈谈解决方案<br>在异步线程中启动一个RunLoop重新发送网络请求,下载图片<br>如果程序启动就需要执行一个耗时操作，你会怎么做？<br>开启一个异步的子线程，并启动它的RunLoop来执行该耗时操作</p>
<h2 id="你在开发过程中怎么使用RunLoop？什么应用场景？"><a href="#你在开发过程中怎么使用RunLoop？什么应用场景？" class="headerlink" title="你在开发过程中怎么使用RunLoop？什么应用场景？"></a>你在开发过程中怎么使用RunLoop？什么应用场景？</h2><p>开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来的消息，处理其他事件）<br>在子线程中开启一个定时器<br>在子线程中进行一些长期监控<br>可以控制定时器在特定模式下运行<br>可以让某些事件（行为，任务）在特定模式下执行<br>可以添加observer监听RunLoop的状态，比如监听点击事件的处理（比如在所有点击事件前做一些处理）<br>1）NSTimer<br>2）ImageView显示：控制方法在特定的模式下可用<br>3）PerformSelector<br>4）常驻线程：在子线程中开启一个runloop<br>5）自动释放池</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="GCD、NSOperation、NSThread区别优缺点"><a href="#GCD、NSOperation、NSThread区别优缺点" class="headerlink" title="GCD、NSOperation、NSThread区别优缺点"></a>GCD、NSOperation、NSThread区别优缺点</h2><p>第一种：pthread<br>    a.特点：<br>        1）一套通用的多线程API<br>        2）适用于Unix\Linux\Windows等系统<br>        3）跨平台\可移植<br>        4）使用难度大<br>    b.使用语言：c语言<br>    c.使用频率：几乎不用<br>    d.线程生命周期：由程序员进行管理<br>第二种：NSThread<br>    a.特点：<br>        1）使用更加面向对象<br>        2）简单易用，可直接操作线程对象<br>        b.使用语言：OC语言<br>        c.使用频率：偶尔使用<br>        d.线程生命周期：由程序员进行管理<br>第三种：GCD<br>    a.特点：<br>        1）旨在替代NSThread等线程技术<br>        2）充分利用设备的多核（自动）<br>    b.使用语言：C语言<br>    c.使用频率：经常使用<br>    d.线程生命周期：自动管理<br>第四种：NSOperation<br>    a.特点：<br>        1）基于GCD（底层是GCD）<br>        2）比GCD多了一些更简单实用的功能<br>        3）使用更加面向对象<br>    b.使用语言：OC语言<br>    c.使用频率：经常使用<br>    d.线程生命周期：自动管理</p>
<h2 id="如何让多个网络请求完成后执行下一步"><a href="#如何让多个网络请求完成后执行下一步" class="headerlink" title="如何让多个网络请求完成后执行下一步"></a>如何让多个网络请求完成后执行下一步</h2><p>  dispatch_group_t</p>
<h2 id="多个网络请求顺序执行后执行下一步"><a href="#多个网络请求顺序执行后执行下一步" class="headerlink" title="多个网络请求顺序执行后执行下一步"></a>多个网络请求顺序执行后执行下一步</h2><pre><code>dispatch_semaphore_wait
</code></pre>
<h2 id="异步操作两组数据时-执行完第一组之后-才能执行第二组"><a href="#异步操作两组数据时-执行完第一组之后-才能执行第二组" class="headerlink" title="异步操作两组数据时, 执行完第一组之后, 才能执行第二组"></a>异步操作两组数据时, 执行完第一组之后, 才能执行第二组</h2><pre><code>dispatch_barrier_async
</code></pre>
<h2 id="你知道哪些锁、使用场景"><a href="#你知道哪些锁、使用场景" class="headerlink" title="你知道哪些锁、使用场景"></a>你知道哪些锁、使用场景</h2><p>@synchronized 一个对象层面的锁，锁住了整个对象，底层使用了互斥递归<br>锁来实现<br>pathread_mutex 互斥锁（c语言）和信号量的实现原理类似，也是阻塞线程并进入睡眠<br>，需要进行上下文切换。<br>NSLock 对象锁-简单的互斥锁（内部封装了一个 pthread_mutex）<br>NSCondition （封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件<br>NSCondition和NSLock、@synchronized等是不同的是，<br>NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。<br>这是非常强大。<br>NSConditionLock （借助 NSCondition 来实现，本质是生产者-消费者模型）<br>也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。<br>NSRecursiveLock 递归锁有时候“加锁代码”中存在递归调用，递归开始前加<br>dispatch_semaphore GCD中信号量，也可以解决资源抢占问题,<br>支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；<br>每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，<br>直到信号量大于0开始执行<br>OSSpinLock 自旋锁(不建议使用)<br>自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取<br>锁就需要等待a线程释放锁。在没有获得锁的期间，b线程会一直处于忙等的状<br>态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太<br>划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。</p>
<h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><p>相同点：都能保证同一时间只有一个线程访问共享资源。<br>都能保证线程安全。<br>不同点：<br>互斥锁：如果共享数据已经有其他线程加锁了，线程会进入<br>休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的<br>线程会被唤醒。<br>自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环<br>的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会<br>立即执行。<br>自旋锁的效率高于互斥锁。<br>由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放<br>自旋锁，否则等待该自旋锁的线程会一直在哪里自旋，这就会浪<br>费CPU时间。<br>持有自旋锁的线程在sleep之前应该释放自旋锁以便其他可以获得<br>该自旋锁。内核编程中，如果持有自旋锁的代码sleep了就可能<br>导致整个系统挂起。</p>
<h2 id="runloop与autoreleasepool的关系"><a href="#runloop与autoreleasepool的关系" class="headerlink" title="runloop与autoreleasepool的关系"></a>runloop与autoreleasepool的关系</h2><p>(AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组成)<br>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），<br>除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址<br>iOS里的TaggedPointer不适用autorelesepool<br>AutoreleasePool 在 runloop 在开始时被push，在runloop休眠时(beforewaiting状态)pop</p>
<h2 id="GCD-在Runloop中的使用"><a href="#GCD-在Runloop中的使用" class="headerlink" title="GCD 在Runloop中的使用"></a>GCD 在Runloop中的使用</h2><pre><code>GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。
</code></pre>
<h2 id="GCD-Global队列创建线程进行耗时操作的风险"><a href="#GCD-Global队列创建线程进行耗时操作的风险" class="headerlink" title="GCD Global队列创建线程进行耗时操作的风险"></a>GCD Global队列创建线程进行耗时操作的风险</h2><p>dispatch_async 函数分发到全局队列不一定会新建线程执行任务，全局队列底层有一个的线程池，如果线程池满了，<br> 那么后续的任务会被 block 住，等待前面的任务执行完成，才会继续执行。如果线程池中的线程<br> 长时间不结束，后续堆积的任务会越来越多，此时就会存在 APP crash的风险。<br> 避免使用 GCD Global 队列创建 Runloop 常驻线程</p>
<h2 id="NSOperation数据结构"><a href="#NSOperation数据结构" class="headerlink" title="NSOperation数据结构"></a>NSOperation数据结构</h2><p>ddDependency操作依赖性<br>KVO 兼容属性<br>cancelAllOperations 响应取消命令<br>start;执行操作<br>NSBlockOperation：用于管理一个或多个block的并发执行。<br>NSInvocationOperation：NSInvocationOperation类是NSOperation的一个具体<br>子类，用于开启一个操作，该操作包括在指定对象上调用一个selector。</p>
<h2 id="重写NSOperation需要注意的点"><a href="#重写NSOperation需要注意的点" class="headerlink" title="重写NSOperation需要注意的点"></a>重写NSOperation需要注意的点</h2><p>1、如果需要自定义并发执行的 Operation，必须重写start、main、isExecuting、isFinished、isAsynchronous方法。<br>2、在 operation 的 main 方法里面，必须提供 autorelease pool,因为你的 operation 完成后需要销毁。<br>3、一旦你的 operation 开始了，必须通过 KVO，告诉所有的监听者，现在该operation的执行状态。<br>4、调用时，如果需要并发执行 Operation，必须调用performOperation:方法，当然，也可以改为自定义其他方法或者直接在start方法添加多线程调用。<br>5、对于自定义的 Operation 类，如果不需要并发执行，可以直接调用start</p>
<h2 id="进程中的哪些空间是线程所共有的？"><a href="#进程中的哪些空间是线程所共有的？" class="headerlink" title="进程中的哪些空间是线程所共有的？"></a>进程中的哪些空间是线程所共有的？</h2><p>  一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)</p>
<h2 id="使用GCD需要注意什么；"><a href="#使用GCD需要注意什么；" class="headerlink" title="使用GCD需要注意什么；"></a>使用GCD需要注意什么；</h2><p>dispatch_sync同步死锁（循环等待）<br>重复的获取互斥资源引发的等待（加锁）<br>开启过多线程<br>线程和RunLoop，子线程不会开启runloop</p>
<h2 id="runloop跟runtime有没有关联"><a href="#runloop跟runtime有没有关联" class="headerlink" title="runloop跟runtime有没有关联"></a>runloop跟runtime有没有关联</h2><p>个人想到的是autoreleasepool、其他的不好找<br>runloop中事件源都是由运行时runtime触发</p>
<h2 id="CPU和GPU怎么相互合作的"><a href="#CPU和GPU怎么相互合作的" class="headerlink" title="CPU和GPU怎么相互合作的"></a>CPU和GPU怎么相互合作的</h2><p>命令缓冲区包含了一个命令队列，由CPU向其中添加命令，而由GPU从中读取命令<br>，添加和读取的过程是互相独立的。命令缓冲区使得CPU和GPU可以互相独立工作<br>。当CPU需要渲染一些对象时，它可以向命令缓冲区中添加命令，而当GPU完成了上<br>一次的渲染任务后，它就可以从命令队列中再取出一个命令并执行它。</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTPS-TLS-SSL加密过程"><a href="#HTTPS-TLS-SSL加密过程" class="headerlink" title="HTTPS TLS/SSL加密过程"></a>HTTPS TLS/SSL加密过程</h2><p>1、客户端向服务器端索要并验证公钥。<br>2、双方协商生成”对话密钥”。<br>3、双方采用”对话密钥”进行加密通信。<br>其中，前两个阶段，被称为“握手阶段”。<br>TLS握手过程有单向验证和双向验证之分，简单解释一下，单向验证就是<br>server端将证书发送给客户端，客户端验证server端证书的合法性等，<br>例如百度、新浪、google等普通的https网站，双向验证则是不仅客户端会验<br>证server端的合法性，同时server端也会验证客户端的合法性，例如银行网银登陆<br>，支付宝登陆交易等。<br>1、确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>2、一个服务器生成的随机数（Sever Random），稍后用于生成”对话密钥”。<br>3、确认使用的加密方法，比如RSA公钥加密。<br>4、服务器证书（Certificate）。<br>5、支持的一些SSL/TLS扩展。</p>
<h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><p>①客户端发送报文进行SSL通信。报文中包含客户端支持的SSL的指定版本、<br>加密组件列表（加密算法及密钥长度等）。<br>②服务器应答，并在应答报文中包含SSL版本以及加密组件。<br>服务器的加密组件内容是从接受到的客户端加密组件内筛选出来的。<br>③服务器发送报文，报文中包含公开密钥证书。<br>④服务器发送报文通知客户端，最初阶段SSL握手协商部分结束。<br>⑤SSL第一次握手结束之后，客户端发送一个报文作为回应。<br>报文中包含通信加密中使用的一种被称Pre-master<br>secret的随机密码串。该密码串已经使用服务器的公钥加密。<br>⑥客户端发送报文，并提示服务器，此后的报文通信会采用<br>Pre-master secret密钥加密。<br>⑦客户端发送Finished报文。该报文包含连接至今全部报文的<br>整体校验值。这次握手协商是否能够完成成功，要以服务器是否能够正确解密该报文作为判定标准。<br>⑧服务器同样发送Change Cipher Spec报文。<br>⑨服务器同样发送Finished报文。<br>⑩服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。<br>⑪应用层协议通信，即发送HTTP响应。<br>⑫最后由客户端断开链接。断开链接时，发送close_nofify报文</p>
<h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。<br>  由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>  对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，<br>  再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>  pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，<br>  如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用<br>  pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和<br>  服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机<br>  可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，<br>  随机性增加的可不是一。</p>
<h2 id="TCP特点及与UDP区别"><a href="#TCP特点及与UDP区别" class="headerlink" title="TCP特点及与UDP区别"></a>TCP特点及与UDP区别</h2><p>基于连接（点对点）<br>传输数据前需要建立好连接，然后在传输<br>双工通信<br>TCP连接一旦建立，就可以在连接上进行双向的通信<br>基于字节流而非报文<br>将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制能够保证TCP协议的有序性和完整性，因此TCP能够提供可靠性传输</p>
<p>可靠传输<br>拥塞控制<br>慢启动，拥塞避免，拥塞发生，快速恢复四个算法<br>流量控制能力</p>
<h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><p>DNS服务器一般分三种，根DNS服务器，顶级DNS服务器，权威DNS服务器。<br>1）浏览器缓存　　<br>2）系统缓存　　<br>3）路由器缓存　　　　<br>4） ISP（互联网服务提供商）DNS缓存<br>5）根域名服务器　　　<br>6）顶级域名服务器　　<br>8）保存结果至缓存</p>
<h2 id="HTTP请求头都有哪些内容"><a href="#HTTP请求头都有哪些内容" class="headerlink" title="HTTP请求头都有哪些内容"></a>HTTP请求头都有哪些内容</h2><p>Accept: <em>/</em>(客户端能接收的资源类型)<br>Accept-Language: en-us(客户端接收的语言类型)<br>Connection: Keep-Alive(维护客户端和服务端的连接关系)<br>Host: localhost:8080(连接的目标主机和端口号)<br>Referer: <a target="_blank" rel="noopener" href="http://localhost/links.asp(%E5%91%8A%E8%AF%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%91%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%93%AA%E9%87%8C)">http://localhost/links.asp(告诉服务器我来自于哪里)</a><br>User-Agent: Mozilla/4.0(客户端版本号的名字)<br>Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)<br>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)<br>Cookie(客户端暂存服务端的信息)<br>Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间</p>
<h2 id="哪些加密算法"><a href="#哪些加密算法" class="headerlink" title="哪些加密算法"></a>哪些加密算法</h2><p>MD5加密算法<br>RSA加密算法<br>AES加密算法<br>Base64加密算法</p>
<h2 id="断点续传怎么实现"><a href="#断点续传怎么实现" class="headerlink" title="断点续传怎么实现;"></a>断点续传怎么实现;</h2><p>续传的文件就好说了，只要给一个续传的标识位置，和对应的字节流就可以了，代码如下:<br>filePath:生成的文件,用来续传用<br>content:将要写入的字节<br>position:续传的字节位置</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p> 单一职责原则<br>      CALayer：动画和视图的显示。<br>      UIView：只负责事件传递、事件响应。<br>      生成的数据模型<br>  开闭原则<br>      对修改关闭，对扩展开放。 要考虑到后续的扩展性，而不是在原有的基础上来回修改<br>  接口隔离原则<br>      使用多个专门的协议、而不是一个庞大臃肿的协议，如<br>      UITableviewDelegate + UITableViewDataSource<br>  依赖倒置原则<br>      抽象不应该依赖于具体实现、具体实现可以依赖于抽象。<br>      调用接口感觉不到内部是如何操作的<br>  里氏替换原则<br>      父类可以被子类无缝替换，且原有的功能不受任何影响 如：KVO<br>  迪米特法则<br>      一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合</p>
<h2 id="iOS有哪些常见的设计模式"><a href="#iOS有哪些常见的设计模式" class="headerlink" title="iOS有哪些常见的设计模式?"></a>iOS有哪些常见的设计模式?</h2><p>01代理委托Delegate是协议的一种<br> ,通过@protocol方式实现，常见的有tableView，textField等。<br> 02观察者 通知机制(notification)和KVO机制(Key-value Observing)<br> 03MVC<br> 04单例（Singleton）,UIApplication, NSBundle, NSNotificationCenter,<br> NSFileManager, NSUserDefault, NSURLCache等都是单例.<br> 05策略<br> 06工厂</p>
<h2 id="内存设计、磁盘设计、网络设计原则"><a href="#内存设计、磁盘设计、网络设计原则" class="headerlink" title="内存设计、磁盘设计、网络设计原则"></a>内存设计、磁盘设计、网络设计原则</h2><p>内存设计:存储的Size,淘汰策略 LRU算法<br>磁盘设计:存储方式\大小限制\淘汰策略<br>网络设计:图片请求最大并发\请求超时策略\请求优先级</p>
<h2 id="MVVM模式思想"><a href="#MVVM模式思想" class="headerlink" title="MVVM模式思想"></a>MVVM模式思想</h2><p>MVVM 即模型-视图-视图模型<br>在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，<br>ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel<br>能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，<br>ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的<br>双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。<br>优点 VIew可以独立于Model的变化和修改，一个ViewModel可以绑定到不同的View上，<br> 降低耦合，增加重用<br> 缺点 过于简单的项目不适用、大型的项目视图状态较多时构建和维护成本太大<br> 合理的运用架构模式有利于项目、团队开发工作，但是到底选择哪个设计模式，</p>
<h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><p>Flux是Facebook用来构建用户端的web应用的应用程序体系架构。<br>它通过利用数据的单向流动为React的可复用的视图组件提供了补充。<br>相比于形式化的框架它更像是一个架构思想，不需要太多新的代码你就可以马上<br>使用Flux构建你的应用。<br>一个 Flux 应用主要包含四个部分：<br>dispatcher<br>处理动作分发，维护 Store 之间的依赖关系<br>stores<br>数据和逻辑部分<br>views<br>React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互<br>actions<br>提供给 dispatcher 传递数据给 store<br>视图上添加的所有的视图组成一个视图多叉树；<br>比如某个UI发生变化后，需要反向到根节点，然后由根节点想下遍历查找需<br>要更新的结点；<br>任何一个子节点是没有权利自我更新的，需要把自我变化更<br>新的消息传递给根节点，由根节点进行更新，相当于由主动行为变成被动行为</p>
<h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：<br>   排版，绘制，UI对象操作。<br>   排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>   绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>   UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。<br>   其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主<br>   线程完成，并且有时后面的操作需要依赖前面操作的结果<br>   （例如TextView创建时可能需要提前计算出文本的大小）。ASDK<br>   所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟<br>   (例如视图的创建、属性的调整)。<br>   为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了<br>   UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如<br>   frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只<br>   通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制<br>   放入了后台线程。但是无论怎么操作，<br>   这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>   ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面<br>   更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了<br>   kCFRunLoopBeforeWaiting 和 kCFRunLoopExit<br>   事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<h2 id="AFNetworking-底层原理分析"><a href="#AFNetworking-底层原理分析" class="headerlink" title="AFNetworking 底层原理分析"></a>AFNetworking 底层原理分析</h2><p>AFNetworking是封装的NSURLSession的网络请求，由五个模块组成：<br>分别由NSURLSession,Security,Reachability,Serialization,UIKit五部分组成<br>NSURLSession：网络通信模块（核心模块） 对应 AFNetworking中的<br>AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager<br>,AFHTTPSessionManager是继承于AFURLSessionmanager的<br>Security：网络通讯安全策略模块 对应 AFSecurityPolicy<br>Reachability：网络状态监听模块 对应AFNetworkReachabilityManager<br>Seriaalization：网络通信信息序列化、反序列化模块 对应AFURLResponseSerialization<br>UIKit：对于iOS UIKit的扩展库</p>
<h2 id="SDWebImage加载图片过程，图片缓存设计"><a href="#SDWebImage加载图片过程，图片缓存设计" class="headerlink" title="SDWebImage加载图片过程，图片缓存设计"></a>SDWebImage加载图片过程，图片缓存设计</h2><p>0、首先显示占位图<br>1、在webimagecache中寻找图片对应的缓存，它是以url为数据索引先在内存中<br>查找是否有缓存；<br>2、如果没有缓存，就通过md5处理过的key来在磁盘中查找<br>对应的数据，如果找到就会把磁盘中的数据加到内存中，并显示出来；<br>3、如果内存和磁盘中都没有找到，就会向远程服务器发送请求，开始下载图片；<br>4、下载完的图片加入缓存中，并写入到磁盘中；<br>5、整个获取图片的过程是在子线程中进行，在主线程中显示。</p>
<h2 id="组建化优缺点"><a href="#组建化优缺点" class="headerlink" title="组建化优缺点"></a>组建化优缺点</h2><p>业务分层、解耦，使代码变得可维护；<br>有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；<br>便于各业务功能拆分、抽离，实现真正的功能复用；<br>分工更加明确，提高开发效率<br>复用性更好，能迅速的组成更多的App</p>
<h2 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h2><p>视图层(View&amp;ViewController)<br>业务逻辑处理(ViewModel)<br>数据层(Model&amp;Engine)<br>数据流<br>数据与数据关系<br>MVVM框架思想<br>ReactiveNative的数据流思想<br>系统UIView更新机制的思想<br>FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想</p>
<h2 id="解耦的方式"><a href="#解耦的方式" class="headerlink" title="解耦的方式"></a>解耦的方式</h2><p>1、组件化<br>2、结合MVVM架构和数据驱动UI模式对原有MVC架构进行了兼容性优化<br>3、通过AOP技术对部分业务进行拆分解耦<br>4、优化事件传递方式</p>
<h2 id="项目中用的技术以及实现；"><a href="#项目中用的技术以及实现；" class="headerlink" title="项目中用的技术以及实现；"></a>项目中用的技术以及实现；</h2><p>1.复杂cell提前缓存行高和UI的frame<br>2.网络请求库的封装<br>3.组建化简单实现<br>4.tableView嵌套滑动<br>5.地图对象的单例封装<br>6.用View代替ViewController的实现<br>7.定时器使用</p>
<h2 id="缓存机制是怎么清除数据的？"><a href="#缓存机制是怎么清除数据的？" class="headerlink" title="缓存机制是怎么清除数据的？"></a>缓存机制是怎么清除数据的？</h2><p>沙盒：iOS系统为每一个应用程序创建一个文件目录,是一个的独立,封闭,安全的空间, 一个沙盒就是一个文件目录。沙盒规定了一个程序只能在自身的沙盒中进行操作,不能去访问其他应用程序的沙盒(iOS8已经部分开放访问)<br>沙盒的作用: 用来存放非代码文件(图片, 音频, 视频, 属性列表(plist), sqlite数据库, 文本文件, 其他等等)</p>
<h2 id="如何进行安全测试；"><a href="#如何进行安全测试；" class="headerlink" title="如何进行安全测试；"></a>如何进行安全测试；</h2><p>ipa包加壳（苹果）<br>敏感信息存储位置<br>通讯网络安全<br>代码混淆</p>
<h2 id="说下生产者-消费者模型，其中的同步机制是怎么样的"><a href="#说下生产者-消费者模型，其中的同步机制是怎么样的" class="headerlink" title="说下生产者-消费者模型，其中的同步机制是怎么样的"></a>说下生产者-消费者模型，其中的同步机制是怎么样的</h2><p>产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。<br>在生产者与消费者之间在加个缓冲区，我们形象的称之为仓库，生产<br>者负责往仓库了进商品，而消费者负责从仓库里拿商品，这就构成了生产者消费者模式。<br>dispatch_semaphore_wait<br>dispatch_semaphore_signal</p>
<h1 id="开发日常"><a href="#开发日常" class="headerlink" title="开发日常"></a>开发日常</h1><h2 id="APP启动时间应从哪些方面优化？"><a href="#APP启动时间应从哪些方面优化？" class="headerlink" title="APP启动时间应从哪些方面优化？"></a>APP启动时间应从哪些方面优化？</h2><p>App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit<br>   Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，<br>   优化需以下方面入手<br>   dylib loading time<br>       核心思想是减少dylibs的引用<br>       合并现有的dylibs（最好是6个以内）<br>       使用静态库<br>   rebase/binding time<br>       核心思想是减少DATA块内的指针<br>       减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）<br>       减少c++虚函数<br>       多使用Swift结构体（推荐使用swift）<br>   ObjC setup time<br>       核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时<br>   initializer time<br>       使用initialize替代load方法<br>       减少使用c/c++的attribute((constructor))；推荐使用<br>       dispatch_once() pthread_once() std:once()等方法<br>       推荐使用swift<br>       不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁<br>       ，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁<br>       不要在初始化中创建线程</p>
<h2 id="如何降低APP包的大小"><a href="#如何降低APP包的大小" class="headerlink" title="如何降低APP包的大小"></a>如何降低APP包的大小</h2><p>可执行文件<br>编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden<br>by Default 设置为 YES，去掉异常支持，Enable C++ Exceptions、Enable<br>Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions<br>利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code<br>编写LLVM插件检测出重复代码、未被调用的代码<br>资源（图片、音频、视频 等）<br>优化的方式可以对资源进行无损的压缩<br>去除没有用到的资源： </p>
<h2 id="UILabel图层混合"><a href="#UILabel图层混合" class="headerlink" title="UILabel图层混合"></a>UILabel图层混合</h2><p>UILabel图层混合解决方法： iOS8以后设置背景色为非透明色并且设置label.layer<br>.masksToBounds=YES让label只会渲染她的实际size区域，<br>就能解决UILabel的图层混合问题<br>iOS8 之前只要设置背景色为非透明的就行<br>为什么设置了背景色但是在iOS8上仍然出现了图层混合呢？<br>UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，<br>而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变。在<br>背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，设<br>置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪 图层混合问题解决了</p>
<h2 id="日常如何检查内存泄露？"><a href="#日常如何检查内存泄露？" class="headerlink" title="日常如何检查内存泄露？"></a>日常如何检查内存泄露？</h2><p>目前我知道的方式有以下几种<br>Memory Leaks<br>Alloctions<br>Analyse<br>Debug Memory Graph<br>MLeaksFinder<br>泄露的内存主要有以下两种：<br>Laek Memory 这种是忘记 Release 操作所泄露的内存。<br>Abandon Memory 这种是循环引用，无法释放掉的内存。</p>
<h2 id="LLDB常用的调试命令？"><a href="#LLDB常用的调试命令？" class="headerlink" title="LLDB常用的调试命令？"></a>LLDB常用的调试命令？</h2><p>po：print object的缩写，表示显示对象的文本描述，如果对象不存在则打印nil。<br>p：可以用来打印基本数据类型。<br>call：执行一段代码 如：call NSLog(@”%@”, @“yang”)<br>expr：动态执行指定表达式<br>bt：打印当前线程堆栈信息 （bt all 打印所有线程堆栈信息）<br>image：常用来寻找栈地址对应代码位置 如：image lookup –address 0xxxx</p>
<h2 id="iOS-常见的崩溃类型有哪些？"><a href="#iOS-常见的崩溃类型有哪些？" class="headerlink" title="iOS 常见的崩溃类型有哪些？"></a>iOS 常见的崩溃类型有哪些？</h2><p>unrecognized selector crash<br>KVO crash<br>NSNotification crash<br>NSTimer crash<br>Container crash<br>NSString crash<br>Bad Access crash （野指针）<br>UI not on Main Thread Crash</p>
<h2 id="iOS-App-稳定性指标及监测"><a href="#iOS-App-稳定性指标及监测" class="headerlink" title="iOS App 稳定性指标及监测"></a>iOS App 稳定性指标及监测</h2><p>开发过程中，主要是通过监控内存使用及泄露，CPU使用率，FPS，启动时间等指标，<br>以及常见的UI的主线程监测，NSAssert断言等，最好能在Debug模式下，实时显<br>示在界面上，针对出现的问题及早解决。</p>
<h2 id="iOS的签名机制是怎么样的"><a href="#iOS的签名机制是怎么样的" class="headerlink" title="iOS的签名机制是怎么样的"></a>iOS的签名机制是怎么样的</h2><p>签名机制：<br>先将应用内容通过摘要算法，得到摘要<br>再用私钥对摘要进行加密得到密文<br>将源文本、密文、和私钥对应的公钥一并发布<br>验证流程：<br>查看公钥是否是私钥方的<br>然后用公钥对密文进行解密得到摘要<br>将APP用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常</p>
<h2 id="instruments它为什么能检测内存泄漏"><a href="#instruments它为什么能检测内存泄漏" class="headerlink" title="instruments它为什么能检测内存泄漏"></a>instruments它为什么能检测内存泄漏</h2><h2 id="推送的原理"><a href="#推送的原理" class="headerlink" title="推送的原理"></a>推送的原理</h2><p>1.由App向iOS设备发送一个注册通知，用户需要同意系统发送推送。<br>2.iOS向APNs远程推送服务器发送App的Bundle Id和设备的UDID。<br>3.APNs根据设备的UDID和App的Bundle Id生成deviceToken再发回给App。<br>4.App再将deviceToken发送给远程推送服务器(自己的服务器), 由服务器保存在数据库中。<br>5.当自己的服务器想发送推送时, 在远程推送服务器中输入要发送的消息并选择发给哪些用户的deviceToken，由远程推送服务器发送给APNs。<br>6.APNs根据deviceToken发送给对应的用户。</p>
<h2 id="项目上线被拒原因"><a href="#项目上线被拒原因" class="headerlink" title="项目上线被拒原因"></a>项目上线被拒原因</h2><p>设计类型的问题，图标、UI等<br>app类型设置不准确<br>第三方资源用到广告等资源</p>
<h2 id="有了解过代码如何编译的嘛"><a href="#有了解过代码如何编译的嘛" class="headerlink" title="有了解过代码如何编译的嘛"></a>有了解过代码如何编译的嘛</h2><p>LLVM编译一个源文件的过程：预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt;<br>   AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件</p>
<h2 id="针对线上版本的崩溃处理；"><a href="#针对线上版本的崩溃处理；" class="headerlink" title="针对线上版本的崩溃处理；"></a>针对线上版本的崩溃处理；</h2><p>UIKit不是线程安全的，执行UIKit操作如果不在主线程很可能造成程序Crash<br>KVO<br>避免 Foundation 类Carsh<br>容器越界（NSArray， NSDictionary,…）<br>unrecognized selector crash (这个很多时候是由于class使用错误导致)<br>第三方工具：友盟<br>dSYMTools分析</p>
<h2 id="Xcode构建过程；"><a href="#Xcode构建过程；" class="headerlink" title="Xcode构建过程；"></a>Xcode构建过程；</h2><p>解析项目文件，获取你项目中的所有文件、target 及其依赖关系、build settings，最后把它变成一个树形结构(有向图)。<br>增量构建。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift139%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift139%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">UI相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:58" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:58+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="程序绘制流程"><a href="#程序绘制流程" class="headerlink" title="程序绘制流程"></a>程序绘制流程</h2><pre><code>Core Animation 在 RunLoop 中注册了一个 Observer 监听
BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件 。
当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer
的层次时，或者手动调用了 UIView/CALayer 的 
setNeedsLayout/setNeedsDisplay方法后，这个
UIView/CALayer 就被标记为待处理，当渲染系统准备就绪，
调用视图的-display方法，同时装配像素存储空间，
建立一个CoreGraphics上下文（CGContextRef），将上下文push进
上下文堆栈，绘图程序进入对应的内存存储空间。
当Oberver监听的事件到来时，回调执行函数中会遍历所有待处理的
UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。
需要CPU和GPU一起协作一部数据通过CoreGraphics、CoreImage
由CPU预处理。最终通过OpenGL ES将数据传送到 GPU，最终显示到屏幕。
</code></pre>
<h2 id="试图绘制为什么不立即执行"><a href="#试图绘制为什么不立即执行" class="headerlink" title="试图绘制为什么不立即执行"></a>试图绘制为什么不立即执行</h2><pre><code>继承于UIView的子类重写，进行布局更新，刷新视图。如果某个视图
自身的bounds或者子视图的bounds发生改变，那么这个方法会在当前
runloop结束的时候被调用。为什么不是立即调用呢？因为渲染毕
竟比较消耗性能，特别是视图层级复杂的时候。这种机制下任何UI
控件布局上的变动不会立即生效，而是每次间隔一个周期，所有
UI控件在布局上的变动统一生效并且在视图上更新，苹果通过这种高
性能的机制保障了视图渲染的流畅性。
</code></pre>
<h2 id="事件响应流程"><a href="#事件响应流程" class="headerlink" title="事件响应流程"></a>事件响应流程</h2><pre><code>点击屏幕-》UIApplication-〉UIWindow-》hitTest：withEvent：
-〉pointInside：withEvent：
-》subviews-〉UIView-》倒序遍历-〉hitTest：withEvent：
hitTest：withEvent内部实现
</code></pre>
<h2 id="UI卡顿原因"><a href="#UI卡顿原因" class="headerlink" title="UI卡顿原因"></a>UI卡顿原因</h2><pre><code>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 
等机制通知 App，App 主线程开始在 CPU 中计算显示内容，
比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 
会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。
随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 
信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 
时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，
等待下一次机会再显示，而这时显示屏会保留之前的内容不变。
这就是界面卡顿的原因。
</code></pre>
<h2 id="滑动优化方案"><a href="#滑动优化方案" class="headerlink" title="滑动优化方案"></a>滑动优化方案</h2><pre><code>从CPU和GPU两个方面
CPU
对象创建，调整，销毁
预排版（布局计算、文字计算）
预渲染（文字等异步绘制、图片解码等）
GPU
纹理渲染（减少离屏渲染）
试图混合（减少不必要的试图、半透明颜色）
</code></pre>
<h2 id="什么是离屏渲染，触发的条件是什么"><a href="#什么是离屏渲染，触发的条件是什么" class="headerlink" title="什么是离屏渲染，触发的条件是什么"></a>什么是离屏渲染，触发的条件是什么</h2><pre><code>GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作
何时会触发
圆角（当和maskToBounds一起使用时）
图层蒙版
阴影
光栅化
</code></pre>
<h2 id="UIView和CALayer关系"><a href="#UIView和CALayer关系" class="headerlink" title="UIView和CALayer关系"></a>UIView和CALayer关系</h2><pre><code>layer给view提供了基础设施，使得绘制内容和呈现更高效动画更容易、更低耗
layer不参与view的事件处理、不参与响应链
layer的内容生成一个位图(bitmap)
,触发动画的时候，是把这个动画和状态信息传递给图形硬件，
图形硬件使用这两个数据就可以构造动画了。处理位图对于图形硬件更快。
</code></pre>
<h2 id="CALayer的mask作用"><a href="#CALayer的mask作用" class="headerlink" title="CALayer的mask作用"></a>CALayer的mask作用</h2><pre><code>mask是一个layer层，并且作为背景层和组成层之间的一个遮罩层通道，
默认是nil。并且如果要创建新的layer赋给mask，
那么新的layer必须没有superlayer，也不支持含有子mask。
mask作用的也不只是当前layer的内容，而是layer和它所有子layer的合成内容。
这个也是可以测试的，设置viewA的layer的mask,
然后不管在viewA上加多少个视图都是会被mask作用到。
不要使用不必要的mask，可以预处理图片为圆形；或者添加中间为圆形透
明的白色背景视图。即使添加额外的视图，会导致额外的计算；
但仍然会快一点，因为相对于切换上下文，GPU更擅长渲染。
</code></pre>
<h2 id="如何高性能给UIImageView加圆角"><a href="#如何高性能给UIImageView加圆角" class="headerlink" title="如何高性能给UIImageView加圆角"></a>如何高性能给UIImageView加圆角</h2><pre><code>不要使用不必要的mask，可以预处理图片为圆形；或者添加中间为圆形
透明的白色背景视图。 离屏渲染会导致GPU利用率不到100%，
帧率却很低。（切换上下文会产生idle time）
1.图片本身做圆角处理
2.添加一个额外的试图进行压盖
3.用贝塞尔曲线.重新绘制一个圆形图片
</code></pre>
<h2 id="如何使用核心动画"><a href="#如何使用核心动画" class="headerlink" title="如何使用核心动画"></a>如何使用核心动画</h2><pre><code>创建
设置相关属性
添加到 CALayer 上，会自动执行动画
</code></pre>
<h2 id="如何增加view点击范围"><a href="#如何增加view点击范围" class="headerlink" title="如何增加view点击范围"></a>如何增加view点击范围</h2><pre><code>在pointInside方法中更大范围返回true
</code></pre>
<h2 id="hitTest：withEvent内部实现"><a href="#hitTest：withEvent内部实现" class="headerlink" title="hitTest：withEvent内部实现"></a>hitTest：withEvent内部实现</h2><pre><code>// 1.是否响应的必要条件
if (self.userInteractionEnabled == NO ||self.alpha &lt; 0.05 || self.hidden == YES) &#123;
    return nil;
&#125;
// 2.判断点是不是在视野范围内
if ([self pointInside:point withEvent:event]) &#123;
    // 遍历所有的子试图
    for (UIView *subView  in  self.subviews) &#123;
        // 坐标转换
        CGPoint converPoint = [subView convertPoint:point toView:self];
        // 依次调用子试图的hit test方法
        UIView *fitView = [subView hitTest:converPoint withEvent:event];
        if (fitView) &#123;
            return fitView;
        &#125;
    &#125;
    // 如果子试图都没有返回自己
    return self;
&#125;
return nil;
首先调用当前视图的pointInside:withEvent:方法判断触摸点
是否在当前视图内；若返回NO,则hitTest:withEvent:返回nil;
若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:
消息，所有子视图的遍历顺序是从top到bottom，即从subviews
数组的末尾向前遍历,直到有子视图返回非空对象或者全部子视图遍历完毕；
若第一次有子视图返回非空对象,则hitTest:withEvent:方法返回此对象，处理结束；
如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。
</code></pre>
<h2 id="程序的启动速度优化"><a href="#程序的启动速度优化" class="headerlink" title="程序的启动速度优化"></a>程序的启动速度优化</h2><pre><code>App开始启动后，系统内核(XNU)首先加载可执行文件（自身App的所
有.o文件的集合），然后加载动态链接器dyld，dyld是一个专门用来加载动态链接库的库。
执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。 
动态链接库包括：iOS 中用到的所有系统 framework，加载OC
runtime方法的libobjc，系统级别的libSystem，例如libdispatch(GCD)
和libsystem_blocks (Block)。
 1、内核加载可执行文件
 2、load dylibs image (加载程序所需的动态库镜像文件)
 3、Rebase image /  Bind image (由于ASLR(address space layout
    randomization)的存在，可执行文件和动态链接库在虚拟内
    存中的加载地址每次启动都不固定，所以需要修复镜像中的资源指针)
 4、Objc setup (注册Objc类、将Category中的方法插入方法列表)
 5、initializers (调用Objc类的+load()方法、调用C++类的构造函数)
针对上边各个启动过程，我们可以做的优化有：
   1、减少动态库的引用，将项目中不使用的Framework及时删除，将Xcode配置中General -&gt; Linked Frameworks and Libraries中使用不到的系统库不再引用。
   2、合并动态库。
   3、尽量不使用内嵌（embedded）的dylib，加载内嵌dylib性能开销较大。
   4、清理项目中冗余的类、category。对于同一个类有多个category的，建议进行合并。
   5、将不必须在+load方法中做的事情延迟到+initialize中。
   6、尽量不要用C++虚函数(创建虚函数表有开销)，不要在C++构造函数中做大量耗时操作。
</code></pre>
<h2 id="drawRect和layouSubviews-的区别"><a href="#drawRect和layouSubviews-的区别" class="headerlink" title="drawRect和layouSubviews 的区别"></a>drawRect和layouSubviews 的区别</h2><pre><code>相同：
1 都是异步执行
2 都是UIView 的方法
不同：
1   layoutSubviews方便数据计算，
2   drawRect方便视图重绘。
layoutSubviews在以下情况下会被调用：
    1、init初始化不会触发layoutSubviews
    2、addSubview会触发layoutSubviews (向对象添加子视图,或者对象添加到父视图,frame为0时不会)
    3、改变view的width和hight的时候会触发layoutSubviews
    4、滚动一个UIScrollView会触发layoutSubviews(受contentSize 的影响)
    5、旋转Screen会触发父UIView上的layoutSubviews事件
    6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件
    7、直接调用setLayoutSubviews。
    8、不要直接调用这个方法,因为不会有任何的作用
    .如果你需要强制layout刷新,调用setNeedsLayout来代替, 
drawRect在以下情况下会被调用： 
    &gt;1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。
    drawRect 调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad
    两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了
    .这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量 值).
    2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。
    然后系统自动调用drawRect:方法。
    3、通过设置contentMode属性值为UIViewContentModeRedraw。
    那么将在每次设置或更改frame的时候自动调用drawRect:。
    4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，
    但是有个前提条件是rect不能为0。以上1,2推荐；而3,4不提倡
</code></pre>
<h2 id="setNeedsLayout与layoutIfNeeded的区别"><a href="#setNeedsLayout与layoutIfNeeded的区别" class="headerlink" title="setNeedsLayout与layoutIfNeeded的区别"></a>setNeedsLayout与layoutIfNeeded的区别</h2><pre><code>UIView的setNeedsDisplay和setNeedsLayout两个方法都是异步执行的。
而setNeedsDisplay会自动调用drawRect方法，这样可以拿到
UIGraphicsGetCurrentContext进行绘制；而setNeedsLayout会默认调用
layoutSubViews，给当前的视图做了标记；layoutIfNeeded
查找是否有标记，如果有标记及立刻刷新。
只有setNeedsLayout和layoutIfNeeded这二者合起来使用，才会起到立刻刷新的效果。
</code></pre>
<h2 id="UIResponder的理解和事件响应分析"><a href="#UIResponder的理解和事件响应分析" class="headerlink" title="UIResponder的理解和事件响应分析"></a>UIResponder的理解和事件响应分析</h2><pre><code>UIResponder类是专门用来响应用户的操作处理各种事件的，包括触摸事件(Touch Events)、
运动事件(Motion Events)、远程控制事件(Remote Control Events)。
我们知道UIApplication、UIView、UIViewController这几个类是直接继承自
UIResponder，所以这些类都可以响应事件。当然我们自定义的继承自UIView的
View以及自定义的继承自UIViewController的控制器都可以响应事件。
</code></pre>
<h2 id="loadView的作用"><a href="#loadView的作用" class="headerlink" title="loadView的作用"></a>loadView的作用</h2><pre><code>loadView方法会在每次访问UIViewController的view
(比如controller.view、self.view)而且view为nil时会被调用，
此方法主要用来负责创建UIViewController的view(重写loadView方法，
并且不需要调用[super loadView])
</code></pre>
<h2 id="UITableView卡顿原因"><a href="#UITableView卡顿原因" class="headerlink" title="UITableView卡顿原因"></a>UITableView卡顿原因</h2><pre><code>1.最常用的就是cell的重用， 注册重用标识符
2.避免cell的重新布局
3.提前计算并缓存cell的属性及内容
4.减少cell中控件的数量
5.不要使用ClearColor，无背景色，透明度也不要设置为0
6.使用局部更新
7.加载网络数据，下载图片，使用异步加载，并缓存
8.少使用addView 给cell动态添加view
9.按需加载cell，cell滚动很快时，只加载范围内的cell
10.不要实现无用的代理方法，tableView只遵守两个协议
11.缓存行高
12.不要做多余的绘制工作。
13.预渲染图像。
14.使用正确的数据结构来存储数据。
</code></pre>
<h2 id="UITableView优化"><a href="#UITableView优化" class="headerlink" title="UITableView优化"></a>UITableView优化</h2><pre><code>本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。
卡顿优化在 CPU 层面
尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView
不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改
尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
Autolayout 会比直接设置 frame 消耗更多的 CPU 资源
图片的 size 最好刚好跟 UIImageView 的 size 保持一致
控制一下线程的最大并发数量
尽量把耗时的操作放到子线程
文本处理（尺寸计算、绘制）
图片处理（解码、绘制）
卡顿优化在 GPU层面
尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸
尽量减少视图数量和层次
减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES
尽量避免出现离屏渲染
</code></pre>
<h2 id="iOS-保持界面流畅的技巧"><a href="#iOS-保持界面流畅的技巧" class="headerlink" title="iOS 保持界面流畅的技巧"></a>iOS 保持界面流畅的技巧</h2><pre><code>1.预排版，提前计算
在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。
尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式
2.预渲染，提前绘制
例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了
避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。
3.异步绘制
4.全局并发线程
5.高效的图片异步加载
</code></pre>
<h2 id="使用-drawRect有什么影响"><a href="#使用-drawRect有什么影响" class="headerlink" title="使用 drawRect有什么影响"></a>使用 drawRect有什么影响</h2><pre><code>drawRect 方法依赖 Core Graphics 框架来进行自定义的绘制 缺点：
它处理 touch 事件时每次按钮被点击后，都会用 setNeddsDisplay 
进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性
能的角度来说，对 CPU 和内存来说都是欠佳的。特别是如果在我们的界
面上有多个这样的UIButton 实例，那就会很糟糕了。这个方法的调用机制
也是非常特别. 当你调用 setNeedsDisplay 方法时, UIKit 将会把当前
图层标记为 dirty,但还是会显示原来的内容,直到下一次的视图渲染周期,才会将
标记为 dirty 的图层重新建立 Core Graphics 上下文,然后将内存
中的数据恢复出来, 再使用 CGContextRef 进行绘制
</code></pre>
<h1 id="OC相关"><a href="#OC相关" class="headerlink" title="OC相关"></a>OC相关</h1><h2 id="分类可以添加哪些内容，为什么不能添加属性"><a href="#分类可以添加哪些内容，为什么不能添加属性" class="headerlink" title="分类可以添加哪些内容，为什么不能添加属性"></a>分类可以添加哪些内容，为什么不能添加属性</h2><pre><code>实力方法、类方法、协议、属性（关联对象：）
在分类的指针结构体中，没有属性列表
在runtime 中，objc_class 结构体大小是固定的，
不可能往这里添加数据，只能修改。所以，ivars
指向了一个固定区域，ivars的内存布局在编译时就已经
决定，只能修改成员变量的值，不能增加
成员变量的个数。方法列表是一个二维数组，可以修改
*methodLists的值来增加成员方法，虽然没办法扩展
methodLists指向的内存区域，却可以改变这个内
存区域的值（里面存的是指针），因此，可以动态添加方法，
不可以添加成员变量。
</code></pre>
<h2 id="类扩展和分类的区别"><a href="#类扩展和分类的区别" class="headerlink" title="类扩展和分类的区别"></a>类扩展和分类的区别</h2><pre><code>OC分类属于Runtime运行时特性，是OC语言独有的创新，
其他编程语言所不具备这样的特性！
类扩展属于编译器特性，在编译阶段就会被添加合并到原类中！
</code></pre>
<h2 id="分类是如何实现的"><a href="#分类是如何实现的" class="headerlink" title="分类是如何实现的"></a>分类是如何实现的</h2><pre><code>获取cls中未完成整合的所有分类 unattachendCategoriesForClass
将分类拼接到class上 attachCategories
倒序遍历所有分类
获取该分类的方法、协议添加到主类上
// 添加方法
rw-&gt;methods.attachLists(mlists,mcount);
// 添加类方法
rw-&gt;properties.attachLists(proplists,propcount);
// 添加协议
rw-&gt;properties.attachLists(protolists,protocount);
计算拼接后的元素总数，根据新的总数重新分配内存
重新设置元素总数
执行内存移位
</code></pre>
<h2 id="分类重写了原类中同名方法会怎么样，为什么"><a href="#分类重写了原类中同名方法会怎么样，为什么" class="headerlink" title="分类重写了原类中同名方法会怎么样，为什么"></a>分类重写了原类中同名方法会怎么样，为什么</h2><pre><code>分类添加的方法可以覆盖原类方法
原因：分类是在运行时添加到原类上的
同名分类方法是能生效决定于编译顺序（倒序遍历所有分类）
名字相同的分类会引起编译报错
</code></pre>
<h2 id="如何给分类添加属性（关联对象）"><a href="#如何给分类添加属性（关联对象）" class="headerlink" title="如何给分类添加属性（关联对象）"></a>如何给分类添加属性（关联对象）</h2><pre><code>关联对象的实现
获取其维护的一个HashMap，是一个全局容器
根据对象指针，查找对象对应的ObjectAssociationMap中的map
添加关联对象
</code></pre>
<h2 id="什么是代理，和通知-BLOCK区别"><a href="#什么是代理，和通知-BLOCK区别" class="headerlink" title="什么是代理，和通知/BLOCK区别"></a>什么是代理，和通知/BLOCK区别</h2><pre><code>代理：是一对一的，对于一个协议就只能用一个代理，所以单例不能用代理。
通知：是一对多
block:可以替代代理，优点是代码简洁。缺点：
block会开辟内存，消耗比较大，delegate则不会
block防止循环引用，要用弱引用
</code></pre>
<h2 id="什么是通知"><a href="#什么是通知" class="headerlink" title="什么是通知"></a>什么是通知</h2><pre><code>同步和异步都是相对于发送通知所在的线程的。
postNotification:总是会卡住当前线程，待observer执行（如不特殊处
理selector也会在postNotification:所在线程执行）结束之后才会继续
往下执行。所以是同步的。
我们在底层当中的消息的触发其实是依赖与端口的，我们想要在一个线程中发消
息，在另一个线程中进行处理的话，我们可以用端口来实现
子线程发通知，需要在子线程添加runloop
[self performSelector:@selector(postNotification) onThread:self.thread withObject:nil waitUntilDone:YES];
</code></pre>
<h2 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h2><pre><code>KVO是通过isa-swizzling技术实现的(这句话是整个KVO实现的重点)。
在运行时根据原类创建一个中间类，这个中间类是原类的子类，并动态修改当前对象的isa指向中间类。
并且将class方法重写，返回原类的Class。所以苹果建议在开发中不应该依赖isa指针，
而是通过class实例方法来获取对象类型。
1.注册A类的name属性变化监听
       [a addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];
2.创建A的子类NSKVONotifyingA
Class noA = objc_allocateClassPair([A class], &quot;NSKVONotifyingA&quot;, observer);
3.isa指针混合
将A类的指针指向NSKVONotifyingA，从而到达调用NSKVONotifyingA类的方法的目的
4.当调用a的setName方法时进入到NSKVONotifyingA类的setName方法
5.调用willChangeValueForKey回调属性将要变化
6.调用NSKVONotifyingA类的【self setName】赋值，实际上执行的是A类的setName，达到赋值目的
7.调用didChangeValueForKey回调属性变化了
</code></pre>
<h2 id="KVC的实现原理"><a href="#KVC的实现原理" class="headerlink" title="KVC的实现原理"></a>KVC的实现原理</h2><pre><code>是一种键值机制
1.首先搜索是否有setKey:的方法（key是成员变量名，首字母大写）
,没有则会搜索是否有setIsKey:的方法。
2.如果没有找到setKey:的方法,此时看+
(BOOL)accessInstanceVariablesDirectly; （是否直接访问成员变量）方法。
若返回NO，则直接调用- (nullable id)valueForUndefinedKey:;(默认是抛出异常)。
</code></pre>
<h2 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h2><pre><code>1、nonatomic、atomiac
2、readwrite、readonly
3、strong、retain、weak、assign、copy、unsafe_unretained
@property 有两个对应的词，一个是 @synthesize，一个是 @dynamic。
如果 @synthesize 和 @dynamic 都没写，那么默认的就是 @syntheszie var = _var;
</code></pre>
<h2 id="include与-import的区别、-import-与-class-的区别"><a href="#include与-import的区别、-import-与-class-的区别" class="headerlink" title="include与#import的区别、#import 与@class 的区别"></a>include与#import的区别、#import 与@class 的区别</h2><pre><code>#include 和#import其效果相同,都是查询类中定义的行为(方法);
#import不会引起交叉编译,确保头文件只会被导入一次；
@class 的表明,只定 义了类的名称,而具体类的行为是未知的,一般用于.h 文件；
@class 比#import 编译效率更高。
</code></pre>
<h2 id="解释-const-static-inline-关键字"><a href="#解释-const-static-inline-关键字" class="headerlink" title="解释 const, static, inline 关键字"></a>解释 const, static, inline 关键字</h2><pre><code>const 修饰指针,或者常量,比如不可变,
static 修饰变量表示作用域,比如全局的私有变量,函数内部的 static 是内部的私有变量。
Static 修饰函数表示函数是文件作用域
Inline 表示内联。一般来说 inline 需要和 static 联合用 一般用法是 
static inline int max(int a, int b) &#123; 
static inline作用是和宏类似,只不过是方便调试(宏不能断掉调 试,
static inline 可以)。运行时候是一样的。
一般 c/c++短小的函数都用 static inline 内联函数 
</code></pre>
<h2 id="OC-里怎么实现多继承"><a href="#OC-里怎么实现多继承" class="headerlink" title="OC 里怎么实现多继承"></a>OC 里怎么实现多继承</h2><pre><code>通过协议实现多继承
通过分类Category实现多继承
</code></pre>
<h2 id="load方法实现原理与initialize区别"><a href="#load方法实现原理与initialize区别" class="headerlink" title="load方法实现原理与initialize区别"></a>load方法实现原理与initialize区别</h2><pre><code>1.调用方式
(1).load是根据函数地址直接调用。
(2).initialize是通过objc_msgSend调用。
2.调用时刻(什么时候会调用)
(1).load是runtime加载类、分类的时候调用(只会调用一次)
（子类的load之前，会先调用父类的load。）父类-&gt;子类-&gt;分类
(2).initialize是类第一次接收到消息的时候调用，
每一个类只会initialize一次(父类的initialize方法可能会被调用多次)。
</code></pre>
<h2 id="懒加载的使用"><a href="#懒加载的使用" class="headerlink" title="懒加载的使用"></a>懒加载的使用</h2><pre><code>- (NSArray *)infoArr &#123;
    if (!_infoArr) &#123;
        _infoArr = @[];
    &#125;
    return _infoArr;
&#125;
</code></pre>
<h2 id="写一个单例"><a href="#写一个单例" class="headerlink" title="写一个单例"></a>写一个单例</h2><pre><code>+ (SingleClass *)sharedSingleton &#123;
    static SingleClass *_single = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^&#123;
        _single = [[super allocWithZone:NULL] init];
    &#125;);
    return _single;
    
&#125;
+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;
    return [SingleClass sharedSingleton];
&#125;
- (id)copyWithZone:(NSZone *)zone &#123;
    return [SingleClass sharedSingleton];
&#125;
</code></pre>
<h2 id="nil-NIL-NSNULL区别，id-和-instanceType-区别，self和super的区别，struct和class的区别"><a href="#nil-NIL-NSNULL区别，id-和-instanceType-区别，self和super的区别，struct和class的区别" class="headerlink" title="nil NIL NSNULL区别，id 和 instanceType 区别，self和super的区别，struct和class的区别"></a>nil NIL NSNULL区别，id 和 instanceType 区别，self和super的区别，struct和class的区别</h2><pre><code>id 在编译的时候不能判断对象的真实类型，instancetype 在编译的时候可以判断对象的真实类型。instancetype 只能作为返回值类型。
self调用自己方法，super调用父类方法，self是类，super是预编译指令
分别对应objc_msgSend、 objc_msgSendSuper
class： 引用类型（位于栈上面的指针（引用）和位于堆上的实体对象）
struct：值类型（实例直接位于栈中）
</code></pre>
<h2 id="如何实现一个线程安全的-NSMutableArray"><a href="#如何实现一个线程安全的-NSMutableArray" class="headerlink" title="如何实现一个线程安全的 NSMutableArray?"></a>如何实现一个线程安全的 NSMutableArray?</h2><pre><code>用dispatch_sync和dispatch_barrier_async结合保证NSMutableArray的线程安全，
dispatch_sync是在当前线程上执行不会另开辟新的线程，当线程返回的时候就可以
拿到读取的结果，我认为这个方案是最完美的选择，既保证的线程安全有发挥了多
线程的优势还不用另写方法返回结果
</code></pre>
<h2 id="JS-和-OC-互相调用的几种方式"><a href="#JS-和-OC-互相调用的几种方式" class="headerlink" title="JS 和 OC 互相调用的几种方式"></a>JS 和 OC 互相调用的几种方式</h2><pre><code>1.利用定义url调用
2.利用js直接调用
3.利用js里对象调用
</code></pre>
<h2 id="数据持久性有哪几种"><a href="#数据持久性有哪几种" class="headerlink" title="数据持久性有哪几种"></a>数据持久性有哪几种</h2><pre><code>iOS本地数据保存有多种方式,比如NSUserDefaults、归档、文件保存、数据库、
CoreData、KeyChain(钥匙串)等多种方式。其中KeyChain
(钥匙串)是保存到沙盒范围以外的地方，也就是与沙盒无关。
</code></pre>
<h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h2 id="NSObject的数据结构"><a href="#NSObject的数据结构" class="headerlink" title="NSObject的数据结构"></a>NSObject的数据结构</h2><pre><code>对象是objc_object结构体
内部有一个 objc_class 类型isa指针
objc_class 内部有isa指针指向根元类
根元类的isa指针指向自己
内部：
Class superClass; 父类
cache_t cache;  缓存
class_data_bits_t bits  数据
</code></pre>
<h2 id="类对象和实例对象的isa指针的指向"><a href="#类对象和实例对象的isa指针的指向" class="headerlink" title="类对象和实例对象的isa指针的指向"></a>类对象和实例对象的isa指针的指向</h2><pre><code>实例对象的isa指向类对象
类的isa指向元类对象
元类指向根元类；
根元类指向自己；
NSObject的父类是nil，根元类的父类是NSObject。
</code></pre>
<h2 id="为什么id类型可以指向OC中任意对象"><a href="#为什么id类型可以指向OC中任意对象" class="headerlink" title="为什么id类型可以指向OC中任意对象"></a>为什么id类型可以指向OC中任意对象</h2><pre><code>id类型被定义为指向对象的指针
NSObject只有一个Class对象isa，而objc_object也是只有一个Class对
象isa,也就是说id等价于NSObject*。所以id是一个一个比较灵活的对象指
针，并且是一个指向任何一个继承了Object（或者NSObject）类的对象
</code></pre>
<h2 id="为什么不能用isa判断一个类的继承关系"><a href="#为什么不能用isa判断一个类的继承关系" class="headerlink" title="为什么不能用isa判断一个类的继承关系"></a>为什么不能用isa判断一个类的继承关系</h2><pre><code>isa指针不总是指向实例对象所属的类，不能依靠它来确定
类型，而是应该用class方法来确定实例对象的类。
因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类
</code></pre>
<h2 id="cache-t的数据结构、实现原理及扩容"><a href="#cache-t的数据结构、实现原理及扩容" class="headerlink" title="cache_t的数据结构、实现原理及扩容"></a>cache_t的数据结构、实现原理及扩容</h2><pre><code>用散列表(哈希表)来缓存曾经调用过的方法，可以提高方法的查找速度，底层结构如下：
用于快速查找方法执行函数
是可增量扩展的哈希表结构
是局部性原理的最佳应用
哈希查找：发现当发生碰撞的时候，索引会+1，查找下一个。
槽位如果不够，_mask 会变换，变为原来的2倍，
并且扩展槽位的时候，会清空数组里原有的缓存内容
子类没有实现方法会调用父类的方法，
会将父类方法加入到子类自己的cache 里。
</code></pre>
<h2 id="cache-t-扩容"><a href="#cache-t-扩容" class="headerlink" title="cache_t 扩容"></a>cache_t 扩容</h2><pre><code>创建新的新的buckets来替换原有的buckets并抹掉原有的buckets
减少对方法快速查找流程的影响：调用objc_msgSend时会触发方法
快速查找，如果进行扩容需要做一些读写操作，对快速查找影响比较大。
对性能要求比较高：开辟新的buckets空间并抹掉原有buckets
的消耗比在原有buckets上进行扩展更加高效
当扩容后，会把新mask设置为newCapacity长度减一，然后清空缓存。
</code></pre>
<h2 id="class-rw-t的数据结构，实现原理"><a href="#class-rw-t的数据结构，实现原理" class="headerlink" title="class_rw_t的数据结构，实现原理"></a>class_rw_t的数据结构，实现原理</h2><pre><code>class_ro_t存放的是编译期间就确定的；
而class_rw_t是在runtime时才确定，它会先将class_ro_t的内容拷贝过去，
然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说class_rw_t
是class_ro_t的超集，当然实际访问类的方法、属性等也都是访问的class_rw_t中的内容
struct class_rw_t &#123;
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro; // 编译时生成的属性方法列表，不可改变

    method_array_t methods; // 方法列表
    property_array_t properties; //属性，和变量的区别，属性是名称，变量是值
    protocol_array_t protocols; // 协议

    Class firstSubclass;
    Class nextSiblingClass;
&#125;;
</code></pre>
<h2 id="哈希碰撞的解决方法"><a href="#哈希碰撞的解决方法" class="headerlink" title="哈希碰撞的解决方法"></a>哈希碰撞的解决方法</h2><pre><code>开放地址法
链地址法
(哈希表)的原理都是一样的，都是通过一个函数，这个函数传入一个key，
通过这个key算出一个索引，如果索引冲突了就加一或者减一
，直至不冲突为止，不同的就是算法不一样。
</code></pre>
<h2 id="方法查找的过程"><a href="#方法查找的过程" class="headerlink" title="方法查找的过程"></a>方法查找的过程</h2><pre><code>1.检查这个selector是不是要被忽略的，比如mac os开发，
   有垃圾回收，就不考虑 retain，release这些函数
2.检测这个target是不是nil对象，
   ObjC的特性允许对一个nil对象发消息而不会崩溃
3.如果以上都通过了，就通过isa指针开始查找这个类的方法列表，
   先从缓存中找（hashMap的结构，查找速度快），完了跳到对应函数执行
4.如果缓存列表找不到，class_rw_t就找一下方法分发表
5.如果方法列表找不到，就到超类的方法分发列表找，
   一直找到NSObject
</code></pre>
<h2 id="消息转发的流程"><a href="#消息转发的流程" class="headerlink" title="消息转发的流程"></a>消息转发的流程</h2><pre><code>（动态添加） 首先是征询接收者所属的类,看其是否能动态添加调用的方法,来处理当前这个未知的选择子;
-(BOOL)resolveInstanceMethod:(SEL)selector
（重定向-备援接收者）寻找是否在其他对象内有该方法实现,并将该消息转发给这个对象
- (id)forwardingTargetForSelector:(SEL)aSelector  
生成方法签名，然后系统用这个方法签名生成NSInvocation对象。
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 
改变选择子
- (void)forwardInvocation:(NSInvocation *)Invocation 
抛出异常
- (void)doesNotRecognizeSelector:(SEL)aSelector方法
</code></pre>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><pre><code>当前对象无论调用任何方法返回的都是当前对象
无论何时，要调用objc_msgSend函数，必须要将函数强制转
换成合适的函数指针类型才能调用。
其实编译器会根据情况在objc_msgSend,
objc_msgSend_stret, objc_msgSendSuper, 或
objc_msgSendSuper_stret四个方法中选择一个来调用。
</code></pre>
<h2 id="系统如何解决新增实例冲突"><a href="#系统如何解决新增实例冲突" class="headerlink" title="系统如何解决新增实例冲突"></a>系统如何解决新增实例冲突</h2><pre><code>类的结构体在编译时都是固定的，如果想修改类的结构需要重新编译
原来UIViewController的结构体中增加了
childViewControllers属性，这个时候和子类的内存偏移就
发生了冲突，只不过，runtime有检测内存地址冲突的机制，
在类生成实例变量时，会判断实例变量是否有地址冲突，
如果发生冲突则调整对象的地址偏移。
</code></pre>
<h2 id="常用的runtime方法有哪些"><a href="#常用的runtime方法有哪些" class="headerlink" title="常用的runtime方法有哪些"></a>常用的runtime方法有哪些</h2><pre><code>获取属性列表
获取方法列表
获取成员变量列表
获取协议列表
获得类方法
添加一个实例变量
添加方法
替换方法
交换方法
</code></pre>
<h2 id="runtime的具体应用有哪些，你在什么地方用到了"><a href="#runtime的具体应用有哪些，你在什么地方用到了" class="headerlink" title="runtime的具体应用有哪些，你在什么地方用到了"></a>runtime的具体应用有哪些，你在什么地方用到了</h2><pre><code>动态交换两个方法的实现
拦截并替换方法
在方法上增加额外功能
实现NSCoding的自动归档和解档
实现字典转模型的自动转换JSONModel、YYModel
给分类添加属性
消息转发机制
KVO实现
JSPatch替换已有的OC方法实行
</code></pre>
<h2 id="runtime-怎么添加属性，方法等"><a href="#runtime-怎么添加属性，方法等" class="headerlink" title="runtime 怎么添加属性，方法等"></a>runtime 怎么添加属性，方法等</h2><pre><code>添加属性：class_addIvar
但是得在调用objc_allocateClassPari之后，
objc_registerClassPair之前。
添加方法：class_addMethod
</code></pre>
<h2 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="runtime 如何实现 weak 属性"></a>runtime 如何实现 weak 属性</h2><pre><code>runtime 对注册的类，会进行内存布局，存储到 hash 表，这是一个全局表，
表中是用 weak 指向的对象内存地址作为 key，用所有指向该对象的 weak 指针表作为 value。
当此对象的引用计数为 0 的时候会 dealloc，假如该对象内存地址是 a，那么就会以 a 为
key，在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil。
</code></pre>
<h2 id="runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）"><a href="#runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）"></a>runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</h2><pre><code>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,
以及参数类型,其实selector本质就是方法名称,
通过这个方法名称就可以在方法列表中找到对应的方法实现.
</code></pre>
<h2 id="runtime如何实现weak变量的自动置nil"><a href="#runtime如何实现weak变量的自动置nil" class="headerlink" title="runtime如何实现weak变量的自动置nil"></a>runtime如何实现weak变量的自动置nil</h2><pre><code>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表
中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时
候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 
在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil
</code></pre>
<h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2><pre><code>在runtime中所有类都存在一个哈希表中，在table的buckets中存储
1. 加载所有类到类的gdb_objc_realized_classes表中
2. 对所有类做重映射
3. 将所有SEL都注册到namedSelectors表中
4. 修复函数指针遗留
5. 将所有Protocol添加到protocol_map表中
6. 将所有Protocol重映射
7. 初始化所有非懒加载的类，进行rw，ro操作 
8. 便利所有懒加载类，执行初始化
9. 处理所有Category包括Class和MetaClass
10. 初始化所有未初始化类
</code></pre>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存中的5大区都是什么？"><a href="#内存中的5大区都是什么？" class="headerlink" title="内存中的5大区都是什么？"></a>内存中的5大区都是什么？</h2><pre><code>堆区
栈区
常量区
全局区（静态区）
程序代码区
</code></pre>
<h2 id="C-内存如何分布、堆和栈的区别"><a href="#C-内存如何分布、堆和栈的区别" class="headerlink" title="C++内存如何分布、堆和栈的区别"></a>C++内存如何分布、堆和栈的区别</h2><pre><code>堆和栈的区别，工程项目中的哪些数据是储存在堆哪些在栈中
malloc咋实现
析构函数是不是必须是虚函数
</code></pre>
<h2 id="ARC实现机制，遵循哪些原则"><a href="#ARC实现机制，遵循哪些原则" class="headerlink" title="ARC实现机制，遵循哪些原则"></a>ARC实现机制，遵循哪些原则</h2><pre><code>ARC是RunTime和LLVM共同协作完成的
</code></pre>
<h2 id="NSObject内存分配、ISA指针的内存大小"><a href="#NSObject内存分配、ISA指针的内存大小" class="headerlink" title="NSObject内存分配、ISA指针的内存大小"></a>NSObject内存分配、ISA指针的内存大小</h2><pre><code>在64位架构下，如果他的第一位是0 。则代表他是一个 isa
指针,表示当前对象的类对象的地址，如果是1，则不仅代表一个 isa
指针,类对象的地址，里面还存储内存管理相关的内容，第二位代表是否有关联对象，
0代表没有，1代表有（has_assoc）,第三位,代表当前对象是否含有C++代码
（has_cxx_dtor）,3-15表示当前对象的类对象内存地址,16-31
,也是，32-35位也是，也就是说，13+16+4 = 33位
</code></pre>
<h2 id="Tagged-Pointer、NONPOINTER-ISA实现机制和作用"><a href="#Tagged-Pointer、NONPOINTER-ISA实现机制和作用" class="headerlink" title="Tagged Pointer、NONPOINTER_ISA实现机制和作用"></a>Tagged Pointer、NONPOINTER_ISA实现机制和作用</h2><pre><code>利用联合体可以用相同的存储空间存储不同型别的数据类型，从而节省内存空间
1.Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate
2.Tagged Pointer指针的值不再是地址了，而是真正的值。
    实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。
    它的内存并不存储在堆中，也不需要malloc和free。
3.在内存读取上有着3倍的效率，创建时比以前快106倍。
4.它不单单是一个指针，还包括了其值+类型
 NONPOINTER_ISA在64位机上，对象的isa区域不再只是一个指向另一块存储空间的指针。
 还包含了更多信息，比如引用计数，析构状态，被其他weak 变量引用情况等。
 如果引用计数超过了当前指针所能表示的范围，Runtime 会使用一张散列表来管理用计数。
</code></pre>
<h2 id="异步多线程访问导致的内存问题分析及解决办法。（代码题）"><a href="#异步多线程访问导致的内存问题分析及解决办法。（代码题）" class="headerlink" title="异步多线程访问导致的内存问题分析及解决办法。（代码题）"></a>异步多线程访问导致的内存问题分析及解决办法。（代码题）</h2><pre><code>ispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);
   for (int i = 0; i &lt; 1000; i ++) &#123;
       dispatch_async(queue, ^&#123;
           self.name = [NSString stringWithFormat:@&quot;abcdefghijklmn&quot;];
       &#125;);
   &#125;
运行结果：崩溃（坏内存访问）
因为setter方法中，对strong修饰的属性会有一个retain和release的操作。在并发多线程的赋值操作中，都是对_name指针进行的操作，可能在_name刚刚被release后进行赋值操作，这个时候_name指向的内存地址是已经被释放了，所以造成了坏内存访问崩溃
解决办法：
1.异步改同步
2.将属性改成原子性
3.加锁
dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);
for (int i = 0; i &lt; 1000; i ++) &#123;
    dispatch_async(queue, ^&#123;
        self.name = [NSString stringWithFormat:@&quot;a&quot;];
    &#125;);
&#125;
为什么不崩溃了？因为没有用到引用计数的内存管理方法，使用的是TaggedPointer
从64bit开始，iOS引入了Tagged
Pointer技术，用于优化NSNumber、NSDate、NSString等小对象存储
</code></pre>
<h2 id="SideTables数据结构及实现原理，为什么用多个SideTables"><a href="#SideTables数据结构及实现原理，为什么用多个SideTables" class="headerlink" title="SideTables数据结构及实现原理，为什么用多个SideTables"></a>SideTables数据结构及实现原理，为什么用多个SideTables</h2><pre><code> SideTables包括了多个SideTable，在不同系统架构中SideTable的个数是不同的；
 SideTables是哈希表，可以通过一个对象的指针来找到具体的引用计数表或弱引用
 表在哪一个具体的SideTable中。
 如果只有一个table，意味着内存中分配的所有对象都要在一个表中操作，
 因为多个线程可能同时操作这个表，所以就要对这个表加锁，如果并发操作这个表的线
 程有成千上万个，就会产生效率问题。所以系统引入了分离锁这样一个技术方案，
 把大表拆成多个小表来进行操作，分别对小表加锁，从而提升效率。
  自旋锁：
                       
</code></pre>
<h2 id="Autoreleasepool的数据结构及实现原理，什么时候释放"><a href="#Autoreleasepool的数据结构及实现原理，什么时候释放" class="headerlink" title="Autoreleasepool的数据结构及实现原理，什么时候释放"></a>Autoreleasepool的数据结构及实现原理，什么时候释放</h2><pre><code>以栈为结点，由双向链表的形式合成的数据结构。与线程一一对应。
AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），
除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址
一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，
连接链表，后来的autorelease对象在新的page加入
Main函数自动添加了@autoreleasepool&#123;&#125;;
在for循环中alloc图片数据等内存消耗较大的场景手动插入autoreleasePool。
在当次runloop将要结束的时候调用AutoreleasePoolPage::pop()。
在for循环大量使用imageNamed:之类的方法生成UIImage对象可能是个更要命的事情，内
存随时可能因为占用过多被系统杀掉。
这种情况下利用Autoreleasepool可以大幅度降低程序的内存占用。
</code></pre>
<h2 id="AutoreleasePool-为何可以嵌套使用"><a href="#AutoreleasePool-为何可以嵌套使用" class="headerlink" title="AutoreleasePool 为何可以嵌套使用"></a>AutoreleasePool 为何可以嵌套使用</h2><pre><code>,每次创建一个AutoreleasePool，@AutoreleasePool，其实系统就
是为我们创建了一个哨兵对象,其实就是创建page，若果当前page没有满，
其实就是创建一个哨兵，所以可以嵌套使用
中间用nil作为分割
从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page
</code></pre>
<h2 id="子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool"><a href="#子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool" class="headerlink" title="子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool"></a>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool</h2><pre><code>在子线程你创建了 Pool 的话，产生的 Autorelease 对象就会交给 pool 去管理。
如果你没有创建 Pool ，但是产生了 Autorelease 对象，就会调用 autoreleaseNoPage
方法。在这个方法中，会自动帮你创建一个 hotpage（hotPage 可以理解为当前正在使用的
AutoreleasePoolPage，如果你还是不理解，可以先看看 Autoreleasepool
的源代码，再来看这个问题 ），并调用 page-&gt;add(obj)将对象添加到
AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！
</code></pre>
<h2 id="dealloc调用流程"><a href="#dealloc调用流程" class="headerlink" title="dealloc调用流程"></a>dealloc调用流程</h2><pre><code>1.直接调用 objc_destructInstance()。
2.之后调用C的 free() 函数。
3.objc_destructInstance() 调用流程
1&gt;.先判断 hasCxxDtor，是否有析构函数（析构器），
要调用 object_cxxDestruct() ，释放（清除成员变量）。
2&gt;.再判断hasAssocitatedObjects，如果有的话，
要调用object_remove_associations()， 移除当前对象的关联对象。
3&gt;.然后调用 clearDeallocating()。 
4.clearDeallocating() 调用流程
0&gt;. 判断isa是否优化过，从arm64架构开始，对isa进行了优化，
变成了一个共用体（union）结构，所以结果一般是优化过了。
判断是否有弱引用或者引用计数
1&gt;.执行 clearDeallocating_slow()。
2&gt;.再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。
3&gt;.接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。
4&gt;.至此为止，Dealloc 的执行流程结束。
</code></pre>
<h2 id="常见的循环引用，如何破除循环引用"><a href="#常见的循环引用，如何破除循环引用" class="headerlink" title="常见的循环引用，如何破除循环引用"></a>常见的循环引用，如何破除循环引用</h2><pre><code>方式1:－－打断引用链条         方式2:－－使用__weak  
NSTimer破除循环引用
weak指针：
既然是强引用导致循环引用，那么用__weak修饰self就好了，想法是对的，但是做法是无效的。
中间类，block
及时销毁
创建一个继承NSProxy的子类WeakProxy，并实现消息转发的相关方法
</code></pre>
<h2 id="weak-修饰的变量在地址被释放后，为何被置为-nil？"><a href="#weak-修饰的变量在地址被释放后，为何被置为-nil？" class="headerlink" title="__weak 修饰的变量在地址被释放后，为何被置为 nil？"></a>__weak 修饰的变量在地址被释放后，为何被置为 nil？</h2><pre><code>1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针
指向对象的地址。
2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数，
objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。
3、释放时，调用clearDeallocating函数。clearDeallocating
函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中
的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。
</code></pre>
<h2 id="深拷贝和浅拷贝区别"><a href="#深拷贝和浅拷贝区别" class="headerlink" title="深拷贝和浅拷贝区别"></a>深拷贝和浅拷贝区别</h2><pre><code>对于对象来说浅拷贝只是增加引用，深拷贝时开辟新的内存地址存放复制对象
</code></pre>
<h2 id="atomic是安全的吗"><a href="#atomic是安全的吗" class="headerlink" title="atomic是安全的吗"></a>atomic是安全的吗</h2><pre><code>不是，只能保证在set和get方法内安全
</code></pre>
<h2 id="assign-vs-weak，-block-vs-weak-区别"><a href="#assign-vs-weak，-block-vs-weak-区别" class="headerlink" title="assign vs weak，_block vs _weak 区别"></a>assign vs weak，_block vs _weak 区别</h2><pre><code>weak和assign都是引用计算不变，两个的差别在于，weak用于object
type，就是指针类型，而assign用于简单的数据类型，如int BOOL 等。
assign看起来跟weak一样，其实不能混用的，assign的变量在释放后并不设置为nil
（和weak不同），当你再去引用时候就会发生错误
block 会对对象强引用，引起retain-cycle，需要使用__weak
（两个指针，指向同一块地址（self））；
__weak和__unsafe_unretained这两个关键字都能产生弱引用，但是它们又有以下不同：
__weak产生的弱引用，当弱指针指向的对象销毁时，也会将这个弱指针的值置为nil
__block修饰的变量，在运行时会生成一个__block对象，拥有__forwarding指针
当block拷贝到堆上时，__forwarding指向了堆上的__block 的__forwarding指针
</code></pre>
<h2 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h2><pre><code>启用Zombie Object进行悬挂指针的检测。
应用Product -&gt; Analysis进行内存泄露的初步检测。
可以在xcode的build setting中打开implicit retain of ‘self’ 
within blocks，xcode编译器会给出警告，逐个排查警告。
应用Leak Instrument进行内存泄露查找。
在以上方法不奏效的情况下，通过查看dealloc是否调用查看某个class是否泄露的问题
</code></pre>
<h2 id="图片加载占用内存对比"><a href="#图片加载占用内存对比" class="headerlink" title="图片加载占用内存对比"></a>图片加载占用内存对比</h2><pre><code>图片较小，并且使用频繁，使用 imageName: 来加载(按钮图标/主页里面图片)
图片较大，并且使用较少，使用 imageWithContentsOfFile: 来加载(版本新特性/相册)
</code></pre>
<h2 id="block一般用那个关键字修饰，为什么"><a href="#block一般用那个关键字修饰，为什么" class="headerlink" title="block一般用那个关键字修饰，为什么"></a>block一般用那个关键字修饰，为什么</h2><pre><code>此答案便是因为block在创建时是stack对象,（栈空间上）
如果我们需要在离开当前函数仍能够使用我们创建的block。
我们就需要把它拷贝到堆上以便进行以引用计数为基础的内存管理。
</code></pre>
<h2 id="写一个MRC的set方法"><a href="#写一个MRC的set方法" class="headerlink" title="写一个MRC的set方法"></a>写一个MRC的set方法</h2><pre><code>-(void)setDelegate:(id)delegate 
&#123; 
    if (_delegate != delegate) &#123; 
        [_delegate release]; 
        _delegate = [delegate retain/copy]; 
    &#125; 
&#125;
</code></pre>
<h2 id="如何解决定时器循环引用"><a href="#如何解决定时器循环引用" class="headerlink" title="如何解决定时器循环引用"></a>如何解决定时器循环引用</h2><pre><code>1.及时调用invalidate
在控制器中创建定时器将target给到self，在runloop中，对timer、self有了强引用
如果timer执行invalidate，则在runloop中，就会取消对timer及self的强引用了。
2.使用带block的定时器（支持iOS10以上），在block里面用walkSelf
3.加入了一个中间者NSProxy，使得timer不直接持有self，而是持有proxy，
让proxy对象弱引用self来解决循环引用（消息重定）
NSProxy是一个用来做消息转发的抽象类
,使用时需写一个子类继承自NSProxy并且子类需要实现两个方法，
- (void)forwardInvocation:(NSInvocation *)invocation;
和- (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel。
当NSProxy对象发送消息时，会跳过查找方法实现、动态方法解析、
被援接受者几个步骤直接进行消息的重定向，所以相比较NSObject的消息转发而言，
NSProxy减少了几个步骤，效率更高性能更优。
</code></pre>
<h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><h2 id="Block为什么用copy"><a href="#Block为什么用copy" class="headerlink" title="Block为什么用copy"></a>Block为什么用copy</h2><pre><code>Block在没有使用外部变量时，内存存在全局区，然而，当Block在使用外部变量的时候，
内存是存在于栈区，当Block copy之后，是存在堆区的。存在于栈区的特点是对象随时有
可能被销毁，一旦销毁在调用的时候，就会造成系统的崩溃。所以Block要用copy关键字。
</code></pre>
<h2 id="Block如何截获不同变量，代码分析"><a href="#Block如何截获不同变量，代码分析" class="headerlink" title="Block如何截获不同变量，代码分析"></a>Block如何截获不同变量，代码分析</h2><pre><code>Block是将函数及其执行上下文封装起来的对象。
对于基本数据类型的局部变量截获的是其值
对于对象类型的局部变量连同所有权修饰符一起截获（强引用）
以指针形式结果局部静态变量
不截获全局变量、全局静态变量
</code></pre>
<h2 id="Block本质数据结构"><a href="#Block本质数据结构" class="headerlink" title="Block本质数据结构"></a>Block本质数据结构</h2><pre><code>Block是将函数及其执行上下文封装起来的对象。
Block本质上是一个结构体，也有自己的isa
</code></pre>
<h2 id="栈上的Block经过copy操作后发生哪些变化"><a href="#栈上的Block经过copy操作后发生哪些变化" class="headerlink" title="栈上的Block经过copy操作后发生哪些变化"></a>栈上的Block经过copy操作后发生哪些变化</h2><pre><code>ARC环境下，一旦Block赋值就会触发copy，__block就会copy到堆上，
Block也是__NSMallocBlock。ARC环境下也是存在__NSStackBlock的时候，
这种情况下，__block就在栈上。
</code></pre>
<h2 id="block循环引用"><a href="#block循环引用" class="headerlink" title="block循环引用"></a>block循环引用</h2><pre><code>__weak所有权修饰变量，是联通属性关键字拷贝的
</code></pre>
<h2 id="block原理"><a href="#block原理" class="headerlink" title="__block原理"></a>__block原理</h2><pre><code>__block 修改变量
都有.__forwarding指针
栈上的__forwarding指向自己（变量）
经过copy后，栈上的.__forwarding指针指向了堆上的__block变量
.__forwarding存在的意义
不论任何内存位置都可以顺利访问统一个__block变量
</code></pre>
<h2 id="strong原理"><a href="#strong原理" class="headerlink" title="__strong原理"></a>__strong原理</h2><pre><code>strongSelf是block内部的一个局部变量，变量的作用域仅限于局部代码，
而程序一旦跳出作用域，strongSelf就会被释放，这个临时产生的“循环引用”
就会被自动打破，代码的执行事实上也是这样子的。
__strong修饰的变量在超出其作用域时retain是会自减
</code></pre>
<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop概念及数据结构、事件循环机制"><a href="#RunLoop概念及数据结构、事件循环机制" class="headerlink" title="RunLoop概念及数据结构、事件循环机制"></a>RunLoop概念及数据结构、事件循环机制</h2><pre><code>CFRunLoop
CFRunLoopMode
Source/Timer/Observer
source0
需要手动唤醒线程
source1
具备唤醒线程的能力
CFRunLoopObserver
观测时间点
kCFRunLoopEntry
kCFRunLoopBeforeTimers
CommonMode的特性
NSRunLoopCommonModes
commonMode不是实际存在的一种mode
是同步Source/Timer/Observer到多个Mode中的一种技术方案
一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个
Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个
Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出
Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的
Source/Timer/Observer，让其互不影响。
</code></pre>
<h2 id="CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用"><a href="#CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用" class="headerlink" title="CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用"></a>CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用</h2><h2 id="RunLoop和NStimer"><a href="#RunLoop和NStimer" class="headerlink" title="RunLoop和NStimer"></a>RunLoop和NStimer</h2><pre><code>NSTimer需要添加到Runloop中， 才能执行的情况
准确的Timer应该和当前线程的RunLoopMode保持一致
一个RunLoop不能同时共存两个mode
当滚动视图滚动时，当前RunLoop处于UITrackingRunLoopMode，
NSTimer的RunLoopMode和当前线程的RunLoopMode不一致，所以会停止
解决方式：将timer的runloopMode改为UITrackingRunLoopMode或
者NSRunLoopCommonModes
如果NSTimer在分线程中创建，会发生什么NSTimer没有启动
在主线程中，系统默认创建并启动主线程的runloop
在分线程中，系统不会自动启动runloop，需要手动启动？
</code></pre>
<h2 id="RunLoop和多线程"><a href="#RunLoop和多线程" class="headerlink" title="RunLoop和多线程"></a>RunLoop和多线程</h2><pre><code>在异步线程中下载很多图片,如果失败了,该如何处理?请结合RunLoop来谈谈解决方案
在异步线程中启动一个RunLoop重新发送网络请求,下载图片
如果程序启动就需要执行一个耗时操作，你会怎么做？
开启一个异步的子线程，并启动它的RunLoop来执行该耗时操作
</code></pre>
<h2 id="如何实现一个常驻线程"><a href="#如何实现一个常驻线程" class="headerlink" title="如何实现一个常驻线程"></a>如何实现一个常驻线程</h2><pre><code>给子线程添加RunLoop
 @autoreleasepool &#123;
    // 子线程对应的runloop需要自己创建并开启
    // 创建子线程对应的runloop,使子线程一直存在
    NSRunLoop *currentRunloop = [NSRunLoop currentRunLoop];
    // 给runloop添加一个基于port的事件(系统事件),让runloop的运行模式不为空,保证runloop不退出
    [currentRunloop addPort:[NSPort port] forMode:NSDefaultRunLoopMode];
    // 开启运行循环
    [currentRunloop run];
    &#125;
</code></pre>
<h2 id="利用-runloop-解释一下页面的渲染的过程"><a href="#利用-runloop-解释一下页面的渲染的过程" class="headerlink" title="利用 runloop 解释一下页面的渲染的过程"></a>利用 runloop 解释一下页面的渲染的过程</h2><pre><code>当我们调用 [UIView setNeedsDisplay] 时，这时会调用当前 View.layer 
的 [view.layer setNeedsDisplay]方法。
这等于给当前的 layer 打上了一个脏标记，而此时并没有直接进行绘制工作。
而是会到当前的 Runloop 即将休眠，也就是 beforeWaiting 时才会进行绘制工作。
紧接着会调用 [CALayer display]，进入到真正绘制的工作。CALayer 
层会判断自己的 delegate 有没有实现异步绘制的代理方法
displayer:，这个代理方法是异步绘制的入口，如果没有实现这个方法，
那么会继续进行系统绘制的流程，然后绘制结束。
CALayer 内部会创建一个 Backing Store，用来获取图形上下文。
接下来会判断这个 layer 是否有 delegate。
如果有的话，会调用 [layer.delegate drawLayer:inContext:]，
并且会返回给我们 [UIView DrawRect:] 的回调，让我们在系统绘制的基础之上再做一些事情。
如果没有 delegate，那么会调用 [CALayer drawInContext:]。
以上两个分支，最终 CALayer 都会将位图提交到 Backing Store，最后提交给 GPU。
</code></pre>
<h2 id="你在开发过程中怎么使用RunLoop？什么应用场景？"><a href="#你在开发过程中怎么使用RunLoop？什么应用场景？" class="headerlink" title="你在开发过程中怎么使用RunLoop？什么应用场景？"></a>你在开发过程中怎么使用RunLoop？什么应用场景？</h2><pre><code>开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来的消息，处理其他事件）
在子线程中开启一个定时器
在子线程中进行一些长期监控
可以控制定时器在特定模式下运行
可以让某些事件（行为，任务）在特定模式下执行
可以添加observer监听RunLoop的状态，比如监听点击事件的处理（比如在所有点击事件前做一些处理）
1）NSTimer
2）ImageView显示：控制方法在特定的模式下可用
3）PerformSelector
4）常驻线程：在子线程中开启一个runloop
5）自动释放池
</code></pre>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程与线程、并行-和-并发-区别"><a href="#进程与线程、并行-和-并发-区别" class="headerlink" title="进程与线程、并行 和 并发 区别"></a>进程与线程、并行 和 并发 区别</h2><pre><code>1.线程是进程的执行单元，进程的所有任务都在线程中执行
2.线程是 CPU 分配资源和调度的最小单位
多线程的实现原理：事实上，同一时间内单核的CPU只能执行一个线程，
多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。
并行：充分利用计算机的多核，在多个线程上同步进行
并发：在一条线程上通过快速切换，让人感觉在同步进行
</code></pre>
<h2 id="GCD、NSOperation、NSThread区别优缺点"><a href="#GCD、NSOperation、NSThread区别优缺点" class="headerlink" title="GCD、NSOperation、NSThread区别优缺点"></a>GCD、NSOperation、NSThread区别优缺点</h2><pre><code>第一种：pthread
    a.特点：
        1）一套通用的多线程API
        2）适用于Unix\Linux\Windows等系统
        3）跨平台\可移植
        4）使用难度大
    b.使用语言：c语言
    c.使用频率：几乎不用
    d.线程生命周期：由程序员进行管理
第二种：NSThread
    a.特点：
        1）使用更加面向对象
        2）简单易用，可直接操作线程对象
        b.使用语言：OC语言
        c.使用频率：偶尔使用
        d.线程生命周期：由程序员进行管理
第三种：GCD
    a.特点：
        1）旨在替代NSThread等线程技术
        2）充分利用设备的多核（自动）
    b.使用语言：C语言
    c.使用频率：经常使用
    d.线程生命周期：自动管理
第四种：NSOperation
    a.特点：
        1）基于GCD（底层是GCD）
        2）比GCD多了一些更简单实用的功能
        3）使用更加面向对象
    b.使用语言：OC语言
    c.使用频率：经常使用
    d.线程生命周期：自动管理
</code></pre>
<h2 id="performSelector-withObject-afterDelay-为什么在子线程无效"><a href="#performSelector-withObject-afterDelay-为什么在子线程无效" class="headerlink" title="performSelector:withObject:afterDelay:为什么在子线程无效"></a>performSelector:withObject:afterDelay:为什么在子线程无效</h2><pre><code>没有performSelector内部实现时NSTimer，nstime需要基于runloop才能实现
</code></pre>
<h2 id="如何让多个网络请求完成后执行下一步"><a href="#如何让多个网络请求完成后执行下一步" class="headerlink" title="如何让多个网络请求完成后执行下一步"></a>如何让多个网络请求完成后执行下一步</h2><pre><code>dispatch_group_t
</code></pre>
<h2 id="多个网络请求顺序执行后执行下一步"><a href="#多个网络请求顺序执行后执行下一步" class="headerlink" title="多个网络请求顺序执行后执行下一步"></a>多个网络请求顺序执行后执行下一步</h2><pre><code>dispatch_semaphore_wait
</code></pre>
<h2 id="异步操作两组数据时-执行完第一组之后-才能执行第二组"><a href="#异步操作两组数据时-执行完第一组之后-才能执行第二组" class="headerlink" title="异步操作两组数据时, 执行完第一组之后, 才能执行第二组"></a>异步操作两组数据时, 执行完第一组之后, 才能执行第二组</h2><pre><code>dispatch_barrier_async
</code></pre>
<h2 id="你知道哪些锁、使用场景"><a href="#你知道哪些锁、使用场景" class="headerlink" title="你知道哪些锁、使用场景"></a>你知道哪些锁、使用场景</h2><pre><code>@synchronized 一个对象层面的锁，锁住了整个对象，底层使用了互斥递归
锁来实现
pathread_mutex 互斥锁（c语言）和信号量的实现原理类似，也是阻塞线程并进入睡眠
，需要进行上下文切换。
NSLock 对象锁-简单的互斥锁（内部封装了一个 pthread_mutex）
NSCondition （封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件
NSCondition和NSLock、@synchronized等是不同的是，
NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。
这是非常强大。
NSConditionLock （借助 NSCondition 来实现，本质是生产者-消费者模型）
也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。
NSRecursiveLock 递归锁有时候“加锁代码”中存在递归调用，递归开始前加
dispatch_semaphore GCD中信号量，也可以解决资源抢占问题,
支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；
每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，
直到信号量大于0开始执行
OSSpinLock 自旋锁(不建议使用)
自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取
锁就需要等待a线程释放锁。在没有获得锁的期间，b线程会一直处于忙等的状
态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太
划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。
</code></pre>
<h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><pre><code>相同点：都能保证同一时间只有一个线程访问共享资源。
都能保证线程安全。
不同点：
互斥锁：如果共享数据已经有其他线程加锁了，线程会进入
休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的
线程会被唤醒。
自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环
的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会
立即执行。
自旋锁的效率高于互斥锁。
由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放
自旋锁，否则等待该自旋锁的线程会一直在哪里自旋，这就会浪
费CPU时间。
持有自旋锁的线程在sleep之前应该释放自旋锁以便其他可以获得
该自旋锁。内核编程中，如果持有自旋锁的代码sleep了就可能
导致整个系统挂起。
</code></pre>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP请求方式有哪些"><a href="#HTTP请求方式有哪些" class="headerlink" title="HTTP请求方式有哪些"></a>HTTP请求方式有哪些</h2><pre><code>GET、POST、HEAD、PUT、DELETE、OPTIONS
</code></pre>
<h2 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h2><pre><code>无连接：HTTP的持久性
是限制每次连接只处理一个请求。服务器处理完客户的请求，
并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接
无状态：Cookie/Session
无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。
即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，
发送完，不会记录任何信息。缺少状态意味着如果后续处理需要前面的信息，
则它必须重传，这样可能导致每次连接传送的数据量增大。
HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。
</code></pre>
<h2 id="HTTP三次握手，为什么需要三次"><a href="#HTTP三次握手，为什么需要三次" class="headerlink" title="HTTP三次握手，为什么需要三次"></a>HTTP三次握手，为什么需要三次</h2><pre><code>客户端发送SYN请求连接
服务端接受SYN，返回SYN和ACK
客户端接受SYN和ACK，返回服务端ACK
“第三次握手”是客户端向服务器端发送数据，这个数据就是要告诉服务器，
客户端有没有收到服务器“第二次握手”时传过去的数据。若发送的这个数据是“
收到了”的信息，接收后服务器就正常建立TCP连接，否则建立TCP连接失败，
服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。
</code></pre>
<h2 id="HTTP四次挥手，为什么需要四次"><a href="#HTTP四次挥手，为什么需要四次" class="headerlink" title="HTTP四次挥手，为什么需要四次"></a>HTTP四次挥手，为什么需要四次</h2><pre><code>客户端发送FIN请求释放连接  FIN-WAIT-1阶段
服务端返回ACK，服务端处于准备断开状态  CLOSE-WAIT阶段（半关闭状态），客户端收到，进入FIN-WAIT-2阶段
服务端做好释放准备，再次向客户端发送FIN和ACK，LAST-ACK阶段
客户端收到FIN和ACK，发送ACK断开连接，TIME-WAIT阶段
随后客户端开始在TIME-WAIT阶段等待2MSL
服务端收到客户端LAST-ACK，进入CLOSED阶段。
与“三次挥手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和
序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文
传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续&quot;挥手&quot;，
以此确保了&quot;四次挥手&quot;的顺利完成。
</code></pre>
<h2 id="为什么“握手”是三次，“挥手”却要四次？"><a href="#为什么“握手”是三次，“挥手”却要四次？" class="headerlink" title="为什么“握手”是三次，“挥手”却要四次？"></a>为什么“握手”是三次，“挥手”却要四次？</h2><pre><code>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，
可以直接返回SYN和ACK报文，开始建立连接。
释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能
立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文
，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。
</code></pre>
<h2 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL"></a>为什么客户端在TIME-WAIT阶段要等2MSL</h2><pre><code>为的是确认服务器端是否收到客户端发出的ACK确认报文
当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。
所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment
Lifetime：一段TCP报文在传输过程中的最大生命周期。
2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。
</code></pre>
<h2 id="HTTPS-TLS-SSL加密过程"><a href="#HTTPS-TLS-SSL加密过程" class="headerlink" title="HTTPS TLS/SSL加密过程"></a>HTTPS TLS/SSL加密过程</h2><pre><code>1、身份验证机制
2、数据传输的机密性
3、消息完整性验证
1、客户端向服务器端索要并验证公钥。
 2、双方协商生成&quot;对话密钥&quot;。
 3、双方采用&quot;对话密钥&quot;进行加密通信。
 其中，前两个阶段，被称为“握手阶段”。
 TLS握手过程有单向验证和双向验证之分，简单解释一下，单向验证就是
 server端将证书发送给客户端，客户端验证server端证书的合法性等，
 例如百度、新浪、google等普通的https网站，双向验证则是不仅客户端会验
 证server端的合法性，同时server端也会验证客户端的合法性，例如银行网银登陆
 ，支付宝登陆交易等。
 1、确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
 2、一个服务器生成的随机数（Sever Random），稍后用于生成&quot;对话密钥&quot;。
 3、确认使用的加密方法，比如RSA公钥加密。
 4、服务器证书（Certificate）。
 5、支持的一些SSL/TLS扩展。
</code></pre>
<h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><pre><code>①客户端发送报文进行SSL通信。报文中包含客户端支持的SSL的指定版本、
加密组件列表（加密算法及密钥长度等）。
②服务器应答，并在应答报文中包含SSL版本以及加密组件。
服务器的加密组件内容是从接受到的客户端加密组件内筛选出来的。
③服务器发送报文，报文中包含公开密钥证书。
④服务器发送报文通知客户端，最初阶段SSL握手协商部分结束。
⑤SSL第一次握手结束之后，客户端发送一个报文作为回应。
报文中包含通信加密中使用的一种被称Pre-master
secret的随机密码串。该密码串已经使用服务器的公钥加密。
⑥客户端发送报文，并提示服务器，此后的报文通信会采用
Pre-master secret密钥加密。
⑦客户端发送Finished报文。该报文包含连接至今全部报文的
整体校验值。这次握手协商是否能够完成成功，要以服务器是否能够正确解密该报文作为判定标准。
⑧服务器同样发送Change Cipher Spec报文。
⑨服务器同样发送Finished报文。
⑩服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。
⑪应用层协议通信，即发送HTTP响应。
⑫最后由客户端断开链接。断开链接时，发送close_nofify报文
</code></pre>
<h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><pre><code>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。
由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，
再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，
如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用
pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和
服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机
可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，
随机性增加的可不是一。
</code></pre>
<h2 id="中间人攻击（charles抓包原理）"><a href="#中间人攻击（charles抓包原理）" class="headerlink" title="中间人攻击（charles抓包原理）"></a>中间人攻击（charles抓包原理）</h2><pre><code>1、截获客户端与服务器通信的通道
2、然后在 SSL 建立连接的时候，进行中间人攻击
3、将自己伪装成客户端，获取到服务器真实有效的 CA 证书（非对称加密的公钥）
4、将自己伪装成服务器，获取到客服端的之后通信的密钥（对称加密的密钥）
5、有了证书和密钥就可以监听之后通信的内容了
</code></pre>
<h2 id="UDP协议及特点、"><a href="#UDP协议及特点、" class="headerlink" title="UDP协议及特点、"></a>UDP协议及特点、</h2><pre><code>无连接协议，也称透明协议，也位于传输层。
UDP通讯协议的特点：
将数据封装为数据包。面向无连接。
每个数据包大小限制在64K。
因为无连接，所以不可靠。
因为不需要建立连接，所以速度快。
UDP通讯是不分服务端和客服端的，只分发送端和接收端。
</code></pre>
<h2 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h2><pre><code>基于连接（点对点）
传输数据前需要建立好连接，然后在传输
双工通信
TCP连接一旦建立，就可以在连接上进行双向的通信
基于字节流而非报文
将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制能够保证TCP协议的有序性和完整性，因此TCP能够提供可靠性传输

可靠传输
拥塞控制
慢启动，拥塞避免，拥塞发生，快速恢复四个算法
流量控制能力
</code></pre>
<h2 id="TCP特点及与UDP区别"><a href="#TCP特点及与UDP区别" class="headerlink" title="TCP特点及与UDP区别"></a>TCP特点及与UDP区别</h2><pre><code>1） TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）；
UDP提供无连接的传输，通信前不需要建立连接。
2） TCP提供可靠的传输（有序，无差错，不丢失，不重复）；
UDP提供不可靠的传输。
3） TCP面向字节流的传输，因此它能将信息分割成组，
并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。
4） TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。
</code></pre>
<h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><pre><code>DNS服务器一般分三种，根DNS服务器，顶级DNS服务器，权威DNS服务器。
1）浏览器缓存　　
2）系统缓存　　
3）路由器缓存　　　　
4） ISP（互联网服务提供商）DNS缓存
5）根域名服务器　　　
6）顶级域名服务器　　
8）保存结果至缓存
</code></pre>
<h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><pre><code>一般而言，用户上网的DNS服务器都是运营商分配的，所以，在这个节点上，运营商可以为所欲为。
例如，访问http://jiankang.qq.com/index.html，
正常DNS应该返回腾讯的ip，而DNS劫持后，会返回一个运营商的中间服务器ip。
访问该服务器会一致性的返回302，让用户浏览器跳转到预处理好的带广告的网页，
在该网页中再通过iframe打开用户原来访问的地址。
</code></pre>
<h2 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h2><pre><code>在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而
且是html类型请求，则拦截处理。后续做法往往分为2种，1种是类
似DNS劫持返回302让用户浏览器跳转到另外的地址，还有1种是在服务器返
回的HTML数据中插入js或dom节点（广告）。
</code></pre>
<h2 id="Cookie机制及作用"><a href="#Cookie机制及作用" class="headerlink" title="Cookie机制及作用"></a>Cookie机制及作用</h2><pre><code>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。
在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。
服务器在向客户端回传相应的超文本的同时也会发回这些个人
信息存放于HTTP响应头（Response Header）；当客户端浏览器接收到来
自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置
自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。
Cookie的maxAge决定着Cookie的有效期，单位为秒（Second）。
</code></pre>
<h2 id="Session机制及作用"><a href="#Session机制及作用" class="headerlink" title="Session机制及作用"></a>Session机制及作用</h2><pre><code>Web应用程序中还经常使用Session来记录客户端状态。
Session是服务器端使用的一种记录客户端状态的机制，
使用上比Cookie简单一些，相应的也增加了服务器的存储压力。
Session技术则是服务端的解决方案，它是通过服务器来保持状态的。
URL地址重写是对客户端不支持Cookie的解决方案。
URL地址重写的原理是将该用户Session的id信息重写到URL地址中。
服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，
也可以使用Session来记录用户状态。
</code></pre>
<h2 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h2><pre><code>cookie数据存放在客户的浏览器上，session数据放在服务器上；
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
，考虑到安全应当使用session；
session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的
性能。考虑到减轻服务器性能方面，应当使用COOKIE；
</code></pre>
<h2 id="如何保证cookie的安全"><a href="#如何保证cookie的安全" class="headerlink" title="如何保证cookie的安全"></a>如何保证cookie的安全</h2><pre><code>对cookie进行加密处理
只在https上携带cookie
设置cookie为httpOnly，防止跨站脚本攻击
</code></pre>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><pre><code>单一职责原则
    CALayer：动画和视图的显示。
    UIView：只负责事件传递、事件响应。
    生成的数据模型
开闭原则
    对修改关闭，对扩展开放。 要考虑到后续的扩展性，而不是在原有的基础上来回修改
接口隔离原则
    使用多个专门的协议、而不是一个庞大臃肿的协议，如 
    UITableviewDelegate + UITableViewDataSource
依赖倒置原则
    抽象不应该依赖于具体实现、具体实现可以依赖于抽象。 
    调用接口感觉不到内部是如何操作的
里氏替换原则
    父类可以被子类无缝替换，且原有的功能不受任何影响 如：KVO
迪米特法则
    一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合
</code></pre>
<h2 id="iOS有哪些常见的设计模式"><a href="#iOS有哪些常见的设计模式" class="headerlink" title="iOS有哪些常见的设计模式?"></a>iOS有哪些常见的设计模式?</h2><pre><code>01代理委托Delegate是协议的一种
,通过@protocol方式实现，常见的有tableView，textField等。
02观察者 通知机制(notification)和KVO机制(Key-value Observing)
03MVC
04单例（Singleton）,UIApplication, NSBundle, NSNotificationCenter,
NSFileManager, NSUserDefault, NSURLCache等都是单例.
05策略
06工厂
</code></pre>
<h2 id="单例优缺点"><a href="#单例优缺点" class="headerlink" title="单例优缺点"></a>单例优缺点</h2><pre><code>主要优点：
1、提供了对唯一实例的受控访问。
2、由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需
要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
3、允许可变数目的实例。
主要缺点：
1、由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。
2、单例类的职责过重，在一定程度上违背了“单一职责原则”。
3、滥用单例将带来一些负面问题，会导致共享连接池对象的程序过多而出现连接池溢出
</code></pre>
<h2 id="内存设计、磁盘设计、网络设计原则"><a href="#内存设计、磁盘设计、网络设计原则" class="headerlink" title="内存设计、磁盘设计、网络设计原则"></a>内存设计、磁盘设计、网络设计原则</h2><pre><code>内存设计:存储的Size,淘汰策略 LRU算法
磁盘设计:存储方式\大小限制\淘汰策略
网络设计:图片请求最大并发\请求超时策略\请求优先级
</code></pre>
<h2 id="MVP、MVVM模式思想"><a href="#MVP、MVVM模式思想" class="headerlink" title="MVP、MVVM模式思想"></a>MVP、MVVM模式思想</h2><pre><code>MVVM 即模型-视图-视图模型
在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，
ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel
能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，
ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的
双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。
优点 VIew可以独立于Model的变化和修改，一个ViewModel可以绑定到不同的View上，
降低耦合，增加重用
缺点 过于简单的项目不适用、大型的项目视图状态较多时构建和维护成本太大
合理的运用架构模式有利于项目、团队开发工作，但是到底选择哪个设计模式，
哪种设计模式更好，就像本文开头所说，不同的设计模式，只是让不同的场
景有了更多的选择方案。根据项目场景和开发需求，选择最合适的解决方案。
MVP（Model、View、Presenter）：MVP模式是MVC模式的一个演化版本，其中Model
与MVC模式中Model层没有太大区别，主要提供数据存储功能，一般都是用来封
装网络获取的json数据；
优点 模型和视图完全分离，可以做到修改视图而不影响模型；更高效的使用模型，View不依赖Model，可以说VIew能做到对业务逻辑完全分离
缺点 Presenter中除了处理业务逻辑以外，还要处理View-Model两层的协调，也会导致Presenter层的臃肿
</code></pre>
<h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><pre><code>Flux是Facebook用来构建用户端的web应用的应用程序体系架构。
它通过利用数据的单向流动为React的可复用的视图组件提供了补充。
相比于形式化的框架它更像是一个架构思想，不需要太多新的代码你就可以马上
使用Flux构建你的应用。
一个 Flux 应用主要包含四个部分：
dispatcher
处理动作分发，维护 Store 之间的依赖关系
stores
数据和逻辑部分
views
React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互
actions
提供给 dispatcher 传递数据给 store
视图上添加的所有的视图组成一个视图多叉树；
比如某个UI发生变化后，需要反向到根节点，然后由根节点想下遍历查找需
要更新的结点；
任何一个子节点是没有权利自我更新的，需要把自我变化更
新的消息传递给根节点，由根节点进行更新，相当于由主动行为变成被动行为
</code></pre>
<h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><pre><code>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：
排版，绘制，UI对象操作。
排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。
绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。
UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。
其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主
线程完成，并且有时后面的操作需要依赖前面操作的结果
（例如TextView创建时可能需要提前计算出文本的大小）。ASDK
所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟
(例如视图的创建、属性的调整)。
为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了
UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如
frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只
通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制
放入了后台线程。但是无论怎么操作，
这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。

ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面
更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了
kCFRunLoopBeforeWaiting 和 kCFRunLoopExit
事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。
</code></pre>
<h2 id="AFNetworking-底层原理分析"><a href="#AFNetworking-底层原理分析" class="headerlink" title="AFNetworking 底层原理分析"></a>AFNetworking 底层原理分析</h2><pre><code>AFNetworking是封装的NSURLSession的网络请求，由五个模块组成：
分别由NSURLSession,Security,Reachability,Serialization,UIKit五部分组成
NSURLSession：网络通信模块（核心模块） 对应 AFNetworking中的
AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager
,AFHTTPSessionManager是继承于AFURLSessionmanager的
Security：网络通讯安全策略模块 对应 AFSecurityPolicy
Reachability：网络状态监听模块 对应AFNetworkReachabilityManager
Seriaalization：网络通信信息序列化、反序列化模块 对应AFURLResponseSerialization
UIKit：对于iOS UIKit的扩展库
</code></pre>
<h2 id="SDWebImage加载图片过程，图片缓存设计"><a href="#SDWebImage加载图片过程，图片缓存设计" class="headerlink" title="SDWebImage加载图片过程，图片缓存设计"></a>SDWebImage加载图片过程，图片缓存设计</h2><pre><code>0、首先显示占位图
1、在webimagecache中寻找图片对应的缓存，它是以url为数据索引先在内存中
查找是否有缓存；
2、如果没有缓存，就通过md5处理过的key来在磁盘中查找
对应的数据，如果找到就会把磁盘中的数据加到内存中，并显示出来；
3、如果内存和磁盘中都没有找到，就会向远程服务器发送请求，开始下载图片；
4、下载完的图片加入缓存中，并写入到磁盘中；
5、整个获取图片的过程是在子线程中进行，在主线程中显示。
</code></pre>
<h2 id="SDWebImage框架设计中"><a href="#SDWebImage框架设计中" class="headerlink" title="SDWebImage框架设计中"></a>SDWebImage框架设计中</h2><pre><code>1.设计UIImageView的分类，添加方法
2.在SDWebImageManager里面判断图片加载逻辑
3.在SDWebImageDecoder处理图片解码
4.在SDWebImageDownloader处理图片下载
5.在SDImageCache里缓存图片
</code></pre>
<h2 id="YYKit"><a href="#YYKit" class="headerlink" title="YYKit"></a>YYKit</h2><pre><code>YYModel — 高性能的 iOS JSON 模型框架。
YYCache — 高性能的 iOS 缓存框架。
YYImage — 功能强大的 iOS 图像框架。
YYWebImage — 高性能的 iOS 异步图像加载框架。
YYText — 功能强大的 iOS 富文本框架。
</code></pre>
<h2 id="组建化优缺点"><a href="#组建化优缺点" class="headerlink" title="组建化优缺点"></a>组建化优缺点</h2><pre><code>业务分层、解耦，使代码变得可维护；
有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；
便于各业务功能拆分、抽离，实现真正的功能复用；
</code></pre>
<h2 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h2><pre><code>视图层(View&amp;ViewController)
业务逻辑处理(ViewModel)
数据层(Model&amp;Engine)
数据流
数据与数据关系
MVVM框架思想
ReactiveNative的数据流思想
系统UIView更新机制的思想
FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想
</code></pre>
<h1 id="开发日常"><a href="#开发日常" class="headerlink" title="开发日常"></a>开发日常</h1><h2 id="APP启动时间应从哪些方面优化？"><a href="#APP启动时间应从哪些方面优化？" class="headerlink" title="APP启动时间应从哪些方面优化？"></a>APP启动时间应从哪些方面优化？</h2><pre><code>App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit 
Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，
优化需以下方面入手
dylib loading time
    核心思想是减少dylibs的引用
    合并现有的dylibs（最好是6个以内）
    使用静态库
rebase/binding time
    核心思想是减少DATA块内的指针
    减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）
    减少c++虚函数
    多使用Swift结构体（推荐使用swift）
ObjC setup time
    核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时
initializer time
    使用initialize替代load方法
    减少使用c/c++的attribute((constructor))；推荐使用
    dispatch_once() pthread_once() std:once()等方法
    推荐使用swift
    不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁
    ，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁
    不要在初始化中创建线程
</code></pre>
<h2 id="如何降低APP包的大小"><a href="#如何降低APP包的大小" class="headerlink" title="如何降低APP包的大小"></a>如何降低APP包的大小</h2><pre><code>可执行文件
编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden
by Default 设置为 YES，去掉异常支持，Enable C++ Exceptions、Enable
Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions
利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code
编写LLVM插件检测出重复代码、未被调用的代码
资源（图片、音频、视频 等）
优化的方式可以对资源进行无损的压缩
去除没有用到的资源： 
</code></pre>
<h2 id="如何检测离屏渲染与优化"><a href="#如何检测离屏渲染与优化" class="headerlink" title="如何检测离屏渲染与优化"></a>如何检测离屏渲染与优化</h2><pre><code>检测，通过勾选Xcode的Debug-&gt;View Debugging–&gt;Rendering-&gt;Run-&gt;Color 
Offscreen-Rendered Yellow项。
优化，如阴影，在绘制时添加阴影的路径
</code></pre>
<h2 id="怎么检测图层混合"><a href="#怎么检测图层混合" class="headerlink" title="怎么检测图层混合"></a>怎么检测图层混合</h2><pre><code>1、模拟器debug中color blended layers红色区域表示图层发生了混合
2、Instrument-选中Core Animation-勾选Color Blended Layers
避免图层混合：
确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明
如无特殊需要，不要设置低于1的alpha值
确保UIImage没有alpha通道
</code></pre>
<h2 id="UILabel图层混合"><a href="#UILabel图层混合" class="headerlink" title="UILabel图层混合"></a>UILabel图层混合</h2><pre><code>UILabel图层混合解决方法： iOS8以后设置背景色为非透明色并且设置label.layer
.masksToBounds=YES让label只会渲染她的实际size区域，
就能解决UILabel的图层混合问题
iOS8 之前只要设置背景色为非透明的就行
为什么设置了背景色但是在iOS8上仍然出现了图层混合呢？
UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，
而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变。在
背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，设
置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪 图层混合问题解决了
</code></pre>
<h2 id="日常如何检查内存泄露？"><a href="#日常如何检查内存泄露？" class="headerlink" title="日常如何检查内存泄露？"></a>日常如何检查内存泄露？</h2><pre><code>目前我知道的方式有以下几种
Memory Leaks
Alloctions
Analyse
Debug Memory Graph
MLeaksFinder
泄露的内存主要有以下两种：
Laek Memory 这种是忘记 Release 操作所泄露的内存。
Abandon Memory 这种是循环引用，无法释放掉的内存。
</code></pre>
<h2 id="LLDB常用的调试命令？"><a href="#LLDB常用的调试命令？" class="headerlink" title="LLDB常用的调试命令？"></a>LLDB常用的调试命令？</h2><pre><code>po：print object的缩写，表示显示对象的文本描述，如果对象不存在则打印nil。
p：可以用来打印基本数据类型。
call：执行一段代码 如：call NSLog(@&quot;%@&quot;, @“yang”)
expr：动态执行指定表达式
bt：打印当前线程堆栈信息 （bt all 打印所有线程堆栈信息）
image：常用来寻找栈地址对应代码位置 如：image lookup --address 0xxxx
</code></pre>
<h2 id="iOS-常见的崩溃类型有哪些？"><a href="#iOS-常见的崩溃类型有哪些？" class="headerlink" title="iOS 常见的崩溃类型有哪些？"></a>iOS 常见的崩溃类型有哪些？</h2><pre><code>unrecognized selector crash
KVO crash
NSNotification crash
NSTimer crash
Container crash
NSString crash
Bad Access crash （野指针）
UI not on Main Thread Crash
</code></pre>
<h2 id="iOS-App-稳定性指标及监测"><a href="#iOS-App-稳定性指标及监测" class="headerlink" title="iOS App 稳定性指标及监测"></a>iOS App 稳定性指标及监测</h2><pre><code>开发过程中，主要是通过监控内存使用及泄露，CPU使用率，FPS，启动时间等指标，
以及常见的UI的主线程监测，NSAssert断言等，最好能在Debug模式下，实时显
示在界面上，针对出现的问题及早解决。
</code></pre>
<h2 id="cocoapods-常见问题"><a href="#cocoapods-常见问题" class="headerlink" title="cocoapods 常见问题"></a>cocoapods 常见问题</h2><pre><code>cocoaPods 是为IOS 提供依赖管理的工具,他是管理第三方类库的工具.
pod update
cocoaPods的实现思路，为什么没有使用cocoaPods管理自己的SDK
</code></pre>
<h2 id="iOS的签名机制是怎么样的"><a href="#iOS的签名机制是怎么样的" class="headerlink" title="iOS的签名机制是怎么样的"></a>iOS的签名机制是怎么样的</h2><pre><code>签名机制：
先将应用内容通过摘要算法，得到摘要
再用私钥对摘要进行加密得到密文
将源文本、密文、和私钥对应的公钥一并发布
验证流程：
查看公钥是否是私钥方的
然后用公钥对密文进行解密得到摘要
将APP用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift138%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift138%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">面试总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:52" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:52+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="58同城"><a href="#58同城" class="headerlink" title="58同城"></a>58同城</h2><h2 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h2><p>我们创建的一般都是静态库，可以制作动态库，不允许上架app store的<br>iOS8，swift以后，出现了阉割版的Extension动态库。这种动态库允许APP和APP Extension共享代码<br>静态库：链接时，静态库会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝<br>系统动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存<br>iOS有没有动态库<br>iOS的动态库（被阉割的动态库）<br>iOS8之前因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，并且iOS是单进程的，也就是某一时刻只有一个进程在运行，那么你写个共享库，给谁共享呢。同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，综上所以上动态库也就没有存在的必要了。<br>但是后来iOS8之后，iOS有了App Extesion特性，而且Swift也诞生了。由于iOS主App需要和Extension共享代码，Swift语言机制也需要动态库，于是苹果后来提出了Embedded Framework，这种动态库允许APP和APP Extension共享代码，但是这份动态库的生命被限定在一个APP进程内。简单点可以理解为被阉割的动态库。<br> App 中（App 和 Extension 的 Bundle 是共享的）所以苹果没有直接把这种Embedded Framework称作动态库而是叫Embedded Framework。<br>前面提到的静态库可以简单理解为一堆目标文件(.o/.obj)的打包体(并非二进制文件)，而动态库可以简单理解为 一个没有main函数的可执行文件。<br>大学再讲编译原理的时候有两个非常重要的过程，编译和链接。编译可以理解为将源代码编译为目标文件，链接可以理解为将各种目标文件上加一些第三方库、并且和系统库链接起来为可执行文件。因为某个目标文件的符号（可以理解为变化、函数）可能来至其他目标文件，链接最为主要的就是决议符号的地址。<br>编译会生成目标文件，目标文件没有经过链接的过程，某些符号还没有调整过，Windows下的.obj文件，Linux下的.o文件，Unix的.out文件。</p>
<p>链接的过程可以简单描述如下：<br>假如主程序main.c 使用了 fun.c 模块的 foo函数，那么main.c在编译的过程，对于调用foo函数的指令，对于指令的目标地址暂时搁置；待到链接的时候，由链接器来填写foo函数的地址。</p>
<h2 id="OC反射"><a href="#OC反射" class="headerlink" title="OC反射"></a>OC反射</h2><p>通过类明获取类，通过方法名获取方法<br>所以说通过上面runtime的方式可以通过指针输出你想要的类当中的的全部属性，当然反过来也是可以实现的（这里对runtime不做过多的讲解，改天更新文章再对runtime进行分享</p>
<h2 id="编译和链接的区别"><a href="#编译和链接的区别" class="headerlink" title="编译和链接的区别"></a>编译和链接的区别</h2><p>将预处理生成的文件，经过词法分析、语法分析、语义分析以及优化后编译成若干个目标模块。可以理解为将高级语言翻译为计算机可以理解的二进制代码，即机器语言。<br>由链接程序将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的载入模型。链接主要解决模块间的相互引用问题。分为地址和空间分配，符号解析和重定位几个步骤。在编译阶段生成目标文件时，会暂时搁置那些外部引用，而这些外部引用就是在链接时进行确定的，链接器在链接时，会根据符号名称去相应模块中寻找对应符号。待符号确定之后，链接器会重写之前那些未确定的符号的地址，这个过程就是重定位。链接一般分为静态链接、载入时动态链接以及运行时动态链接三种。</p>
<h2 id="OC和JS交互方式"><a href="#OC和JS交互方式" class="headerlink" title="OC和JS交互方式"></a>OC和JS交互方式</h2><p>注入 API 和 拦截 URL SCHEME<br>UIWebView 拦截 URL<br>WebViewJavascriptBridge。<br>只要调用<br>window.location.href = “openimagepicker://“<br>就会调用<br>(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</p>
<p>WebViewJavascriptBridge中OC调用JS采用的是WebView提供的JS执行方法；而JS调用OC采用的是URL拦截的方式，OC端通过识别特定的URL来区分是否需要拦截，并做相应的逻辑处理。<br>addScriptMessageHandler<br>evaluateJavaScript<br>JavaScriptCore<br>JSContext上下文，类似全局t对象，html的window对象一样</p>
<p>WKwebView，直接注入了JS方法名，不需要通过JavaScriptCore作为中间件<br>WKWebView 白屏问题： WKWebView 是一个多进程组件，Other Process 的内存占用会增加。WebContent Process 会 crash，从而出现白屏现象<br>缺点：承载当前webView的控制器无法正常释放<br>原因注意：这种方法很可能照成循环引用，所以在适当的时机要移除。</p>
<h2 id="OC和JS是如何交互的"><a href="#OC和JS是如何交互的" class="headerlink" title="OC和JS是如何交互的"></a>OC和JS是如何交互的</h2><p>依赖注入<br>OC先声明一段JS代码，在第一次进入此webView页的时候注入到 webView中，之后webView上下文中就有了这些js函数。<br>注册声明 js 会被 oc 调用的方法存放在 js 环境的字典中；<br>oc 发起调用，生成一个message字典，三个参数（handlerName 方法名，data数据， callbackId 回调方法）<br>把message字典转成json字符串，处理字符串里面的\、\、\r、\n 等特殊字符。生成新的字符串并加上<br>WebViewJavascriptBridge._handleMessageFromObjC(‘messageJSON‘)，形成一段字符串形式的js代码（既通过提前注入js中的函数_handleMessageFromObjC去处理 messageJSON 参数）。</p>
<h2 id="模块化同层的依赖如何实现"><a href="#模块化同层的依赖如何实现" class="headerlink" title="模块化同层的依赖如何实现"></a>模块化同层的依赖如何实现</h2><p>通过引用的方式打出framework，所以需要在项目中同时使用</p>
<p>DNS过程 DNS劫持</p>
<p>编译过程</p>
<p>线程同步方法<br>死锁。如何避免<br>输入url后的事件流程<br>获取mac地址的过程<br>10亿数据查找目标，bitmap<br>浏览器渲染页面过程<br>设计一个StringBuffer<br>设计多线程下载一个1G文件<br>讲一讲hashmap 和hashtable 的区别<br>分享一个最值得分享的经历，觉得最有成就感的？过程中最有收获的点<br>什么是信号量<br>git<br>问这三个http版本有啥区别的区别<br>进程和线程切换的开销<br>    切换虚拟地址空间<br>    切换CPU上下文<br>    切换内核栈<br>进程间通讯的四种方式<br>    共享内存<br>    信号<br>    管道<br>    消息队列<br>动态链接库和共享内存的区别在哪呢？ 区别就在于：多个程序虽然可以共享同一个动态链接库中的相同代码，但每一个进程都为动态链接库使用的全部数据分配了自己的地址空间。而共享内存是代码和数据均被多个程序所共享。动态链接库只是实现了代码的复用，对于数据，各个程序要自己保存。共享内存用于进程间通信，主要用于数据…</p>
<p>DNS查询<br>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift138%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift138%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">UI相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:47" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:47+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="程序绘制流程"><a href="#程序绘制流程" class="headerlink" title="程序绘制流程"></a>程序绘制流程</h2><h2 id="试图绘制为什么不立即执行"><a href="#试图绘制为什么不立即执行" class="headerlink" title="试图绘制为什么不立即执行"></a>试图绘制为什么不立即执行</h2><h2 id="事件响应流程"><a href="#事件响应流程" class="headerlink" title="事件响应流程"></a>事件响应流程</h2><h2 id="UI卡顿原因"><a href="#UI卡顿原因" class="headerlink" title="UI卡顿原因"></a>UI卡顿原因</h2><h2 id="滑动优化方案"><a href="#滑动优化方案" class="headerlink" title="滑动优化方案"></a>滑动优化方案</h2><h2 id="什么是离屏渲染，触发的条件是什么"><a href="#什么是离屏渲染，触发的条件是什么" class="headerlink" title="什么是离屏渲染，触发的条件是什么"></a>什么是离屏渲染，触发的条件是什么</h2><h2 id="UIView和CALayer关系"><a href="#UIView和CALayer关系" class="headerlink" title="UIView和CALayer关系"></a>UIView和CALayer关系</h2><h2 id="CALayer的mask作用"><a href="#CALayer的mask作用" class="headerlink" title="CALayer的mask作用"></a>CALayer的mask作用</h2><h2 id="如何高性能给UIImageView加圆角"><a href="#如何高性能给UIImageView加圆角" class="headerlink" title="如何高性能给UIImageView加圆角"></a>如何高性能给UIImageView加圆角</h2><h2 id="如何使用核心动画"><a href="#如何使用核心动画" class="headerlink" title="如何使用核心动画"></a>如何使用核心动画</h2><h2 id="如何增加view点击范围"><a href="#如何增加view点击范围" class="headerlink" title="如何增加view点击范围"></a>如何增加view点击范围</h2><h2 id="hitTest：withEvent内部实现"><a href="#hitTest：withEvent内部实现" class="headerlink" title="hitTest：withEvent内部实现"></a>hitTest：withEvent内部实现</h2><h2 id="程序的启动速度优化"><a href="#程序的启动速度优化" class="headerlink" title="程序的启动速度优化"></a>程序的启动速度优化</h2><h2 id="drawRect和layouSubviews-的区别"><a href="#drawRect和layouSubviews-的区别" class="headerlink" title="drawRect和layouSubviews 的区别"></a>drawRect和layouSubviews 的区别</h2><h2 id="setNeedsLayout与layoutIfNeeded的区别"><a href="#setNeedsLayout与layoutIfNeeded的区别" class="headerlink" title="setNeedsLayout与layoutIfNeeded的区别"></a>setNeedsLayout与layoutIfNeeded的区别</h2><h2 id="UIResponder的理解和事件响应分析"><a href="#UIResponder的理解和事件响应分析" class="headerlink" title="UIResponder的理解和事件响应分析"></a>UIResponder的理解和事件响应分析</h2><h2 id="loadView的作用"><a href="#loadView的作用" class="headerlink" title="loadView的作用"></a>loadView的作用</h2><h2 id="UITableView卡顿原因"><a href="#UITableView卡顿原因" class="headerlink" title="UITableView卡顿原因"></a>UITableView卡顿原因</h2><h2 id="UITableView优化"><a href="#UITableView优化" class="headerlink" title="UITableView优化"></a>UITableView优化</h2><h2 id="iOS-保持界面流畅的技巧"><a href="#iOS-保持界面流畅的技巧" class="headerlink" title="iOS 保持界面流畅的技巧"></a>iOS 保持界面流畅的技巧</h2><h2 id="使用-drawRect有什么影响"><a href="#使用-drawRect有什么影响" class="headerlink" title="使用 drawRect有什么影响"></a>使用 drawRect有什么影响</h2><h2 id="tableViewCell的自适应如何实现，如何保证性能"><a href="#tableViewCell的自适应如何实现，如何保证性能" class="headerlink" title="tableViewCell的自适应如何实现，如何保证性能"></a>tableViewCell的自适应如何实现，如何保证性能</h2><h2 id="转场动画相关操作"><a href="#转场动画相关操作" class="headerlink" title="转场动画相关操作"></a>转场动画相关操作</h2><h2 id="绘图相关知识-coreGraphics框架的使用"><a href="#绘图相关知识-coreGraphics框架的使用" class="headerlink" title="绘图相关知识(coreGraphics框架的使用)"></a>绘图相关知识(coreGraphics框架的使用)</h2><h2 id="view的生命周期"><a href="#view的生命周期" class="headerlink" title="view的生命周期"></a>view的生命周期</h2><h2 id="系统UIView更新机制的思想"><a href="#系统UIView更新机制的思想" class="headerlink" title="系统UIView更新机制的思想"></a>系统UIView更新机制的思想</h2><h2 id="drawRect常用作用"><a href="#drawRect常用作用" class="headerlink" title="drawRect常用作用"></a>drawRect常用作用</h2><h2 id="layoutSubView和drawRect的调用时机；"><a href="#layoutSubView和drawRect的调用时机；" class="headerlink" title="layoutSubView和drawRect的调用时机；"></a>layoutSubView和drawRect的调用时机；</h2><h2 id="用UIView实现Scrollview。"><a href="#用UIView实现Scrollview。" class="headerlink" title="用UIView实现Scrollview。"></a>用UIView实现Scrollview。</h2><h2 id="轮播图的实现"><a href="#轮播图的实现" class="headerlink" title="轮播图的实现"></a>轮播图的实现</h2><h2 id="CGSize-intrinsicContentSize-是干什么用的？"><a href="#CGSize-intrinsicContentSize-是干什么用的？" class="headerlink" title="-(CGSize)intrinsicContentSize:是干什么用的？"></a>-(CGSize)intrinsicContentSize:是干什么用的？</h2><h2 id="渲染UI为什么要在主线程？"><a href="#渲染UI为什么要在主线程？" class="headerlink" title="渲染UI为什么要在主线程？"></a>渲染UI为什么要在主线程？</h2><h2 id="如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？"><a href="#如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？" class="headerlink" title="如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？"></a>如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？</h2><h2 id="scrollview与消息响应链冲突？"><a href="#scrollview与消息响应链冲突？" class="headerlink" title="scrollview与消息响应链冲突？"></a>scrollview与消息响应链冲突？</h2><h2 id="Core-Graphics的更底层的是什么；"><a href="#Core-Graphics的更底层的是什么；" class="headerlink" title="Core Graphics的更底层的是什么；"></a>Core Graphics的更底层的是什么；</h2><h1 id="OC相关"><a href="#OC相关" class="headerlink" title="OC相关"></a>OC相关</h1><h2 id="分类可以添加哪些内容，为什么不能添加属性"><a href="#分类可以添加哪些内容，为什么不能添加属性" class="headerlink" title="分类可以添加哪些内容，为什么不能添加属性"></a>分类可以添加哪些内容，为什么不能添加属性</h2><h2 id="类扩展和分类的区别"><a href="#类扩展和分类的区别" class="headerlink" title="类扩展和分类的区别"></a>类扩展和分类的区别</h2><h2 id="分类是如何实现的"><a href="#分类是如何实现的" class="headerlink" title="分类是如何实现的"></a>分类是如何实现的</h2><h2 id="分类重写了原类中同名方法会怎么样，为什么"><a href="#分类重写了原类中同名方法会怎么样，为什么" class="headerlink" title="分类重写了原类中同名方法会怎么样，为什么"></a>分类重写了原类中同名方法会怎么样，为什么</h2><h2 id="如何给分类添加属性（关联对象）"><a href="#如何给分类添加属性（关联对象）" class="headerlink" title="如何给分类添加属性（关联对象）"></a>如何给分类添加属性（关联对象）</h2><h2 id="什么是代理，和通知-BLOCK区别"><a href="#什么是代理，和通知-BLOCK区别" class="headerlink" title="什么是代理，和通知/BLOCK区别"></a>什么是代理，和通知/BLOCK区别</h2><h2 id="什么是通知"><a href="#什么是通知" class="headerlink" title="什么是通知"></a>什么是通知</h2><h2 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h2><h2 id="KVC的实现原理"><a href="#KVC的实现原理" class="headerlink" title="KVC的实现原理"></a>KVC的实现原理</h2><h2 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h2><h2 id="include与-import的区别、-import-与-class-的区别"><a href="#include与-import的区别、-import-与-class-的区别" class="headerlink" title="include与#import的区别、#import 与@class 的区别"></a>include与#import的区别、#import 与@class 的区别</h2><h2 id="解释-const-static-inline-关键字"><a href="#解释-const-static-inline-关键字" class="headerlink" title="解释 const, static, inline 关键字"></a>解释 const, static, inline 关键字</h2><h2 id="OC-里怎么实现多继承"><a href="#OC-里怎么实现多继承" class="headerlink" title="OC 里怎么实现多继承"></a>OC 里怎么实现多继承</h2><h2 id="load方法实现原理与initialize区别"><a href="#load方法实现原理与initialize区别" class="headerlink" title="load方法实现原理与initialize区别"></a>load方法实现原理与initialize区别</h2><h2 id="懒加载的使用"><a href="#懒加载的使用" class="headerlink" title="懒加载的使用"></a>懒加载的使用</h2><h2 id="写一个单例"><a href="#写一个单例" class="headerlink" title="写一个单例"></a>写一个单例</h2><h2 id="nil-NIL-NSNULL区别，id-和-instanceType-区别，self和super的区别，struct和class的区别"><a href="#nil-NIL-NSNULL区别，id-和-instanceType-区别，self和super的区别，struct和class的区别" class="headerlink" title="nil NIL NSNULL区别，id 和 instanceType 区别，self和super的区别，struct和class的区别"></a>nil NIL NSNULL区别，id 和 instanceType 区别，self和super的区别，struct和class的区别</h2><h2 id="如何实现一个线程安全的-NSMutableArray"><a href="#如何实现一个线程安全的-NSMutableArray" class="headerlink" title="如何实现一个线程安全的 NSMutableArray?"></a>如何实现一个线程安全的 NSMutableArray?</h2><h2 id="JS-和-OC-互相调用的几种方式"><a href="#JS-和-OC-互相调用的几种方式" class="headerlink" title="JS 和 OC 互相调用的几种方式"></a>JS 和 OC 互相调用的几种方式</h2><h2 id="数据持久性有哪几种"><a href="#数据持久性有哪几种" class="headerlink" title="数据持久性有哪几种"></a>数据持久性有哪几种</h2><h2 id="blcok，NSNotification，delegate，Observer比较"><a href="#blcok，NSNotification，delegate，Observer比较" class="headerlink" title="blcok，NSNotification，delegate，Observer比较"></a>blcok，NSNotification，delegate，Observer比较</h2><h2 id="const-extern-static-用法区别"><a href="#const-extern-static-用法区别" class="headerlink" title="const extern static 用法区别"></a>const extern static 用法区别</h2><h2 id="写一个宏定义函数，实现返回三个数中最大的"><a href="#写一个宏定义函数，实现返回三个数中最大的" class="headerlink" title="写一个宏定义函数，实现返回三个数中最大的"></a>写一个宏定义函数，实现返回三个数中最大的</h2><h2 id="static和extern的访问范围，用extern的情况下什么时候程序会报错"><a href="#static和extern的访问范围，用extern的情况下什么时候程序会报错" class="headerlink" title="static和extern的访问范围，用extern的情况下什么时候程序会报错"></a>static和extern的访问范围，用extern的情况下什么时候程序会报错</h2><h2 id="inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？"><a href="#inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？" class="headerlink" title="inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？"></a>inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？</h2><h2 id="OC里的基本数据类型如数组字典等的数据结构是怎样的；"><a href="#OC里的基本数据类型如数组字典等的数据结构是怎样的；" class="headerlink" title="OC里的基本数据类型如数组字典等的数据结构是怎样的；"></a>OC里的基本数据类型如数组字典等的数据结构是怎样的；</h2><h2 id="sychronized实现原理"><a href="#sychronized实现原理" class="headerlink" title="sychronized实现原理"></a>sychronized实现原理</h2><h2 id="问NSTimer的底层实现原理"><a href="#问NSTimer的底层实现原理" class="headerlink" title="问NSTimer的底层实现原理"></a>问NSTimer的底层实现原理</h2><h2 id="block中为什么要用Strong类型的引用来保持self；"><a href="#block中为什么要用Strong类型的引用来保持self；" class="headerlink" title="block中为什么要用Strong类型的引用来保持self；"></a>block中为什么要用Strong类型的引用来保持self；</h2><h2 id="问-ifdef-cplusplus-extern-“C-“"><a href="#问-ifdef-cplusplus-extern-“C-“" class="headerlink" title="问#ifdef __cplusplus extern “C “"></a>问#ifdef __cplusplus extern “C “</h2><h2 id="说下ASCII和unicode的区别utf-8的优势"><a href="#说下ASCII和unicode的区别utf-8的优势" class="headerlink" title="说下ASCII和unicode的区别utf-8的优势"></a>说下ASCII和unicode的区别utf-8的优势</h2><h2 id="iOS-launchwith-options-返回no有什么作用；"><a href="#iOS-launchwith-options-返回no有什么作用；" class="headerlink" title="iOS launchwith options 返回no有什么作用；"></a>iOS launchwith options 返回no有什么作用；</h2><h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h2 id="NSObject的数据结构"><a href="#NSObject的数据结构" class="headerlink" title="NSObject的数据结构"></a>NSObject的数据结构</h2><h2 id="类对象和实例对象的isa指针的指向"><a href="#类对象和实例对象的isa指针的指向" class="headerlink" title="类对象和实例对象的isa指针的指向"></a>类对象和实例对象的isa指针的指向</h2><h2 id="为什么id类型可以指向OC中任意对象"><a href="#为什么id类型可以指向OC中任意对象" class="headerlink" title="为什么id类型可以指向OC中任意对象"></a>为什么id类型可以指向OC中任意对象</h2><h2 id="为什么不能用isa判断一个类的继承关系"><a href="#为什么不能用isa判断一个类的继承关系" class="headerlink" title="为什么不能用isa判断一个类的继承关系"></a>为什么不能用isa判断一个类的继承关系</h2><h2 id="cache-t的数据结构、实现原理及扩容"><a href="#cache-t的数据结构、实现原理及扩容" class="headerlink" title="cache_t的数据结构、实现原理及扩容"></a>cache_t的数据结构、实现原理及扩容</h2><h2 id="cache-t-扩容"><a href="#cache-t-扩容" class="headerlink" title="cache_t 扩容"></a>cache_t 扩容</h2><h2 id="class-rw-t的数据结构，实现原理"><a href="#class-rw-t的数据结构，实现原理" class="headerlink" title="class_rw_t的数据结构，实现原理"></a>class_rw_t的数据结构，实现原理</h2><h2 id="哈希碰撞的解决方法"><a href="#哈希碰撞的解决方法" class="headerlink" title="哈希碰撞的解决方法"></a>哈希碰撞的解决方法</h2><h2 id="方法查找的过程"><a href="#方法查找的过程" class="headerlink" title="方法查找的过程"></a>方法查找的过程</h2><h2 id="消息转发的流程"><a href="#消息转发的流程" class="headerlink" title="消息转发的流程"></a>消息转发的流程</h2><h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><h2 id="系统如何解决新增实例冲突"><a href="#系统如何解决新增实例冲突" class="headerlink" title="系统如何解决新增实例冲突"></a>系统如何解决新增实例冲突</h2><h2 id="常用的runtime方法有哪些"><a href="#常用的runtime方法有哪些" class="headerlink" title="常用的runtime方法有哪些"></a>常用的runtime方法有哪些</h2><h2 id="runtime的具体应用有哪些，你在什么地方用到了"><a href="#runtime的具体应用有哪些，你在什么地方用到了" class="headerlink" title="runtime的具体应用有哪些，你在什么地方用到了"></a>runtime的具体应用有哪些，你在什么地方用到了</h2><h2 id="runtime-怎么添加属性，方法等"><a href="#runtime-怎么添加属性，方法等" class="headerlink" title="runtime 怎么添加属性，方法等"></a>runtime 怎么添加属性，方法等</h2><h2 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="runtime 如何实现 weak 属性"></a>runtime 如何实现 weak 属性</h2><h2 id="runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）"><a href="#runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）"></a>runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</h2><h2 id="runtime如何实现weak变量的自动置nil"><a href="#runtime如何实现weak变量的自动置nil" class="headerlink" title="runtime如何实现weak变量的自动置nil"></a>runtime如何实现weak变量的自动置nil</h2><h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2><h2 id="共用体方法查找"><a href="#共用体方法查找" class="headerlink" title="共用体方法查找"></a>共用体方法查找</h2><h2 id="msgSend如何查找"><a href="#msgSend如何查找" class="headerlink" title="msgSend如何查找"></a>msgSend如何查找</h2><h2 id="msgSend参数都有哪些；"><a href="#msgSend参数都有哪些；" class="headerlink" title="msgSend参数都有哪些；"></a>msgSend参数都有哪些；</h2><h2 id="class方法相关"><a href="#class方法相关" class="headerlink" title="class方法相关"></a>class方法相关</h2><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存中的5大区都是什么？"><a href="#内存中的5大区都是什么？" class="headerlink" title="内存中的5大区都是什么？"></a>内存中的5大区都是什么？</h2><h2 id="C-内存如何分布、堆和栈的区别"><a href="#C-内存如何分布、堆和栈的区别" class="headerlink" title="C++内存如何分布、堆和栈的区别"></a>C++内存如何分布、堆和栈的区别</h2><h2 id="ARC实现机制，遵循哪些原则"><a href="#ARC实现机制，遵循哪些原则" class="headerlink" title="ARC实现机制，遵循哪些原则"></a>ARC实现机制，遵循哪些原则</h2><h2 id="NSObject内存分配、ISA指针的内存大小"><a href="#NSObject内存分配、ISA指针的内存大小" class="headerlink" title="NSObject内存分配、ISA指针的内存大小"></a>NSObject内存分配、ISA指针的内存大小</h2><h2 id="Tagged-Pointer、NONPOINTER-ISA实现机制和作用"><a href="#Tagged-Pointer、NONPOINTER-ISA实现机制和作用" class="headerlink" title="Tagged Pointer、NONPOINTER_ISA实现机制和作用"></a>Tagged Pointer、NONPOINTER_ISA实现机制和作用</h2><h2 id="异步多线程访问导致的内存问题分析及解决办法。（代码题）"><a href="#异步多线程访问导致的内存问题分析及解决办法。（代码题）" class="headerlink" title="异步多线程访问导致的内存问题分析及解决办法。（代码题）"></a>异步多线程访问导致的内存问题分析及解决办法。（代码题）</h2><h2 id="SideTables数据结构及实现原理，为什么用多个SideTables"><a href="#SideTables数据结构及实现原理，为什么用多个SideTables" class="headerlink" title="SideTables数据结构及实现原理，为什么用多个SideTables"></a>SideTables数据结构及实现原理，为什么用多个SideTables</h2><pre><code>                       
</code></pre>
<h2 id="Autoreleasepool的数据结构及实现原理，什么时候释放"><a href="#Autoreleasepool的数据结构及实现原理，什么时候释放" class="headerlink" title="Autoreleasepool的数据结构及实现原理，什么时候释放"></a>Autoreleasepool的数据结构及实现原理，什么时候释放</h2><h2 id="AutoreleasePool-为何可以嵌套使用"><a href="#AutoreleasePool-为何可以嵌套使用" class="headerlink" title="AutoreleasePool 为何可以嵌套使用"></a>AutoreleasePool 为何可以嵌套使用</h2><h2 id="子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool"><a href="#子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool" class="headerlink" title="子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool"></a>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool</h2><h2 id="dealloc调用流程"><a href="#dealloc调用流程" class="headerlink" title="dealloc调用流程"></a>dealloc调用流程</h2><h2 id="常见的循环引用，如何破除循环引用"><a href="#常见的循环引用，如何破除循环引用" class="headerlink" title="常见的循环引用，如何破除循环引用"></a>常见的循环引用，如何破除循环引用</h2><h2 id="weak-修饰的变量在地址被释放后，为何被置为-nil？"><a href="#weak-修饰的变量在地址被释放后，为何被置为-nil？" class="headerlink" title="__weak 修饰的变量在地址被释放后，为何被置为 nil？"></a>__weak 修饰的变量在地址被释放后，为何被置为 nil？</h2><h2 id="深拷贝和浅拷贝区别"><a href="#深拷贝和浅拷贝区别" class="headerlink" title="深拷贝和浅拷贝区别"></a>深拷贝和浅拷贝区别</h2><h2 id="atomic是安全的吗"><a href="#atomic是安全的吗" class="headerlink" title="atomic是安全的吗"></a>atomic是安全的吗</h2><h2 id="assign-vs-weak，-block-vs-weak-区别"><a href="#assign-vs-weak，-block-vs-weak-区别" class="headerlink" title="assign vs weak，_block vs _weak 区别"></a>assign vs weak，_block vs _weak 区别</h2><h2 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h2><h2 id="图片加载占用内存对比"><a href="#图片加载占用内存对比" class="headerlink" title="图片加载占用内存对比"></a>图片加载占用内存对比</h2><h2 id="block一般用那个关键字修饰，为什么"><a href="#block一般用那个关键字修饰，为什么" class="headerlink" title="block一般用那个关键字修饰，为什么"></a>block一般用那个关键字修饰，为什么</h2><h2 id="写一个MRC的set方法"><a href="#写一个MRC的set方法" class="headerlink" title="写一个MRC的set方法"></a>写一个MRC的set方法</h2><h2 id="如何解决定时器循环引用"><a href="#如何解决定时器循环引用" class="headerlink" title="如何解决定时器循环引用"></a>如何解决定时器循环引用</h2><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><h2 id="什么是虚拟内存、共享内存、物理内存"><a href="#什么是虚拟内存、共享内存、物理内存" class="headerlink" title="什么是虚拟内存、共享内存、物理内存"></a>什么是虚拟内存、共享内存、物理内存</h2><h2 id="举例一些I-O操作的例子"><a href="#举例一些I-O操作的例子" class="headerlink" title="举例一些I/O操作的例子"></a>举例一些I/O操作的例子</h2><h2 id="如何开辟一块内存；"><a href="#如何开辟一块内存；" class="headerlink" title="如何开辟一块内存；"></a>如何开辟一块内存；</h2><h2 id="什么时候深复制，什么时候浅复制；"><a href="#什么时候深复制，什么时候浅复制；" class="headerlink" title="什么时候深复制，什么时候浅复制；"></a>什么时候深复制，什么时候浅复制；</h2><h2 id="怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手"><a href="#怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手" class="headerlink" title="怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手"></a>怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手</h2><h2 id="问堆和栈的区别。"><a href="#问堆和栈的区别。" class="headerlink" title="问堆和栈的区别。"></a>问堆和栈的区别。</h2><h2 id="Block的创建，何时被释放。"><a href="#Block的创建，何时被释放。" class="headerlink" title="Block的创建，何时被释放。"></a>Block的创建，何时被释放。</h2><h2 id="dynamic的应用场景？"><a href="#dynamic的应用场景？" class="headerlink" title="@dynamic的应用场景？"></a>@dynamic的应用场景？</h2><h2 id="问题：-property-copy-NSMutableArray-array"><a href="#问题：-property-copy-NSMutableArray-array" class="headerlink" title="问题：@property (copy) NSMutableArray *array;"></a>问题：@property (copy) NSMutableArray *array;</h2><h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><h2 id="Block为什么用copy"><a href="#Block为什么用copy" class="headerlink" title="Block为什么用copy"></a>Block为什么用copy</h2><h2 id="Block如何截获不同变量，代码分析"><a href="#Block如何截获不同变量，代码分析" class="headerlink" title="Block如何截获不同变量，代码分析"></a>Block如何截获不同变量，代码分析</h2><h2 id="Block本质数据结构"><a href="#Block本质数据结构" class="headerlink" title="Block本质数据结构"></a>Block本质数据结构</h2><h2 id="栈上的Block经过copy操作后发生哪些变化"><a href="#栈上的Block经过copy操作后发生哪些变化" class="headerlink" title="栈上的Block经过copy操作后发生哪些变化"></a>栈上的Block经过copy操作后发生哪些变化</h2><h2 id="block循环引用"><a href="#block循环引用" class="headerlink" title="block循环引用"></a>block循环引用</h2><h2 id="block原理"><a href="#block原理" class="headerlink" title="__block原理"></a>__block原理</h2><h2 id="strong原理"><a href="#strong原理" class="headerlink" title="__strong原理"></a>__strong原理</h2><h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop概念及数据结构、事件循环机制"><a href="#RunLoop概念及数据结构、事件循环机制" class="headerlink" title="RunLoop概念及数据结构、事件循环机制"></a>RunLoop概念及数据结构、事件循环机制</h2><h2 id="CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用"><a href="#CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用" class="headerlink" title="CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用"></a>CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用</h2><h2 id="RunLoop和NStimer"><a href="#RunLoop和NStimer" class="headerlink" title="RunLoop和NStimer"></a>RunLoop和NStimer</h2><h2 id="RunLoop和多线程"><a href="#RunLoop和多线程" class="headerlink" title="RunLoop和多线程"></a>RunLoop和多线程</h2><h2 id="如何实现一个常驻线程"><a href="#如何实现一个常驻线程" class="headerlink" title="如何实现一个常驻线程"></a>如何实现一个常驻线程</h2><h2 id="利用-runloop-解释一下页面的渲染的过程"><a href="#利用-runloop-解释一下页面的渲染的过程" class="headerlink" title="利用 runloop 解释一下页面的渲染的过程"></a>利用 runloop 解释一下页面的渲染的过程</h2><h2 id="你在开发过程中怎么使用RunLoop？什么应用场景？"><a href="#你在开发过程中怎么使用RunLoop？什么应用场景？" class="headerlink" title="你在开发过程中怎么使用RunLoop？什么应用场景？"></a>你在开发过程中怎么使用RunLoop？什么应用场景？</h2><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程与线程、并行-和-并发-区别"><a href="#进程与线程、并行-和-并发-区别" class="headerlink" title="进程与线程、并行 和 并发 区别"></a>进程与线程、并行 和 并发 区别</h2><h2 id="GCD、NSOperation、NSThread区别优缺点"><a href="#GCD、NSOperation、NSThread区别优缺点" class="headerlink" title="GCD、NSOperation、NSThread区别优缺点"></a>GCD、NSOperation、NSThread区别优缺点</h2><h2 id="performSelector-withObject-afterDelay-为什么在子线程无效"><a href="#performSelector-withObject-afterDelay-为什么在子线程无效" class="headerlink" title="performSelector:withObject:afterDelay:为什么在子线程无效"></a>performSelector:withObject:afterDelay:为什么在子线程无效</h2><h2 id="如何让多个网络请求完成后执行下一步"><a href="#如何让多个网络请求完成后执行下一步" class="headerlink" title="如何让多个网络请求完成后执行下一步"></a>如何让多个网络请求完成后执行下一步</h2><h2 id="多个网络请求顺序执行后执行下一步"><a href="#多个网络请求顺序执行后执行下一步" class="headerlink" title="多个网络请求顺序执行后执行下一步"></a>多个网络请求顺序执行后执行下一步</h2><h2 id="异步操作两组数据时-执行完第一组之后-才能执行第二组"><a href="#异步操作两组数据时-执行完第一组之后-才能执行第二组" class="headerlink" title="异步操作两组数据时, 执行完第一组之后, 才能执行第二组"></a>异步操作两组数据时, 执行完第一组之后, 才能执行第二组</h2><h2 id="你知道哪些锁、使用场景"><a href="#你知道哪些锁、使用场景" class="headerlink" title="你知道哪些锁、使用场景"></a>你知道哪些锁、使用场景</h2><h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><h2 id="CommonMode的特性"><a href="#CommonMode的特性" class="headerlink" title="CommonMode的特性"></a>CommonMode的特性</h2><h2 id="runloop与autoreleasepool的关系"><a href="#runloop与autoreleasepool的关系" class="headerlink" title="runloop与autoreleasepool的关系"></a>runloop与autoreleasepool的关系</h2><h2 id="GCD-在Runloop中的使用"><a href="#GCD-在Runloop中的使用" class="headerlink" title="GCD 在Runloop中的使用"></a>GCD 在Runloop中的使用</h2><h2 id="GCD-Global队列创建线程进行耗时操作的风险"><a href="#GCD-Global队列创建线程进行耗时操作的风险" class="headerlink" title="GCD Global队列创建线程进行耗时操作的风险"></a>GCD Global队列创建线程进行耗时操作的风险</h2><h2 id="CADispalyTimer和Timer哪个更精确"><a href="#CADispalyTimer和Timer哪个更精确" class="headerlink" title="CADispalyTimer和Timer哪个更精确"></a>CADispalyTimer和Timer哪个更精确</h2><h2 id="怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"><a href="#怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作" class="headerlink" title="怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"></a>怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作</h2><h2 id="分析线程同步串行、同步并行、异步串行、异步并行问题"><a href="#分析线程同步串行、同步并行、异步串行、异步并行问题" class="headerlink" title="分析线程同步串行、同步并行、异步串行、异步并行问题"></a>分析线程同步串行、同步并行、异步串行、异步并行问题</h2><h2 id="GCD执行原理、问题分析"><a href="#GCD执行原理、问题分析" class="headerlink" title="GCD执行原理、问题分析"></a>GCD执行原理、问题分析</h2><h2 id="dispatch-once如何实现一次性代码"><a href="#dispatch-once如何实现一次性代码" class="headerlink" title="dispatch_once如何实现一次性代码"></a>dispatch_once如何实现一次性代码</h2><h2 id="NSOperation数据结构"><a href="#NSOperation数据结构" class="headerlink" title="NSOperation数据结构"></a>NSOperation数据结构</h2><h2 id="重写NSOperation需要注意的点"><a href="#重写NSOperation需要注意的点" class="headerlink" title="重写NSOperation需要注意的点"></a>重写NSOperation需要注意的点</h2><h2 id="进程中的哪些空间是线程所共有的？"><a href="#进程中的哪些空间是线程所共有的？" class="headerlink" title="进程中的哪些空间是线程所共有的？"></a>进程中的哪些空间是线程所共有的？</h2><h2 id="使用GCD需要注意什么；"><a href="#使用GCD需要注意什么；" class="headerlink" title="使用GCD需要注意什么；"></a>使用GCD需要注意什么；</h2><h2 id="runloop跟runtime有没有关联"><a href="#runloop跟runtime有没有关联" class="headerlink" title="runloop跟runtime有没有关联"></a>runloop跟runtime有没有关联</h2><h2 id="CPU和GPU怎么相互合作的"><a href="#CPU和GPU怎么相互合作的" class="headerlink" title="CPU和GPU怎么相互合作的"></a>CPU和GPU怎么相互合作的</h2><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP请求方式有哪些"><a href="#HTTP请求方式有哪些" class="headerlink" title="HTTP请求方式有哪些"></a>HTTP请求方式有哪些</h2><h2 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h2><h2 id="HTTP三次握手，为什么需要三次"><a href="#HTTP三次握手，为什么需要三次" class="headerlink" title="HTTP三次握手，为什么需要三次"></a>HTTP三次握手，为什么需要三次</h2><h2 id="HTTP四次挥手，为什么需要四次"><a href="#HTTP四次挥手，为什么需要四次" class="headerlink" title="HTTP四次挥手，为什么需要四次"></a>HTTP四次挥手，为什么需要四次</h2><h2 id="为什么“握手”是三次，“挥手”却要四次？"><a href="#为什么“握手”是三次，“挥手”却要四次？" class="headerlink" title="为什么“握手”是三次，“挥手”却要四次？"></a>为什么“握手”是三次，“挥手”却要四次？</h2><h2 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL"></a>为什么客户端在TIME-WAIT阶段要等2MSL</h2><h2 id="HTTPS-TLS-SSL加密过程"><a href="#HTTPS-TLS-SSL加密过程" class="headerlink" title="HTTPS TLS/SSL加密过程"></a>HTTPS TLS/SSL加密过程</h2><h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><h2 id="中间人攻击（charles抓包原理）"><a href="#中间人攻击（charles抓包原理）" class="headerlink" title="中间人攻击（charles抓包原理）"></a>中间人攻击（charles抓包原理）</h2><h2 id="UDP协议及特点、"><a href="#UDP协议及特点、" class="headerlink" title="UDP协议及特点、"></a>UDP协议及特点、</h2><h2 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h2><h2 id="TCP特点及与UDP区别"><a href="#TCP特点及与UDP区别" class="headerlink" title="TCP特点及与UDP区别"></a>TCP特点及与UDP区别</h2><h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><h2 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h2><h2 id="Cookie机制及作用"><a href="#Cookie机制及作用" class="headerlink" title="Cookie机制及作用"></a>Cookie机制及作用</h2><h2 id="Session机制及作用"><a href="#Session机制及作用" class="headerlink" title="Session机制及作用"></a>Session机制及作用</h2><h2 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h2><h2 id="如何保证cookie的安全"><a href="#如何保证cookie的安全" class="headerlink" title="如何保证cookie的安全"></a>如何保证cookie的安全</h2><h2 id="HTTP请求头都有哪些内容"><a href="#HTTP请求头都有哪些内容" class="headerlink" title="HTTP请求头都有哪些内容"></a>HTTP请求头都有哪些内容</h2><h2 id="哪些加密算法"><a href="#哪些加密算法" class="headerlink" title="哪些加密算法"></a>哪些加密算法</h2><h2 id="TCP和UDP各自使用场景"><a href="#TCP和UDP各自使用场景" class="headerlink" title="TCP和UDP各自使用场景"></a>TCP和UDP各自使用场景</h2><h2 id="http为什么底层是tcp不是udp"><a href="#http为什么底层是tcp不是udp" class="headerlink" title="http为什么底层是tcp不是udp ?"></a>http为什么底层是tcp不是udp ?</h2><h2 id="socket异常断开时，设计一个合理的重连机制。"><a href="#socket异常断开时，设计一个合理的重连机制。" class="headerlink" title="socket异常断开时，设计一个合理的重连机制。"></a>socket异常断开时，设计一个合理的重连机制。</h2><h2 id="有了mac地址为什么要有ip地址"><a href="#有了mac地址为什么要有ip地址" class="headerlink" title="有了mac地址为什么要有ip地址"></a>有了mac地址为什么要有ip地址</h2><h2 id="断点续传怎么实现"><a href="#断点续传怎么实现" class="headerlink" title="断点续传怎么实现;"></a>断点续传怎么实现;</h2><h2 id="大型文件怎么下载并保存到本地；"><a href="#大型文件怎么下载并保存到本地；" class="headerlink" title="大型文件怎么下载并保存到本地；"></a>大型文件怎么下载并保存到本地；</h2><h2 id="xml和json的区别"><a href="#xml和json的区别" class="headerlink" title="xml和json的区别"></a>xml和json的区别</h2><h2 id="加密解密的技术讲解。"><a href="#加密解密的技术讲解。" class="headerlink" title="加密解密的技术讲解。"></a>加密解密的技术讲解。</h2><h2 id="reachability如何检测到网络状态变化？"><a href="#reachability如何检测到网络状态变化？" class="headerlink" title="reachability如何检测到网络状态变化？"></a>reachability如何检测到网络状态变化？</h2><h2 id="IP-地址用-int-保存和读取转化"><a href="#IP-地址用-int-保存和读取转化" class="headerlink" title="IP 地址用 int 保存和读取转化"></a>IP 地址用 int 保存和读取转化</h2><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h2 id="iOS有哪些常见的设计模式"><a href="#iOS有哪些常见的设计模式" class="headerlink" title="iOS有哪些常见的设计模式?"></a>iOS有哪些常见的设计模式?</h2><h2 id="单例优缺点"><a href="#单例优缺点" class="headerlink" title="单例优缺点"></a>单例优缺点</h2><h2 id="内存设计、磁盘设计、网络设计原则"><a href="#内存设计、磁盘设计、网络设计原则" class="headerlink" title="内存设计、磁盘设计、网络设计原则"></a>内存设计、磁盘设计、网络设计原则</h2><h2 id="MVP、MVVM模式思想"><a href="#MVP、MVVM模式思想" class="headerlink" title="MVP、MVVM模式思想"></a>MVP、MVVM模式思想</h2><h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><h2 id="AFNetworking-底层原理分析"><a href="#AFNetworking-底层原理分析" class="headerlink" title="AFNetworking 底层原理分析"></a>AFNetworking 底层原理分析</h2><h2 id="SDWebImage加载图片过程，图片缓存设计"><a href="#SDWebImage加载图片过程，图片缓存设计" class="headerlink" title="SDWebImage加载图片过程，图片缓存设计"></a>SDWebImage加载图片过程，图片缓存设计</h2><h2 id="YYKit"><a href="#YYKit" class="headerlink" title="YYKit"></a>YYKit</h2><h2 id="组建化优缺点"><a href="#组建化优缺点" class="headerlink" title="组建化优缺点"></a>组建化优缺点</h2><h2 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h2><h2 id="为什么要做组件化"><a href="#为什么要做组件化" class="headerlink" title="为什么要做组件化"></a>为什么要做组件化</h2><h2 id="你认为组件化的一些收益"><a href="#你认为组件化的一些收益" class="headerlink" title="你认为组件化的一些收益"></a>你认为组件化的一些收益</h2><h2 id="redux-单向数据流是怎么产生的-描述下"><a href="#redux-单向数据流是怎么产生的-描述下" class="headerlink" title="redux 单向数据流是怎么产生的 描述下"></a>redux 单向数据流是怎么产生的 描述下</h2><h2 id="Charts框架底层实现；"><a href="#Charts框架底层实现；" class="headerlink" title="Charts框架底层实现；"></a>Charts框架底层实现；</h2><h2 id="画出项目的结构图。"><a href="#画出项目的结构图。" class="headerlink" title="画出项目的结构图。"></a>画出项目的结构图。</h2><h2 id="yyModel的逻辑"><a href="#yyModel的逻辑" class="headerlink" title="yyModel的逻辑"></a>yyModel的逻辑</h2><h2 id="解耦的方式"><a href="#解耦的方式" class="headerlink" title="解耦的方式"></a>解耦的方式</h2><h2 id="项目中用的技术以及实现；"><a href="#项目中用的技术以及实现；" class="headerlink" title="项目中用的技术以及实现；"></a>项目中用的技术以及实现；</h2><h2 id="就是项目中遇到的问题以及解决方式；"><a href="#就是项目中遇到的问题以及解决方式；" class="headerlink" title="就是项目中遇到的问题以及解决方式；"></a>就是项目中遇到的问题以及解决方式；</h2><h2 id="缓存机制是怎么清除数据的？"><a href="#缓存机制是怎么清除数据的？" class="headerlink" title="缓存机制是怎么清除数据的？"></a>缓存机制是怎么清除数据的？</h2><h2 id="如何进行安全测试；"><a href="#如何进行安全测试；" class="headerlink" title="如何进行安全测试；"></a>如何进行安全测试；</h2><h2 id="涂鸦怎么实现；"><a href="#涂鸦怎么实现；" class="headerlink" title="涂鸦怎么实现；"></a>涂鸦怎么实现；</h2><h2 id="实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；"><a href="#实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；" class="headerlink" title="实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；"></a>实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；</h2><h2 id="说下生产者-消费者模型，其中的同步机制是怎么样的"><a href="#说下生产者-消费者模型，其中的同步机制是怎么样的" class="headerlink" title="说下生产者-消费者模型，其中的同步机制是怎么样的"></a>说下生产者-消费者模型，其中的同步机制是怎么样的</h2><h1 id="开发日常"><a href="#开发日常" class="headerlink" title="开发日常"></a>开发日常</h1><h2 id="APP启动时间应从哪些方面优化？"><a href="#APP启动时间应从哪些方面优化？" class="headerlink" title="APP启动时间应从哪些方面优化？"></a>APP启动时间应从哪些方面优化？</h2><h2 id="如何降低APP包的大小"><a href="#如何降低APP包的大小" class="headerlink" title="如何降低APP包的大小"></a>如何降低APP包的大小</h2><h2 id="如何检测离屏渲染与优化"><a href="#如何检测离屏渲染与优化" class="headerlink" title="如何检测离屏渲染与优化"></a>如何检测离屏渲染与优化</h2><h2 id="怎么检测图层混合"><a href="#怎么检测图层混合" class="headerlink" title="怎么检测图层混合"></a>怎么检测图层混合</h2><h2 id="UILabel图层混合"><a href="#UILabel图层混合" class="headerlink" title="UILabel图层混合"></a>UILabel图层混合</h2><h2 id="日常如何检查内存泄露？"><a href="#日常如何检查内存泄露？" class="headerlink" title="日常如何检查内存泄露？"></a>日常如何检查内存泄露？</h2><h2 id="LLDB常用的调试命令？"><a href="#LLDB常用的调试命令？" class="headerlink" title="LLDB常用的调试命令？"></a>LLDB常用的调试命令？</h2><h2 id="iOS-常见的崩溃类型有哪些？"><a href="#iOS-常见的崩溃类型有哪些？" class="headerlink" title="iOS 常见的崩溃类型有哪些？"></a>iOS 常见的崩溃类型有哪些？</h2><h2 id="iOS-App-稳定性指标及监测"><a href="#iOS-App-稳定性指标及监测" class="headerlink" title="iOS App 稳定性指标及监测"></a>iOS App 稳定性指标及监测</h2><h2 id="cocoapods-常见问题"><a href="#cocoapods-常见问题" class="headerlink" title="cocoapods 常见问题"></a>cocoapods 常见问题</h2><h2 id="iOS的签名机制是怎么样的"><a href="#iOS的签名机制是怎么样的" class="headerlink" title="iOS的签名机制是怎么样的"></a>iOS的签名机制是怎么样的</h2><h2 id="instruments它为什么能检测内存泄漏"><a href="#instruments它为什么能检测内存泄漏" class="headerlink" title="instruments它为什么能检测内存泄漏"></a>instruments它为什么能检测内存泄漏</h2><h2 id="推送的原理"><a href="#推送的原理" class="headerlink" title="推送的原理"></a>推送的原理</h2><h2 id="项目上线被拒原因"><a href="#项目上线被拒原因" class="headerlink" title="项目上线被拒原因"></a>项目上线被拒原因</h2><h2 id="项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线"><a href="#项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线" class="headerlink" title="项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线"></a>项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线</h2><h2 id="iPhone自带的AssistiveTouch你如何实现"><a href="#iPhone自带的AssistiveTouch你如何实现" class="headerlink" title="iPhone自带的AssistiveTouch你如何实现"></a>iPhone自带的AssistiveTouch你如何实现</h2><h2 id="有了解过代码如何编译的嘛"><a href="#有了解过代码如何编译的嘛" class="headerlink" title="有了解过代码如何编译的嘛"></a>有了解过代码如何编译的嘛</h2><h2 id="编译好的目标文件有data-和text段他们两者有啥区别"><a href="#编译好的目标文件有data-和text段他们两者有啥区别" class="headerlink" title="编译好的目标文件有data 和text段他们两者有啥区别"></a>编译好的目标文件有data 和text段他们两者有啥区别</h2><h2 id="appstore上架流程"><a href="#appstore上架流程" class="headerlink" title="appstore上架流程"></a>appstore上架流程</h2><h2 id="一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ"><a href="#一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ" class="headerlink" title="一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ;"></a>一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ;</h2><h2 id="针对线上版本的崩溃处理；"><a href="#针对线上版本的崩溃处理；" class="headerlink" title="针对线上版本的崩溃处理；"></a>针对线上版本的崩溃处理；</h2><h2 id="Xcode构建过程；"><a href="#Xcode构建过程；" class="headerlink" title="Xcode构建过程；"></a>Xcode构建过程；</h2><h2 id="js和Oc交互以及区别；"><a href="#js和Oc交互以及区别；" class="headerlink" title="js和Oc交互以及区别；"></a>js和Oc交互以及区别；</h2><h2 id="pod-install和pod-update有什么区别？"><a href="#pod-install和pod-update有什么区别？" class="headerlink" title="pod install和pod update有什么区别？"></a>pod install和pod update有什么区别？</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift137%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift137%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">其他问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:42" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:42+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36747738/article/details/106537874">https://blog.csdn.net/qq_36747738/article/details/106537874</a></p>
<h2 id="共用体方法查找"><a href="#共用体方法查找" class="headerlink" title="共用体方法查找"></a>共用体方法查找</h2><pre><code>公用体
位运算，|，&amp;
encding :编码
方法缓存（散列表）
key IMP
seleter &amp;  _mask 就是数据在索引中位置   或者求%
如果找到相同的key不同，就是i - 1或者+1
</code></pre>
<h2 id="msgSend如何查找"><a href="#msgSend如何查找" class="headerlink" title="msgSend如何查找"></a>msgSend如何查找</h2><pre><code>SEL  key;       //方法名称
IMP imp;       //方法的实现，imp是一个函数指针类型
msgSend
// objc_msgSend(person, sel_registerName(&quot;test&quot;));
search_method_list // 排序的（二分查找），线性的、填充缓存
lookUpImpOrForward
cache_getImp
getMethodNoSuper_nolock
cache_fill
</code></pre>
<h2 id="msgSend参数都有哪些；"><a href="#msgSend参数都有哪些；" class="headerlink" title="msgSend参数都有哪些；"></a>msgSend参数都有哪些；</h2><pre><code>第一个参数：消息接受的对象实例
第二个参数：执行的方法
</code></pre>
<h2 id="class方法相关"><a href="#class方法相关" class="headerlink" title="class方法相关"></a>class方法相关</h2><pre><code>class在nsobject中实现，谁调用返回的就是谁
isKaidof[NSObect class] 无论谁调用都分会yes
print能调用成功是应为通过对象找到的就是 isa
</code></pre>
<h1 id="UI相关"><a href="#UI相关" class="headerlink" title="UI相关"></a>UI相关</h1><h2 id="tableViewCell的自适应如何实现，如何保证性能"><a href="#tableViewCell的自适应如何实现，如何保证性能" class="headerlink" title="tableViewCell的自适应如何实现，如何保证性能"></a>tableViewCell的自适应如何实现，如何保证性能</h2><pre><code>提前计算好每个cell的高度，保存在一个frameModel中，每次从frameModel中取
</code></pre>
<h2 id="转场动画相关操作"><a href="#转场动画相关操作" class="headerlink" title="转场动画相关操作"></a>转场动画相关操作</h2><pre><code>前面提到转场的本质是下一个场景的视图替换当前场景的视图，从当前场景过渡下一个场景。下面称即将消失的
场景的视图为 fromView，对应的视图控制器为 fromVC，即将出现的视图为 toView，对应的视图控制器称之为 toVC。
交互控制器(Interaction Controller)
转场环境(Transition Context)
转场协调器(Transition Coordinator)
</code></pre>
<h2 id="绘图相关知识-coreGraphics框架的使用"><a href="#绘图相关知识-coreGraphics框架的使用" class="headerlink" title="绘图相关知识(coreGraphics框架的使用)"></a>绘图相关知识(coreGraphics框架的使用)</h2><pre><code>绘图周期
iOS在运行循环中会整合所有的绘图请求，并一次将它们绘制出来
不能在子线程中绘制，也不能进行复杂的操作，否则会造成主线程卡顿
视图绘制
调用UIView的drawRect:方法进行绘制。如果调用一个视图的setNeedsDisplay方法
，那么该视图就被标记为重新绘制，并且会在下一次绘制周期中重新绘制，自动调用drawRect:方法。
视图布局
调用UIView的layoutSubviews方法。如果调用一个视图的setNeedsLayout方法，
那么该视图就被标记为需要重新布局，UIKit会自动调用layoutSubviews
方法及其子视图的layoutSubviews方法。
在绘图时，我们应该尽量多使用布局，少使用绘制，是因为布局使用的是GPU，而
绘制使用的是CPU。GPU对于图形处理有优势，而CPU要处理的事情较多，且不擅长
处理图形，所以尽量使用GPU来处理图形。

绘图原理
context：imageContext：图片上下文，
CGPathRef / UIBezierPath图形的绘制需要绘制一个路径
</code></pre>
<h2 id="view的生命周期"><a href="#view的生命周期" class="headerlink" title="view的生命周期"></a>view的生命周期</h2><pre><code>1).initWithCoder
2).awakeFromNib: 此时frameh还没有完成。
2.手写代码：
1.initWithCoder
initWithFrame
view采用懒加载的方式，只有用到view时才会被创建，即才会被调用
loadView-&gt;viewDidLoad这一系列函数，控制器的View
是延迟加载的: 创建控制器并不一定会创建控制器的view,等用到时再加载。
</code></pre>
<h2 id="系统UIView更新机制的思想"><a href="#系统UIView更新机制的思想" class="headerlink" title="系统UIView更新机制的思想"></a>系统UIView更新机制的思想</h2><pre><code>UIView提供了layoutSubViews方法来处理。
需要注意的时layoutSubViews方法由系统来调用，不能程序员来调用。
可以调用setNeedsLayout方法进行标记,以保证在UI下个刷屏系统中会调用layoutSubviews。
或者layoutIfNedded直接请求系统调用layoutIfNeeded直接请求系统调用layoutSubviews。
layoutSubViews的被调用时机:
1.addSubView会触发layoutSubviews,比如ivewA add ViewB，
第一次添加A和B的layoutSubviews都会被调用，而第二次( viewA 已经有了viewB)只调用viewB的。
2.view的frame改变会触发layoutSubViews。
3.滚动一个UIScrollView会触发layoutSubviews。
4.旋转Screen会触发UIView的layoutSubviews。
5.改变transform属性时，当然frame也会变。
6.处于key window的UIView才会被调用( 程序同一时间只有一个window为keyWindow，
可以简单理解为显示在最前面的window的keywindow)
</code></pre>
<h2 id="drawRect常用作用"><a href="#drawRect常用作用" class="headerlink" title="drawRect常用作用"></a>drawRect常用作用</h2><pre><code>实际需求：1、在当前画板上画图像，曲线、虚线、几何图形、写字等等。

2、UITextView添加自定义placeholder的需求中，将holder的label添加在写drawRect内，设置holder字符串时调用setNeedsDisplay重绘UITextView。
</code></pre>
<h2 id="layoutSubView和drawRect的调用时机；"><a href="#layoutSubView和drawRect的调用时机；" class="headerlink" title="layoutSubView和drawRect的调用时机；"></a>layoutSubView和drawRect的调用时机；</h2><h2 id="用UIView实现Scrollview。"><a href="#用UIView实现Scrollview。" class="headerlink" title="用UIView实现Scrollview。"></a>用UIView实现Scrollview。</h2><pre><code>而子视图的frame正是基于父视图的坐标系，当我们更改父视图bounds中origin的
时候子视图的位置就发生了变化，这就是实现scrollView的关键点！！！
通过contentSize限制scrollView的内部空间，实现代码如下
</code></pre>
<h2 id="轮播图的实现"><a href="#轮播图的实现" class="headerlink" title="轮播图的实现"></a>轮播图的实现</h2><pre><code>基于collectionView进行的封装（推荐）
基于scrollView的无限轮播（首尾各多创建一个展示图片的ImageView）
同样是基于scrollView的无限轮播（总共就创建三个ImageView）
（答定时器，标志位判断，代理方法）
</code></pre>
<h2 id="CGSize-intrinsicContentSize-是干什么用的？"><a href="#CGSize-intrinsicContentSize-是干什么用的？" class="headerlink" title="-(CGSize)intrinsicContentSize:是干什么用的？"></a>-(CGSize)intrinsicContentSize:是干什么用的？</h2><pre><code>属性来获取内置大小
答：固有大小。顾名思义，在AutoLayout中，它作为UIView的属性（不是语法上的属性），
意思就是说我知道自己的大小，如果你没有为我指定大小，我就按照这个大小来。
</code></pre>
<h2 id="渲染UI为什么要在主线程？"><a href="#渲染UI为什么要在主线程？" class="headerlink" title="渲染UI为什么要在主线程？"></a>渲染UI为什么要在主线程？</h2><pre><code>因为UIKit框架不是线程安全的，所以涉及多个线程同时对UI进行操作会造成什么影响、
问题、错误，这里就不再赘述。那么，就有人会问为什么不把UIKit框架设置为线程安全呢？
因为线程安全需要加锁，我们都知道加锁就会消耗性能，影响处理速度，影响渲染速度，
我们通常自己在写@property时都会写nonatomic来追求高性能高效率。
而UI又是最追求速度流畅，体验无顿挫感的，给UI加锁是不可能的，这辈子都不可能的，
想要UI极度流畅，但线程安全又得不到保障，怎么办呢？
</code></pre>
<h2 id="如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？"><a href="#如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？" class="headerlink" title="如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？"></a>如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？</h2><pre><code>（答一般block里面回调的话，数据还是会回来的。但是，如果控制器销毁了的话，self置为nil，对nil的操作一般也是安全的，就是浪费了流量。）；
</code></pre>
<h2 id="scrollview与消息响应链冲突？"><a href="#scrollview与消息响应链冲突？" class="headerlink" title="scrollview与消息响应链冲突？"></a>scrollview与消息响应链冲突？</h2><pre><code>1、设置是否延时传递给内部组件
self.delaysContentTouches = NO;
设置返回值为YES
-(BOOL)touchesShouldCancelInContentView:(UIView *)view
&#123;
    [super touchesShouldCancelInContentView:view];
    return YES;
&#125;
同时识别多个手势
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
自定义手势
</code></pre>
<h2 id="Core-Graphics的更底层的是什么；"><a href="#Core-Graphics的更底层的是什么；" class="headerlink" title="Core Graphics的更底层的是什么；"></a>Core Graphics的更底层的是什么；</h2><pre><code>　1）获取上下文
　2）绘制路径
　3）添加路径到上下文
　4）修改图形状态参数
　5）渲染上下文
　CGContextRef、CGPathRef、UIBezierPath
</code></pre>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><pre><code>指针指对象的地址，引用是对象的引用计数
指针调用和函数调用
原因：调用函数的时候，由于runtime机制，通过方法objc_msgSend() 把函数的调用对象和方法名发送出去
根据对象名找到对象类存储的函数函数列表MethordList,再根据方法名找到MethordList 中的函数指针method_imp，再根据函数指针调用响应函数
</code></pre>
<h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><pre><code>内存泄漏（memory leak）：是指申请的内存空间使用完毕之后未回收。
一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，
最终导致程序crash。（因此，开发中我们要尽量避免内存泄漏的出现）
内存溢出（out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用。
通俗理解就是内存不够用了，通常在运行大型应用或游戏时，应用或游戏所需要
的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。最终导致机器重启或者程序crash。
第一种：静态分析方法（Analyze）
第二种：动态分析方法（Instrument工具库里的Leaks）。一般推荐使用第二种。
</code></pre>
<h2 id="什么是虚拟内存、共享内存、物理内存"><a href="#什么是虚拟内存、共享内存、物理内存" class="headerlink" title="什么是虚拟内存、共享内存、物理内存"></a>什么是虚拟内存、共享内存、物理内存</h2><pre><code>物理内存就是实打实的存放数据的硬件，
虚拟内存是在物理内存上的一层与具体硬件无关的抽象
共享内存：进程在运行过程中，会加载许多操作系统的动态库，比如 libc.so、libld.so等。
这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。
</code></pre>
<h2 id="举例一些I-O操作的例子"><a href="#举例一些I-O操作的例子" class="headerlink" title="举例一些I/O操作的例子"></a>举例一些I/O操作的例子</h2><pre><code>1）阻塞IO
2）非阻塞IO
3）IO复用（select和poll）
4）信号驱动IO（sigio）
5）异步IO（aio_）
</code></pre>
<h2 id="如何开辟一块内存；"><a href="#如何开辟一块内存；" class="headerlink" title="如何开辟一块内存；"></a>如何开辟一块内存；</h2><pre><code>其实结论就是 实际分配内存是按照16字节对齐的 内存大小都是16 的倍数。
</code></pre>
<h2 id="什么时候深复制，什么时候浅复制；"><a href="#什么时候深复制，什么时候浅复制；" class="headerlink" title="什么时候深复制，什么时候浅复制；"></a>什么时候深复制，什么时候浅复制；</h2><pre><code>string 是拷贝的（指针）
copy是内容的复制。
不可变对象用浅复制。
可变对象用深复制
自定义对象的copy我们要实现NSCoding协议
</code></pre>
<h2 id="怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手"><a href="#怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手" class="headerlink" title="怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手"></a>怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手</h2><pre><code>（答 检查是否有野指针,检查是否有循环引用,优化数组存取等）；
复用机制
少使用xib
不要阻塞线程
图片优化
合理使用数组字典优化查找速度
懒加载
缓存
一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。可以用单例来处理，避免日期格式转换
选择正确的数据格式，json、xml、二进制数据流
少使用webView
优化tableView
选择正确的数据持久化
</code></pre>
<h2 id="问堆和栈的区别。"><a href="#问堆和栈的区别。" class="headerlink" title="问堆和栈的区别。"></a>问堆和栈的区别。</h2><pre><code>（答对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。）
</code></pre>
<h2 id="Block的创建，何时被释放。"><a href="#Block的创建，何时被释放。" class="headerlink" title="Block的创建，何时被释放。"></a>Block的创建，何时被释放。</h2><pre><code>（答Block在栈区创建，用copy从栈区拷贝到堆区保证安全，由系统回收，何时回收）；
如果没有其他对象强引用，block执行完毕就会被释
</code></pre>
<h2 id="dynamic的应用场景？"><a href="#dynamic的应用场景？" class="headerlink" title="@dynamic的应用场景？"></a>@dynamic的应用场景？</h2><pre><code>@dynamic 就是要来告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会
在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译。其主要的作用就是
用在NSManageObject对象的属性声明上，由于此类对象的属性一般是从Core Data
的属性中生成的，Core Data框架会在程序运行的时候为此类属性生成getter和Setter方法。
</code></pre>
<h2 id="问题：-property-copy-NSMutableArray-array"><a href="#问题：-property-copy-NSMutableArray-array" class="headerlink" title="问题：@property (copy) NSMutableArray *array;"></a>问题：@property (copy) NSMutableArray *array;</h2><pre><code>答1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩
溃.因为copy就是复制一个不可变NSArray的对象；
2、使用了atomic属性会影响性能。
</code></pre>
<h1 id="OC语言相关"><a href="#OC语言相关" class="headerlink" title="OC语言相关"></a>OC语言相关</h1><h2 id="blcok，NSNotification，delegate，Observer比较"><a href="#blcok，NSNotification，delegate，Observer比较" class="headerlink" title="blcok，NSNotification，delegate，Observer比较"></a>blcok，NSNotification，delegate，Observer比较</h2><pre><code>代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知；
效率：Delegate比NSNOtification高；
Delegate和Block一般是一对一的通信；
Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信；
Block：Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate；
</code></pre>
<h2 id="const-extern-static-用法区别"><a href="#const-extern-static-用法区别" class="headerlink" title="const extern static 用法区别"></a>const extern static 用法区别</h2><pre><code>只要使用static修改局部变量之后, 当执行到定义局部变量的代码就会
分配存储空间, 但是只有程序结束才会释放该存储空间
extern：此变量/函数是在别处定义的，要在此处引用
</code></pre>
<h2 id="写一个宏定义函数，实现返回三个数中最大的"><a href="#写一个宏定义函数，实现返回三个数中最大的" class="headerlink" title="写一个宏定义函数，实现返回三个数中最大的"></a>写一个宏定义函数，实现返回三个数中最大的</h2><pre><code>#define MAX(a,b,c) (a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c))
</code></pre>
<h2 id="static和extern的访问范围，用extern的情况下什么时候程序会报错"><a href="#static和extern的访问范围，用extern的情况下什么时候程序会报错" class="headerlink" title="static和extern的访问范围，用extern的情况下什么时候程序会报错"></a>static和extern的访问范围，用extern的情况下什么时候程序会报错</h2><pre><code>静态变量用static修饰，其目的是声明一个变量只能被此文件里的函数享有。因而它的主要工作就是防止变量被外部函数使用
extern存储类型的目的却是允许几个源文件可以共享同一个变量
编译器当然不会答应他俩修饰同一个变量。
</code></pre>
<h2 id="inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？"><a href="#inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？" class="headerlink" title="inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？"></a>inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？</h2><pre><code>避免了频繁调用函数对栈内存重复开辟所带来的消耗
inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，
它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。
</code></pre>
<h2 id="OC里的基本数据类型如数组字典等的数据结构是怎样的；"><a href="#OC里的基本数据类型如数组字典等的数据结构是怎样的；" class="headerlink" title="OC里的基本数据类型如数组字典等的数据结构是怎样的；"></a>OC里的基本数据类型如数组字典等的数据结构是怎样的；</h2><pre><code>数组字典都是使用工厂方法创建的，根据不同数据，生成类不同
字典本质上是一个hash表，根据字典的key进行哈希取位置
开放定址法的结构通常允许在通列表的数量达到了某个阈值，通常是通列表长度的80%使用量
时，对通列表进行一次扩充grow，然后重新计算数据的keyHash放入新桶中
但是不断扩容的空间就是其弊端，因此开放地址法最好存储的是临时需要，尽快释放的资源
例如字典参数和associated object，拉链法就保证了资源的可控性，像这种@synchronized
锁就可以根据地址拉链出一条对应的使用线程即可，随时使用。
正如你会猜测的，__NSArrayM 用了环形缓冲区 (circular buffer)。这个数据结构相当简单，
只是比常规数组或缓冲区复杂点。环形缓冲区的内容能在到达任意一端时绕向另一端。
环形缓冲区有一些非常酷的属性。尤其是，除非缓冲区满了，否则在任意一端插入
或删除均不会要求移动任何内存。我们来分析这个类如何充分利用环形缓冲区来使得自身比 C
数组强大得多。在任意一端插入或者删除，只是修改offset参数，不需要移动内存，我们访问的时
候只是不和普通的数组一样index多少就是多少，这里会计算加上offset之后处理的值取数据，而不
是插入头和尾巴的时候，环形结构会根据最少移动内存指针的方式插入，例如要在A和B之间插入，按照
C的数组，我们需要把B到E的元素移动内存，但是环形缓冲区的设计，我们只要把A的值向前移动一
个单位内存，即可，同时修改offset偏移量，就能保证最小的移动单元来完成中间插入
可以看到插入头尾只是修改offset指针而已，如果插入数据到达阀值，一样需要扩容。
往中部插入对象有非常相似的结果。合理的解释就是，__NSArrayM 试着去最
小化内存的移动，因此会移动最少的一边元素。
</code></pre>
<h2 id="sychronized实现原理"><a href="#sychronized实现原理" class="headerlink" title="sychronized实现原理"></a>sychronized实现原理</h2><pre><code>你调用 sychronized 的每个对象，Objective-C runtime 都会为其分配一个递归锁并存储在哈希表中。
如果在 sychronized 内部对象被释放或被设为 nil 看起来都 OK。不过这没在文档中说明，所以我不会再生产代码中依赖这条。
注意不要向你的 sychronized block 传入 nil！这将会从代码中移走线程安全。
你可以通过在 objc_sync_nil 上加断点来查看是否发生了这样的事情。
</code></pre>
<h2 id="问NSTimer的底层实现原理"><a href="#问NSTimer的底层实现原理" class="headerlink" title="问NSTimer的底层实现原理"></a>问NSTimer的底层实现原理</h2><pre><code>NSTimer可以选择是否重复执行，为了保证NSTimer调用的方法中传递的
对象生命周期，NSTimer会对外界传递的对象进行一次retain。
进行invalidate，NSTimer才会消失，这时Object对象也就会释放了
NSTimer会默认为我们添加到Runloop的NSDefaultRunLoopMode中，而
且由于是在主线程中，所以Runloop是开启的，不需要我们手动打开
</code></pre>
<h2 id="block中为什么要用Strong类型的引用来保持self；"><a href="#block中为什么要用Strong类型的引用来保持self；" class="headerlink" title="block中为什么要用Strong类型的引用来保持self；"></a>block中为什么要用Strong类型的引用来保持self；</h2><pre><code>确保strongSelf在block中不会被释放。
</code></pre>
<h2 id="问-ifdef-cplusplus-extern-“C-“"><a href="#问-ifdef-cplusplus-extern-“C-“" class="headerlink" title="问#ifdef __cplusplus extern “C “"></a>问#ifdef __cplusplus extern “C “</h2><pre><code>&#123; #endif………… …………#ifdef __cplusplus &#125; #endif这段代码为什么总是会出现
答：编译器判断是否支持c++，涉及到c++命名问题，如果是c++编译器，要加上extern &quot;C&quot;
</code></pre>
<h2 id="说下ASCII和unicode的区别utf-8的优势"><a href="#说下ASCII和unicode的区别utf-8的优势" class="headerlink" title="说下ASCII和unicode的区别utf-8的优势"></a>说下ASCII和unicode的区别utf-8的优势</h2><pre><code>ASCII 码一共规定了128个字符的编码
Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号
UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节
表示一个符号，根据不同的符号而变化字节长度。
</code></pre>
<h2 id="iOS-launchwith-options-返回no有什么作用；"><a href="#iOS-launchwith-options-返回no有什么作用；" class="headerlink" title="iOS launchwith options 返回no有什么作用；"></a>iOS launchwith options 返回no有什么作用；</h2><pre><code> application:openURL:options: 方法是否执行
 当 return YES 时执行，return NO 时不执行
</code></pre>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="CommonMode的特性"><a href="#CommonMode的特性" class="headerlink" title="CommonMode的特性"></a>CommonMode的特性</h2><pre><code>1. 首先runloop对象到自己的common modes里面拿出被标记的运行模式commonModes.
2. 匹配commonModes和modes-&gt;model-&gt;name.
3. 匹配成功的模式，将timer加入到对应model-&gt;timers里面.
4. source, observer同timer.
</code></pre>
<h2 id="runloop与autoreleasepool的关系"><a href="#runloop与autoreleasepool的关系" class="headerlink" title="runloop与autoreleasepool的关系"></a>runloop与autoreleasepool的关系</h2><pre><code>(AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组成)
AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），
除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址
iOS里的TaggedPointer不适用autorelesepool
AutoreleasePool 在 runloop 在开始时被push，在runloop休眠时(beforewaiting状态)pop
</code></pre>
<h2 id="GCD-在Runloop中的使用"><a href="#GCD-在Runloop中的使用" class="headerlink" title="GCD 在Runloop中的使用"></a>GCD 在Runloop中的使用</h2><pre><code>GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。
</code></pre>
<h2 id="GCD-Global队列创建线程进行耗时操作的风险"><a href="#GCD-Global队列创建线程进行耗时操作的风险" class="headerlink" title="GCD Global队列创建线程进行耗时操作的风险"></a>GCD Global队列创建线程进行耗时操作的风险</h2><pre><code>dispatch_async 函数分发到全局队列不一定会新建线程执行任务，全局队列底层有一个的线程池，如果线程池满了，
那么后续的任务会被 block 住，等待前面的任务执行完成，才会继续执行。如果线程池中的线程
长时间不结束，后续堆积的任务会越来越多，此时就会存在 APP crash的风险。
避免使用 GCD Global 队列创建 Runloop 常驻线程
</code></pre>
<h2 id="CADispalyTimer和Timer哪个更精确"><a href="#CADispalyTimer和Timer哪个更精确" class="headerlink" title="CADispalyTimer和Timer哪个更精确"></a>CADispalyTimer和Timer哪个更精确</h2><pre><code>CADisplayLink 更精确
iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。
CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视
频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可
以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的
好处就是我们不需要在格外关心屏幕的刷新
频率了，因为它本身就是跟屏幕刷新同步的。
</code></pre>
<h2 id="怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"><a href="#怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作" class="headerlink" title="怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"></a>怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作</h2><pre><code>我们就可以将更新UI事件放在主线程的NSDefaultRunLoopMode上执行即可，这样
就会等用户不再滑动页面，主线程RunLoop由UITrackingRunLoopMode切
换到NSDefaultRunLoopMode时再去更新UI
</code></pre>
<h2 id="分析线程同步串行、同步并行、异步串行、异步并行问题"><a href="#分析线程同步串行、同步并行、异步串行、异步并行问题" class="headerlink" title="分析线程同步串行、同步并行、异步串行、异步并行问题"></a>分析线程同步串行、同步并行、异步串行、异步并行问题</h2><h2 id="GCD执行原理、问题分析"><a href="#GCD执行原理、问题分析" class="headerlink" title="GCD执行原理、问题分析"></a>GCD执行原理、问题分析</h2><pre><code>GCD底层有一个线程池，这个线程池存放的是一个个的线程，这个线程池中
的线程可以重用，当一段时间这个线程没有被调用就会被销毁，
开辟多少线程不是由同步异步决定的而是底层线程池决定的，线程池是系统维护，
</code></pre>
<h2 id="dispatch-once如何实现一次性代码"><a href="#dispatch-once如何实现一次性代码" class="headerlink" title="dispatch_once如何实现一次性代码"></a>dispatch_once如何实现一次性代码</h2><pre><code>定义一个dispatch_once_t(其实也就是整型)静态变量，
意义：作为标识下面dispatch_once的block是否已执行过。
 static修饰会默认将其初始化为0，当值为0时才会执行block。
 当block执行完成，底层会将onceToken设置为1，这也就是为什
 么要传onceToken的地址（static修饰的变量可以通过地址修改
 onceToken的值），同时底层会加锁来保证这个方法是线程安全的
</code></pre>
<h2 id="NSOperation数据结构"><a href="#NSOperation数据结构" class="headerlink" title="NSOperation数据结构"></a>NSOperation数据结构</h2><pre><code>addDependency操作依赖性
KVO 兼容属性
cancelAllOperations 响应取消命令
start;执行操作
NSBlockOperation：用于管理一个或多个block的并发执行。
NSInvocationOperation：NSInvocationOperation类是NSOperation的一个具体
子类，用于开启一个操作，该操作包括在指定对象上调用一个selector。
</code></pre>
<h2 id="重写NSOperation需要注意的点"><a href="#重写NSOperation需要注意的点" class="headerlink" title="重写NSOperation需要注意的点"></a>重写NSOperation需要注意的点</h2><pre><code>1、如果需要自定义并发执行的 Operation，必须重写start、main、isExecuting、isFinished、isAsynchronous方法。
2、在 operation 的 main 方法里面，必须提供 autorelease pool,因为你的 operation 完成后需要销毁。
3、一旦你的 operation 开始了，必须通过 KVO，告诉所有的监听者，现在该operation的执行状态。
4、调用时，如果需要并发执行 Operation，必须调用performOperation:方法，当然，也可以改为自定义其他方法或者直接在start方法添加多线程调用。
5、对于自定义的 Operation 类，如果不需要并发执行，可以直接调用start
</code></pre>
<h2 id="进程中的哪些空间是线程所共有的？"><a href="#进程中的哪些空间是线程所共有的？" class="headerlink" title="进程中的哪些空间是线程所共有的？"></a>进程中的哪些空间是线程所共有的？</h2><pre><code>一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)
</code></pre>
<h2 id="使用GCD需要注意什么；"><a href="#使用GCD需要注意什么；" class="headerlink" title="使用GCD需要注意什么；"></a>使用GCD需要注意什么；</h2><pre><code>dispatch_sync同步死锁（循环等待）
重复的获取互斥资源引发的等待（加锁）
开启过多线程
线程和RunLoop，子线程不会开启runloop
</code></pre>
<h2 id="runloop跟runtime有没有关联"><a href="#runloop跟runtime有没有关联" class="headerlink" title="runloop跟runtime有没有关联"></a>runloop跟runtime有没有关联</h2><pre><code>个人想到的是autoreleasepool、其他的不好找
runloop中事件源都是由运行时runtime触发
</code></pre>
<h2 id="CPU和GPU怎么相互合作的"><a href="#CPU和GPU怎么相互合作的" class="headerlink" title="CPU和GPU怎么相互合作的"></a>CPU和GPU怎么相互合作的</h2><pre><code>命令缓冲区包含了一个命令队列，由CPU向其中添加命令，而由GPU从中读取命令
，添加和读取的过程是互相独立的。命令缓冲区使得CPU和GPU可以互相独立工作
。当CPU需要渲染一些对象时，它可以向命令缓冲区中添加命令，而当GPU完成了上
一次的渲染任务后，它就可以从命令队列中再取出一个命令并执行它。
</code></pre>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP请求头都有哪些内容"><a href="#HTTP请求头都有哪些内容" class="headerlink" title="HTTP请求头都有哪些内容"></a>HTTP请求头都有哪些内容</h2><pre><code>Accept: */*(客户端能接收的资源类型) 
Accept-Language: en-us(客户端接收的语言类型) 
Connection: Keep-Alive(维护客户端和服务端的连接关系) 
Host: localhost:8080(连接的目标主机和端口号) 
Referer: http://localhost/links.asp(告诉服务器我来自于哪里) 
User-Agent: Mozilla/4.0(客户端版本号的名字) 
Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) 
If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  
Cookie(客户端暂存服务端的信息) 
Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间
响应(服务端-&gt;客户端[response])
HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)
Location: http://www.baidu.com(服务端需要客户端访问的页面路径) 
Server:apache tomcat(服务端的Web服务端名)
Content-Encoding: gzip(服务端能够发送压缩编码类型) 
Content-Length: 80(服务端发送的压缩数据的长度) 
Content-Language: zh-cn(服务端发送的语言类型) 
Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)
Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)
Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)
Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)
Transfer-Encoding: chunked(分块传递数据到客户端）  
Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)
Expires: -1//3种(服务端禁止客户端缓存页面数据)
Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  
Pragma: no-cache(服务端禁止客户端缓存页面数据)   
Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  
Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)
</code></pre>
<h2 id="哪些加密算法"><a href="#哪些加密算法" class="headerlink" title="哪些加密算法"></a>哪些加密算法</h2><pre><code>MD5加密算法
RSA加密算法
AES加密算法
Base64加密算法
</code></pre>
<h2 id="TCP和UDP各自使用场景"><a href="#TCP和UDP各自使用场景" class="headerlink" title="TCP和UDP各自使用场景"></a>TCP和UDP各自使用场景</h2><pre><code>TCP应用场景：
效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认
、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输
（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
UDP应用场景：
效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、
在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题
，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。
</code></pre>
<h2 id="http为什么底层是tcp不是udp"><a href="#http为什么底层是tcp不是udp" class="headerlink" title="http为什么底层是tcp不是udp ?"></a>http为什么底层是tcp不是udp ?</h2><pre><code>tcp协议比udp更安全（结合tcp的特点讲）
</code></pre>
<h2 id="socket异常断开时，设计一个合理的重连机制。"><a href="#socket异常断开时，设计一个合理的重连机制。" class="headerlink" title="socket异常断开时，设计一个合理的重连机制。"></a>socket异常断开时，设计一个合理的重连机制。</h2><pre><code>当与服务器断开连接或网络出错时，先不要处理当前正在连接的socket，可能回应下当前UI的数据显示问题；
可以另起一个socket服务，与服务器尝试连接，当连接成功时，通知当前Socket进行重新连接
每六秒连接一次如果30秒仍未连接上则通知UI掉线，之后仍然继续连接，知道连接上为止
</code></pre>
<h2 id="有了mac地址为什么要有ip地址"><a href="#有了mac地址为什么要有ip地址" class="headerlink" title="有了mac地址为什么要有ip地址"></a>有了mac地址为什么要有ip地址</h2><pre><code>mac地址与我们的设备进行绑定，就能确定我们身份。其实MAC地址，并不能算是地址，更应该算是一个身份证，用来表明身份。
只拥有MAC地址的话，只有在同一网络区域内，才能进行数据传输，不能跨网络区域。
如果想跨网络区域进行数据传递，最现实的方法就是借助ISP提供的网络区域。
ISP能提供全球互联的网络——因特网，借助因特网可以传输数据给连接因特网上的机器。
</code></pre>
<h2 id="断点续传怎么实现"><a href="#断点续传怎么实现" class="headerlink" title="断点续传怎么实现;"></a>断点续传怎么实现;</h2><pre><code>续传的文件就好说了，只要给一个续传的标识位置，和对应的字节流就可以了，代码如下:
filePath:生成的文件,用来续传用
content:将要写入的字节
position:续传的字节位置
</code></pre>
<h2 id="大型文件怎么下载并保存到本地；"><a href="#大型文件怎么下载并保存到本地；" class="headerlink" title="大型文件怎么下载并保存到本地；"></a>大型文件怎么下载并保存到本地；</h2><pre><code>大型文件压缩、分割成小份文件
</code></pre>
<h2 id="xml和json的区别"><a href="#xml和json的区别" class="headerlink" title="xml和json的区别"></a>xml和json的区别</h2><pre><code>1，xml是重量级的，json是轻量级的。
2，xml在传输过程中比较占带宽，json占带宽少，易于压缩。
3，xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。
4，json可用jackson，gson等方法解析，xml可用dom，sax，demo4j等方式解析。
</code></pre>
<h2 id="加密解密的技术讲解。"><a href="#加密解密的技术讲解。" class="headerlink" title="加密解密的技术讲解。"></a>加密解密的技术讲解。</h2><pre><code>（密解密就是是base64加密、POST加密、MD5加密、时间戳密码等等）
</code></pre>
<h2 id="reachability如何检测到网络状态变化？"><a href="#reachability如何检测到网络状态变化？" class="headerlink" title="reachability如何检测到网络状态变化？"></a>reachability如何检测到网络状态变化？</h2><pre><code>Reachability 是苹果官方提供的示例源码，它是对 SystemConfiguration.framework 
模块中的 SCNetworkReachability.h 头文件里提供的一系列网络连接状态相关的 C 函数进行简单封装
Reachability 中提供了三个快速初始化方法，分别为
reachabilityWithHostName:、reachabilityWithAddress: 和 reachabilityForInternetConnection。
通过上述初始化方法获得一个 Reachability 对象后，可调用 startNotifier 方法开始进行网络状态变化的监听
</code></pre>
<h2 id="IP-地址用-int-保存和读取转化"><a href="#IP-地址用-int-保存和读取转化" class="headerlink" title="IP 地址用 int 保存和读取转化"></a>IP 地址用 int 保存和读取转化</h2><pre><code>/**
     * 根据位运算把 byte[] -&gt; int
     * @param bytes
     * @return int
     */
    public static int bytesToInt(byte[] bytes) &#123;
        int addr = bytes[3] &amp; 0xFF;
        addr |= ((bytes[2] &lt;&lt; 8) &amp; 0xFF00);
        addr |= ((bytes[1] &lt;&lt; 16) &amp; 0xFF0000);
        addr |= ((bytes[0] &lt;&lt; 24) &amp; 0xFF000000);
        return addr;
    &#125;
</code></pre>
<h1 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h1><h2 id="instruments它为什么能检测内存泄漏"><a href="#instruments它为什么能检测内存泄漏" class="headerlink" title="instruments它为什么能检测内存泄漏"></a>instruments它为什么能检测内存泄漏</h2><pre><code>Activity Monitor（活动监视器）：监控进程的CPU,内存,磁盘，网络使用情况 是程序在手机运行真正占用的内存大小
Cocoa Layout 观察NSLayoutConstraint对象的改变，帮助我们判断什么时间什么地点的constraint是否合理
Energy Log  耗电量监控
Leaks（泄漏）：一般的措施内存使用情况，检查泄漏的内存，并提供了所有活动的分
配和泄漏模块的类对象分配统计信息以及内存地址历史记录；
Core Animation（图形性能）这个模块显示程序显卡性能以及CPU使用情况
Network 用链接工具分析你的程序如何使用TCP/IP和UDP/IP链接
</code></pre>
<h2 id="推送的原理"><a href="#推送的原理" class="headerlink" title="推送的原理"></a>推送的原理</h2><pre><code>1.由App向iOS设备发送一个注册通知，用户需要同意系统发送推送。
2.iOS向APNs远程推送服务器发送App的Bundle Id和设备的UDID。
3.APNs根据设备的UDID和App的Bundle Id生成deviceToken再发回给App。
4.App再将deviceToken发送给远程推送服务器(自己的服务器), 由服务器保存在数据库中。
5.当自己的服务器想发送推送时, 在远程推送服务器中输入要发送的消息并选择发给哪些用户的deviceToken，由远程推送服务器发送给APNs。
6.APNs根据deviceToken发送给对应的用户。
</code></pre>
<h2 id="项目上线被拒原因"><a href="#项目上线被拒原因" class="headerlink" title="项目上线被拒原因"></a>项目上线被拒原因</h2><pre><code>设计类型的问题，图标、UI等
app类型设置不准确
第三方资源用到广告等资源
</code></pre>
<h2 id="项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线"><a href="#项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线" class="headerlink" title="项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线"></a>项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线</h2><pre><code>加载大图，内存崩溃
时间戳问题
复杂页面的设计
页面之间交互
</code></pre>
<h2 id="iPhone自带的AssistiveTouch你如何实现"><a href="#iPhone自带的AssistiveTouch你如何实现" class="headerlink" title="iPhone自带的AssistiveTouch你如何实现"></a>iPhone自带的AssistiveTouch你如何实现</h2><pre><code>UIWindow进行实现；
层级UIWindowLevelAlert + 1
</code></pre>
<h2 id="有了解过代码如何编译的嘛"><a href="#有了解过代码如何编译的嘛" class="headerlink" title="有了解过代码如何编译的嘛"></a>有了解过代码如何编译的嘛</h2><pre><code>LLVM编译一个源文件的过程：预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt; 
AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件
</code></pre>
<h2 id="编译好的目标文件有data-和text段他们两者有啥区别"><a href="#编译好的目标文件有data-和text段他们两者有啥区别" class="headerlink" title="编译好的目标文件有data 和text段他们两者有啥区别"></a>编译好的目标文件有data 和text段他们两者有啥区别</h2><pre><code>text段: 用于存放程序代码的区域， 编译时确定， 只读。
data段 :用于存放在编译阶段(而非运行时)就能确定的数据，可读可写。也是通常
所说的静态存储区，赋了初值的全局变量、常量和静态变量都存放在这个域。
</code></pre>
<h2 id="appstore上架流程"><a href="#appstore上架流程" class="headerlink" title="appstore上架流程"></a>appstore上架流程</h2><pre><code>1.申请开发者账号
2.创建开发者证书
3.创建项目app id
4.添加测试设备
5.生成描述文件
6.itnues connect创建项目
7.上传app
8.提交以供审核
</code></pre>
<h2 id="一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ"><a href="#一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ" class="headerlink" title="一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ;"></a>一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ;</h2><pre><code>微信自己添加应用白名单，自己app通过k能否打开微信定义的url来判断用户是否安装
</code></pre>
<h2 id="针对线上版本的崩溃处理；"><a href="#针对线上版本的崩溃处理；" class="headerlink" title="针对线上版本的崩溃处理；"></a>针对线上版本的崩溃处理；</h2><pre><code>UIKit不是线程安全的，执行UIKit操作如果不在主线程很可能造成程序Crash
KVO
避免 Foundation 类Carsh
容器越界（NSArray， NSDictionary,...）
unrecognized selector crash (这个很多时候是由于class使用错误导致)
第三方工具：友盟
dSYMTools分析
</code></pre>
<h2 id="Xcode构建过程；"><a href="#Xcode构建过程；" class="headerlink" title="Xcode构建过程；"></a>Xcode构建过程；</h2><pre><code>解析项目文件，获取你项目中的所有文件、target 及其依赖关系、build settings，最后把它变成一个树形结构(有向图)。
增量构建。
</code></pre>
<h2 id="js和Oc交互以及区别；"><a href="#js和Oc交互以及区别；" class="headerlink" title="js和Oc交互以及区别；"></a>js和Oc交互以及区别；</h2><pre><code>js调用oc、oc调用js、通过javaSpritCore实现，JavascriptBridge
</code></pre>
<h2 id="pod-install和pod-update有什么区别？"><a href="#pod-install和pod-update有什么区别？" class="headerlink" title="pod install和pod update有什么区别？"></a>pod install和pod update有什么区别？</h2><pre><code>pod install:执行该命令时，如果Podfile.lock文件存在, 则
直接从此文件中读取框架信息并且它会只下载Podfile.lock
文件中指定的版本安装。对于不在Podfile.lock文件中的pod库，pod
install命令会搜索这个pod库在Podfile文件中指定的版本来安装
pod update:只有当你想要更新pod库的版本时才使用pod update；它
不管Podfile.lock是否存在, 都会读取Podfile文件的的框架信息去下载安装
，下载好之后, 再根据下载好的框架信息, 生成Podfile.lock文件
</code></pre>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="为什么要做组件化"><a href="#为什么要做组件化" class="headerlink" title="为什么要做组件化"></a>为什么要做组件化</h2><pre><code>随着app业务发展过程中体积越来越大，堆叠大量的业务逻辑，不同业务之间相互调用，相互嵌套
代码之间的耦合性越来越高，不方便维护
</code></pre>
<h2 id="你认为组件化的一些收益"><a href="#你认为组件化的一些收益" class="headerlink" title="你认为组件化的一些收益"></a>你认为组件化的一些收益</h2><pre><code>解耦合
分工更加明确，提高开发效率
复用性更好，能迅速的组成更多的App
</code></pre>
<h2 id="redux-单向数据流是怎么产生的-描述下"><a href="#redux-单向数据流是怎么产生的-描述下" class="headerlink" title="redux 单向数据流是怎么产生的 描述下"></a>redux 单向数据流是怎么产生的 描述下</h2><h2 id="Charts框架底层实现；"><a href="#Charts框架底层实现；" class="headerlink" title="Charts框架底层实现；"></a>Charts框架底层实现；</h2><pre><code>通过CoreGraphics绘制的，数据模型。不如js方便美观
</code></pre>
<h2 id="画出项目的结构图。"><a href="#画出项目的结构图。" class="headerlink" title="画出项目的结构图。"></a>画出项目的结构图。</h2><pre><code>Fundation 基础资源（配置信息、基础分类、宏、工具集合）
Map 地图资源（地图单例对象）
Navi 导航资源 （导航页面控制器相关全部）
Net 网络资源 （业务层对应的网络、测试网、线网、版本）
Lib 图片、第三方资源 
App 业务层 （主页、我的、poi、路线规划）
</code></pre>
<h2 id="yyModel的逻辑"><a href="#yyModel的逻辑" class="headerlink" title="yyModel的逻辑"></a>yyModel的逻辑</h2><pre><code>（YYModel的核心是通过runtime获取结构体中得Ivars的值，
将此值定义为key,然后给key赋value值，所以我们需要自己遍历容器
（NSArray，NSSet，NSDictionary），获取每一个值，然后KVC进行处理）。
</code></pre>
<h2 id="解耦的方式"><a href="#解耦的方式" class="headerlink" title="解耦的方式"></a>解耦的方式</h2><pre><code>1、组件化
2、结合MVVM架构和数据驱动UI模式对原有MVC架构进行了兼容性优化
3、通过AOP技术对部分业务进行拆分解耦
4、优化事件传递方式
</code></pre>
<h2 id="项目中用的技术以及实现；"><a href="#项目中用的技术以及实现；" class="headerlink" title="项目中用的技术以及实现；"></a>项目中用的技术以及实现；</h2><pre><code>1.复杂cell提前缓存行高和UI的frame
2.网络请求库的封装
3.组建化简单实现
4.tableView嵌套滑动
5.地图对象的单例封装
6.用View代替ViewController的实现
7.定时器使用
</code></pre>
<h2 id="就是项目中遇到的问题以及解决方式；"><a href="#就是项目中遇到的问题以及解决方式；" class="headerlink" title="就是项目中遇到的问题以及解决方式；"></a>就是项目中遇到的问题以及解决方式；</h2><h2 id="缓存机制是怎么清除数据的？"><a href="#缓存机制是怎么清除数据的？" class="headerlink" title="缓存机制是怎么清除数据的？"></a>缓存机制是怎么清除数据的？</h2><pre><code>沙盒：iOS系统为每一个应用程序创建一个文件目录,是一个的独立,封闭,安全的空间, 一个沙盒就是一个文件目录。沙盒规定了一个程序只能在自身的沙盒中进行操作,不能去访问其他应用程序的沙盒(iOS8已经部分开放访问)
沙盒的作用: 用来存放非代码文件(图片, 音频, 视频, 属性列表(plist), sqlite数据库, 文本文件, 其他等等)
</code></pre>
<h2 id="如何进行安全测试；"><a href="#如何进行安全测试；" class="headerlink" title="如何进行安全测试；"></a>如何进行安全测试；</h2><pre><code>ipa包加壳（苹果）
敏感信息存储位置
通讯网络安全
代码混淆
</code></pre>
<h2 id="涂鸦怎么实现；"><a href="#涂鸦怎么实现；" class="headerlink" title="涂鸦怎么实现；"></a>涂鸦怎么实现；</h2><pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
最终我们决定放弃 drawRect 而选用图层 CAShapeLayer。CAShapeLayer 不仅在功能上满足了我们的需求，对比之下 CAShapeLayer 在性能方面表现也非常出色。
</code></pre>
<h2 id="实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；"><a href="#实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；" class="headerlink" title="实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；"></a>实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；</h2><h2 id="说下生产者-消费者模型，其中的同步机制是怎么样的"><a href="#说下生产者-消费者模型，其中的同步机制是怎么样的" class="headerlink" title="说下生产者-消费者模型，其中的同步机制是怎么样的"></a>说下生产者-消费者模型，其中的同步机制是怎么样的</h2><pre><code>产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。
在生产者与消费者之间在加个缓冲区，我们形象的称之为仓库，生产
者负责往仓库了进商品，而消费者负责从仓库里拿商品，这就构成了生产者消费者模式。
//生产者消费者
   dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
   self.array = [[NSMutableArray alloc] init];
   dispatch_queue_t queue = dispatch_queue_create(&quot;cn.chutong.www&quot;, DISPATCH_QUEUE_CONCURRENT);
  //生产
   dispatch_async(queue, ^&#123;
       while (YES) &#123;
           int count = random()%10;
           sleep(1);
           dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
           [self.array addObject:[NSString stringWithFormat:@&quot;%d&quot;,count]];
           dispatch_semaphore_signal(semaphore);
           NSLog(@&quot;生产了%d&quot;,count);
       &#125;
   &#125;);
   //消费
   dispatch_async(queue, ^&#123;
       while (YES) &#123;
       if (self.array.count&gt;0) &#123;
           NSLog(@&quot;消费了%@&quot;,self.array.lastObject);
           dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
           [self.array removeLastObject];
           dispatch_semaphore_signal(semaphore);
       &#125;
           
       &#125;
   &#125;);
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift136%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift136%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:38" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:38+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.jishudog.com/8744/html">https://www.jishudog.com/8744/html</a><br>Tagged Pointer<br>所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。<br>所有类都继承自NSObject，因此每个对象都有一个isa指针指向它所属的类。在《ARM64 and You》文章中指出：在32位环境下，对象的引用计数都保存在一个外部的表中，<br>而对引用计数的增减操作都要先锁定这个表，操作完成后才解锁。这个效率是非常慢的。<br>而在64位环境下，isa也是64位，实际作为指针部分只用到的其中33位,剩余的部分会运用到Tagged Pointer的概念，其中19位将保存对象的引用计数，这样对引用计数的操作只需要原子的修改这个指针即可，<br>如果引用计数超出19位，才会将引用计数保存到外部表，而这种情况往往是很少的，因此效率将会大大提高。</p>
<p>1.Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate<br>2.Tagged Pointer指针的值不再是地址了，而是真正的值。<br>    实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。<br>    它的内存并不存储在堆中，也不需要malloc和free。<br>3.在内存读取上有着3倍的效率，创建时比以前快106倍。<br>4.它不单单是一个指针，还包括了其值+类型</p>
<p>dispatch_queue_t queue = dispatch_queue_create(“queue”, DISPATCH_QUEUE_CONCURRENT);<br>   for (int i = 0; i &lt; 1000; i ++) {<br>       dispatch_async(queue, ^{<br>           self.name = [NSString stringWithFormat:@”abcdefghijklmn”];<br>       });<br>   }<br>运行结果：崩溃（坏内存访问）<br>因为setter方法中，对strong修饰的属性会有一个retain和release的操作。在并发多线程的赋值操作中，都是对_name指针进行的操作，可能在_name刚刚被release后进行赋值操作，这个时候_name指向的内存地址是已经被释放了，所以造成了坏内存访问崩溃<br>解决办法：<br>1.异步改同步<br>2.将属性改成原子性<br>3.加锁</p>
<p>dispatch_queue_t queue = dispatch_queue_create(“queue”, DISPATCH_QUEUE_CONCURRENT);<br>for (int i = 0; i &lt; 1000; i ++) {<br>    dispatch_async(queue, ^{<br>        self.name = [NSString stringWithFormat:@”a”];<br>    });<br>}<br>为什么不崩溃了？因为没有用到引用计数的内存管理方法，使用的是TaggedPointer<br>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象存储</p>
<p>NONPOINTER_ISA<br> NONPOINTER_ISA在64位机上，对象的isa区域不再只是一个指向另一块存储空间的指针。还包含了更多信息，比如引用计数，析构状态，被其他weak 变量引用情况等。如果引用计数超过了当前指针所能表示的范围，Runtime 会使用一张散列表来管理用计数。<br>(union)，利用联合体可以用相同的存储空间存储不同型别的数据类型，从而节省内存空间<br> ARC：由LLVM和Runtime共同协作来进行自动引用计数的。<br>   uintptr_t nonpointer : 1;</p>
<p>         uintptr_t has_assoc : 1; // </p>
<p>         uintptr_t has_cxx_dtor : 1;</p>
<p>         uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000</p>
<p>         uintptr_t magic : 6;</p>
<p>         uintptr_t weakly_referenced : 1;</p>
<p>         uintptr_t deallocating : 1;</p>
<p>         uintptr_t has_sidetable_rc : 1;</p>
<p>         uintptr_t extra_rc : 19;</p>
<p> SideTables包括了多个SideTable，在不同系统架构中SideTable的个数是不同的；SideTables是哈希表，可以通过一个对象的指针来找到具体的引用计数表或弱引用表在哪一个具体的SideTable中。</p>
<p> 为什么用多个SideTable？ 如果只有一个table，意味着内存中分配的所有对象都要在一个表中操作，因为多个线程可能同时操作这个表，所以就要对这个表加锁，如果并发操作这个表的线程有成千上万个，就会产生效率问题。所以系统引入了分离锁这样一个技术方案，把大表拆成多个小表来进行操作，分别对小表加锁，从而提升效率。</p>
<p> 自旋锁：<br>                       自旋锁：是“忙等”的锁。由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则其他等待该自旋锁的线程会一直自旋，从而浪费CPU时间。</p>
<p>                        自旋锁适用于那些仅需要阻塞很短时间的场景。</p>
<p>dealloc -&gt; weak_clear_no_lock(从弱引用表中取出所有该对象的weak_entry_t对象，weak_entry_t里存放了weak_referrer_t数组，就是所有的弱引用，全部设为nil，然后再移除weak_entry_t对象)</p>
<p>Autoreleasepool的实现原理:</p>
<p>以栈为结点，由双向链表的形式合成的数据结构。<br>与线程一一对应。</p>
<p>Main函数自动添加了@autoreleasepool{}; 很多次循环的内部最好自己添加@autoreleasepool{},以及时释放其内部的临时对象。<br> 在当次runloop将要结束的时候调用AutoreleasePoolPage::pop()。<br>autoreleasePoolPage 数据结构<br>可在源码中查看<br>    id *next;<br>    pthread_t const thread;<br>    AutoreleasePoolPage * const parent;<br>    AutoreleasePoolPage *child;<br>    uint32_t const depth;</p>
<p>                        多层嵌套就是多次插入哨兵对象。</p>
<p>                        在for循环中alloc图片数据等内存消耗较大的场景手动插入autoreleasePool。<br>AutoreleasePool 为何可以嵌套使用</p>
<p>多层嵌套就是多次插入哨兵对象<br>,每次创建一个AutoreleasePool，@AutoreleasePool，其实系统就是为我们创建了一个哨兵对象,其实就是创建page，若果当前page没有满，其实就是创建一个哨兵，所以可以嵌套使用<br>中间用nil作为分割</p>
<p>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理？不手动处理会内存泄漏吗？<br>在子线程你创建了 Pool 的话，产生的 Autorelease 对象就会交给 pool 去管理。如果你没有创建 Pool ，但是产生了 Autorelease 对象，就会调用 autoreleaseNoPage 方法。在这个方法中，会自动帮你创建一个 hotpage（hotPage 可以理解为当前正在使用的 AutoreleasePoolPage，如果你还是不理解，可以先看看 Autoreleasepool 的源代码，再来看这个问题 ），并调用 page-&gt;add(obj)将对象添加到 AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！</p>
<p>将对象放入自动释放池不会引起引用计数+1</p>
<p>在for循环大量使用imageNamed:之类的方法生成UIImage对象可能是个更要命的事情，内存随时可能因为占用过多被系统杀掉。<br>这种情况下利用Autoreleasepool可以大幅度降低程序的内存占用。</p>
<p>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成（分别对应结构中的parent指针和child指针）<br>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）<br>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址<br>上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置<br>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</p>
<p>1.根据传入的哨兵对象地址找到哨兵对象所处的page<br>2.在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置<br>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page</p>
<p>黑魔法之Thread Local Storage</p>
<p>Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写，比如在非arm架构下，使用pthread提供的方法实现：</p>
<p>一 、dealloc 调用流程</p>
<p>1.首先调用 _objc_rootDealloc()</p>
<p>2.接下来调用 rootDealloc() </p>
<p>3. isTaggedPointer   是否是标记指针 是直接 return ;</p>
<p>  接下来会判断是否可以被直接快速释放，判断的依据主要有 5 个，判断是否有以下五种情况</p>
<p>nonpointer              是否优化过isa指针</p>
<p> weakly_reference  是否存在弱引用指向</p>
<p> has_assoc              是否设置过关联对象</p>
<p> has_cxx_dtor         是否有cpp的析构函数（.cxx_destruct）</p>
<p> has_sidetable_rc   引用计数器是否过大无法存储在isa中</p>
<p>二、object_dispose() 调用流程。</p>
<p>1.直接调用 objc_destructInstance()。</p>
<p>2.之后调用C的 free() 函数。</p>
<p>3.objc_destructInstance() 调用流程</p>
<p>1&gt;.先判断 hasCxxDtor，是否有析构函数（析构器），要调用 object_cxxDestruct() ，释放（清除成员变量）。</p>
<p>2&gt;.再判断hasAssocitatedObjects，如果有的话，要调用object_remove_associations()， 移除当前对象的关联对象。</p>
<p>3&gt;.然后调用 clearDeallocating()。 </p>
<p>4&gt;.执行完毕。</p>
<p>4.clearDeallocating() 调用流程<br>0&gt;. 判断isa是否优化过，从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，所以结果一般是优化过了。</p>
<p>判断是否有弱引用或者引用计数</p>
<p>1&gt;.执行 clearDeallocating_slow()。</p>
<p>2&gt;.再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。</p>
<p>3&gt;.接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。</p>
<p>4&gt;.至此为止，Dealloc 的执行流程结束。</p>
<p>如何破除循环引用</p>
<p>方式1:－－打断引用链条         方式2:－－使用__weak<br>NSTimer破除循环引用<br>weak指针：<br>既然是强引用导致循环引用，那么用__weak修饰self就好了，想法是对的，但是做法是无效的。<br>中间类，block<br>及时销毁<br>创建一个继承NSProxy的子类WeakProxy，并实现消息转发的相关方法<br>多次调用对象的autorelease方法会导致什么问题?<br>答：多次将地址存到自动释放池中,导致野指针异常<br>图片加载占用内存对比</p>
<p>使用 imageName: 加载图片：<br>加载到内存当中后，占据内存空间较大<br>相同的图片，图片不会重复加载<br>加载内存当中之后，会一直停留在内存当中，不会随着对象销毁而销毁<br>加载进去图片之后，占用的内存归系统管理，我们无法管理<br>使用 imageWithContentsOfFile: 加载图片<br>加载到内存当中后,占据内存空间较小<br>相同的图片会被重复加载内存当中<br>对象销毁的时候,加载到内存中图片会随着一起销毁<br>结论:<br>图片较小，并且使用频繁，使用 imageName: 来加载(按钮图标/主页里面图片)<br>图片较大，并且使用较少，使用 imageWithContentsOfFile: 来加载(版本新特性/相册)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift135%E6%88%AA%E5%9B%BE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift135%E6%88%AA%E5%9B%BE%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">截图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:33" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:33+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>class = objc_class -&gt;继承 objc_object<br>objc_class 内部：superClass ; cache; clss_data_bits_t bits</p>
<p>class_rw_t<br>    class_ro_t<br>    protocols  —&gt; lsit_array_tt 二维数组类型<br>    properties<br>    methods</p>
<p>method_t<br>    名称 SEL<br>    返回值、参数体 const char *types;<br>    函数体 IMP<br>const char *types; type encoding<br>返回值 参数1.参数2，参数3</p>
<p>isa指向<br>class -》 subclass -〉subclass meta<br>继承关系<br>class-&gt;superclass-&gt;nsobject<br>subclass meta -&gt; root  class meta - &gt;nsobject</p>
<p>消息传递<br>开始-缓存是否有-当前类方法列表中是否有 - 逐级父类方法列表<br>消息转发<br>动态添加-转发类给别的类-生成方法签名-处理方法-抛出异常</p>
<p>@dynamic<br>    动态运行时语言将函数决议推迟到运行时<br>    编译时语言在编译期进行函数决议</p>
<p>hash查找<br>给定值时对象内存地址，目标值是数组索引<br>f(ptr) = (untntptr_t) ptr % array.count;</p>
<p>retain实现<br>获取sidetable。<br>获取对象的引用计数<br>引用计数加一</p>
<p>retainCount实现 （默认是1的原理）<br>获取sideTable，默认count =1；<br>获取引用计数，与上SIDE_TABLE_RC_SHIFT</p>
<p>delloc<br>开始-》objc_root_dealloc-&gt;root_dealloc<br>判断是否能够释放<br>    是否isa优化-〉是否有弱引用-是否有关联对象-是否有c++晰构器-是否有引用计数表<br>清除c++ object_cXXDestruct<br>清除关联对象 bobject_remove_assocations()</p>
<p>清除引用计数<br>    清除弱引用 weak_clear_no_lock<br>    清除引用计数 table.refcnts.erase<br>添加weak<br>    objc_initWeak-storeWeak-weak_register_no_lock</p>
<p>CFRunLoop<br>    pthread<br>    currentMode<br>    modes<br>    commonModes - &gt;集合<br>    cmomonModeItems<br>CFRunLoopMode<br>    name<br>    sources0 需要手动唤醒<br>    sources1 具备自动唤醒能力<br>    observers<br>    timers</p>
<p>runLoop - n个 model - n个 sources、timer、observer<br>三次握手<br>1.syn——–》<br>2.《——–syn，ack<br>3.ack———》<br>四次挥手<br>1.fin———〉<br>2.〈——–ack<br>3.《——–fin、ack<br>4.———ack<br>https<br>tls版本号，加密算法随机数 ——-》<br>《——商定加密算法、随机数、证书<br>客户端：验证证书<br>客户端：组装会话密钥<br>通过公钥对预主密钥进行加密—-》<br>服务端：通过私钥得到预主密钥<br>服务端：组装会话密钥<br>加密的握手消息————–〉<br>〈—————-加密的握手消息<br>UDP解析<br>12字节伪首部<br>8字节UDp首部<br>7字节数据<br>UDP复用分用<br>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，<br>1.源端口： 源端口号，需要对方回信时选用，不需要时全部置0.<br>2.目的端口：目的端口号，在终点交付报文的时候需要用到。<br>3.长度：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）<br>4.校验和：检测UDP数据报在传输中是否有错，有错则丢弃。<br>TCP<br>无差错、不丢失、不重复、安序到达<br>超时重传、确认迟到、确认丢失<br>面向字节流<br>滑动窗口<br>发送窗口：发送缓存（最后被确认的字节-最后发送的字节）<br>接受窗口：接收缓存（下一个期望收到的字节）<br>拥塞窗口<br>慢开始-拥塞避免-拥塞堵塞（乘法减少）-慢开始—-<br>解决DNS劫持<br>httpDNS  server<br>    使用DNS协议向DNS服务器的53端口进行请求<br>    使用HTTP协议向DNS服务器的80端口进行请求<br>长连接<br>    client -长连接通道 - 长连接server — API server</p>
<p>session<br>发送信息 ———-》 记录用户状态，生成sessionid<br>《——————返回cookie 中携带sessid<br>发送信息，携带cookie，内容是sessid—》通过识别sessid<br>图片缓存框架<br>manager<br>    内存、磁盘、网络<br>    图片解码、图片压缩、解压缩<br>淘汰策略：以队列形式，先进先出的方式淘汰<br>如果缓存文件超过 maxCacheAge 中指定的时长，就会被删除掉。<br> maxCacheSize 控制 SDImageCache 所允许的最大缓存空间<br>RN数据流思想：多叉树<br>    自顶向下遍历更新<br>    自底向上反馈<br>    包含dispatcher、stores、views、actions<br>依赖注入<br>中间层（业务A、业务B。。。。<br>AsyncDisplayKit<br>    Layout：文本计算，试图布局计算<br>    Rendering：文本渲染、图片解码、图形绘制<br>    UIKit Object：对象创建、对象调整、对象销毁</p>
<p>AsyncDisplayKit原理<br>ASNode<br>    view<br>    node</p>
<p>block的copy<br>在arc环境下，编译器会根据情况自动将栈上的block复制到堆上<br>如果block copy到堆上，会调用_Block_objcet_assign<br>如果block移除内部会调用dispose函数，内部会调用_Block_objcet_disponse<br>设计模式<br>创建型模式：单例、 工厂方法<br>结构模式：代理、适配器、组合、装饰<br>行为模式：命令模式、观察者模式、责任链模式<br>通知：Notification_Map<br>key:notificationName value:observer<br>浅拷贝就是内存地址的copy，让目标对象指针和源对象指向同一片内存<br>可变对象的copy和mutablecopy都是深拷贝<br>不可变对象的copy是浅c拷贝，nutableCopy是浅拷贝<br>copy方法返回的s都是不可变对象</p>
<p>试图绘制<br>setNeedsDisplay<br>display<br>displayLayer<br>other works<br>    CGBitmapContext<br>    CoreGraphic API<br>    CGBitmapContext<br>setContents</p>
<p>layer has delegate<br> yes：drawRect<br> no：drawInContext<br> calayer uploads backing store to GPU</p>
<p> source0<br>    触摸事件<br>    performSelector onThread<br>source1<br>    基于port的线程间通信<br>    系统事件捕捉<br>timers<br>    nstimer<br>    performselector withObject anterDelay<br>Observers<br>    用于监听RunLoop的状态<br>    UI刷新（beforeWaiting）</p>
<p>耗电量优化<br>    尽量减少CPU、GPU功耗<br>    少用定时器<br>    优化IO操作<br>    网络优化<br>    减少压缩网络数据</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift134%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift134%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:28" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:28+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><pre><code>单一职责原则
开闭原则
接口隔离原则
依赖倒置原则
里氏替换原则
迪米特法则
</code></pre>
<h2 id="内存设计"><a href="#内存设计" class="headerlink" title="内存设计"></a>内存设计</h2><pre><code>存储的Size
淘汰策略 LRU算法
</code></pre>
<h2 id="磁盘设计"><a href="#磁盘设计" class="headerlink" title="磁盘设计"></a>磁盘设计</h2><pre><code>存储方式
大小限制
淘汰策略
</code></pre>
<h2 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h2><pre><code>图片请求最大并发
请求超时策略
请求优先级
</code></pre>
<h2 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h2><pre><code>对于不同格式的图片，解码采用什么方式
应用策略模式对不同图片格式进行解码
在那个阶段做图片解码处理
</code></pre>
<h2 id="记录上传器"><a href="#记录上传器" class="headerlink" title="记录上传器"></a>记录上传器</h2><pre><code>关于延时上传具体场景有哪些
前后台切换
从无网络到有网络的变化
通用轻量接口少捎带
</code></pre>
<h2 id="MVVM框架思想"><a href="#MVVM框架思想" class="headerlink" title="MVVM框架思想"></a>MVVM框架思想</h2><pre><code>即模型-视图-视图模型
在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。
</code></pre>
<h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><p>Flux是Facebook用来构建用户端的web应用的应用程序体系架构。它通过利用数据的单向流动为React的可复用的视图组件提供了补充。相比于形式化的框架它更像是一个架构思想，不需要太多新的代码你就可以马上使用Flux构建你的应用。<br>一个 Flux 应用主要包含四个部分：<br>dispatcher<br>处理动作分发，维护 Store 之间的依赖关系</p>
<p>stores<br>数据和逻辑部分</p>
<p>views<br>React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互</p>
<p>actions<br>提供给 dispatcher 传递数据给 store</p>
<h2 id="系统UIView更新机制的思想"><a href="#系统UIView更新机制的思想" class="headerlink" title="系统UIView更新机制的思想"></a>系统UIView更新机制的思想</h2><h2 id="FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想"><a href="#FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想" class="headerlink" title="FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想"></a>FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36747738/article/details/106537874">https://blog.csdn.net/qq_36747738/article/details/106537874</a><br>AsyncDisplayKit</p>
<p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<p>作者：柳大官人<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/17045f7dade6">https://www.jianshu.com/p/17045f7dade6</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift133%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift133%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:23" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:23+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="同步串行"><a href="#同步串行" class="headerlink" title="同步串行"></a>同步串行</h2><pre><code> // 队列引起的循环等待
//    dispatch_sync(dispatch_get_main_queue(), ^&#123;
//        [self print];
//    &#125;);
</code></pre>
<h2 id="同步并行"><a href="#同步并行" class="headerlink" title="同步并行"></a>同步并行</h2><pre><code>// 同步并行
//    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;
//        NSLog(@&quot;1&quot;);
//        dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;
//            NSLog(@&quot;2&quot;);
//        &#125;);
//        NSLog(@&quot;3&quot;);
//    &#125;);
//
</code></pre>
<h2 id="异步串行"><a href="#异步串行" class="headerlink" title="异步串行"></a>异步串行</h2><pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;
       NSLog(@&quot;1&quot;);
       
       [self performSelector:@selector(print) withObject:nil afterDelay:2];
       [[NSRunLoop currentRunLoop] run];
   &#125;);
   NSLog(@&quot;3&quot;);
    // 在gcd中开启的线程没有runloop，我们提交任务到runloop中是会失效的
     //而performSelector:withObject:afterDelay:其实就是在内部创建了一个NSTimer，
       //然后会添加到当前线程的Runloop中。所以当该方法添加到子线程中时，需要格外的注意两个地方
       // 因为子线程中的runloop默认是没有启动的状态。使用run方法开启当前线程的runloop，但是一定要注意run方法和执行该延迟方法的顺序。
       //而performSelector:withObject:afterDelay:其实就是在内部创建了一个NSTimer
       //所以在子线程中两者的顺序必须是先执行performSelector延迟方法之后再执行run方法。
   //因为run方法只是尝试想要开启当前线程中的runloop，但是如果该线程中并没有任何事件(source、timer、observer)的话，并不会成功的开启。
</code></pre>
<h2 id="异步并行"><a href="#异步并行" class="headerlink" title="异步并行"></a>异步并行</h2><p>NSOperation<br>需要和NSOperationQueue配合使用来实现多线程方案（如果直接start的话，是在主线程执行）<br>添加任务依赖<br>任务执行状态控制<br>最大并发量</p>
<p>NSOperation 实现多线程的使用步骤分为三步：</p>
<p>创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。<br>创建队列：创建 NSOperationQueue 对象。<br>将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。<br>凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行，感谢指正）<br>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。</p>
<p>系统是怎么移除一个isFinished=YES的NSOperation<br>通过KVO的方式</p>
<p>常用属性方法<br>判断操作状态方法</p>
<ul>
<li>(void)cancel; 可取消操作，实质是标记 isCancelled 状态。</li>
<li>(BOOL)isFinished; 判断操作是否已经结束。</li>
<li>(BOOL)isCancelled; 判断操作是否已经标记为取消。</li>
<li>(BOOL)isExecuting; 判断操作是否正在在运行。</li>
<li>(BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</li>
</ul>
<p>操作同步</p>
<ul>
<li>(void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。</li>
<li>(void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。</li>
<li>(void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li>(void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。<br>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。<br>NSOperationQueue 常用属性和方法</li>
</ul>
<p>取消/暂停/恢复操作</p>
<ul>
<li>(void)cancelAllOperations; 可以取消队列的所有操作。</li>
<li>(BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。</li>
<li>(void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。<br>操作同步</li>
<li>(void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。<br>添加/获取操作</li>
<li>(void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。</li>
<li>(void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束</li>
<li>(NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。</li>
<li>(NSUInteger)operationCount; 当前队列中的操作数。<br>获取队列</li>
</ul>
<ul>
<li>(id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。</li>
<li>(id)mainQueue; 获取主队列。</li>
</ul>
<p>NSThread启动流程<br>start-》创建pthread-〉main函数-》执行-〉结束</p>
<p>iOS常见的锁<br>@synchronized 一般创建单例对象的时候使用<br>atomic<br>修饰属性的关键字<br>对被修饰对象进行院子性操作（不负责使用）<br>atomic作用：多线程下将属性设置为atomic可以保证读取数据的一致性。因为他将保证数据只能被一个线程占用，也就是说一个线程对属性进行写操作时，会使用自旋锁锁住该属性。不允许其他的线程对其进行读取操作了。<br>简而言之，atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。<br>atomic修饰的实际上是这个指针，也就是占8个字节内存的指针，因此就不可能随意使用多线程来操作这块内存的。因为这块内存是原子性的。是线程安全的。<br>真正不安全的是指针指向的那块内存区域，他是非原子性的，当多个线程去操作这块内存的时候，就会出现不安全的情况。<br>OSSpinLock循环等待询问，不释放资源，用于轻量级数据访问，简单的int值+ 1 -1操作<br>NSLock 互斥锁<br>//主线程中<br>NSLock *lock = [[NSLock alloc] init];</p>
<p>//线程1<br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    [lock lock];<br>    NSLog(@”线程1”);<br>    sleep(2);<br>    [lock unlock];<br>    NSLog(@”线程1解锁成功”);<br>});</p>
<p>//线程2<br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    sleep(1);//以保证让线程2的代码后执行<br>    [lock lock];<br>    NSLog(@”线程2”);<br>    [lock unlock];<br>});<br>2016-08-19 14:23:09.659 ThreadLockControlDemo[1754:129663] 线程1<br>2016-08-19 14:23:11.663 ThreadLockControlDemo[1754:129663] 线程1解锁成功<br>2016-08-19 14:23:11.665 ThreadLockControlDemo[1754:129659] 线程2<br>NSLock 对象是在应用中用于协调多个线程操作<br>你不应该把这个类实现递归锁。如果在同一个线程上调用两次lock方法，将会对这个线程永久上锁。使用NSRecursiveLock类来才可以实现递归锁。<br>解锁一个没有被锁定的锁是一个程序错误，这个地方需要注意。<br>某个线程A调用lock方法。这样，NSLock将被上锁。可以执行“关键部分”，完成后，调用unlock方法。<br>如果，在线程A 调用unlock方法之前，另一个线程B调用了同一锁对象的lock方法。那么，线程B只有等待。直到线程A调用了unlock。<br>同一个线程不能连续两次调用加锁</p>
<p>NSRecursiveLock  递归锁<br>它允许同一线程多次加锁，而不会造成死锁。</p>
<p>发挥CPU多核（多线程）的优势</p>
<p>dispatch_semaphore_t 唤醒一个被动行为</p>
<p>GCD的常见作用<br>延迟执行dispatch_time<br>一次执行dispatch_once<br>dispatch_group_async的使用，调度，当所有任务执行完成之后再执行dispatch_group_notify<br>dispatch_barrier_async等待一些任务完成之后才能继续执行，使用barrier来等待之前任务完成，避免数据竞争等问题。<br>dispatch_semaphore信号量</p>
<p>多线程使用场景<br>类似聊天页的小视频和本地视频列表这样的tableView在显示视频的缩略图时，需要使用多线程来解决tableView的卡顿问题。因为对视频进行切图的操作是耗时的，如果在主线程进行，则会卡住tableView的滑动。<br>异步加载网络数据及解析<br>批量下载图片、图片压缩等处理，之后再刷新ui，<br>延迟执行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift132%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift132%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:17" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:17+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><pre><code>方法 URL 协议版本号 首部字段 实体
</code></pre>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><pre><code>版本 状态码 短语 首部字段 实体
</code></pre>
<h2 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h2><pre><code>GET、POST、HEAD、PUT、DELETE、OPTIONS
</code></pre>
<h2 id="HTTP三次握手"><a href="#HTTP三次握手" class="headerlink" title="HTTP三次握手"></a>HTTP三次握手</h2><pre><code>客户端发送SYN请求连接
服务端接受SYN，返回SYN和ACK
客户端接受SYN和ACK，返回服务端ACK
“第三次握手”是客户端向服务器端发送数据，这个数据就是要告诉服务器，客户端有没有收到服务器“第二次握手”时传过去的数据。若发送的这个数据是“收到了”的信息，接收后服务器就正常建立TCP连接，否则建立TCP连接失败，服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。
</code></pre>
<h2 id="HTTP四次挥手"><a href="#HTTP四次挥手" class="headerlink" title="HTTP四次挥手"></a>HTTP四次挥手</h2><pre><code>客户端发送FIN请求释放连接  FIN-WAIT-1阶段
服务端返回ACK，服务端处于准备断开状态  CLOSE-WAIT阶段（半关闭状态），客户端收到，进入FIN-WAIT-2阶段
服务端做好释放准备，再次向客户端发送FIN和ACK，LAST-ACK阶段
客户端收到FIN和ACK，发送ACK断开连接，TIME-WAIT阶段
随后客户端开始在TIME-WAIT阶段等待2MSL
服务端收到客户端LAST-ACK，进入CLOSED阶段。
与“三次挥手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续&quot;挥手&quot;，以此确保了&quot;四次挥手&quot;的顺利完成。
</code></pre>
<h2 id="为什么“握手”是三次，“挥手”却要四次？"><a href="#为什么“握手”是三次，“挥手”却要四次？" class="headerlink" title="为什么“握手”是三次，“挥手”却要四次？"></a>为什么“握手”是三次，“挥手”却要四次？</h2><pre><code>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。
释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。
</code></pre>
<h2 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL?"></a>为什么客户端在TIME-WAIT阶段要等2MSL?</h2><pre><code>为的是确认服务器端是否收到客户端发出的ACK确认报文
当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。

（1）序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
（2）确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
（3）标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：
URG：紧急指针（urgent pointer）有效。
ACK：确认序号有效。
PSH：接收方应该尽快将这个报文交给应用层。
RST：重置连接。
SYN：发起一个新连接。
FIN：释放一个连接。
</code></pre>
<h2 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h2><pre><code>无连接：HTTP的持久性
是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接
无状态：Cookie/Session
无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。
</code></pre>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><pre><code>即HTTP下加入SSL层
SSL/TLS协议提供的服务主要有：
1、认证用户和服务器，确保数据发送到正确的客户机和服务器；
2、加密数据以防止数据中途被窃取；
3、维护数据的完整性，确保数据在传输过程中不被改变。
SSL安全机制

1、身份验证机制
基于证书利用数字签名方法对服务器和客户端进行身份验证，其中客户端的身份验证是可选的。
2、数据传输的机密性
利用对称密钥算法对传输的数据进行加密。
3、消息完整性验证
消息传输过程中使用MAC算法来检验消息的完整性。
</code></pre>
<h2 id="TLS的主要增强内容"><a href="#TLS的主要增强内容" class="headerlink" title="TLS的主要增强内容"></a>TLS的主要增强内容</h2><pre><code>TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS 在SSL v3.0 的基础上，提供了以下增强内容：

1、更安全的MAC算法
2、更严密的警报
3、“灰色区域”规范的更明确的定义
</code></pre>
<h2 id="TLS对于安全性的改进"><a href="#TLS对于安全性的改进" class="headerlink" title="TLS对于安全性的改进"></a>TLS对于安全性的改进</h2><pre><code>1、对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。
2、增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。
3、改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。
4、一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。
5、特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。
</code></pre>
<h2 id="基本运行过程"><a href="#基本运行过程" class="headerlink" title="基本运行过程"></a>基本运行过程</h2><pre><code>1、客户端向服务器端索要并验证公钥。
2、双方协商生成&quot;对话密钥&quot;。
3、双方采用&quot;对话密钥&quot;进行加密通信。
其中，前两个阶段，被称为“握手阶段”。

TLS握手过程有单向验证和双向验证之分，简单解释一下，单向验证就是server端将证书发送给客户端，客户端验证server端证书的合法性等，例如百度、新浪、google等普通的https网站，双向验证则是不仅客户端会验证server端的合法性，同时server端也会验证客户端的合法性，例如银行网银登陆，支付宝登陆交易等。
1、确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
2、一个服务器生成的随机数（Sever Random），稍后用于生成&quot;对话密钥&quot;。
3、确认使用的加密方法，比如RSA公钥加密。
4、服务器证书（Certificate）。
5、支持的一些SSL/TLS扩展。

客户端需要对服务端的证书进行检查，如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥。然后，向服务器发送下面三项信息：

1、一个随机数（Pre Master Secret）。该随机数用服务器公钥加密，防止被窃听。
2、编码改变通知（Change Chiper Spec），表示随后的信息都将用双方商定的加密方法和密钥发送。
3、客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
</code></pre>
<h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><pre><code>&quot;不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。
</code></pre>
<h2 id="HTTPS通信的步骤"><a href="#HTTPS通信的步骤" class="headerlink" title="HTTPS通信的步骤"></a>HTTPS通信的步骤</h2><pre><code>①客户端发送报文进行SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件列表（加密算法及密钥长度等）。
②服务器应答，并在应答报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接受到的客户端加密组件内筛选出来的。
③服务器发送报文，报文中包含公开密钥证书。
④服务器发送报文通知客户端，最初阶段SSL握手协商部分结束。
⑤SSL第一次握手结束之后，客户端发送一个报文作为回应。报文中包含通信加密中使用的一种被称Pre-master secret的随机密码串。该密码串已经使用服务器的公钥加密。
⑥客户端发送报文，并提示服务器，此后的报文通信会采用Pre-master secret密钥加密。
⑦客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够完成成功，要以服务器是否能够正确解密该报文作为判定标准。
⑧服务器同样发送Change Cipher Spec报文。
⑨服务器同样发送Finished报文。
⑩服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。
⑪应用层协议通信，即发送HTTP响应。
⑫最后由客户端断开链接。断开链接时，发送close_nofify报文
</code></pre>
<h2 id="中间人攻击（charles抓包原理）"><a href="#中间人攻击（charles抓包原理）" class="headerlink" title="中间人攻击（charles抓包原理）"></a>中间人攻击（charles抓包原理）</h2><pre><code>流程如下：
1、截获客户端与服务器通信的通道
2、然后在 SSL 建立连接的时候，进行中间人攻击
3、将自己伪装成客户端，获取到服务器真实有效的 CA 证书（非对称加密的公钥）
4、将自己伪装成服务器，获取到客服端的之后通信的密钥（对称加密的密钥）
5、有了证书和密钥就可以监听之后通信的内容了
抓取https包的时候,青花瓷会要求使用者 对抓包的设备(手机或其他设备)
,安装一个证书,安装这个证书的时候,其实是安装了一个根证书(允许颁发CA的一个证书机构的根证书),当你安装了该根证书之后,该证书机构颁发的其他证书,默认都会被你的系统所信任,这个就是青花瓷完成https抓包的一个重要前提!!
</code></pre>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><pre><code>UDP协议：

无连接协议，也称透明协议，也位于传输层。
UDP通讯协议的特点：

将数据封装为数据包。面向无连接。
每个数据包大小限制在64K。
因为无连接，所以不可靠。
因为不需要建立连接，所以速度快。
UDP通讯是不分服务端和客服端的，只分发送端和接收端。

两者区别：

1） TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。
2） TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。
3） TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。
4） TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。
</code></pre>
<h2 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h2><pre><code>    基于连接（点对点）
    传输数据前需要建立好连接，然后在传输
    双工通信
    TCP连接一旦建立，就可以在连接上进行双向的通信
    基于字节流而非报文
    将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制能够保证TCP协议的有序性和完整性，因此TCP能够提供可靠性传输

    可靠传输
    拥塞控制
    慢启动，拥塞避免，拥塞发生，快速恢复四个算法
    流量控制能力
通过滑动窗口控制数据的发送速率，滑动窗口的本质是动态缓冲区，接收区根据自己的能力在TCP的header中动态调整窗口大小，通过ACK应答包通知给发送端，发送端根据窗口大小调控发送速率
</code></pre>
<h2 id="TCP传输是可靠的原因"><a href="#TCP传输是可靠的原因" class="headerlink" title="TCP传输是可靠的原因"></a>TCP传输是可靠的原因</h2><pre><code>（1）TCP协议采用发送应答机制，即发送端发送的每个
TCP报文段都必须得到接收方的应答，才能认为这个TCP报文段传输成功。
（2）TCP协议采用超时重传机制，发送端在发送出一个TCP报文
段之后启动定时器，如果在定时时间内未收到应答，它将重新发送该报文段。
（3）由于TCP报文段最终是以IP数据报发送的，而IP数
据报到达接收端可能乱序、重复、所以TCP协议还会将接收到的TCP报文段重排、整理、再交付给应用层。
TCP使用滑动窗口机制来进行流量控制。
建立连接时，各端分配一个缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给
另一端。接收方发送的确认消息中包含了自己剩余的缓冲区尺寸。剩余缓冲区空间的数
量叫做窗口。其实就是建立连接的双虎互相知道彼此剩余的缓冲区大小。
 （5）、拥塞控制
 拥塞控制：防止过多的数据注入到网路中，这样可以使网络中的路由器
 或链路不至于阻塞。拥塞控制是一个全局性的过程，和流量控制不同，流量控制是点对点的控制。
 2.拥塞避免：
 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的
 拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按照线性规律缓慢增长。
</code></pre>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><pre><code>DNS服务器一般分三种，根DNS服务器，顶级DNS服务器，权威DNS服务器。
1）浏览器缓存　　
2）系统缓存　　
3）路由器缓存　　　　
4） ISP（互联网服务提供商）DNS缓存
5）根域名服务器　　　
6）顶级域名服务器　　
8）保存结果至缓存
</code></pre>
<h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><pre><code>一般而言，用户上网的DNS服务器都是运营商分配的，所以，在这个节点上，运营商可以为所欲为。
例如，访问http://jiankang.qq.com/index.html，
正常DNS应该返回腾讯的ip，而DNS劫持后，会返回一个运营商的中间服务器ip。
访问该服务器会一致性的返回302，让用户浏览器跳转到预处理好的带广告的网页，
在该网页中再通过iframe打开用户原来访问的地址。
</code></pre>
<h2 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h2><pre><code>在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而
且是html类型请求，则拦截处理。后续做法往往分为2种，1种是类
似DNS劫持返回302让用户浏览器跳转到另外的地址，还有1种是在服务器返
回的HTML数据中插入js或dom节点（广告）。
</code></pre>
<p>Cookie<br>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。<br>服务器在向客户端回传相应的超文本的同时也会发回这些个人信息存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置<br>自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。<br>Cookie的maxAge决定着Cookie的有效期，单位为秒（Second）。Cookie中通过getMaxAge()方法与setMaxAge(int maxAge)方法来读写maxAge属性。 如果maxAge属性为正数，则表示该Cookie会在maxAge秒之后自动失效。<br>Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。读者可以通过上例的程序进行验证，设置不同的属性。</p>
<p>Session机制</p>
<p>除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。<br>Session技术则是服务端的解决方案，它是通过服务器来保持状态的。<br>URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。HttpServletResponse类提供了encodeURL(Stringurl)实现URL地址重写，例如：</p>
<p>Cookie与Session的区别</p>
<p>cookie数据存放在客户的浏览器上，session数据放在服务器上；<br>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；<br>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；<br>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；<br>Cookie和Session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，上面我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用（注意：有些资料说ASP解决这个问题，当浏览器的cookie被禁掉，服务端的session任然可以正常使用，ASP我没试验过，但是对于网络上很多用php和jsp编写的网站，我发现禁掉cookie，网站的session都无法正常的访问）。</p>
<p>如何保证cookie的安全<br>对cookie进行加密处理<br>只在https上携带cookie<br>设置cookie为httpOnly，防止跨站脚本攻击</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">266</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
