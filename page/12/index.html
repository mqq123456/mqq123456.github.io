<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/03/M_Swift91%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/03/M_Swift91%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">算法之数组操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-03 10:16:39" itemprop="dateCreated datePublished" datetime="2018-08-03T10:16:39+08:00">2018-08-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><pre><code>// 定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中
function unique(arr) &#123;
    var res = [arr[0]];
    for (var i = 0; i &lt; arr.length; i++) &#123;
        var repeat = false;
        for (var j = 0; j &lt; res.length; i++) &#123;
            if (arr[i] == res[j]) &#123;
                repeat = true;
                break;
            &#125;
        &#125;
        if (!repeat) &#123;
            res.push(arr[i]);
        &#125;
    &#125;
    return res;
&#125;
// 思路：每次取出原数组的元素，然后再对象中访问这个属性，如果存在就说明重复
function unique(arr) &#123;
    var res = [];
    var json = &#123;&#125;;
    for (var i = 0; i &lt; arr.length; i++) &#123;
        if (!json[arr[i]]) &#123;
            res.push(arr[i]);
            json[arr[i]] = 1;
        &#125;
    &#125;
    return res;
&#125;
// 利用下标查询
function unique(arr) &#123;
    var newArr = [arr[0]];
    for (var i = 0; i &lt; arr.length; i++) &#123;
        if (newArr.indexOf(arr[i]) == -1) &#123;
            newArr.push(arr[i]);
        &#125;
    &#125;
    return newArr;
&#125;

// 两个数组中相同的元素和不同的元素
// 合并两数组，并删除重复元素(代码类似于数组去重，只不过都是比较两个数组)
</code></pre>
<h2 id="对数组进行反转"><a href="#对数组进行反转" class="headerlink" title="对数组进行反转"></a>对数组进行反转</h2><pre><code>function reverae(arr) &#123;
    var j = arr.length - 1;
    for (var i = 0; i &lt; arr.length; i++) &#123;
        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        j--;
    &#125;
&#125;
</code></pre>
<h2 id="获取数组中连续的元素"><a href="#获取数组中连续的元素" class="headerlink" title="获取数组中连续的元素"></a>获取数组中连续的元素</h2><pre><code>function fn(arr)&#123;
  var result = [],
      i = 0;
  result[i] = [arr[0]];
  arr.reduce(function(prev, cur)&#123;
    cur-prev === 1 ? result[i].push(cur) : result[++i] = [cur];
    return cur;
  &#125;);
  return result;
&#125;
</code></pre>
<h2 id="数组合并-先排序，再合并"><a href="#数组合并-先排序，再合并" class="headerlink" title="数组合并(先排序，再合并)"></a>数组合并(先排序，再合并)</h2><pre><code>// 合并两个有序数组
function mergeOrder(arr1,arr2) &#123;
    var result = arr1 +arr2;
    var m = 0;
    var n = 0;
    for (var i = 0; i &lt; result.length; i++) &#123;
        if (m == arr1.length) &#123;
            result[i] = arr2[n++];
        &#125;else if (n==arr2.length) &#123;
            result[i] = arr1[m++];
        &#125;else&#123;
            if (arr1[m] &lt; arr2[n]) &#123;
                result[i] = arr1[m++];
            &#125;else&#123;
                result[i] = arr2[n++];
            &#125;
        &#125;

    &#125;
    return result;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/07/24/M_Swift76_2018%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/24/M_Swift76_2018%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">2018规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-24 20:03:36" itemprop="dateCreated datePublished" datetime="2018-07-24T20:03:36+08:00">2018-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>眼看2017年这就要过去了，是时候想一下2018年的自己了，2018年，你有什么打算，有什么思考，想做点什么，然后是想怎么样过完自己的2018年，很重要，是时候规划一下了。<br>貌似，我觉得我2017年初的时候应该也是有规划的，不知道现在还能回想一下是什么不，现在有点忍不住想回头看一下的冲动。<br>翻看了一下，竟然没有。。。。。让我很吃惊，哈哈怎么会是这样的。我2017年的规划去哪里了？？<br>好了，不回望过去了，说说接下来的2018年吧。<br>我计划是能够达到10万元的年收入，除去现在的车，我想，我车已经算是买了，但是我需要2018年，一整年的时间来去偿还，还是比较耗费资本的，这一年我将不光是为了车努力，我还是要多挣钱，准备自己的房子的首付。<br>但是，我这个人还是有点担忧的，我觉得我属于那种忧愁型的人，如果真的要贷款买房的话，我想对于我来说是不小的挑战。<br>说了半天房子，其实我觉得2018年肯定是没有希望的，我想如果有希望，应该是2019年，但是前提是保证房子的价格保持不变，如果房子继续上涨的话，那么我2019年也不一定了。哈哈<br>那2018年的你会做什么啊？真的是一个值得思考的问题，现在天太冷的，总是说浪费时间，整的是，是寒冬冻住了我的行动，让我裹足不前，我应该在什么方向上寻找突破呢？真的是一个让人忧愁的问题。<br>现在看来。2018，我还是比较迷茫的，毕竟公司的前景不明，我也不知道该怎么办，一直以来都是认为应该在北京呆着，可是，怎么呆着确实是一个问题。满满的，人就会变的懒惰，变的暴躁，变的无聊，毕竟分割两地，真的是一件值得伤脑的事情。<br>2018年究竟要做点什么事情才能让自己不遗憾呢？说实话，自己快奔30的人了，真的是不小了。而且也确实该立业了，毕竟家已经有了，能不能有自己一个好的工作，能不能创出自己的一片天，真的需要智慧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/07/24/N_Android16%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/24/N_Android16%E8%BF%9B%E9%98%B6/" class="post-title-link" itemprop="url">Android进阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-24 20:02:18" itemprop="dateCreated datePublished" datetime="2018-07-24T20:02:18+08:00">2018-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Android开发有一段事件了，是时候整理了，网上有很多好的博客整理的比较好，我顺便就抄写下来，也算是对自己的巩固吧。<br>接口interface</p>
<p>interface是一些功能的集合，但它只定义了对象必须实现的成员，而不包含成员的实现代码，成员的具体代码由实现接口的类提供。Android对接口的使用场景主要有三类：事件监听器接口、对象序列化结构、线程类相关接口。<br>事件监听器接口</p>
<p>这类接口名称一般以Listener或者CallBack结尾，监听器定义了事件触发时应该进行的操作方法，具体操作步骤需要自定义实现。常见的监听器接口有：<br>对象序列化接口<br>线程类相关接口<br>抽象类abtract class<br>部分基础控件<br>适配器<br>适配器在实际使用时都要派生重写，所以sdk里的适配器类都是抽象类或接口，包括：<br>1、列表适配器，如ListAdapter、SpinnerAdapter、BaseAdapter等等；<br>2、页面适配器，如PagerAdapter、FragmentPagerAdapter、FragmentStatePagerAdapter等等</p>
<p>静态static<br>静态方法<br>1、静态方法中只能调用静态方法，不能调用非静态方法；<br>静态变量在运行时一般无需修改，如果在运行时修改了变量值，可能会得到非预期的结果。<br>2、静态方法中只能使用静态的类变量，不能使用非静态的类变量；<br>3、静态方法中不能使用this和super，即使this后面跟的是静态类变量也不行；<br>静态类<br>静态类指的是名称前加了static修饰符的类，一般用于开放给外部使用的类中内部类，这样就可以通过“上级类的类名.内部类的类名”来访问。比如说AlertDialog类的内部类Builder，可通过AlertDialog.Builder来调用；再比如Build类的内部类VERSION，可通过Build.VERSION来调用。<br>终态final</p>
<p>单例模式有三个特点；<br>1、某个类只能有一个实例；<br>2、它要自行创建这个实例；<br>3、它只有唯一途径向整个系统提供这个实例。<br>public class SingletonInner {</p>
<p>private static class SingletonHolder {<br>private static SingletonInner instance = new SingletonInner();<br>}</p>
<p>private SingletonInner() {<br>}</p>
<p>public static SingletonInner getInstance() {<br>return SingletonHolder.instance;<br>}</p>
<p>}<br>类工厂</p>
<p>类工厂的输入参数为类名，这得用模板来表示了。类工厂用的就比较多，比如java的容器类ArrayList、HashMap等等都用到了类工厂</p>
<p>策略模式<br>装饰模式</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/07/24/N_Android15%E4%B8%8E%E6%97%B6%E4%BF%B1%E8%BF%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/24/N_Android15%E4%B8%8E%E6%97%B6%E4%BF%B1%E8%BF%9B/" class="post-title-link" itemprop="url">Android与时俱进</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-24 20:02:12" itemprop="dateCreated datePublished" datetime="2018-07-24T20:02:12+08:00">2018-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Android开发有一段事件了，是时候整理了，网上有很多好的博客整理的比较好，我顺便就抄写下来，也算是对自己的巩固吧。<br>Toolbar，SearchView，SlidingPaneLayout，RecyclerView，RecyclerView.Adapter，LinearLayoutManager，GridLayoutManager，StaggeredGridLayoutManager，SwipeRefreshLayout，导航视图NavigationView，画廊Gallery，图像切换ImageSwitcher，卡片视图CardView，视频播放方式：使用MediaPlayer结合SurfaceView进行播放<br>VideoView结合MediaController<br>MediaRecorder/MediaPlayer<br>屏幕捕捉：给屏幕截图用到了ImageReader，它的常用方法说明如下：<br>把用户在屏幕上的操作行为录制成视频，我们称之为录屏<br>集合动画AnimationSet，属性动画组合AnimatorSet，插值器和估值器<br>水波图形RippleDrawable，水波动画RippleView<br>矢量图形VectorDrawable，组标签group，根标签vector，路径标签path<br>协调布局CoordinatorLayout，应用栏布局AppBarLayout<br>可折叠工具栏布局CollapsingToolbarLayout<br>自定义行为Behavior<br>文本输入布局TextInputLayout</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/07/24/N_Android14%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/24/N_Android14%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">Android通信相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-24 20:02:02" itemprop="dateCreated datePublished" datetime="2018-07-24T20:02:02+08:00">2018-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Android开发有一段事件了，是时候整理了，网上有很多好的博客整理的比较好，我顺便就抄写下来，也算是对自己的巩固吧。</p>
<p>下面是Activity类与生命周期有关的方法：<br>onCreate : 创建页面<br>onStart : 开始页面<br>onStop : 停止页面<br>onResume : 恢复页面<br>onPause : 暂停页面<br>onDestroy : 销毁页面<br>onRestart : 重启页面<br>onNewIntent : 重用栈中已存在的实例<br>onSaveInstanceState : 保存实例状态。使用场景：1、从A视图跳转到B视图，需要保存A视图的状态（不考虑特殊情况）；2、屏幕从竖屏变为横屏，需要保存竖屏时的视图状态，从横屏变为竖屏亦然；3、当前Activity处于后台，系统因资源紧张将其杀死。<br>onRestoreInstanceState : 恢复实例状态。使用场景：1、屏幕从竖屏变为横屏，横屏显示时需要恢复之前保存的竖屏状态；2、activity后台运行被系统杀死。此处注意，从B视图返回A视图时并不调用该方法。</p>
<p>Intent用于处理Android各组件之间的通讯。Intent完成的工作主要有三部分：<br>1、Intent需标明本次通讯请求是从哪里来，到哪里去，要怎么走；<br>2、发起方携带上本次通讯需要的数据内容，接收方则对收到的Intent数据进行解包；<br>3、如发起方要求判断接收方的处理结果，Intent还需负责传回应答的数据内容；<br>Intent由以下部分组成：<br>Component : 组件，用于指定Intent的来源与目的<br>Action : 用于指定Intent的动作<br>Data(即Uri) :  用于指定动作要操纵的数据路径<br>Category : 用于指定动作的类别<br>Type : 数据类型，用于指定Data类型的定义<br>Extras : 扩展信息，用于指定装载的参数信息<br>Flags : 标志位，用于指定Intent的运行模式（也叫启动标志）。详细说明见上一节的《Android开发笔记（三十九）Activity的生命周期》。</p>
<p>广播的调用方法</p>
<p>sendBroadcast : 发送广播<br>registerReceiver : 注册接收器，一般在onStart或者onResume方法中注册<br>unregisterReceiver : 注销接收器，一般在onStop或者onPause方法中注销</p>
<p>基本的手势事件主要有如下三个方法：<br>dispatchTouchEvent : 判断该事件是否需要下发。返回true表示需要下发给下级视图，返回false表示不需要下发（交给自身的onTouchEvent处理）。但是否最终下发，还需根据onInterceptTouchEvent的拦截结果。<br>onInterceptTouchEvent : 判断当前容器是否需要拦截该事件。返回true表示予以拦截（交给自身的onTouchEvent处理）、不放给下级视图，返回false表示不拦截该事件。<br>onTouchEvent : 判断该事件是否处理完毕。返回true表示处理完毕，则无需处理上级视图的onTouchEvent，一路返回结束流程。返回false表示该事件未完成，则返回继续处理上级视图的onTouchEvent，然后再根据上级onTouchEvent的返回值判断是直接结束还是由再上级处理。<br>手势事件的生命周期</p>
<p>控件响应<br>Activity.dispatchTouchEvent(返回true)-&gt;ViewGroup.dispatchTouchEvent(返回true)-&gt;ViewGroup.onInterceptTouchEvent(返回false)-&gt;View.dispatchTouchEvent(返回true)-&gt;View.onTouchEvent(返回true)-&gt;结束<br>TouchEvent</p>
<p>下面是触摸事件的常用方法：<br>getAction : 获取当前的动作<br>getX : 获取当前在控件内部的相对坐标X<br>getY : 获取当前在控件内部的相对坐标Y<br>getRawX : 获取当前在屏幕上的相对坐标X<br>getRawY : 获取当前在屏幕上的相对坐标Y<br>getEventTime : 获取当前的事件时间</p>
<p>弹性滑动</p>
<p>滑动计算器Scroller</p>
<p>Scroller是Android用于计算滑动参数的辅助类，常用方法如下：<br>startScroll : 设置开始滑动的参数，包括起始的xy坐标、xy偏移量，另一个重载的方法还可以设置滑动的持续时间。<br>computeScrollOffset : 计算滑动偏移量。返回值可判断滑动是否结束，返回fasle表示滑动结束，返回true表示还在滑动当中。<br>getCurrX : 获得当前的X坐标<br>getCurrY : 获得当前的Y坐标<br>getDuration : 获得滑动的持续时间<br>forceFinished : 强行停止滑动<br>isFinished : 判断滑动是否结束。返回fasle表示还未结束，返回true表示滑动结束。该方法与computeScrollOffset的区别在于：1、computeScrollOffset内部还有计算偏移量，而isFinished只返回标志不做其他处理；2、computeScrollOffset返回fasle表示滑动结束，而isFinished返回true表示滑动结束。<br>scrollTo : 将控件滑动到指定坐标位置</p>
<p>View的滑动方法</p>
<p>虽然Scroller提供了滑动的相关计算函数，但是Scroller本身并不能直接滑动控件。因为Scroller只是个运算模拟器，根据时间的流逝计算xy坐标，所以我们必须调用控件自身的滑动方法，才能真正让控件动起来。View类中操纵滑动的方法有两个：<br>scrollTo : 将控件滑动到指定坐标位置<br>scrollBy : 将控件滑动指定偏移量。查看源码会发现scrollBy内部就是调用scrollTo，当然得先把当前坐标加上偏移量，从而得到滑动后的绝对坐标。</p>
<p>一、采用Handler类的post方法<br>Handler常用的post方法有下面几种：<br>post : 立即启动Runnable<br>postDelayed : 延迟指定时间间隔后启动Runnable<br>postAtTime : 在指定时间启动Runnable<br>removeCallbacks : 回收/移除指定的Runnable</p>
<p>AsyncTask是个模板类（AsyncTask&lt;Params, Progress, Result&gt;），继承它的新类需要指定模板的参数类型，模板参数说明如下：<br>Params : 任务启动时的输入参数，比如http访问的url、请求参数等等。可设置为String类型或者自定义的数据结构<br>Progress : 任务执行的进度。可设置为Integer类型<br>Result : 任务执行完的结果。可设置为String类型或者自定义的数据结构<br>doInBackground : 异步处理操作都放在该方法中，params参数对应execute方法的输入参数。该方法运行于分线程，所以不能操作UI，其他方法都能操作UI<br>onPreExecute : 在doInBackground执行之前调用<br>onProgressUpdate : doInBackground方法中调用publishProgress时会触发该方法，通常用于处理过程中刷新进度条<br>onPostExecute : 在doInBackground执行完毕时调用，通常用于处理完毕后刷新展示页面<br>onCancelled : doInBackground方法中调用cancel时会触发该方法<br>定时器：Timer和TimerTask，CountDownTimer，AlarmManager<br>权限申请</p>
<p>通过前面对设备的基本操作介绍，可看到Android四大组件各显神通，各组件协同配合完成了许多功能。具体的组件使用分类如下：</p>
<p>1、Activity：包括拨号（Intent.ACTION_CALL）、手工发短信（Intent.ACTION_SENDTO）、发邮件（Intent.ACTION_SEND）、系统设置页面（Settings.ACTION_SETTINGS）以及其他分项设置页面。<br>2、Service：包括获取子系统服务的管理器，如电话管理器TelephonyManager（Context.TELEPHONY_SERVICE）、定位管理器LocationManager（Context.LOCATION_SERVICE）、蓝牙管理器BluetoothAdapter（BLUETOOTH_MANAGER_SERVICE）、WLAN管理器WifiManager（Context.WIFI_SERVICE）、数据连接管理器ConnectivityManager（Context.CONNECTIVITY_SERVICE）。<br>3、Broadcast：包括开关飞行模式、开关GPS、自动发送短信的发送成功通知与接收成功通知。<br>4、ContentProvider：包括通过ContentResolver获取与开关的功能，如屏幕自动旋转、亮度自动调节、飞行模式等等。<br>json</p>
<p>json的常用方法有：<br>JSONObject构造函数 : 从指定字符串构造出一个JSONObject对象<br>JSONObject.getJSONObject : 获取指定名称的JSONObject对象<br>JSONObject.getString : 获取指定名称的字符串值<br>JSONObject.put : 添加一个json元素<br>JSONObject.toString : 把当前JSONObject输出为一个json字符串<br>JSONObject.getJSONArray : 获取指定名称的json对象数组<br>JSONArray.length : 获取json对象数组的大小<br>JSONArray.getJSONObject : 获取json对象数组在指定位置处的JSONObject对象<br>JSONArray.put : 往json对象数组中添加一个JSONObject对象</p>
<p>URL编码，BASE64编码。MD5加密，RSA加密，3DES加密</p>
<p>内存泄漏的场景</p>
<p>在Android开发中，内存泄漏可能发生在如下几个场景：<br>1、查询操作后，没有关闭游标Cursor；<br>2、刷新适配器Adapter时，没有重用convertView对象；<br>3、Bitmap对象使用完毕，没有调用recycle方法回收内存；<br>4、给系统服务注册了监听器，却没有及时注销；<br>5、Activity引用了耗时对象，造成页面关闭时无法释放被引用的对象；</p>
<p>picasso</p>
<p>picasso是Square公司开源的一个Android图片缓存库<br>Universal-Image-Loader</p>
<p>Universal-Image-Loader是个广泛应用的图片加载框架，它的功能比Picasso更丰富，当然用起来也会复杂一些。</p>
<p>Java的异常分两类，运行时异常RuntimeException和非运行时异常。<br>运行时异常包括空指针异常NullPointerException、数组越界异常IndexOutOfBoundsException、类型转换异常ClassCastException、数据库异常SQLException等等，（网上很多文章把SQLException归为非运行时异常，但查看源码SQLException继承自RuntimeException，所以它应是运行时异常）。非运行时异常包括输入输出异常IOException、无此加密算法异常NoSuchAlgorithmException等等。<br>非运行时异常在编码的时候就要进行处理，不然编译都通不过。运行时异常有的在程序运行时才会发现，但也有的在编码时就得处理，比如说非法参数异常IllegalArgumentException、非法状态异常IllegalStateException等等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/07/24/N_Android13%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/24/N_Android13%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">Android开发总结内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-24 20:01:54" itemprop="dateCreated datePublished" datetime="2018-07-24T20:01:54+08:00">2018-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Android开发有一段事件了，是时候整理了，网上有很多好的博客整理的比较好，我顺便就抄写下来，也算是对自己的巩固吧。</p>
<p>res是Android项目工程中存放各类的目录，主要包括布局、图形与配置等等。res的子目录主要有：</p>
<p>anim : 存放动画的描述文件<br>drawable : 存放各类图形的描述文件，包括drawable的描述文件，以及三种图片格式：png（推荐）、jpg（支持）、gif（不推荐，因为ImageView只显示gif的第一帧）。以drawable打头的有好几个目录，分别存放不同分辨率的图片，这些目录的区别详见<br>layout : 存放页面的布局文件，主要在Acitivity、Fragment以及部分自定义控件中使用<br>menu : 存放菜单的布局文件<br>raw : 存放原始格式的文件，一般是二进制的流文件，比如音频文件、视频文件等等<br>values : 存放各类参数的配置文件，具体的配置文件说明如下<br>——arrays.xml : 存放各类数组的定义文件，字符串数组的根节点为string-array，整型数组的根节点为integer-array<br>——booleans.xml : 存放布尔类型的定义文件，根节点为resources，元素节点为bool<br>——attrs.xml : 存放自定义控件的属性信息，根节点为resources，元素节点为declare-styleable——attr<br>——colors.xml : 存放颜色的定义文件，根节点为resources，元素节点为color<br>——dimens.xml : 存放像素的定义文件，根节点为resources，元素节点为dimen<br>——ids.xml : 存放控件id的定义文件，根节点为resources，元素节点为item，type为id<br>——integers.xml : 存放整数类型的定义文件，根节点为resources，元素节点为integer<br>——strings.xml : 存放字符串类型的定义文件，根节点为resources，元素节点为string<br>——styles.xml : 存放控件风格的定义文件，根节点为resources，元素节点为style——item<br>xml : 存放其他的xml文件，比如说存放SearchView的searchable.xml属性定义文件</p>
<p>其余目录下面的配置文件，一般需要在代码中解析数据结构，比如说图像、字符串、整型数、二进制流等等。具体的代码调用方式如下：</p>
<p>drawable : 一般使用getResources().getDrawable(R.drawable.example);，gif文件使用getResources().getMovie(R.drawable.example);<br>raw : getResources().openRawResource(R.raw.example);<br>values :<br>——arrays.xml : 解析字符串数组使用getResources().getStringArray(R.array.city);，解析整型数组使用getResources().getIntArray(R.array.code);<br>——attrs.xml : 代码中不解析该文件的数据结构，在自定义控件的构造函数中通过如下方式使用：TypedArray attrArray=getContext().obtainStyledAttributes( attrs, R.styleable.example);<br>——booleans.xml : getResources().getBoolean(R.bool.example);<br>——colors.xml : getResources().getColor(R.color.example);<br>——dimens.xml : getResources().getDimension(R.dimen.example);<br>——ids.xml : 代码中不使用该文件配置，在布局文件中使用为：android:id=”@id/…”（注意与一般情况相比去掉了加号）<br>——integers.xml : getResources().getInteger(R.integer.example);<br>——strings.xml : getResources().getString(R.string.example);<br>——styles.xml : 代码中不解析该文件的数据结构，布局文件的使用在控件内部加上style属性：style=”@style/example”<br>xml : getResources().getXml(R.xml.example);</p>
<p>assets目录用于存放应用程序的资产文件，该目录下的文件不会被系统编译，所以无法通过R.*.*这种方式来访问。Android专门为assets目录提供了一个工具类AssetManager，通过该工具，我们能够以字节流方式打开assets下的文件，并将字节流转换为文本或者图像。<br>ssetManager提供了如下方法用于处理assets：<br>1、 String[] list(String path);<br>列出该目录下的下级文件和文件夹名称<br>2、 InputStream open(String fileName);<br>以顺序读取模式打开文件，默认模式为ACCESS_STREAMING<br>3、 InputStream open(String fileName, int accessMode);<br>以指定模式打开文件。读取模式有以下几种：<br>ACCESS_UNKNOWN : 未指定具体的读取模式<br>ACCESS_RANDOM : 随机读取<br>ACCESS_STREAMING : 顺序读取<br>ACCESS_BUFFER : 缓存读取<br>4、 void close()<br>关闭AssetManager实例</p>
<p>集合(Set/HashSet)</p>
<p>集合中的元素是没有顺序的，而且不可以重复。这意味着，集合只能遍历而无法通过索引访问指定元素，并且如果重复添加相同值将不会增大集合。因为Set只是接口，所以实际用的是它的一个派生类HashSet。<br>集合的常用方法如下：<br>add : 添加元素<br>clear : 清空容器<br>contains : 判断容器中是否存在该元素<br>iterator : 获取第一个元素的指针<br>isEmpty : 判断容器是否为空<br>remove : 删除元素<br>size : 获取容器大小</p>
<p>队列(ArrayList)</p>
<p>队列与集合恰恰相反，队列中的元素是有顺序的，而且允许重复，所以队列可以使用索引来访问指定元素（类似数组的下标）。<br>队列的常用方法包括上面集合列出的几个，下面列出有变更或者添加的方法：<br>add : 提供了两个方法。默认在队列末尾添加元素；如果指定了索引位置，则在指定位置末尾添加元素<br>get : 获取指定位置的元素<br>indexOf : 获取指定元素的第一个索引位置<br>lastIndexOf : 获取指定元素的最后一个索引位置<br>remove : 提供了两个方法。除了删除元素之外，还可以删除指定位置的元素<br>set : 替换指定位置的元素<br>subList : 截取从开始位置到结束位置之间的子队列</p>
<p>映射(Map/HashMap)</p>
<p>映射保存的是键值对（即key—value）的映射关系，一个映射中不能包含相同的key，每个key只能映射一个value。但Map只是接口，实际中常用的是它的一个派生类HashMap。类似的，队列、链表、向量都是派生自List接口。<br>映射的常用方法如下：<br>clear : 清空容器<br>containsKey : 判断容器中是否存在该键（key）的元素<br>containsValue : 判断容器中是否存在该值（value）的元素<br>get : 根据指定键获得元素的值<br>isEmpty : 判断容器是否为空<br>keySet : 获取容器中键的集合<br>put : 设置键值对的映射关系。如原来没有该键，则添加元素；如果原来存在该键，则替换元素<br>remove : 删除指定键对应的元素<br>size : 获取容器的大小<br>values : 获取容器中值的集合</p>
<p>Application组件</p>
<p>Application是比Activity高级的组件，它的生命周期覆盖了APP运行的全过程；而Activity页面的生命周期很短暂，只要进入别的页面，原页面就被停止或者销毁；因此我们可以在Application中保存全局变量。在打开App时，系统会先初始化Application，然后才进入到开始的Activity页面。通常我们不需要指定一个Application，这时系统会自动帮我们创建，如果需要创建自己的Application，创建一个派生自Application的类，并在manifest的application标签中注册就好了。</p>
<p>SharedPreferences存储数据</p>
<p>下面是Properties的常用方法：<br>load : 从属性文件中加载属性对象<br>store : 把属性对象保存到属性文件<br>getProperty : 获取属性值<br>setProperty : 设置属性值<br>loadFromXML : 从XML格式的属性文件中加载属性对象<br>storeToXML : 把属性对象保存到XML格式的属性文件</p>
<p>SQLite</p>
<p>Realm应用背景</p>
<p>File类</p>
<p>File类是java中的文件操作工具类，它的常用方法如下：<br>File构造函数 : 根据文件路径构造File对象<br>delete : 删除文件<br>exists : 判断文件是否存在<br>getName : 获取文件的文件名<br>getPath : 获取文件的目录路径<br>getParent : 获取上级目录路径<br>isDirectory : 判断是否为目录/文件夹<br>isFile : 判断是否为文件<br>length : 获取该文件的大小<br>list : 列出该目录下的所有文件（夹），返回String数组<br>listFiles : 列出该目录下的所有文件（夹），返回File数组<br>mkdirs : 创建目录/文件夹<br>renameTo : 重命名文件，其实就是移动文件到指定目录</p>
<p>Environment类</p>
<p>Environment类是Android中获取各种目录信息的工具，主要方法如下：<br>getDataDirectory : 获得系统data目录的路径<br>getDownloadCacheDirectory : 获得下载缓存目录的路径<br>getExternalStorageState : 获得外部存储的状态<br>SD卡操作</p>
<p>下载请求</p>
<p>要想使用下载功能，首先得构建一个下载请求，说明从哪里下载、下载参数为何、下载的文件保存到哪里等等。这个下载请求便是DownloadManager的子类Request，下面是该类的常用方法<br>Request构造函数 : 指定从哪个网络地址下载文件。<br>Request.setAllowedNetworkTypes : 指定允许进行下载的网络类型。Request.NETWORK_WIFI表示wifi环境（推荐），Request.NETWORK_MOBILE表示数据连接环境（不推荐），Request.NETWORK_BLUETOOTH表示蓝牙环境。<br>Request.setDestinationInExternalFilesDir : 设置下载文件在本地的保存路径。<br>Request.addRequestHeader : 给HTTP请求添加头部参数。<br>Request.setMimeType : 设置下载文件的媒体类型。<br>Request.setVisibleInDownloadsUi : 设置下载页面是否可见。<br>下载操作</p>
<p>构建下载请求完毕，然后才能进行下载的相关操作。下面是DownloadManager常用的下载方法：<br>enqueue : 将下载请求加入到任务队列中，即开始下载任务。该方法返回本次下载任务的编号。<br>remove : 取消指定编号的下载任务。<br>restartDownload : 重新下载指定编号的任务。<br>openDownloadedFile : 打开下载完成的文件。<br>getMimeTypeForDownloadedFile : 获取下载完成的文件的媒体类型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/07/24/N_Android12%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/24/N_Android12%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Android开发总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-24 20:01:43" itemprop="dateCreated datePublished" datetime="2018-07-24T20:01:43+08:00">2018-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Android开发有一段事件了，是时候整理了，网上有很多好的博客整理的比较好，我顺便就抄写下来，也算是对自己的巩固吧。<br>Android项目开发建议：</p>
<p>1、全部Activity可继承自BaseActivity，便于统一风格与处理公共事件，构建对话框，统一构造器的建立，万一需要整体变动，一处改动个处处有效。</p>
<p>2、数据库表字段常量和SQL逻辑分离，更清晰，建议使用Lite系列狂降LiteOrm库，超级清晰且重心可以放在业务上不用关心数据库细节</p>
<p>3、全局变量放全局类中，模块私有放自己的管理类中，让常量清晰且集中</p>
<p>4、不要相信庞大的管理类的东西会带来什么好处，可能是一场灾难，而要时刻注意单一原则，一个类专心做好一件事</p>
<p>Android两种方式事件处理</p>
<p>1、基于回调的事件处理</p>
<p>2、基于监听器的事件处理</p>
<p>Android的事件处理机制是一种委派式（Delegation）事件处理方式<br>普通组件（事件源）将整个事件处理委托给特定的对象（事件监听器），当该事件源发生制定的事件时，就通知所委托的事件监听器，由监听器处理这个事件。<br>Android默认约定当UI线程阻塞超过20秒，会引发ANR(Application Not Responding)异常</p>
<p>为了找起来方便，暂且分为七大类：显示、存储、通信、发布与调优、进阶用法、与时俱进、继续精进。</p>
<p>显示又分为八块：屏幕、文本、图形、简单控件、自定义视图、动画、窗口、复杂控件；</p>
<p>存储分为六块：资源、内存、键值对、数据库、文件、网络存储；</p>
<p>通信分作六块：组件通信、事件通信、多线程通信、跨进程通信、设备通信、网络通信；</p>
<p>发布与调优分为五块：打包、安全、性能、健壮、兼容；</p>
<p>进阶用法分为六块：java细节、设计模式、图像处理、高级控件、第三方sdk、开发者工具；</p>
<p>与时俱进分为六块：新版控件、多媒体开发、高级动画、行为协调、页面切换、花样输入；</p>
<p>继续精进分为六块：人工智能、混合开发、三维动画、物联网、屏幕特效、视频加工；</p>
<p>dp和px的转换<br>屏幕分辨率getWindowManager<br>Drawable资源目录</p>
<p>drawable文件放在res目录的各个drawable目录下，\res\drawable一般放的是描述性的xml文件，图片文件一般放在具体分辨率的drawable目录下。例如<br>drawable-ldpi里面主要放低分辨率的图片，如QVGA（240×320）<br>drawable-mdpi里面主要放中等分辨率的图片，如HVGA（320×480）<br>drawable-hdpi里面主要放高分辨率的图片，如WVGA（480×800），FWVGA（480×854）<br>drawable-xhdpi里面主要放加高分辨率的图片，如Nexus（720×1280）以上分辨率<br>drawable-xxhdpi里面主要放超高分辨率的图片，如Nexus（1080×1920）以上分辨率<br>StateListDrawable是在一个xml文件中定义不同状态下呈现的图像。下面是一个例子btn_visit_selector.xml<br>state_pressed：为true时表示按下，一般用于按钮Button，图形设置于android:background<br>state_checked：为true时表示勾选，一般用于单选框RadioButton、复选框CheckBox，图形设置于android:drawableLeft<br>state_selected：为true时表示选中，一般用于单选框RadioButton、复选框CheckBox，图形设置于android:background<br>state_focused：为true时表示获取焦点，一般用于文本框EditText，图形设置于android:background</p>
<p>shape的定义文件是xml，以shape元素为根节点。根节点下定义了六个节点：corners（圆角）、gradien（渐变）、padding（间隔）、size（尺寸）、solid（填充）、stroke（描边），各节点的属性值主要是各种长宽、半径、角度，以及颜色。<br>visibility各取值的区别 : 该属性有三个取值，分别是：visible表示可见，invisible表示不可见，gone表示消失</p>
<p>View是单个视图，所有的控件类都是从它派生出来；而ViewGroup是个视图组织，所有的布局视图类都是从它派生出来。由于View和ViewGroup是基类，因此很少会直接使用，偶尔用到的场景，主要有如下几个：<br>1、页面上需要单独显示一条横线或者竖线。如果填充图片显然不够经济，最简单的做法，就是在xml布局中增加一个View控件，高度或宽度设置为1dp，背景颜色设置为线条颜色，这样便实现了单独显示线条的需求。<br>2、点击事件的处理函数onClick(View v)，这里面我们要调用View的getId方法获取发生点击事件的控件id，从而进行该控件对应的点击处理。<br>3、在代码中设置某控件为可见或不可见或消失，此时需要使用View类的三个变量，分别是View.VISIBLE、View.INVISIBLE和View.GONE。</p>
<p>Button是文本按钮（继承自TextView），而ImageButton是图像按钮（继承自ImageView）。两者之间的区别在于：<br>1、Button即可显示文本也可显示图形（通过设置背景图），而ImageButton只能显示图形不能显示文本；<br>2、Button可在文本周围区域显示小图，而ImageButton无法在某个区域显示小图；<br>3、ImageButton上的图像可按比例进行拉伸，而Button上的大图会拉伸变形（因为背景图无法按比例拉伸）；<br>从上面可以看出，Button的适应面更广，所以实际开发中基本使用Button。</p>
<p>CheckBox</p>
<p>CheckBox是复选框，点击勾选，再点击则取消勾选。CheckBox是CompoundButton的一个子类，所以继承了CompoundButton的所有属性和方法。</p>
<p>RadioGroup和RadioButton</p>
<p>RadioButton是单选框，点击选中，但是再点击不会取消选中。只有点击同组的其他RadioButton，原来勾选的RadioButton才会取消选中。RadioButton也是CompoundButton的一个子类，所以继承了CompoundButton的所有属性和方法。<br>RadioGroup是容纳多个RadioButton的组布局，同组中只能有一个RadioButton被选中。下面是RadioGroup常用的几个方法：<br>setCheckedId : 选中指定ID的RadioButton。<br>getCheckedRadioButtonId : 获取选中状态RadioButton的ID。<br>setOnCheckedChangeListener : 设置勾选变化的监听器。<br>自定义视图存在三个构造函数，分别是<br>//只有一个参数，用于在代码中构造对象<br>public SignatureView(Context context) {<br>super(context);<br>}</p>
<p>//有两个参数，用于在XML布局中构造对象<br>public SignatureView(Context context, AttributeSet attrs) {<br>super(context, attrs);<br>if (attrs != null) {<br>TypedArray attrArray=getContext().obtainStyledAttributes( attrs, R.styleable.SignatureView);<br>mPaintColor = attrArray.getColor(R.styleable.SignatureView_paint_color, 0);<br>attrArray.recycle();<br>}<br>}</p>
<p>//有三个参数，用于在XML布局中构造对象<br>public SignatureView(Context context, AttributeSet attrs, int defStyleAttr) {<br>super(context, attrs, defStyleAttr);<br>}<br>三个可进行绘制的方法</p>
<p>在自定义视图中，有三个函数可以重写用于界面绘制，在视图创建过程中，三个函数的执行顺序依次是：onLayout、onDraw、dispatchDraw。<br>1、onLayout(boolean changed, int left, int top, int right, int bottom) :<br>onLayout用于定位该视图在上级视图中的位置，从其参数中就可以看出来。由于该函数没有画布，因此只适合绘制现成的视图控件。<br>2、onDraw(Canvas canvas) :<br>自定义控件一般是重写onDraw方法，在画布中绘制各种图形。<br>3、dispatchDraw(Canvas canvas) :<br>dispatchDraw与onDraw的区别在于：onDraw在绘制下级视图之前，而dispatchDraw在绘制下级视图之后，所以如果不想自己的绘图被下级视图覆盖的话，就要在dispatchDraw中进行绘制操作。为方便记忆，只要是从ViewGroup衍生出的视图，都用dispatchDraw，其他小控件都用onDraw。</p>
<p>菜单Menu</p>
<p>Android的菜单分为两类：选项菜单和上下文菜单，默认使用选项菜单。菜单的布局文件存放在res/menu目录下，使用ADT新建一个Android工程，首页代码MainActivity中会自动生成onMenuOpened和onMenuItemSelected函数代码。<br>下面是选项菜单需要重写的方法：<br>onMenuOpened : 在菜单弹出时调用，一般无需重写<br>onMenuItemSelected : 在菜单项选择时调用，查看该方法的源码，会发现该方法内部做分支处理，判断如果是选项菜单则调用onOptionsItemSelected，如果是上下文菜单则调用onContextItemSelected。一般无需重写<br>onCreateOptionsMenu : 在页面打开时调用，需要重写指定菜单项目<br>onOptionsItemSelected : 在选项菜单的菜单项选中时调用，需要重写对不同菜单项做分支处理<br>onPrepareOptionsMenu : 在准备打开选项菜单时调用，一般无需重写<br>onOptionsMenuClosed : 在选项菜单关闭时调用，一般无需重写<br>AlertDialog</p>
<p>Android中最常用的对话框是AlertDialog，它可以完成常见的交互操作，如提示、确认、选择等等，然后就是进度对话框ProgressDialog<br>AlertDialog没有公开的构造函数，必须借助于AlertDialog.Builder才能完成参数设置。Builder的常用方法如下：<br>setIcon : 设置标题的图标。<br>setTitle : 设置标题的文本。<br>setCustomTitle : 设置自定义的标题视图。<br>–以上方法用于设置标题部分。注意setTitle和setCustomTitle只能设置其一，不能重复设置。<br>setMessage : 设置内容的文本。<br>setView : 设置自定义的内容视图。<br>setAdapter : 设置List方式的内容视图。使用较麻烦，一般不用。<br>setItems : 设置Spinner方式的内容视图。窗口显示与对话框模式的Spinner极为相似，没有底部的按钮，一旦选中某项就立即关闭对话框。<br>setSingleChoiceItems : 设置单选列表的内容视图。与setItems的区别在于有显示底部的交互按钮，并且每项右边有单选按钮。<br>setMultiChoiceItems : 设置多选列表的内容视图。底部有交互按钮，并且每项右边有复选按钮。<br>–以上方法用于设置内容部分。注意这些方法互相冲突，同时只能设置其一。<br>setPositiveButton : 设置肯定按钮的信息，如文本、点击监听器。<br>setNegativeButton : 设置否定按钮的信息，如文本、点击监听器。<br>setNeutralButton : 设置中性按钮的信息，如文本、点击监听器。<br>–以上方法用于设置交互按钮。</p>
<p>WindowManager<br>getDefaultDisplay : 获取默认的显示屏信息。通常用该方法获取屏幕分辨率<br>addView : 往窗口添加视图。第二个参数为WindowManager.LayoutParams对象。<br>updateViewLayout : 更新指定视图的布局参数。第二个参数为WindowManager.LayoutParams对象。<br>removeView : 往窗口移除指定视图。</p>
<p>TabBar<br>1、使用TabActivity。其中在布局文件中设置TabHost、TabWidget和RadioButton，在代码文件中应用TabActivity、TabSpec和CompoundButton。<br>2、使用ActivityGroup。将几个栏目的首页Activity都放入ActivityGroup，然后根据点击事件选择切换到哪个Activity。<br>3、使用FragmentActivity和Fragment。将几个栏目的首页Fragment都放入FragmentActivity，可自动响应点击事件。<br>其中TabActivity继承自ActivityGroup，目前Android声称TabActivity与ActivityGroup都已废弃，建议采用Fragment和FragmentManager来代替。从实现代码来看，TabActivity和ActivityGroup两种方式的代码量都较多，而FragmentActivity方式的代码就显得很简洁，所以博主也推荐第三种方式。</p>
<p>标题栏ActionBar<br>1、在AndroidManifest.xml中给activity设置无标题栏的主题，就关闭ActionBar。否则就显示<br><activity android:theme="@android:style/Theme.Holo.NoActionBar"><br>2、在styles.xml的当前主题中加入一个项android:windowNoTitle，为true时表示关闭ActionBar；为false表示显示<br><item name="android:windowNoTitle">true</item><br>3、在Activity代码的setContentView之前加入下面代码，就关闭ActionBar。否则就显示<br>requestWindowFeature(Window.FEATURE_NO_TITLE);<br>4、在Activity代码中获得ActionBar实例，调用该实例的hide方法表示关闭ActionBar；调用show方法表示显示<br>ActionBar actionBar = getActionBar();<br>if (actionBar != null) {<br>actionBar.hide();  //隐藏ActionBar<br>actionBar.show();  //显示ActionBar<br>}</p>
<p>ViewPager<br>下面是ViewPager的常用方法：<br>setAdapter : 设置ViewPager的适配器<br>setCurrentItem : 设置当前的页码，即默认打开ViewPager时显示哪一页的内容。<br>setOnPageChangeListener : 设置ViewPager的页面变化监听器。<br>ViewPager的适配器<br>ViewPager的监听器</p>
<p>ViewPager一般不监听每个页面项的点击事件，而是监听页面滑动的监听事件，对应的监听器类是OnPageChangeListener。该类的三个方法介绍如下：<br>onPageScrollStateChanged : 翻页状态改变时调用，状态参数取值说明为：0表示静止，1表示正在滑动，2表示滑动完毕。在翻页过程中，状态值变化依次为：正在滑动-&gt;滑动完毕-&gt;静止。<br>onPageScrolled : 在翻页过程中调用。该方法的三个参数取值说明为：第一个参数表示当前页面的序号；第二个参数表示当前页面偏移的百分比，最小值为0，最大值为1；第三个参数表示当前页面的偏移距离，单位px。<br>onPageSelected : 在页面选择时调用，该方法用得较多。位置参数表示当前页面的序号。</p>
<p>WaterfallGridView,StaggeredGridView,PinterestLikeAdapterView</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/07/24/N_Android11%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/24/N_Android11%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">Android开发整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-24 20:01:11" itemprop="dateCreated datePublished" datetime="2018-07-24T20:01:11+08:00">2018-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>做安卓开发也算是有一些时间了，一直都没有想过要整理一些东西，最近不是太忙，想着能整理一些，对自己也是一个提升吧。<br>我没有什么整理的头绪，也没有什么脉络，其实网上有很多好的博客整理的比较好，我顺便就抄写下来，也算是对自己的巩固吧。<br>Android项目目录结构<br>Activity：应用被打开时显示的界面<br>src：项目代码<br>R.java：项目所有的资源文件<br>Android.jar：Android的jar包，倒入此包方可使用Android的api<br>libs：导入第三方jar包<br>assets：存放资源文件，比如mp3，视频文件<br>bin：存放编译打包的文件<br>res：存放资源文件<br>drawable：存放图片文件<br>layout：存放布局文件<br>menu：定义菜单的样式<br>String.xml:存放字符串资源</p>
<p>Android的配置文件<br>指定应用的包名<br>package= “com.item.helloworld”<br>data/data/com.item.helloworld<br>应用生成的文件都在此路径<br>Android的四大组件使用前全部都需要在此清单文件中配置</p>
<p>常用的adb指令<br>adb start-server ：启动adb进程<br>adb kill-server: 杀死进程<br>adb divices :查看当前开发环境链接的设备<br>adb install xxx.apk 往模拟器安装apk<br>adb uninstall 包名： 删除模拟器中应用<br>adb shell ： 进入linux命令</p>
<p>常用布局：线性布局<br>LinerLayout<br>指定各个节点排列方向<br>android：orientation = “horizontal”<br>设置右对齐<br>android：layout_gravity=”right”<br>当竖直布局时，只能左右对齐和水平居中，顶部底部对齐竖直剧中无效<br>当水平对齐时，只能顶部底部对齐，和竖直居中<br>线性布局非常重要的一个属性：权重<br>android：layout_weight=’1’<br>权重：按照比例分配屏幕的剩余宽度或者高度</p>
<p>常见布局：相对布局<br>RelativeLayout<br>组件默认左对齐，顶部对齐<br>设置组件制定组件的右边<br>android:layout_toRightOf=”id/tv1”<br>设置右对齐父控件<br>android：layout_alignParentRight=”true”</p>
<p>帧布局：FrameLayout<br>默认组件都是左对齐和顶部对齐，每个组件相当于一个div</p>
<p>文件读写操作<br>Ram内存：运行内存，相当于电脑内存<br>Rom内存：内部存储空间，相当于电脑硬盘<br>sd卡：外部存储空间，相当于电脑移动硬盘<br>//持久化保存数据<br>File file = new File(“data/data/com.itheima.rwinrom/info.txt”);<br>FileOutputStream fos = new FileOutputStream(file);<br>fos.write((name + “##” + pass).getBytes());<br>fos.close();<br>读取数据前先检测文件是否存在<br>if(file.exists())<br>读取保存的数据，也是直接开文件输入流读取<br>File file = new File(“data/data/com.itheima.rwinrom/info.txt”);<br>FileInputStream fis = new FileInputStream(file);<br>//把字节流转换成字符流<br>BufferedReader br = new BufferedReader(new InputStreamReader(fis));<br>String text = br.readLine();<br>String[] s = text.split(“##”);</p>
<p>SharePreference<br>用于存储账号密码<br>往SharePrefreence写数据<br>拿到一个SharePreference对象<br>SharePrefrence sp = getSharePrefenrences(“config”,MODE_PRIVATE);<br>拿到编辑器<br>Editor ed = sp.edit();<br>写数据<br>ed.putBoolen(“name”,name)<br>ed.commit();<br>从SharedPreference里取数据<br>SharedPreferences sp = getSharedPreferences(“config”, MODE_PRIVATE);<br>//从SharedPreference里取数据<br>String name = sp.getBoolean(“name”, “”);</p>
<p>ListView<br>MVC结构<br>M：model模型层，要显示的数据集合<br>V：view试图层，用户看到的界面–ListView<br>C：controller控制层，操作数据如何显示—adapter对象</p>
<p>BaseAdapter</p>
<p>必须实现的两个方法</p>
<p>第一个</p>
<p>//系统调用此方法，用来获知模型层有多少条数据<br>@Override<br>public int getCount() {<br>return people.size();<br>}</p>
<p>第二个</p>
<p>//系统调用此方法，获取要显示至ListView的View对象<br>//position:是return的View对象所对应的数据在集合中的位置<br>@Override<br>public View getView(int position, View convertView, ViewGroup parent) {<br>System.out.println(“getView方法调用” + position);<br>TextView tv = new TextView(MainActivity.this);<br>//拿到集合中的元素<br>Person p = people.get(position);<br>tv.setText(p.toString());</p>
<p>//把TextView的对象返回出去，它会变成ListView的条目<br>return tv;<br>}</p>
<p>消息队列<br>主线程创建时，系统会同事创建消息队列对象（MessageQueue）和消息轮询器对象（Looper）<br>轮询器的作用，就是不停的检测消息队列中是否有消息（Message）<br>Looper一旦发现Message Queue中有消息，就会把消息取出来，然后把消息扔给Handler对象，Handler会调用自己HandleMessage方法处理这条消息<br>Handler handler = new Handler() {<br>主线程有一个消息轮询器looper，不断检测消息队列是否有新消息，如果发现有新消息，自动调用此方法，注意：此方法是主线程运行的<br>public void handleMessage(android.os.Message msg) {</p>
<p>}<br>}<br>在子线程中使用Handler对象往消息队列里发消息<br>创建消息对象<br>Message msg = new Message（）；<br>//消息的obj属性可以付给任意对象，通过这个属性可以携带数据<br>msg.obj = bm;<br>//what属性相当于一个标签，用于区分不同的消息，从而运行不同的代码<br>msg.what = 1<br>handler.sendMessage(msg);</p>
<p>Activity生命周期（掌握）</p>
<p>void onCreate()</p>
<p>Activity已经被创建完毕<br>void onStart()</p>
<p>Activity已经显示在屏幕，但没有得到焦点<br>void onResume()</p>
<p>Activity得到焦点，可以与用户交互<br>void onPause()</p>
<p>Activity失去焦点，无法再与用户交互，但依然可见<br>void onStop()</p>
<p>Activity不可见，进入后台<br>void onDestroy()</p>
<p>Activity被销毁<br>void onRestart()</p>
<p>Activity从不可见变成可见时会执行此方法</p>
<p>横竖屏写死<br>android:screenOrientation=”landscape”<br>android:screenOrientation=”portrait”<br>让系统的环境 不再去敏感横竖屏的切换。</p>
<p>android:configChanges=”orientation|screenSize|keyboardHidden”</p>
<p>进程优先级（掌握）</p>
<p>前台进程：拥有一个正在与用户交互的activity（onResume方法被调用）的进程<br>可见进程：拥有一个非前台，但是对用户可见的activity（onPause方法被调用）的进程<br>服务进程：拥有一个通过startService方法启动的服务的进程<br>后台进程：拥有一个后台activity（onStop方法被调用）的进程<br>空进程：没有拥有任何活动的应用组件的进程，也就是没有任何服务和activity在运行</p>
<p>样式与主题（熟悉）</p>
<p>样式与主题定义方式一样<br>样式用于布局文件中的组件<br>主题用于Activity</p>
<p>Fragment（重要）</p>
<p>用途：在一个Activity里切换界面，切换界面时只切换Fragment里面的内容<br>生命周期方法跟Activity一致，可以理解把其为就是一个Activity<br>fragment切换时会销毁旧的，再创建新的<br>定义布局文件作为Fragment的显示内容<br>//此方法返回的View就会被显示在Fragment上<br>@Override<br>public View onCreateView(LayoutInflater inflater, ViewGroup container,<br>Bundle savedInstanceState) {<br>// TODO Auto-generated method stub<br>//用布局文件填充成一个View对象，返回出去，那么就显示在Fragment上了<br>View v = inflater.inflate(R.layout.fragment01, null);<br>return v;<br>}<br>把Fragment显示至指定ViewGroup中</p>
<p>//把fragment显示至界面<br>//new出fragment对象<br>Fragment01 fg = new Fragment01();<br>FragmentManager fm = getFragmentManager();<br>//开启事务<br>FragmentTransaction ft = fm.beginTransaction();<br>//把fragment对象显示到指定资源id的组件里面<br>ft.replace(R.id.fl, fg);<br>ft.commit();<br>生命周期（重要）</p>
<p>fragment切换时旧fragment对象会销毁，新的fragment对象会被创建<br>在drawable目录下定义xml文件，子节点为animation-list，在这里定义要显示的图片和每张图片的显示时长</p>
<animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false">
<item android:drawable="@drawable/g1" android:duration="200" />
<item android:drawable="@drawable/g2" android:duration="200" />
<item android:drawable="@drawable/g3" android:duration="200" />
</animation-list>
ImageView iv = (ImageView) findViewById(R.id.iv);
//把动画文件设置为imageView的背景
iv.setBackgroundResource(R.drawable.animations);
AnimationDrawable ad = (AnimationDrawable) iv.getBackground();
//播放动画        
ad.start();

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/07/24/M_Swift52%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/24/M_Swift52%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">工作总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-24 20:00:01" itemprop="dateCreated datePublished" datetime="2018-07-24T20:00:01+08:00">2018-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个星期本来打算搞点餐的项目的，没想到就这样搁置了，周一的时候想了一下，现在我已经不想了，我想这周末没事的时候可以跟我一个同学一起讨论一下，毕竟闲着也是闲着。<br>周一搞了一下那个东西以后，基站边界划分的问题也就出来了，我也没时间去考虑别的问题，直到今天周四，本来明天写这些东西的，我想了下也就算了，还是今天写吧。明天不知道又会有什么事。<br>但是我想我那个项目的事情是不能停的，我会继续写的，我如果有一天我写出来了，我想我会得到相应的回报的，至少要对自己有信心，是吧。<br>目前看来，我对大数据的能力越来越不足，我将很难担当起大数据的项目。从一开始我就不是一个领导的身份。我想接下来我要好好审视自己了，如何去做这些让人头疼的事情是一个问题。做不好怎么办，我很担心，我一直在弱化我自己的位置，不知道当有一天到来的时候，我能问心无愧的告诉自己，我付出了，我不后悔。<br>关于学习，这事那事的东西缠绕着，我也没有去学习Python，但是很多年轻人都在前赴后继的在这条学习的路上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/25/M_Swift88%E5%B0%8F%E5%B0%8F%E7%9A%84%E4%B8%80%E5%A4%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/25/M_Swift88%E5%B0%8F%E5%B0%8F%E7%9A%84%E4%B8%80%E5%A4%A9/" class="post-title-link" itemprop="url">小小一天</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-25 17:19:52" itemprop="dateCreated datePublished" datetime="2018-06-25T17:19:52+08:00">2018-06-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从昨天的思考，到今天，我想是时候说一下无聊的东西了，这样一天天的，是的，没事做的心情，继续写一点东西吧，谈谈人生，谈谈理想，说一些胡话，就算是聊以慰藉吧。<br>日子一天一天，很快，不知道这样是好是坏，我们总是打算着很多事情，但是有的时候到头来却是一场空，我不知道这样的日子还能多久，我也不想，但是我想，我需要写点东西，我需要让人生充实，我想有的人可以用很多东西来写东西，有的人就是这样。<br>哈哈，感觉头绪有点乱，真的不知道写什么好。天气热的要死，一出门，就是热浪腾腾。今天倒是还好，有点阴天，雾茫茫的，总算是没有大太阳了。<br>好像在说一堆没用的事情，但是人生就是这样，你不知道你会在哪里遇见什么人，你也不知道下一个路口在什么地方，总之，你就这样走着，这样活着，我们说是行尸走肉，其实我们每个人何尝又不是，每个人在社会上其实都是活着，别说你意义很大，其实你处的位置决定了你的作为，所以，不必惊讶，也不必低沉，其实我们都一样。<br>有钱人过的生活我们是享受不了，但是有钱人也有我们不曾有过的焦虑，其实都一样，他们说他们很忙，也好吧，其实说是有意义，当我们真正到老了，真的不知道是不是还是乐观的说有什么意思。<br>真的我们也许在有的时候会很天真，有的时候又很无聊，生活就是这样。<br>好了，不知道又胡扯了什么，今天看了一个新闻，说有声阅读将成为下一个风口，我想确实有一定的作用，但是我们不可否认，当我们没有事情可以做的时候，新闻称为了我们最大的慰藉，这有着一股神奇的力量，我想这有点可怕，我想现在的新闻变了，变成我们不认识的样子，真的是的，我现在发现，我打字真的是又点查，工作这么多年了，竟然打字一直都这样差，真的是有点说不过去，不过也就这样吧，平时写代码，真的不是太纠结打字速度的，但是当你写文字的时候，对于打字这个问题，还是比较注重的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">266</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
