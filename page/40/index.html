<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/40/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/40/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/B_OC9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/B_OC9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 23:14:52" itemprop="dateCreated datePublished" datetime="2016-07-30T23:14:52+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>OC中的内存管理</p>
</blockquote>
<p>alloc+init 方式创建对象, 一般情况下在堆上上,使用完一定要释放<br>手动内存管理<br>自动内存管理(自动引用计数-ARC)<br>如何内存管理方式切换到手动内存管理?<br>工程配置–&gt;TARGETS-&gt;Build Setting-&gt; 搜索 counting,  设置为NO</p>
<blockquote>
<p>内存管理中常用的方法</p>
</blockquote>
<p>alloc+init<br>//1.alloc+init<br>//alloc: 为对象申请空间,把这块空间全部初始化为0<br>//alloc申请的对象一般情况下都在堆空间,必须考虑释放的问题<br>//init 初始化这个对象<br>Dog *princess = [[Dog alloc] init];<br>dealloc+release<br>retain+retainCount</p>
<blockquote>
<p>引用计数这种内存管理方式</p>
</blockquote>
<p>//获取对象被使用的次数<br>NSLog(@”count=%lu”,princess.retainCount);<br>//以后内存管理中有问题的<br>//retain: 让对象引用次数+1<br>//retain的对象也要release<br>[p release];<br>NSLog(@”count=%lu”,princess.retainCount);<br>//释放放在最后<br>//release作用:<br>//  如果retainCount&gt;1 说明有多个人在使用这个对象,不会释放,对象引用次数-1<br>//  如果retianCount==1<br>//  最后使用的”人”释放这个对象<br>//      调用dealloc真正释放对象<br>[princess release];<br>NSMutableString *str = [[NSMutableString alloc] initWithString:@”的麻烦了看什么地方了开始免费立刻马上离开父母萨洛克没放到里面是打发来看马萨拉蒂方面撒地方可拉伸的佛罗伦萨地方了”];<br>//特别值得注意的问题<br>//  最好千万不要在对象release之后使用对象<br>//什么是释放:<br>//  释放是失去了这块内存的使用权(内存还在)<br>//      一旦释放, 别人有可能使用这块内存<br>//      咱们在使用的就会出现问题<br>//[princess show];<br>copy+mutableCopy<br>//问题:<br>//  retain两个指针, 只有一个对象<br>//  copy复制这个对象<br>//  效果:  两个指针指向不同的对象<br>//  copy 返回不可变对象<br>//  mutableCopy返回可变对象<br>NSMutableString *pname = [name mutableCopy];</p>
<blockquote>
<p>内存管理原则:黄金法则<br>如果你对一个对象使用了 alloc,retain,copy/mutableCopy, 使用完这个对象之后需要调用对应的realese或autorelease<br>代码中alloc和release成对出现的retain和release也是成对出现的</p>
</blockquote>
<blockquote>
<blockquote>
<p>代码中出现的各种内存管理情况</p>
</blockquote>
</blockquote>
<p>(0)如果在方法内部定义了一个对象指针,指向了alloc申请的对象<br>需要在方法结束前释放这个对象</p>
<blockquote>
<p>init中为对象指针(类的实例变量)的申请对象</p>
</blockquote>
<p>需要在dealloc方法中释放 (重点)<br>//需求: 创建车的同时添加引擎<br>-(id)init<br>{<br>if(self = [super init])<br>{<br>//考虑到释放问题<br>//类中对象指针一般在init中申请对象<br>//  在dealloc中释放对象<br>_engine = [[Engine alloc] init];<br>//NSString *str = [[NSString alloc] init];<br>//[str release];<br>}<br>return self;<br>}<br>-(void)dealloc<br>{<br>NSLog(@”Car dealloc”);<br>[_engine release];<br>//这句放在最后<br>[super dealloc];<br>}</p>
<blockquote>
<p>对象指针的setter方法</p>
</blockquote>
<p>//_engine实现设置方法<br>-(void)setEngine:(Engine *)engine<br>{<br>//以前的写法<br>//_engine = engine;<br>//传入的指针和保存指针相同,返回即可<br>if(_engine == engine)<br>{<br>return;<br>}<br>//旧的对象不用了, 立即释放<br>[_engine release];<br>//多一个指针指向engine对象<br>//引用次数+1,调用retian方法<br>_engine = [engine retain];<br>}</p>
<blockquote>
<p>对象指针的getter方法</p>
</blockquote>
<p>//_engine实现获取方法<br>-(Engine *)engine<br>{<br>//以前的实现<br>//return _engine;<br>//retain: 返回的对象类外的指针指向, 多了一个使用, 引用+1<br>//  autorelease谁使用,谁释放<br>//      不能用release, 立即使用<br>return [[_engine retain] autorelease];<br>}</p>
<blockquote>
<p>各种实例变量的property (重点)</p>
</blockquote>
<p>//使用property实例变量添加getter和setter<br>// 一般情况, NSString 使用copy作为属性修饰符<br>//copy, 把传入的字符串拷贝一个份新的<br>//字符串,字典,数组用copy最好<br>@property (copy) NSString *type;<br>//assign表示直接赋值, 不retain也不copy<br>//  默认是assign, assgin可以不写<br>//@property (assign) float price;<br>@property float price;<br>//retain表示实现的setter中添加retain,getter也会添加retain<br>@property (retain) Engine *engine;</p>
<p>//代理设计模式中<br>//  代理的属性修饰符必须是assgin,不能是retain,否则会引起无法释放的问题<br>@property (assign) id delegate;</p>
<blockquote>
<p>取消线程保护 nonautomic</p>
</blockquote>
<p>//nonatomic取消多线程保护<br>//1.什么是多线程(多任务)<br>// 迅雷下载(界面响应用户点击,下载数据)<br>//2.为啥要加这一句啊<br>//  多线程保护比较耗时, 取消提供代码速度<br>@property (nonatomic) float speed;</p>
<blockquote>
<p>类方法创建对象如何写?</p>
</blockquote>
<p>//类方法创建的对象无需释放, 也不能释放<br>创建对象的方法,类方法<br>+(id)car<br>{<br>//干两件事情<br>Car *car = [[Car alloc] init];<br>//if(car)<br>//{<br>//设置car的属性<br>//}<br>//alloc和autorelease对应起来<br>return [car autorelease];<br>}</p>
<blockquote>
<p>数组中的添加对象内存管理  NSArray</p>
</blockquote>
<p>//数组被释放的时候会给数组中每个对象发送release<br>[array release];</p>
<blockquote>
<p>字符串的内存管理</p>
</blockquote>
<p>//  特点: 特立独行,有性格<br>//字符串常量的引用数是极大值,不需要释放<br>//总结:<br>以alloc创建的字符串最后使用release释放<br>字符串常量和以类方法创建的字符串不需要释放</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/B_OC7plist,%E5%BD%92%E6%A1%A3%E5%92%8CJson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/B_OC7plist,%E5%BD%92%E6%A1%A3%E5%92%8CJson/" class="post-title-link" itemprop="url">plist,归档和Json</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 22:54:39" itemprop="dateCreated datePublished" datetime="2016-07-30T22:54:39+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>数据持久化简介</p>
</blockquote>
<p>文件:    最常用的最基础的存储数据的方式<br>plist,xml,json    表示数据的某种格式<br>数据库:        海量的数据(省上所有人的电话信息)存储到数据库中<br>SQL Server 2000, mysql, Oracle<br>云端存储:        数据都存储的网络上, 安全性好, 跨设备,跨平台</p>
<blockquote>
<p>plist文件</p>
</blockquote>
<p>用途比较多<br>本质上来说是 Property List file, 属性列表文件<br>存储格式:  数据都是由字典,数组,字符串构成的<br>2.2 如何创建plist文件<br>File-&gt;OS X-Resource–&gt; Proerty List<br>2.3 plist文件的读取和写入<br>//如何读取这个plist文件???<br>NSString *path = @”/Users/mac/Desktop/oc7-持久化存储/PlistUseDemo/PlistUseDemo/student.plist”;<br>//plist根结点只有两种类型, 数组和字典<br>//  分别使用NSArray和NSDictionary读取plist<br>NSDictionary *dict = [[NSDictionary alloc] initWithContentsOfFile:path];<br>//输出所有的班级的信息<br>//NSArray *classList = [dict valueForKey:@”classes”];<br>NSArray *classList = dict[@”classes”];<br>for (NSDictionary *classDict in classList) {<br>}<br>//  可以把一个数组或者字典写入到plist中<br>//参数1: 传入一个路径<br>//参数2: 表示是否安全的写入<br>[classList writeToFile:@”/Users/mac/Desktop/classList.plist” atomically:YES];</p>
<blockquote>
<p>归档</p>
</blockquote>
<p>使用归档, 可以直接把一个对象保存到文件中</p>
<p>//归档的使用<br>//作用: 对象保存到文件中<br>//相比plist: plist使用简单, 不能存储自定义对象<br>//  归档可以存储任意类型对象<br>NSArray *array = [[NSArray alloc] initWithObjects:@”小二”,@”三少”,@”四娘”,@”跳舞大神”, nil];<br>//通过归档的形式存储到文件中<br>//设置文件名<br>NSString *path = @”/Users/mac/Desktop/people.data”;<br>//NSKeyedArchiver专门用于归档的类<br>//参数1: 传入需要保存的对象<br>//参数2: 传入文件路径<br>BOOL b = [NSKeyedArchiver archiveRootObject:array toFile:path];<br>//把对象从文件中恢复出来===解档<br>//参数1: 传入保存了对象文件<br>//返回值: 返回保存的对象<br>//  类型原来存储的是什么类型, 用什么类型接收<br>NSArray *readArray = [NSKeyedUnarchiver unarchiveObjectWithFile:path];<br>for(NSString *str in readArray)<br>{<br>}</p>
<blockquote>
<p>自定义对象的归档和解档</p>
</blockquote>
<p>//归档<br>NSString <em>path = @”/Users/mac/Desktop/dog.data”;<br>//****</em>  自定义的对象不能直接归档, 会出现崩溃<br>//*****  需要告诉系统我们对象应该如何归档<br>//          自己类中添加一些指定的方法</p>
<p>[NSKeyedArchiver archiveRootObject:huaer toFile:path];</p>
<p>//解档刚才存入的对象<br>Dog *newDog = [NSKeyedUnarchiver unarchiveObjectWithFile:path];<br>NSLog(@”–&gt; %@ %@ %f %@”,<br>      newDog.nickname,<br>      newDog.gender,<br>      newDog.weight,<br>      newDog.type);</p>
<p>//告诉系统, 这个对象应该如何编码<br>//  如果没有加这个方法,自定义对象归档的时候会奔溃</p>
<ul>
<li>(void)encodeWithCoder:(NSCoder *)aCoder<br>{<br>  //把类中的对象指定一个key, 编码到文件中<br>  [aCoder encodeObject:self.nickname forKey:@”nickname”];<br>  [aCoder encodeObject:self.gender forKey:@”gender”];<br>  [aCoder encodeObject:[NSNumber numberWithFloat:self.weight] forKey:@”weight”];<br>  [aCoder encodeObject:self.type forKey:@”type”];</li>
</ul>
<p>}</p>
<p>//告诉系统, 这个对象应该如何解码<br>//  如果没有加这个方法,自定义对象解档的时候会奔溃</p>
<ul>
<li>(id)initWithCoder:(NSCoder *)aDecoder<br>{<br>  if (self = [super init]) {<pre><code>  //对数据进行解码操作
  self.nickname = [aDecoder decodeObjectForKey:@&quot;nickname&quot;];
  self.gender = [aDecoder decodeObjectForKey:@&quot;gender&quot;];
  self.weight = [[aDecoder decodeObjectForKey:@&quot;weight&quot;] floatValue];
  self.type = [aDecoder decodeObjectForKey:@&quot;type&quot;];
  
</code></pre>
  }<br>  return self;<br>}</li>
</ul>
<blockquote>
<p>Json解析</p>
</blockquote>
<p>Javascript Object Notation 简写<br>网络常用一种表示数据或交换数据的格式<br>4.2 Json数据格式<br>[]表示一个数组, 对应NSArray<br>{}表示一个字典, 对应NSDictionary<br>key:value  表示一个键值对<br>“str”    表示一个字符串   NSString<br>90        表示一个数字       NSNumber<br>,  表示并列的数据<br>4.3 Json格式的读取和使用<br>//如何解析JSON, 解析后如何获取其中数据<br>NSString *path = @”/Users/mac/Desktop/1422带课/oc7-持久化存储/topic.txt”;<br>//JSON先读取到程序中(NSString,NSData)<br>NSData *data = [[NSData alloc] initWithContentsOfFile:path];<br>//OC提供专门用于JSON解析的类<br>//NSJSONSerialization<br>//功能: 把NSData类型JSON数据转化为字典或者数组<br>//参数1: 需要解析的JSON数据<br>//参数2: 传入一个选项<br>//参数3: 错误<br>//返回值: 如果JSON顶层结点是[],用NSArray接收<br>//       如果顶层结点是{}, 用NSDictionary接收<br>NSArray *array = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/B_OC6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/B_OC6%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E7%B1%BB/" class="post-title-link" itemprop="url">OC文件和目录管理类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 22:44:56" itemprop="dateCreated datePublished" datetime="2016-07-30T22:44:56+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>NSFileManager 文件或目录管理类(重点)</p>
</blockquote>
<p>1.1 创建NSFileManager的对象<br>//创建对象<br>//默认用于创建对象方法<br>//defaultManager创建出对象都是同一个对象<br>//单例模式: 有时候想让让一个类只能创建一个对象<br>NSFileManager *fm = [NSFileManager defaultManager];<br>1.2 获取目录下的所有文件和目录<br>//(2)知道某个目录下都有哪些文件和目录<br>//细节: 不会显示子目录<br>NSArray *array = [fm contentsOfDirectoryAtPath:@”/Users/mac/Desktop/dir” error:nil];<br>//显示所有文件包括子目录<br>array = [fm subpathsOfDirectoryAtPath:@”/Users/mac/Desktop/dir” error:nil];<br>1.3 创建目录, 创建文件<br>实例: 创建 /Users/mac/Desktop/dir/hello<br>//参数2: 表示是否创建中间目录<br>BOOL b;<br>b = [fm createDirectoryAtPath:@”/Users/mac/Desktop/dir/hello” withIntermediateDirectories:YES attributes:nil error:nil];<br>NSLog(@”b = %d”,b);<br>b = [fm createFileAtPath:@”/Users/mac/Desktop/dir/saozi.txt” contents:nil attributes:nil];<br>NSLog(@”b = %d”,b);<br>1.4 复制文件, 移动文件, 删除文件<br>//参数1: 源文件<br>//参数2: 目标文件<br>b = [fm copyItemAtPath:@”/Users/mac/Desktop/dir/saozi.txt” toPath:@”/Users/mac/Desktop/dir/hanzi.txt” error:nil];<br>//移动文件<br>BOOL b = [fm moveItemAtPath:@”/Users/mac/Desktop/dir/saozi.txt” toPath:@”/Users/mac/Desktop/dir/hello/saozi.txt” error:nil];<br>BOOL b = [fm removeItemAtPath:@”/Users/mac/Desktop/dir/hanzi.txt” error:nil];<br>1.5 判断文件是否存在<br>//(5)判断文件是否存在<br>BOOL b =[fm fileExistsAtPath:@”/Users/mac/Desktop/dir/dict.txt”];</p>
<blockquote>
<p>文件读写操作 NSFileHandle</p>
</blockquote>
<p>2.1 打开文件<br> 细节：打开应选择的模式；<br> 1.为了写文件fileHandleForWritingAtPath<br> 2.为了读文件fileHandleForReadingAtPath<br>(1)创建对象打开文件<br>NSFileHandle *fh = [NSFileHandle fileHandleForReadingAtPath:@”/Users/mac/Desktop/dir/123.txt”];<br>if(fh == nil)<br>{<br>    NSLog(@”文件打开失败”);<br>    return 1;<br>}<br>2.2 读取文件数据<br>//(2)读取文件数据<br>//读取指定长度的数据<br>//一直读取直到文件末尾<br>//  NSData 表示二进制的数据<br>NSData *data = [fh readDataOfLength:100];<br>//读取出得二进制数据转化为字符串<br>NSString *info  =[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];<br>2.3 写文件<br>//写入数据<br>NSString *str = @”好吃不过饺子,hao wan bu guo sao zi”;<br>//转化<br>NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];<br>//清空文件内容<br>//[fh truncateFileAtOffset:0];<br>//文件读写位置设置到文件的末尾<br>[fh seekToEndOfFile];<br>[fh writeData:data];</p>
<p>2.4 移动文件读写位置<br>//文件读写位置设置到文件的末尾<br>[fh seekToEndOfFile];</p>
<blockquote>
<p>NSValue和NSNumber的使用</p>
</blockquote>
<p>int a=10;<br>int b=20;<br>//完成了基本数据类型到对象转化<br>NSNumber *num1 = [NSNumber numberWithInt:a];<br>NSNumber *num2 = [NSNumber numberWithInt:b];<br>NSArray *array = [[NSArray alloc] initWithObjects:num1,num2,nil];<br>//需求: 把一个结构体变量存储到NSArray中?<br>//思考:   把一个结构体变量转化为对象 NSValue<br>typedef struct Person{<br>    int age;<br>    float height;<br>}Person;<br>Person zhangsan = {18,1.77};</p>
<p>//作用: 把C的类型的数据转化为NSValue类型<br>//参数1:  数据的地址<br>//参数2:  数据的类型<br>//@encode作用把类型转化为字符串<br>NSValue *value = [[NSValue alloc] initWithBytes:&amp;zhangsan objCType:@encode(Person)];<br>NSMutableArray *marr = [[NSMutableArray alloc] init];<br>[marr addObject:value];</p>
<p>Person newPerson;<br>//从NSValue中解析出存储的数据<br>[value getValue:&amp;newPerson];</p>
<blockquote>
<p>NSDate的使用</p>
</blockquote>
<p>(1)获取当前时间<br>NSDate *date = [NSDate date];<br>//时区概念 +8区<br>(2)时间格式化输出<br>NSDateFormatter *df = [[NSDateFormatter alloc] init];<br>//设置时间的格式<br>[df setDateFormat:@”yyyy/MM/dd HH:mm:ss S”];<br>NSString *dateString = [df stringFromDate:date];<br>(3)获取年,月,日<br> 设置需要的格式<br>(4)计算某个操作所消耗的时间–计算时间差<br>NSDate *beginDate = [NSDate date];<br>long sum=0;<br>for (long i=0; i&lt;1000000000; i++) {<br>    sum = sum+i;<br>}<br>NSDate *endDate = [NSDate date];<br>double interval = [endDate timeIntervalSinceDate:beginDate];</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/B_OC5setter%E5%92%8Cgetter%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/B_OC5setter%E5%92%8Cgetter%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">OC @property</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 22:36:08" itemprop="dateCreated datePublished" datetime="2016-07-30T22:36:08+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>OC是一门面向对象的语言<br>面向对象: 封装, 继承,    多态</p>
</blockquote>
<blockquote>
<p>能不能让编译器自动生成getter和setter方法的原型?</p>
</blockquote>
<p>使用 @property帮我们生成getter和setter方法的声明<br>(1)形式1<br>//以名字name为例<br>-(void)setName:(NSString *)n;<br>-(NSString *)name;<br>(2)形式2<br>@property NSString * name;</p>
<blockquote>
<p>能不能让编译器自动生成getter和setter方法的实现(早期版本)</p>
</blockquote>
<p>使用 @synthesize 帮我们生成getter和setter方法的实现<br>(1)形式1<br>//以名字name为例<br>//name的设置方法<br>-(void)setName:(NSString *)n<br>{<br>    NSLog(@”setName”);<br>    name = n;<br>}<br>//name的获取方法<br>-(NSString *)name<br>{<br>    //返回name是实例变量name<br>    return name;<br>}<br>(2)形式2<br>@synthesize name;</p>
<blockquote>
<p>实例变量设置为只读的</p>
</blockquote>
<p>@property (readonly) NSString *sex;</p>
<blockquote>
<p>指定getter方法和setter方法的方法名?</p>
</blockquote>
<p>@property (getter = isShow,<br>           setter = changeShow:) BOOL show;</p>
<blockquote>
<p>不同类型的实例变量的property如何写</p>
</blockquote>
<p>对于字符串和对象有特殊的处理<br>添加property<br>nonatomic 作用取消线程保护,提高代码执行速度<br>@property (nonatomic) int age;<br>copy 表示拷贝对象<br>@property (nonatomic,copy) NSString *name;<br>retin 表示持有对象<br>@property (nonatomic,retain) Eye *eye;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/B_OC4%E5%AD%97%E5%85%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/B_OC4%E5%AD%97%E5%85%B8/" class="post-title-link" itemprop="url">OC字典</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 22:29:28" itemprop="dateCreated datePublished" datetime="2016-07-30T22:29:28+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p> 创建初始化</p>
</blockquote>
<p>//参数格式: value1,key1,  value2,key2, …..<br>NSDictionary *dict = [[NSDictionary alloc] initWithObjectsAndKeys:<br>@”zhangsan,B,13611112222”, @”zhangsan”,<br>@”lisi,G,1101101101110”, @”lisi”,<br>nil];</p>
<blockquote>
<p>使用其中对象</p>
</blockquote>
<p>NSString *str = [dict objectForKey:@”lisi”];</p>
<blockquote>
<p>快速遍历</p>
</blockquote>
<p>//细节1: 使用forin获取到的都是key,不是值<br>//细节2: 使用字典, 存进去是某个顺序, 取出来不一定是这个顺序<br>for (NSString *key in dict) {<br>NSString *value = [dict objectForKey:key];<br>NSLog(@”key = %@, value = %@”,key,value);<br>}</p>
<blockquote>
<p>==NSMutableDictionary==</p>
</blockquote>
<p>NSMutableDictionary类继承与NSDictionary</p>
<blockquote>
<p>创建对象</p>
</blockquote>
<p>NSMutableDictionary *mdict = [[NSMutableDictionary alloc] init];</p>
<blockquote>
<p>添加或替换</p>
</blockquote>
<p>//细节: 如果这个key不存在, 相当于字典中添加一个对象<br>//如果key存在, 则会覆盖这个key对应的值<br>[mdict setValue:@”zhangsan,27” forKey:@”zs”];<br>[mdict setValue:@”lisi,30” forKey:@”ls”];</p>
<blockquote>
<p>移除对象</p>
</blockquote>
<p>[mdict removeObjectForKey:@”ww”];<br>[mdict removeAllObjects];</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/B_OC3%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/B_OC3%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">OC数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 22:25:41" itemprop="dateCreated datePublished" datetime="2016-07-30T22:25:41+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p> 创建初始化</p>
</blockquote>
<p>NSArray *array = [[NSArray alloc] initWithObjects:@”z”,@”l”,@”w”,nil];<br>NSArray *array2 = [[NSArray alloc] initWithArray:array];<br>NSString *str1 = [array objectAtIndex:1];    //不要越界,会崩溃</p>
<blockquote>
<p>快速遍历</p>
</blockquote>
<p>long count = array.count;<br>for(long i=0; i&lt;count; i++)<br>for(NSString *s  in  array)</p>
<blockquote>
<p>查找指定对象</p>
</blockquote>
<p>long loc = [array indexOfObject:@”lishi”];</p>
<blockquote>
<p>==NSMutableArray==</p>
</blockquote>
<p>NSMutableArray继承自NSArray, 使用NSArray的所有方法</p>
<blockquote>
<p>创建对象</p>
</blockquote>
<p>NSMutableArray *marr = [[NSMutableArray alloc] init];<br>NSMutableArray *marr = [NSMutableArray array];</p>
<blockquote>
<p>添加对象</p>
</blockquote>
<p>[marr addObject:str1];</p>
<blockquote>
<p>插入对象</p>
</blockquote>
<p>[marr insertObject:@”zhuge” atIndex:0];</p>
<blockquote>
<p>移除对象</p>
</blockquote>
<p>[marr removeObject:@”zhuge”];<br>[marr removeObjectAtIndex:0];</p>
<blockquote>
<p>替换对象</p>
</blockquote>
<p>[marr replaceObjectAtIndex:0 withObject:@”ouyang”];</p>
<blockquote>
<p>排序</p>
</blockquote>
<p>[marr sortUsingSelector:@selector(mycompare:)];</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/B_OC2%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/B_OC2%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">OC字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 22:24:37" itemprop="dateCreated datePublished" datetime="2016-07-30T22:24:37+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>创建字符串对象</p>
</blockquote>
<p>NSString *str = @”hello world”;<br>//从C的字符串创建一个字符串对象<br>NSString *str2 = [[NSString alloc] initWithUTF8String:”tian qi bu cuo o”];<br>NSString *str2 = [NSString<br>                  stringWithUTF8String:”tian qi bu cuo o”];<br>//从其他数据生成字符串对象<br>NSString *str3 = [[NSString alloc] initWithFormat:@”zhangsan %d %c”,age,sex];<br>//从另外一个字符串对象,创建字符串对象<br>NSString *str4 = [[NSString alloc] initWithString:str3];</p>
<blockquote>
<p>计算长度</p>
</blockquote>
<p>long length=[str length]</p>
<blockquote>
<p>比较字符串</p>
</blockquote>
<p>BOOL a=[str1 isEqualToString str2];<br>int r=[str1 compare str2];</p>
<blockquote>
<p>查找子串</p>
</blockquote>
<p>NSRstring range=[str rangeOfString substr];</p>
<blockquote>
<p>提取字符和字符串</p>
</blockquote>
<p>unichar c=[str characterAtInder :4]<br>NSString *subetring=[str substringWithRange:range];</p>
<blockquote>
<p>转换</p>
</blockquote>
<p>int num=[str intValue]</p>
<blockquote>
<p>从文件生成字符串</p>
</blockquote>
<p>NSString *str10=@”/Users/student/Desktopdict.txt”;<br>NSString *f=[[NSString alloc]initWithContentsOfFile:str10 encoding:NSUTF8StringEncoding error:<br>             nil];</p>
<blockquote>
<p>==NSMutableString==</p>
</blockquote>
<p>&lt;1&gt; 创建对象<br>&lt;2&gt; 复制(设置字符串)<br>&lt;3&gt; 连接(附加)<br>&lt;4&gt; 插入<br>&lt;5&gt; 删除<br>&lt;6&gt; 替换</p>
<blockquote>
<p>== 字符串处理相关</p>
</blockquote>
<p>&lt;1&gt; 字符串分割    , 使用NSString的componentsSeparatedByString<br>NSArray *arr = [str componentsSeparatedByString:@” “];<br>&lt;2&gt; 数组合并为字符串 ,使用NSArray的componentsJoinedByString<br>NSString *comStr = [arr componentsJoinedByString:@”—“];</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/B_OC1%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/B_OC1%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">OC 类和对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 21:59:39" itemprop="dateCreated datePublished" datetime="2016-07-30T21:59:39+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Objective-c是c语言的母集合，它的原意就是在原始的c语言的主体上加入面向对象的特性。<br>1、面向对象和面向过程<br>面向对象和面向过程是编程的两种思考方式。面向对象，简称OOP，它是以事物为中心，参与事件的事物是核心，完成事件只是事物的一个小任务。面向过程，简称OPP，它是以事件为中心，事件是核心，列出了完成事件的每一个步骤，一步一步完成。也就是面向对象侧重于从问题在寻找客体、客体的作用。客体间的关系即“谁”、“做什么”、“怎么做”，面向过程侧重于问题的分解即“事件怎么做”。<br>2、类和对象<br>（1）类是一组具有相同（特征）属性和行为（功能）的事物的集合（抽象）。对象就是类的具体实现。世间万物皆对象。类其实就是一种数据类型，它的变量就是对象。<br>（2）类的定义<br>在OC中，类的定义分两部分：接口部分和实现部分；<br>接口部分（interface）：声明了类与父类的名字、方法是实例变量。接口文件以.h为后缀。<br>例如 Student.h        接口文件<br>@interface Student : NSObject      //NSObject是继承的父类<br>{<br>@public  //访问修饰符<br>    //以下是实例变量的声明<br>    NSString * name;   //姓名<br>    int age;                   //年龄<br>    NSString * address;//地址<br>    NSString * hobby; //爱好<br>}<br>//是方法的声明<br>-(void) sayHi;   //打招呼的方法<br>-(void) eat;       //吃饭的方法<br>-(void) walk;    //走的的方法<br>实现部分（implementation）：包含了方法的实现，真正意义上定义了类的行为。实现文件以.m为后缀。<br>注意：<br>编译器不要求将接口文件和实现文件的代码放在不同的文件中。每一个类用一对接口/实现源文件是一个良好的习惯。一个文件中可以声明和定义多个类。<br>如果类之间没有什么关系，最好不要把不同的类放在同一个文件书写。<br>例如 //Student.m   实现文件<br>#import<br>@implementation Student<br>//以下是方法的实现<br>-(void) sayHi   //打招呼的方法<br>{<br>    NSLog(@”我是来自%@的%@，今年%d岁，喜欢%@”,address,age,name,hobby);<br>}<br>-(void) eat       //吃饭的方法<br>{<br>    NSLog(@“%@也得吃饭。”,name);<br>}<br>（3）对象的创建和使用<br>1&gt;对象的创建<br>内存分配：为对象动态的分配内存地址。<br>初始化：在内存中填上的初始值。<br>例如：Student * stu =[[Student alloc] init];<br>说明：向类发送alloc消息，就是为该类分配一块足够大内存，用于存放实例变量，同时初始化内存，填上的初始值。<br>2&gt;对象的赋值使用<br>例如：//main函数<br>#import “Student.h”<br>int main (int argc, const char * argv[])<br>{<br>    @autoreleasepool {<br>        //创建一个学生对象<br>        Student * student = [[Student alloc] init];<br>        student-&gt;name = @”孙悟空”;//为姓名赋值<br>        student-&gt;age = 500;      //为年龄赋值<br>        student-&gt;address = @”傲来国花果山”;//为地址赋值<br>        student-&gt;hobby =@”游山玩水”;//为爱好赋值<br>        //调用打招呼的方法<br>        [student sayHi];<br>    }<br>    -&gt;赋值必须实例变量的修饰符是@public。实例变量的修饰符还有@protected和@private，系统默认实例变量的类型是@protected，对于这两种类型的实例变量，我们需要调用方法为其赋值或者取值。<br>    广义上讲为实例变量赋值的方法成为设置器，取出实例变量的方法成为访问器。<br>    设置器、访问器说明：<br>    1. 设置器命名: set+首字母大写的实例变量名  如：-(void)setAge:(int)newAge<br>    2. 设置器参数不要与实例变量重名。<br>    3. 读取器:与实例变量名同名，并且返回类型与实例类型一致。<br>    缺点：<br>    实例变量越多，编写就越麻烦。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/A_C1%E7%BB%88%E7%AB%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/A_C1%E7%BB%88%E7%AB%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">终端的一些常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 21:49:10" itemprop="dateCreated datePublished" datetime="2016-07-30T21:49:10+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文件系统 : </p>
</blockquote>
<p>在类unix中，一切皆文件，无论是文档，u盘，摄像机，音响等<br>设备，只要连接到类unix系统，在系统本身看来都可以通过操作<br>文件的方式来操作该设备。而所做的这些操作自然是在终端中了<br>文件系统是模仿树的结构设计的。<br>自然界的树只有一个根，树根连带主干是一部分，主干上面还有<br>可多的分支，分支上又有小分支和树叶。<br>类unix上的文件系统也是如此，也有一个根目录（目录即文件夹）<br>根目录下有一些分支目录，分支目录里还有一些小的分支目录，<br>小的分支目录里面还可能有一些更小的分支目录和文件，所有的<br>分支目录都可以看成树枝，所有的文件都可以看成是树叶。</p>
<blockquote>
<p>pwd 显示当前目录的绝对路径</p>
</blockquote>
<p>所谓绝对路径就是从根目录（／）开始的这个路径<br>相对路径就是相对与当前的这个路径而言</p>
<blockquote>
<p>ls  显示当前目录（文件夹）里的一些文件或目录的名字</p>
</blockquote>
<p>这些文件或者目录都是可见的。一般目录里还会有隐藏文件或隐藏目录，这些文件和目<br>录是以.为开头的。若是想要显示所有文件和目录（包括隐藏的文件和隐            藏的目录）。那么要用到   ls   -a  还有一个常用的命令是 ls  -l  和 ls -al</p>
<blockquote>
<p>cd  切换一个目录 </p>
</blockquote>
<p>cd命令后可加一个相对路径也可以加一个绝对路径。<br>咱们每创建一个新目录，那么这个目录里面是会默认生成两个新目录，名字分别是.和 ..。<br>的意义是当前文件，而..是当前目录的上一级目录（或者管它叫当前目录的父目录）</p>
<blockquote>
<p>cp  拷贝一个文件或者目录</p>
</blockquote>
<p>touch  新创建一个空文件<br>$ touch   已存在文件的目录<br>相当于把该文件时间戳更新，文件内容并未改变<br>$ touch  newfile<br>newfile就是那个新创建的空文件的名字</p>
<blockquote>
<p>rm   删除一个文件，或者删除一个目录</p>
</blockquote>
<p>删除一个文件就是<br>$ rm   filename<br>删除一个目录<br>$ rm －r dirname</p>
<blockquote>
<p>tab键   补全功能:</p>
</blockquote>
<p>补全文件或文件夹的名字，也可以补全目录下的相关文件</p>
<blockquote>
<p>open  在终端以文件夹窗口的形式来打开某个目录或文件，也可以打开应用程序</p>
</blockquote>
<p>小技巧：当以文件夹窗口的形式找到文件或者目录后，想要在终端中打开，很方便的<br>一个操作就是把该文件或者目录拖拽到终端窗口即可获得其绝对路径</p>
<blockquote>
<p>vim 编辑器</p>
</blockquote>
<p>1）vim 可以打开一个已经存在的文件，这种情况下它是<br>vim  文件名<br>如果vim后面跟的名字的文件并不存在，那么vim进文件之后保存<br>退出就相当于创建了一个新文件。</p>
<blockquote>
<p>vim 有3中模式：命令模式 ， 插入模式（编辑模式），可视模式</p>
</blockquote>
<p>（1）命令模式，就是我可以键入各种命令（前提是这些命令都是被支持的）<br>一般输入命令要用 “：命令名字”<br>：w         表示保存该文件<br>：q          表示退出该文件<br>：q！      表示强制退出并且不保存该文件<br>：wq       表示保存并且退出该文件<br>：wq！   表示保存修改并且强制退出该文件</p>
<p>（2）编辑模式<br>当处于编辑模式的时候我们可以任意更改该文件内容<br>（3）可视模式<br>一般用于修改代码格式要用到，例如代码风格对齐要用到，用法为：<br>（4）当用vim打开一个文件的时候它会默认进入到命令模式，如果我要修改该文件那么就需要键入“i”键，切换到编辑模式。那么从编辑模式切换到命令模式我们是用ESC键。如果想要通过命令模式切换到可视模式，需要在命令模式下键入 “v”键。想要从可视模式切回命令模式依然是用ESC键。</p>
<blockquote>
<p>命令模式下我们经常会用到一些命令</p>
</blockquote>
<p>“a”在当前光标位置后插入文本（内容），并且会自动切入到编辑模式<br>“o”在当前光标所在行的下一行另起一行，并且切入到编辑模式<br>“O”在当前光标所在行的上一行另起一行,并且切入到了编辑模式<br>“x”要删除一个字符那么把光标移动到该字符，然后点下‘x’<br>“dd”其实是连续按两次‘d’键，作用是删除光标所在行整行内容<br>“4dd”相当于删除从光标所在行往下数4行内容<br>“yy”是复制光标所在行一整行内容<br>“4yy” 相当于复制从光标所在行往下数4行内容<br>“p”如果误删除了某几行那么我们可以用‘p’键把删除的内容再粘回来<br>具体做就是在光标的下一行位置插入几行的内容<br>“u”撤消之前的一步操作,若是想撤消之前多步操作就是多点几回‘u’</p>
<blockquote>
<p>光标移动</p>
</blockquote>
<p>“$”将光标移动到当前行的行尾<br>“^”将光标移动到当前行的第一个非空白字符位置<br>“G”将光标定位到最后一行上<br>“gg”将光标移动到第一行<br>“:set number”显示行号<br>“:set nonumber”把已经显示出的行号去掉</p>
<blockquote>
<p>简单搜索</p>
</blockquote>
<p>“/string”用于搜索一个字串string。<br>要查找上次查找的字符串的下一个位置使用“n”命令。<br>vim编辑器的配置文件，该配置文件的名字是唯一的“.vimrc”。<br>$ vim  .vimrc<br>syntax on<br>set number<br>set showmatch<br>set tabstop=4<br>set shiftwidth=4<br>set softtabstop=4<br>set smartindent<br>注意：.vimrc这个文件必须是存放在家目录（不一定是/home那个目录，一般新打开一个终端，命令行会默认在某一个目录下，该目录就是家目录）</p>
<blockquote>
<p>格言：</p>
</blockquote>
<p>在这个世界上，唯一不变的规律是这个世界一直在变。一定要不断提高<br>自己以适应这个变化的世界。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2016/07/30/A_C5%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/07/30/A_C5%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">C语言中的关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-07-30 21:45:49" itemprop="dateCreated datePublished" datetime="2016-07-30T21:45:49+08:00">2016-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>一 const 修饰的数据类型是指常类型，常类型的变量或对象的值是不能被更新的。</p>
</blockquote>
<p>const关键字的作用主要有以下几点：<br>（1）可以定义const常量，具有不可变性。 例如：<br>const int Max=100; int Array[Max];<br>（2）便于进行类型检查，使编译器对处理内容有更多了解，消除了一些隐患。例如： void f(const int i) { ………} 编译器就会知道i是一个常量，不允许修改；<br>（3）可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。<br>（4）可以保护被修饰的东西，防止意外的修改，增强程序的健壮性。 还是上面的例子，如果在函数体内修改了i，编译器就会报错； 例如：<br>void f(const int i) { i=10;//error! }<br>（5） 为函数重载提供了一个参考。<br>class A { ……<br>void f(int i) {……} //一个函数<br>void f(int i) const {……} //上一个函数的重载 ……<br>};<br>（6） 可以节省空间，避免不必要的内存分配。 例如：<br>#define PI 3.14159 //常量宏<br>const doulbe Pi=3.14159; //此时并未将Pi放入ROM中 ……<br>double i=Pi; //此时为Pi分配内存，以后不再分配！<br>double I=PI; //编译期间进行宏替换，分配内存<br>double j=Pi; //没有内存分配<br>double J=PI; //再进行宏替换，又一次分配内存！<br>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝。<br>（7） 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</p>
<blockquote>
<p>二  外部变量，局部变量以及extern，static关键字</p>
</blockquote>
<p>1）外部变量又叫全局变量，管全局变量叫外部变量是因为该变量在函数外部声明<br>（1）全局变量在声明的时候初始化，那么该全局变量的值为被初始化的那个值全局变量在声明的时候若未初始化，那么系统会自动把它初始化为0.<br>（2）全局变量的作用域：是从全局变量声明到该文件的结尾<br>（3）如果在一个全局变量的作用域内的函数里面声明一个局部变量跟全局变量的名字相同，在该函数内全局变量是不可见的，用的只是那个局部变量。也可以说这个相同名字的局部变量在该变量作用域内会屏蔽掉那个全局变量<br>注意：全局变量是很危险的，因为任何一个函数都有可能改掉该全局变量，而造成不可预期的错误。可以用const这个关键字来修饰一个全局变量而使其成为一个只读变量，这样可以避免全局变量所遇到到一些危险操作。<br>2）局部变量：auto自动变量，平时在声明一个变量的时候若是不加该关键字，系统默认成自动变量，例如：<br>int a;<br>虽然没有加auto关键字，但是系统已经认为他是auto类型的变量。<br>（1）局部变量的作用域仅限于该变量在某一个代码块内声明到该代码块退出，当然作用域也是变量的生存周期。例如：</p>
<blockquote>
<p>三 extern关键字</p>
</blockquote>
<p>（1）当前文件用到其他文件中的全局变量<br>extern int my_global;<br>（2）使用当前文件里所没有的函数，而使用的函数是在别的文件里定义的，需要声明<br>该函数是其他文件里的函数，而在当前文件如下声明：<br>extern char *my_strcpy(char *str1,const char *str2);<br>4）static关键字,一般管static修饰的变量叫做静态变量，static修饰的函数叫做静态函数。<br>static代表什么意思呢？<br>1）如果是static 修饰的是变量，那么它说明该变量只能在当前文件里用，而外部其他<br>文件则不能通过外部链接来使用该变量。例如：</p>
<p>/<em>file1.c</em>/</p>
<p>static int my_static_variable=12;</p>
<p>/<em>file2.c</em>/<br>extern int my_static_variable;           //这一条语句符合语法要求，因为任何一<br>个文件都有权利引用外部链接的一个变量<br>int main(void)<br>{<br>printf(“%d\n”,my_static_variable);      //这条语句会有错误，因为这两个<br>文件里找不到对第二个文件可用的<br>my_static_variable变量.<br>return 0;<br>}<br>file2.c这种声明方式是没有问题的，但在用my_static_variable时却找不到该变量。<br>因为在file1.c里面我把my_static_variable 变量声明为了静态变量，表示该变量的<br>作用域只能在file1.c文件生效，其他文件不能在通过外部链接使用该变量。<br>2）static修饰函数时，表示该函数只在＝当前文件生效，而通过外部链接是找不到的该<br>函数的，具体的情况描述同1）相同。</p>
<blockquote>
<p>四 随机数相关函数和动态内存分配</p>
</blockquote>
<p>1）随机数<br>srand(time(NULL));<br>sroand以时间设置一个种子<br>rand（）<br>rand（）通过一个算法计算得到一个很大的数如果生成的这个随机数在某个范围内，例如：骰子能表达的数是1-6，那我我用随机数产生的数据应该是1-6，按照下面的方法得到<br>n＝rand()%6+1；<br>2）动态内存分配<br>void 修饰函数表示函数没有返回值<br>void *修饰返回值表示函数的返回值为任意指针类型（char *,int *,double *,struct book *）<br>void *malloc(size_t size);<br>char *p;<br>p=malloc(100);<br>if(p==NULL)<br>{<br>printf(“malloc failed!\n”);<br>return -1;<br>}<br>malloc执行成功的时候，用完这块内存，我们需要手动的释放掉该内存。因为操作系统不会帮我们释放掉在堆空间申请的内存。程序员可以用free（）函数来释放掉我们手动申请的内存。例如把上面的内存释放掉可以用<br>下述方法：<br>free(p);</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/39/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/39/">39</a><span class="page-number current">40</span><a class="page-number" href="/page/41/">41</a><a class="extend next" rel="next" href="/page/41/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">403</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
