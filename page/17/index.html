<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/17/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/M_Swift160%E7%82%B9%E7%BA%BF%E9%9D%A2%E7%BB%98%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/M_Swift160%E7%82%B9%E7%BA%BF%E9%9D%A2%E7%BB%98%E5%88%B6/" class="post-title-link" itemprop="url">OpenGL点线面绘制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 14:25:12" itemprop="dateCreated datePublished" datetime="2020-12-02T14:25:12+08:00">2020-12-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于地图应用程序来讲一般来说绘制的都是三角形类型的数据，GL_TRIANGLES<br>点的绘制：<br>一般是绘制图标和文本，涉及的问题主要是计算图标及文本的位置<br>线的绘制：<br>一般是根据线的宽度，生成三角形数据的线，然后进行绘制<br>面的绘制：<br>一般是绘制三角形数据</p>
<p>地图层级绘制：<br>这涉及到地图数据编译的开发，地图数据编译一个重要方面是数据分层，要将数据展示在不同级别的比例尺的地图上，所以不同比例尺下，我们看到地图展示的数据是不一样的，我们要抽希数据放在高层比例尺上，比如北京市，我们可能在20km以上的比例尺才会显示，在较低的比例尺上我们就不会再显示，这就是数据的分层。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/M_Swift159OpenGL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/M_Swift159OpenGL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E/" class="post-title-link" itemprop="url">OpenGL常用函数说明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 11:57:27" itemprop="dateCreated datePublished" datetime="2020-12-02T11:57:27+08:00">2020-12-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>OpenGL中所有函数都以字符gl作为前缀，还有些以glfw、gl3w或glew为前缀的函数，来自于第三方库GLFW、GL3W、GLEW</p>
<p>由于OpenGL是C语言的库，没有重载，所以OpenGL中区分同名函数使用后缀的变化来标记，例如glUniform2f()和glUniform3fv()，2f中的2表示两个参数，f表示参数类型为GLfloat类型，即glUniform2f()需要传入两个GLfloat类型的参数，而glUniform3fv()中v表示vector(向量)类型，即这个函数我们需要使用一个3维向量作为参数传入，这个三维向量的每个分量都是GLfloat类型，注意，在OpenGL中，向量vector类型是使用一维数组来表示，所以glUniform3fv()的参数为一个含有3个GLfloat值的一维数组<br>后缀与参数类型对应关系<br>b 8位整数  char<br>s 16位整数 short<br>i 32位整数 int<br>f 32位浮点 float<br>d 64位浮点 double<br>ub 8位无符号整型<br>us 16位无符号整型<br>ui 323位无符号整型</p>
<p>Uniform：属性是一种对整个批次属性都取统一值的单一值。它是不变的。通过设置uniform变量就紧接着发送一个图元批次命令，Uniform变量实际上可以无数次限制地使用，设置一个应用于整个表面的单个颜色值，还可以设置一个时间值。在每次渲染某种类型的顶点动画时修改它。、</p>
<p>glEnable(GL_LINE_STIPPLE);//打开虚线模式glDisable（GL_LINE_STIPPLE）可关闭<br>glLineStipple(2, 0x0F0F);//void glLineStipple(GLint factor, GLushort pattern); pattern为虚线样式序列（16位二进制数）</p>
<p>glClear度<br>glBegin(GL_LINES);</p>
<p>点</p>
<p>线<br>glLineWidth(10.0f);//线宽<br>glEnable(GL_LINE_STIPPLE);<br>glDisable(GL_LINE_STIPPLE);</p>
<p>面<br>正面反面<br>GL_FRONT<br>GL_BACK<br>面的处理方式则有填充和轮廓<br>glPolygonMode<br>GL_LINE<br>GL_FILL<br>glEnable(GL_POLYGON_STIPPLE);//打开镂空模式</p>
<p>glDeleteTextures - 删除纹理<br>glPushMatrix<br>glTranslatef<br>glScalef<br>glRotatef<br>glDisable<br>glEnable<br>glBlendFunc<br>glEnableClientState<br>glBindTexture<br>glTexParameterf</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/flycatdeng/article/details/82588903">https://blog.csdn.net/flycatdeng/article/details/82588903</a></p>
<p>glActiveTexture - 激活纹理单元<br>glAttachShader- 将着色器对象附加到program对象<br>glBindAttribLocation - 将通用顶点属性索引与命名属性变量相关联<br>glBindAttribLocation - 将通用顶点属性索引与命名属性变量相关联</p>
<p>glEnable( GL_BLEND );   // 启用混合<br>glBlendFunc( GLenum sfactor , GLenum dfactor );         // 混合函数</p>
<p>sfactor 源混合因子</p>
<p>dfactor 目标混合因子<br>OpenGL——纹理过滤函数glTexParameteri()<br>    图象从纹理图象空间映射到帧缓冲图象空间(映射需要重新构造纹理图像,这样就会造成应用到多边形上的图像失真),这时就可用glTexParmeteri()函数来确定如何把纹理象素映射成像素.<br>GL_TEXTURE_2D: 操作2D纹理.<br>GL_TEXTURE_WRAP_S: S方向上的贴图模式.<br> GL_CLAMP: 将纹理坐标限制在0.0,1.0的范围之内.如果超出了会如何呢.不会错误,只是会边缘拉伸填充.<br>GL_LINEAR: 线性过滤, 使用距离当前渲染像素中心最近的4个纹素加权平均值.<br>GL_REPEAT</p>
<p>openggl 图片优化<br>如果纹理很大，并且您每次分配新内存来存储越来越多的副本，那么很快就会用完的记忆。解决方案是在应用程序初始化期间调用 glTexImage2D 一次，并且仅在要使用它时才调用 glBindTexture 。如果要在单击时更改纹理本身，请仅调用 glBindTexture 和 glTexImage2D 。如果新图像的大小与先前图像的大小相同，则可以调用 glTexSubImage2D 告诉OpenGL覆盖旧图像数据，而不是删除并上传新图像数据。 / p&gt; </p>
<h2 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><pre><code>/*
 * glGenRenderbuffers 的原型为：
 * void glGenRenderbuffers (GLsizei n, GLuint* renderbuffers)
 * 它是为 renderbuffer 申请一个 id（或曰名字）。
 * 参数 n 表示申请生成 renderbuffer 的个数，
 * 而 renderbuffers 返回分配给 renderbuffer 的 id，
 * 注意：返回的 id 不会为0，id 0 是OpenGL ES 保留的，我们也不能使用 id 为0的 renderbuffer。
 */
glGenRenderbuffers(1, &amp;self-&gt;_colorRenderBuffer);

/*
 * glBindRenderbuffer 的原型为：
 * void glBindRenderbuffer (GLenum target, GLuint renderbuffer)
 * 这个函数将指定 id 的 renderbuffer 设置为当前 renderbuffer。
 * 参数 target 必须为 GL_RENDERBUFFER，参数 renderbuffer 是就是使用 glGenRenderbuffers 生成的 id。
 * 当指定 id 的 renderbuffer 第一次被设置为当前 renderbuffer 时，会初始化该 renderbuffer 对象，其初始值为：
 * width 和 height：像素单位的宽和高，默认值为0；
 * internal format：内部格式，三大 buffer 格式之一 -- color，depth or stencil；
 * Color bit-depth：仅当内部格式为 color 时，设置颜色的 bit-depth，默认值为0；
 * Depth bit-depth：仅当内部格式为 depth时，默认值为0；
 * Stencil bit-depth: 仅当内部格式为 stencil，默认值为0；
 */
glBindRenderbuffer(GL_RENDERBUFFER, self.colorRenderBuffer);


/*
 * glFramebufferRenderbuffer的函数原型为：
 * void glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
 * 该函数是将相关 buffer（三大buffer之一）attach到framebuffer上（如果 renderbuffer不为 0，
 * 知道前面为什么说glGenRenderbuffers 返回的id 不会为 0 吧）或从 framebuffer上detach
 * （如果 renderbuffer为 0）。参数 attachment 是指定 renderbuffer 被装配到那个装配点上，zm
 * 其值是GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT中的一个，
 * 分别对应 color，depth和 stencil三大buffer。
 */
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.colorRenderBuffer);

/*
 * glDrawElements 函数的原型为：
 * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
 * 第一个参数 mode 为描绘图元的模式，其有效值为：GL_POINTS, GL_LINES, GL_LINE_STRIP,  GL_LINE_LOOP,  GL_TRIANGLES,  GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN。这些模式具体含义下面有介绍。
 * 第二个参数 count 为顶点索引的个数也就是，type 是指顶点索引的数据类型，因为索引始终是正值，索引这里必须是无符号型的非浮点类型，
 * 因此只能是 GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, GL_UNSIGNED_INT 之一，为了减少内存的消耗，尽量使用最小规格的类型如 GL_UNSIGNED_BYTE。
 * 第三个参数 indices 是存放顶点索引的数组。（indices 是 index 的复数形式，3D 里面很多单词的复数都挺特别的。）
 */
glDrawElements(GL_LINES, sizeof(indices)/sizeof(GLubyte), GL_UNSIGNED_BYTE, indices);


/*
 * glClearColor用来设置清屏颜色，默认为黑色
 */
glClearColor(0, 1.0, 0, 1.0);

/*
 * glClear(GLbitfieldmask)用来指定要用清屏颜色来清除由mask指定的buffer
 * mask 可以是 GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT的自由组合。
 */
glClear(GL_COLOR_BUFFER_BIT);

/*
 * 设置 viewport
 * glViewport  表示渲染 surface 将在屏幕上的哪个区域呈现出来，
 */
glViewport(0, 0, self.frame.size.width, self.frame.size.height);
</code></pre>
<h2 id="glPushMatrix、glPopMatrix"><a href="#glPushMatrix、glPopMatrix" class="headerlink" title="glPushMatrix、glPopMatrix"></a>glPushMatrix、glPopMatrix</h2><pre><code>操作事实上就相当于栈里的入栈和出栈。
https://blog.csdn.net/u010579736/article/details/51884989
比如你当前的坐标系原点在你电脑屏幕的左上方。如今你调用glPushMatrix，然后再调用一堆平移、旋转代码等等，然后再绘图。那些平移和旋转都是基于左上角为原点进行变化的。并且都会改变坐标的位置，经过了这些变化后，你的坐标肯定不再左上角了。
　　那假设想恢复怎么办呢？这时就调用glPopMatrix从栈里取出一个“状态”了，这个状态就是你调用glPushMatrix之前的那个状态。就如非常多opengl的书上所讲：调用glPushMatrix事实上就是把当前状态做一个副本放入堆栈之中。

当你做了一些移动或旋转等变换后，使用glPushMatrix();
OpenGL 会把这个变换后的位置和角度保存起来。
然后你再随便做第二次移动或旋转变换，再用glPopMatrix();
OpenGL 就把刚刚保存的那个位置和角度恢复。

比方：
glLoadIdentity();
glTranslatef(1,0,0);//向右移动(1,0,0)
glPushMatrix();//保存当前位置
glTranslatef(0,1,0);//如今是(1,1,0)了
glPopMatrix();//这样，如今又回到(1,0,0)了
1.原理解说

最终明确为什么使用glPushMatrix()和glPopMatrix()的原因了。将本次须要运行的缩放、平移等操作放在glPushMatrix和glPopMatrix之间。glPushMatrix()和glPopMatrix()的配对使用能够消除上一次的变换对本次变换的影响。使本次变换是以世界坐标系的原点为參考点进行。以下对上述结论做进一步的解释：

1）OpenGL中的modelview矩阵变换是一个马尔科夫过程：上一次的变换结果对本次变换有影响，上次modelview变换后物体在世界坐标系下的位置是本次modelview变换的起点。默认时本次变换和上次变换不独立。

2）OpenGL物体建模实际上是分两步走的。第一步，在世界坐标系的原点位置绘制出该物体；第二步，通过modelview变换矩阵对世界坐标系原点处的物体进行仿射变换，将该物体移动到世界坐标系的目标位置处。

3）将modelview变换放在glPushMatrix和glPopMatrix之间能够使本次变换和上次变换独立。

4）凡是使用glPushMatrix()和glPopMatrix()的程序一般能够判定是采用世界坐标系建模。既世界坐标系固定，modelview矩阵移动物体。
</code></pre>
<h2 id="glTranslatef-函数和glRotatef-函数和glLoadIdentity-函数"><a href="#glTranslatef-函数和glRotatef-函数和glLoadIdentity-函数" class="headerlink" title="glTranslatef()函数和glRotatef()函数和glLoadIdentity()函数"></a>glTranslatef()函数和glRotatef()函数和glLoadIdentity()函数</h2><pre><code>https://blog.csdn.net/code_ac/article/details/60970103

glLoadIdentity()

将当前的用户坐标系的原点移到了屏幕中心：类似于一个复位操作 
glTranslatef(x, y, z)

沿着 X, Y 和 Z 轴移动。

注意在glTranslatef(x, y, z)中,当您移动的时候，您并不是相对屏幕中心移动，而是相对与当前所在的屏幕位置。

glRotatef(angle, x, y, z) 

与glTranslatef(x, y, z)类似，glRotatef(angle, x, y, z)也是对坐标系进行操作。 旋转轴经过原点，方向为(x,y,z),旋转角度为angle，方向满足右手定则。 

glScalef是openGL中的模型缩放函数，就是把当前矩阵与一个表示延各个轴对物体进行拉伸、压缩、反射的矩阵相乘。这个物体的每个点的x,y,z坐标与对应的xyz参数相乘。
例如：
如glScalef(2.0f，3.0f，4.0f);将模型按x,y,z方向分别拉伸了2,3,4倍。


【GL_LINES】
　　独立的线段，下式中，p2与p3间没有连线。
【GL_LINE_STRIP】
　　连续的线段，下式中， p2与p3会连成线段。
【GL_LINE_LOOP】
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/M_Swift151OpenGLES%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/M_Swift151OpenGLES%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Opengl es</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 11:57:06" itemprop="dateCreated datePublished" datetime="2020-12-02T11:57:06+08:00">2020-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 16:08:28" itemprop="dateModified" datetime="2021-04-12T16:08:28+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>opengl 是一个跨平台、跨编程语言的图形处理接口，opengl es是它的一个子集，专门用来针对手机，平板电脑等嵌入式设备的图像处理库。对于手机来说，它的所有对图像的计算和渲染都是在gpu上完成，所以具有较好的性能<br>opengl es的接口设计中不涉及上下文环境和窗口的管理，这由各个平台自行实现。比如ios就是EAGL；安卓就是EGL；<br>tips:<br>libSDL，它是一个跨平台的图形处理库，其中有包含对对OpenGL es的标准接口的封装及各个平台上下文，窗口管理的封装。<br>备注：Opengl es 2.0 官方接口文档 <a target="_blank" rel="noopener" href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/">https://www.khronos.org/registry/OpenGL-Refpages/es2.0/</a></p>
<p>gltypes.h 是包含了 OpenGL ES 2.0 的基本数据类型的定义；<br>glext.h 是包含各种宏定义，以及矩阵运算等常用的函数；<br>gl.h 是 OpenGL ES 2.0 所有的核心函数（命令）；</p>
<p>#Opengl es渲染管线<br>这里是opengl es2.0以后的版本的渲染管线<br>1、确定几何形状，比如是要点，线，还是三角形(长方形，正方形和其它二维几何图形都是由三角形来渲染的)。<br>它最终由glDrawArrays()函数的调用来确定，其第一个参数确定了形状可取值如下：<br>GL_POINTS:绘制点<br>GL_LINES:线<br>GL_TRIANGLE_STRIP:三角形<br>2、处理顶点坐标<br>此阶段需要顶点着色器的参与，首先由应用端传递给顶点着色器几何图形的坐标，纹理的坐标(如果有的话)；然后根据opengl es内部的坐标系和投影矩阵进行转化<br>成最终的坐标;在这一步中，应用端需要知道的是基于(左下角为原点(-1,-1),右上角(1,1)，这个范围就是前面glViewPort()开辟大小)的坐标系来确定几何图形的坐标<br>；基于(左上角为原点(0,0),右下角(1,1))的坐标系来确定纹理的坐标,但是纹理坐标要上下翻转180度后在与几何坐标顺序一直传递<br>tips:<br>常用的就是渲染图片，所以图片都是矩形，所以传递的几何坐标如下：<br>static float verData1[8] = {<br>-1.0f, -1.0f, // 左下角<br>1.0f,-1.0f,  // 右下角<br>-1.0f,1.0f, // 左上角<br>1.0f,1.0f,  // 右上角<br>};<br>一般按照如上的顺序传递坐标，取值也可以是其它值，比如<br>static float verData1[8] = {<br>-0.5f, -0.5f, // 左下角<br>0.5f,-0.5f,  // 右下角<br>-0.5f,0.5f, // 左上角<br>0.5f,0.5f,  // 右上角<br>};<br>表示取中间的1/2区域；实际上就是压缩效果<br>static float verData1[8] = {<br>-2.0f, -2.0f, // 左下角<br>2.0f,-2.0f,  // 右下角<br>-2.0f,2.0f, // 左上角<br>2.0f,2.0f,  // 右上角<br>};<br>表示将原来的坐标系放大了一倍后在基于原始的进行截取<br>传递的纹理坐标系(OpenGL es纹理坐标系左上角为原点(0,0),右下角为(1,1)与几何坐标系上下刚好翻转180度)如下：<br>static float uvData[8] = {<br>0.0f, 1.0f,// 左下角<br>1.0f, 1.0f, // 右下角<br>0.0f, 0.0f,// 左上角<br>1.0f, 0.0f, // 右上角<br>};<br>纹理坐标系一般不要去改变它的值，传这个就好，(当然也可该，前提是知道内部的转换原理),如果要实现压缩和裁剪效果，改变几何坐标系方便一些。<br>3、图元组装<br>经过阶段二的顶点处理操作之后，不论模型的顶点还是纹理坐标都已经确定，这个阶段，顶点将会应用程序的指令规则比如glDrawArrays()函数确定的(如<br>GL_POINTS,GL_LINES,GL_TRIANGES等)，将根据这些顶点坐标描绘出具体的图元(比如最终要渲染成一个矩形图元)<br>4、栅格化操作<br>由阶段3传递过来的图元，将在此阶段被分解成更小的单元并对应于帧缓冲区的各个像素，这些单元成为片元，一个片元包含颜色，坐标等属性。片元的坐标属性<br>根据顶点坐标利用插值运算确定，这个过程称为栅格化操作。该阶段只是确定了每个片元的坐标属性，颜色由下阶段通过片元着色器确定。<br>5、片元处理<br>上阶段确定了各个片元的坐标，此阶段将通过片段着色器GLSL语言确定各个片元的颜色。比如可以通过纹理坐标获取纹理中对应片元坐标的颜色，如果应用端传进来的纹理大小和要绘制的几何图形大小不一样，那么opengles会根据应用自己设置的缩放规则(比如用glTexParameteri()函数指定的规则)进行插值运算来获取到对应<br>的颜色)如果没有纹理，可以根据自己的代码规则确定片元颜色;这个过程就是给GLSL的内建变量gl_FragColor赋值<br>6、帧缓存操作<br>该阶段主要指向帧缓冲的写入操作，负责将最终的像素值写入帧缓冲区中。</p>
<p>#光栅化<br>前面就是opengl es标准的渲染管线，但是要想将图像最终呈现到屏幕上，还需要进行光栅化操作(也就是将帧缓冲区中的像素数据渲染到屏幕上)，而<br>这这一步的实现是由各个设备供应商提供的，称为Opengl EGL API，拿苹果ios的例子来说，需要调用EAGLContext 的presentRenderbuffer函数，图<br>像才会最终渲染到屏幕上;</p>
<p>#opengl es api和EGL api<br>opengl es api是用来进行图像渲染操作的，<br>egl api是由各个操作系统实现的系统api，它主要的作用就是创建窗口，创建opengl 上下文环境等。可以由各自厂商自行定义，使用通用的EGL接口。<br>如苹果就是EAGL，安卓就可以用EGL来自行管理，也可以用GLSurface系统创建opengl 环境</p>
<h1 id="opengl-es坐标系"><a href="#opengl-es坐标系" class="headerlink" title="opengl es坐标系"></a>opengl es坐标系</h1><p>1、它以左下角作为原点的坐标系<br>此函数的意思就是，基于当前视图左下角作为原点的坐标系，选取一个左下角坐标为x,y,长宽为w,h的区域作为渲染的区域<br>glViewPort(x,y,w,h) 函数窗口创建的渲染区域</p>
<p>#纹理坐标系<br>在opengl 中，通常将纹理中的像素根据纹理坐标系来进行编址，纹理坐标系的横轴成为S轴，纵轴成为T轴，垂直于ST轴的成为R轴，在2D纹理中，没有<br>R轴，横轴和纵轴又称为UV轴，所以2D纹理坐标系又称为UV坐标系，UV轴的取值范围都是(0,1)。与OpenGL 坐标系不同的是，纹理坐标系的原点位于左<br>上角<br>#纹素<br>纹理中的最小单元就成为纹素，纹理是由一个个纹素组成</p>
<p>#纹理映射<br>纹理的映射就是让物体的每个片元（每个颜色像素）都找到对应的纹理纹素点，在这个映射过程中，因为纹理和物体的不匹配，势必会出现两种情况。<br>第一种是拥有大量纹素的纹理被映射到只还有少量片元的物体中<br>第二种是拥有少量纹素的纹理被映射到含有大量片元的物体中<br>如下：<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR)<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR)<br>GL_TEXTURE_MIN_FILTER:<br>是多个纹素对应一个片元的解决方案。可以设置两个值,GL_NEAREST 和 GL_LINEAR ，这两个值分别对应了两种不同的解决方案。GL_LINEAR 会混合匹配的颜色来得到片元的颜色，产生的颜色可能是纹理中不存在的颜色。例如一个纹理是由交替的黑色和白色的纹素组成，那个线性取样会使最终的片元颜色为灰色。GL_NEAREST 会拾取与片元 U，V 坐标最相近的颜色。<br>GL_TEXTURE_MAG_FILTER:<br>是没有足够的纹素来映射片元的解决方案。可以设置的值同 GL_TEXTURE_MIN_FILTER 一样。GL_LINEAR 会告诉OpenGL ES 混合附近纹素的颜色来计算片元的颜色。GL_LINEAR会有一个放大纹理的效果，当没有足够的纹素来映射片元时，会让纹理模糊的出现在要渲染的图形上。<br>GL_NEAREST 仅仅会拾取片元的 U ，V 位置接近的纹素的颜色，并放大纹理，会使其像素化的出现在要渲染的图形上。<br>GL_LINEAR:<br>线性插值，取最近的点的线性平均值 (性能消耗较大)<br>mipmaps<br>它也是一种纹理过滤算法，按我的理解它是以空间换时间的一种技巧，具体原理就是事先根据纹理生成长和宽逐渐除以2的小纹理，比如原始纹理大小128x128，<br>采用此方法后，会生成64x64 32x32 16x16 8x8 4x4 2x2 1x1的一系列纹理，如果需要20x18的纹理，则取最近的32x32 16x16进行平均<br>该方法很好的解决了如下问题：<br>1、当纹理很大，但是屏幕区域很小，渲染出现的闪烁问题，因为根据最邻近插值和线性插值都无法很快计算出合理的像素<br>它可以取的值如下：<br>GL_NEAREST_MIPMAP_NEAREST 选择最近的mipmap层，然后再用最邻近过滤插值<br>GL_LINEAR_MIPMAP_NEAREST    选择最近mipmap层，然后再用线性插值<br>GL_NEAREST_MIPMAP_LINEAR    选择最近的2层mipmap用最邻近过滤插值<br>GL_LINEAR_MIPMAP_LINEAR       选择最邻近的2层mipmap用线性插值<br>使用如下函数生成mipmaps<br>glGenerateMipmap(GLenum target);</p>
<p>#warp<br>另外一种在映射时可能出现的情况是纹理的四个顶点坐标不是1.0时，将采用如下方式：<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_WARP_S,GL_REPEAT) S轴方向<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_WARP_T,GL_REPEAT) T轴方向<br>GL_REPEAT:纹理没有覆盖的部分重复之前的纹理，当纹理大小大于物体大小时，纹理采样会出错。<br>GL_MIRRODED_REPEAT:将原来的纹理先颠倒再重复，当纹理大小大于物体大小时，纹理采样会出错。<br>GL_CLAMP_TO_EDGE:延续结束时的纹理</p>
<p>#顶点着色器中顶点坐标的顺序规则<br>open gl 中顶点坐标<br>static float verData1[8] = {<br>-1.0f,-1.0f,    // 左下角<br>1.0f,-1.0f,     // 右下角<br>-1.0f,1.0f,     // 左上角<br>1.0f,1.0f,      // 右上角<br>};<br>对应的纹理坐标<br>static float uvData[8] = {<br>0.0f, 1.0f,     // 左下角<br>1.0f, 1.0f,     // 右下角<br>0.0f, 0.0f,     // 左上角<br>1.0f, 0.0f,     // 右上角<br>};<br>对应的为glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); 可以渲染出一张图片</p>
<p>一个纹理的位置值通常称为一个纹理单元(Texture Unit)<br>着色器对象Shader<br>    片段着色器<br>    顶点着色器<br>program对象</p>
<p>缓冲区对象GLuint buffer<br>帧缓冲区对象 GLuint framebuffer</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/M_Swift157OpenGL%E7%BB%98%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/M_Swift157OpenGL%E7%BB%98%E5%88%B6/" class="post-title-link" itemprop="url">OpenGL 渲染</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 11:56:09" itemprop="dateCreated datePublished" datetime="2020-12-02T11:56:09+08:00">2020-12-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="创建render-buffer-（渲染缓冲区）"><a href="#创建render-buffer-（渲染缓冲区）" class="headerlink" title="创建render buffer （渲染缓冲区）"></a>创建render buffer （渲染缓冲区）</h2><p> Render buffer 是OpenGL的一个对象，用于存放渲染过的图像。</p>
<ul>
<li>(void)setupRenderBuffer {<br>  glGenRenderbuffers(1, &amp;_colorRenderBuffer);<br>  glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);<br>  [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_eaglLayer];<br>}</li>
</ul>
<h2 id="创建一个-frame-buffer（帧缓冲区）"><a href="#创建一个-frame-buffer（帧缓冲区）" class="headerlink" title="创建一个 frame buffer（帧缓冲区）"></a>创建一个 frame buffer（帧缓冲区）</h2><ul>
<li>(void)setupFrameBuffer {<br>  GLuint framebuffer;<br>  glGenFramebuffers(1, &amp;framebuffer);<br>  glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<br>  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderBuffer);  // 深度测试<br>  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBuffer);<br>}<h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2></li>
<li>(void)setupDepthBuffer {<br>  glGenRenderbuffers(1, &amp;_depthRenderBuffer);<br>  glBindRenderbuffer(GL_RENDERBUFFER, _depthRenderBuffer);<br>  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, self.frame.size.width, self.frame.size.height);<br>}</li>
</ul>
<h2 id="加载着色器"><a href="#加载着色器" class="headerlink" title="加载着色器"></a>加载着色器</h2><ul>
<li>(void)compileShaders {<br>  // 1<br>  GLuint vertexShader = [self compileShader:@”SimpleVertex5” withType:GL_VERTEX_SHADER];<br>  GLuint fragmentShader = [self compileShader:@”SimpleFragment5” withType:GL_FRAGMENT_SHADER];  // 2<br>  GLuint programHandle = glCreateProgram();<br>  glAttachShader(programHandle, vertexShader);<br>  glAttachShader(programHandle, fragmentShader);<br>  glLinkProgram(programHandle);  // 3 检查link状态<br>  GLint linkSuccess;<br>  glGetProgramiv(programHandle, GL_LINK_STATUS, &amp;linkSuccess);<br>  if (linkSuccess == GL_FALSE) {<pre><code>  GLchar messages[256];
  glGetProgramInfoLog(programHandle, sizeof(messages), 0, &amp;messages[0]);
  NSString *messageString = [NSString stringWithUTF8String:messages];
  NSLog(@&quot;link no Success-------------%@&quot;, messageString);
  exit(1);
</code></pre>
  }  // 4 让OpenGL执行glProgram<br>  glUseProgram(programHandle);  // 5<br>  _positionSlot = glGetAttribLocation(programHandle, “Position”);<br>  _colorSlot = glGetAttribLocation(programHandle, “SourceColor”);<br>  glEnableVertexAttribArray(_positionSlot);<br>  glEnableVertexAttribArray(_colorSlot);  // 投影<br>  _projectionUniform = glGetUniformLocation(programHandle, “Projection”);<br>  // 移动<br>  _modelViewUniform = glGetUniformLocation(programHandle, “Modelview”);<br>}</li>
</ul>
<h2 id="编译着色代码"><a href="#编译着色代码" class="headerlink" title="编译着色代码"></a>编译着色代码</h2><ul>
<li>(GLuint)compileShader:(NSString *)shaderName withType:(GLenum)shaderType {<br>  // 1 查找shader文件<br>  NSString *shaderPath = [[NSBundle mainBundle] pathForResource:shaderName ofType:@”glsl”];<br>  NSFileManager *mg = [NSFileManager defaultManager];  if ([mg fileExistsAtPath:shaderPath]) {<pre><code>  NSLog(@&quot;ok&quot;);
</code></pre>
  }else{<pre><code>  NSLog(@&quot;no&quot;);
</code></pre>
  }  NSError *error;<br>  NSString *shaderString = [NSString stringWithContentsOfFile:shaderPath encoding:NSUTF8StringEncoding error:&amp;error];  if (!shaderString) {<pre><code>  NSLog(@&quot;-----------Error loading shader: %@&quot;, error.localizedDescription);
  exit(1);
</code></pre>
  }  // 2 创建一个代表shader的OpenGL对象, 指定vertex或fragment shader<br>  GLuint shaderHandle = glCreateShader(shaderType);  // 3获取shader的source<br>  const char *shaderStringUTF8 = [shaderString UTF8String];<br>  int shaderStringLength = (int)[shaderString length];<br>  glShaderSource(shaderHandle, 1, &amp;shaderStringUTF8, &amp;shaderStringLength);  // 4 编译shader<br>  glCompileShader(shaderHandle);  // 5查询shader对象的信息<br>  GLint compileSuccess;<br>  glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &amp;compileSuccess);  if (compileSuccess == GL_FALSE) {<pre><code>  GLchar messages[256];
  glGetShaderInfoLog(shaderHandle, sizeof(messages), 0, &amp;messages[0]);
  NSString *messageString = [NSString stringWithUTF8String:messages];
  NSLog(@&quot;compile no Success-----------%@&quot;, messageString);
  exit(1);
</code></pre>
  }  return shaderHandle;<br>}<h2 id="清理屏幕"><a href="#清理屏幕" class="headerlink" title="清理屏幕"></a>清理屏幕</h2></li>
<li>(void)render {<br>  glClearColor(0, 104.0/255.0, 55.0/255.0, 1.0);<br>  glClear(GL_COLOR_BUFFER_BIT);<br>  [_context presentRenderbuffer:GL_RENDERBUFFER];<br>}<h2 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h2>  /**<ol>
<li>GL_ARRAY_BUFFER用于顶点数组</li>
<li>绑定vertexBuffer到GL_ARRAY_BUFFER</li>
<li>给VBO传递数据</li>
<li>取出地址</li>
<li>取出颜色</li>
<li>glVertexAttribPointer的最后一个参数是要获取的参数在GL_ARRAY_BUFFER（每一个Vertex）的偏移量</li>
</ol>
  */</li>
<li>(void)setupVBOs{  GLuint verticesBuffer;<br>  glGenBuffers(1, &amp;verticesBuffer);<br>  glBindBuffer(GL_ARRAY_BUFFER, verticesBuffer);<br>  glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br>  glEnableVertexAttribArray(GLKVertexAttribPosition);<br>  glEnableVertexAttribArray(GLKVertexAttribColor);<br>  glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 0);<br>  glVertexAttribPointer(GLKVertexAttribColor, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 3);<br>}</li>
</ul>
<p>b.流程代码化</p>
<p>  一、配置渲染环境<br>    1) 配置渲染窗口 [ 继承自 UIView ]<br>    2) 配置渲染上下文<br>    3) 配置帧渲染<br>    4) 配置渲染缓存<br>    5) 帧缓存装载渲染缓存的内容<br>    6) 渲染上下文绑定渲染窗口（图层）<br>二、修改背景色</p>
<p>  三、 初始化数据</p>
<p>  四、 配置 OpenGL ES Shader</p>
<pre><code>1) 编写 Vertex Shader Code 文件
2) 编写 Fragment Shader Code 文件
3) 配置 Vertex Shader
4) 配置 Fragment Shader
5) 创建 Shader Program
6) 装载 Vertex Shader 和 Fragment Shader
7) 链接 Shader Program
</code></pre>
<p>  五、渲染绘制</p>
<pre><code>1) 清空旧渲染缓存
2) 设置渲染窗口
3) 使用 Shder Program
4) **关联数据**
5) 绘制图形
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift163iOS%E5%9C%B0%E5%9B%BESDK%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift163iOS%E5%9C%B0%E5%9B%BESDK%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">地图SDK开发设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:11:56" itemprop="dateCreated datePublished" datetime="2020-12-01T14:11:56+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 15:38:42" itemprop="dateModified" datetime="2021-04-12T15:38:42+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="设计方向"><a href="#设计方向" class="headerlink" title="设计方向"></a>设计方向</h2><pre><code>1.距离计算
2.坐标转换
3.覆盖物的设计理念
4.弧线坐标获取逻辑
5.webgl截屏
6.地图手势
7.地图覆盖物管理
8.比例尺计算
9.定位计算
10.坐标转换
11.宏定义
12.覆盖物定义逻辑
13.poi点击
</code></pre>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><pre><code>1.mark问题
目前采用了直接地图绘制marker的方式，后续考虑添加接口实现点击效果
2.地图样式问题
添加地图样式接口，目前配置文件没有其它样式数据
3.地图绘制文本

4.地图导航图标绘制
没有绘制成功，

5.地图定位图标的绘制

6.未完成接口
1.Annomation 接口
2.

1.判断折线是否被点击
    原理：点到线的距离是否大与线的宽度
2.判断是否在弧形上
    原理：点到圆心的距离相同。2点在弧形的三角形内
2.判断是否在圆内
    原理：点到圆心的距离小于半径
3.判断是否在面内
    原理：
5.图形的点击
    判断点是否在rect内

7.覆盖物的选中和非选中状态

6.覆盖物的拖拽：
    原理是修改覆盖物的位置

覆盖物的内容
1.点 MAMarker
2.线 MAPolyline
3.面 MAPolygon
4.圆 MACircle
5.弧 MAArc
6.3d图 MAGroundOverlay

问题：
比例尺不同 ：咱们这个好行0是最大
倾斜角度不同 ：咱们是 0 - 90 度

今天终点是定位，显示定位点，用marker实现，不用annimation

定位点的显示逻辑
1.是否定位
2.是否显示定位点
3.是否自定义定位点
4.是否显示精度圈
5.是否自定义精度圈



初始完成
默认定位是打开的，所以设置完代理时，启动定位
默认显示用户位置，所以启动完定位，添加用户位置

添加定位的逻辑


Annimation使用
由annimation转为view，在地图上添加view、可拖拽的view

点击
选中
取消选中
拖拽


地图Annimation 的重用机制原理
1.添加Annimation 
2.当annimation 位置处在地图以外时，在地图上再添加annimation时，使用屏幕外的annimation 就可以了
3.当annimation位置在、


未实现覆盖物
2.大地曲线
4.路段纹理绘制
5.车标绘制

问题：
1.贴图丢失
2.转角问题
3.大地曲线
4.图片贴图显示问题


https://www.cnblogs.com/csu-lmw/category/1555941.html


未实现接口

图标问题
分段纹理

室内地图
点平滑移动
绘制海量点
获取地址


1.内存问题，map对象不消失，一致占用较大内存
2.室内地图缩放等级不对
3.室内地图绘制poi
4.室内地图事件回调
5.

重用机制
：就是删除数据时候不将数据放到备用池中
室内地图配色
室内地图poi绘制
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift161iOS%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift161iOS%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">iOS常用框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:11:50" itemprop="dateCreated datePublished" datetime="2020-12-01T14:11:50+08:00">2020-12-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>界面图形框架 – UIKit<br>核心动画框架 – Core Animation<br>苹果封装的图形框架 – Core Graphics &amp; Quartz 2D<br>传统跨平台图形框架 – OpenGL ES<br>苹果最新力推的图形框架 – Metal<br>适合图片的苹果滤镜框架 – Core Image<br>适合视频的第三方滤镜方案 – GPUImage<br>游戏引擎 – Scene Kit (3D) 和 Sprite Kit (2D)<br>计算机视觉在iOS的应用 – OpenCV for iOS<br>UIKit与Core Graphics的关系</p>
<h2 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h2><p>在UIKit中，UIView类本身在绘制时自动创建一个图形环境，即Core Graphics层的CGContext类型，作为当前的图形绘制环境。在绘制时可以调用 UIGraphicsGetCurrentContext 函数获得当前的图形环境，例如：</p>
<ul>
<li>(void)drawRect:(CGRect)rect {<br>  // Drawing code<br>  NSLog(@”%s”,<strong>func</strong>);<br>  //1.获取上下文<br>  CGContextRef contextRef = UIGraphicsGetCurrentContext();<br>  //2.描述路径<br>  UIBezierPath * path = [UIBezierPath bezierPath];<br>  //起点<br>  [path moveToPoint:CGPointMake(10, 10)];<br>  //终点<br>  [path addLineToPoint:CGPointMake(100, 100)];<br>  //设置颜色<br>  [[UIColor whiteColor]setStroke];<br>  //3.添加路径<br>  CGContextAddPath(contextRef, path.CGPath);<br>  //显示路径<br>  CGContextStrokePath(contextRef);</li>
</ul>
<p>}</p>
<h2 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h2><p>Core Animation 是一套Objective-C API，实现了一个高性能的复合引擎，并提供一个简单易用的编程接口，给用户UI添加平滑运动和动态反馈能力。</p>
<p>Core Animation 是 UIKit 实现动画和变换的基础，也负责视图的复合功能。使用Core Animation可以实现定制动画和细粒度的动画控制，创建复杂的、支持动画和变换的layered 2D视图。</p>
<p>Core Animation 不属于绘制系统，但它是以硬件复合和操作显示内容的基础设施。这个基础设施的核心是layer对象，用来管理和操作显示内容。在 iOS 中 每一个视图都对应Core Animation的一个层对象，与视图一样，层之间也组织为层关系树。一个层捕获视图内容为一个被图像硬件容易操作的位图。在多数应用中层作为管理视图的方式使用，但也可以创建独立的层到一个层关系树中来显示视图不够支持的显示内容。</p>
<p>OpenGL ES的内容也可以与Core Animation内容进行集成。</p>
<p>为了使用Core Animation实现动画，可以修改 层的属性值 来触发一个action对象的执行，不同的action对象实现不同的动画。</p>
<h2 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h2><p>Core Graphics是一套C-based API， 支持向量图形，线、形状、图案、路径、剃度、位图图像和pdf 内容的绘制。</p>
<h2 id="Quartz-2D"><a href="#Quartz-2D" class="headerlink" title="Quartz 2D"></a>Quartz 2D</h2><p>Quartz 2D是Core Graphics中的2D 绘制呈现引擎。Quartz是资源和设备无关的,提供路径绘制，anti-aliased呈现，剃度填充图案，图像，透明绘制和透明层、遮蔽和阴影、颜色管理，坐标转换，字体、offscreen呈现、pdf文档创建、显示和分析等功能。</p>
<p>Quartz 2D能够与所有的图形和动画技术（如Core Animation, OpenGL ES, 和 UIKit 等）一起使用。</p>
<p>Quartz 2D采用paint模式进行绘制。<br>Quartz 2D提供的主要类包括：</p>
<p>CGContext：表示一个图形环境；<br>CGPath：使用向量图形来创建路径，并能够填充和stroke；<br>CGImage：用来表示位图；<br>CGLayer：用来表示一个能够用于重复绘制和offscreen绘制的绘制层；<br>CGPattern：用来表示Pattern，用于重复绘制；<br>CGShading和 CGGradient：用于绘制剃度；<br>CGColor 和 CGColorSpace；用来进行颜色和颜色空间管理；<br>CGFont, 用于绘制文本；<br>CGPDFContentStream、CGPDFScanner、CGPDFPage、CGPDFObject,CGPDFStream, CGPDFString等用来进行pdf文件的创建、解析和显示。</p>
<p>在调用任何OpenGL ES 功能之前必须首先初始化一个EAGLContext 对象。每一个IOS应用的每一个线程都有一个当前context，在调用OpenGL ES函数时，使用或改变此context中的状态。</p>
<p>EAGLContext 的类方法setCurrentContext: 用来设置当前线程的当前context。EAGLContext 的类方法currentContext 返回当前线程的当前context。在切换相同线程的两个上下文之前，必须调用glFlush函数来确保先前已提交的命令被提交到图形硬件中。<br>为了创建全屏幕的视图或使OpenGL ES内容与UIKit视图集成，可以使用GLKit。在使用GLKit时，GLKit提供的类GLKView类本身实现呈现目标及创建和维护一个framebuffer。<br>1） GLKView 和GLKViewController类提供一个标准的OpenGL ES视图和相关联的呈现循环。GLKView可以作为OpenGL ES内容的呈现目标，GLKViewController提供内容呈现的控制和动画。视图管理和维护一个framebuffer，应用只需在framebuffer进行绘画即可。</p>
<p>2）GLKTextureLoader 为应用提供从IOS支持的各种图像格式的源自动加载纹理图像到OpenGL ES 图像环境的方式，并能够进行适当的转换，并支持同步和异步加载方式。</p>
<p>3）数学运算库，提供向量、矩阵、四元数的实现和矩阵堆栈操作等OpenGL ES 1.1功能。</p>
<p>4）Effect效果类提供标准的公共着色效果的实现。能够配置效果和相关的顶点数据，然后创建和加载适当的着色器。GLKit 包括三个可配置着色效果类：GLKBaseEffect实现OpenGL ES 1.1规范中的关键的灯光和材料模式, GLKSkyboxEffect提供一个skybox效果的实现, GLKReflectionMapEffect 在GLKBaseEffect基础上包括反射映射支持。</p>
<p>如果想要一个 iOS 上高性能的并行计算库，答案非常简单。Metal 是唯一的选择。OpenGL 在 iOS 上是私有框架，而 Core Image (使用了 OpenGL) 对这样的任务来说既不够强大又不够灵活。</p>
<h2 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a>Core Image</h2><p>Core Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 滤镜链 将各种效果的 Filter叠加 起来形成强大的自定义效果</p>
<p>Core Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。</p>
<p>// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)<br>context = [CIContext contextWithOptions: [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextUseSoftwareRenderer]];</p>
<p>// 创建基于 GPU 的 CIContext 对象<br>context = [CIContext contextWithOptions: nil];</p>
<p>// 创建基于 GPU 的 CIContext 对象<br>EAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];<br>context = [CIContext contextWithEAGLContext:eaglctx];<br>GPUImage 在视频处理上有更好的表现。<br>GPUImage 的代码完成公开，实现透明。<br>可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift164%E5%AD%97%E8%8A%82%E5%BA%8F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift164%E5%AD%97%E8%8A%82%E5%BA%8F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">字节序问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:08:08" itemprop="dateCreated datePublished" datetime="2020-12-01T14:08:08+08:00">2020-12-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>Little endian<br>    简写：LE<br>    常见翻译：小端序，低端序<br>    解释：将低序字节存储在起始地址。就是高位值放在存储（可以认为是内存）的高位，低位值放在存储的低位，<br>        即：顺序写入到内存中。最符合人的思维，低位高位对应内存地址的高位低位。</p>
<p>Big endian<br>    简写：BE<br>    常见翻译：大端序，高端序<br>    解释：将高序字节存储在起始地址。地址低位存储值的高位，地址高位存储值的低位。<br>        即：一个二进制数，那么从高位到低位顺序写到内存中(内存是从低位到高位的，我们写数字的时候是从高位到低位)。<br>        所以这种方式是最直观的。</p>
<p>iOS中一般是Little endian</p>
<p>比如int数据bit大端许写法如下<br>void BufferPutInt(MapBuffer *pBuffer, int val) {<br>    if (pBuffer-&gt;m_pPtr &gt;= pBuffer-&gt;m_pEnd)<br>        return;<br>    pBuffer-&gt;m_pPtr[0] =  (val &gt;&gt; 24);<br>    pBuffer-&gt;m_pPtr[1] =  (val &gt;&gt; 16);<br>    pBuffer-&gt;m_pPtr[2] =  (val &gt;&gt; 8);<br>    pBuffer-&gt;m_pPtr[3] =  (val);<br>    pBuffer-&gt;m_pPtr += 4;<br>//    MEMCPY(pBuffer-&gt;m_pPtr, &amp;val, sizeof(int));<br>//    pBuffer-&gt;m_pPtr += sizeof(int);<br>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift165%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift165%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/" class="post-title-link" itemprop="url">地图开发技能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:08:08" itemprop="dateCreated datePublished" datetime="2020-12-01T14:08:08+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 15:40:55" itemprop="dateModified" datetime="2021-04-12T15:40:55+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="瓦片地图"><a href="#瓦片地图" class="headerlink" title="瓦片地图"></a>瓦片地图</h2><p>瓦片的切分方式。具体参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/8006049?fr=aladdin">https://baike.baidu.com/item/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/8006049?fr=aladdin</a></p>
<h2 id="webgl教程"><a href="#webgl教程" class="headerlink" title="webgl教程"></a>webgl教程</h2><p>参考网站：<a target="_blank" rel="noopener" href="https://www.yiibai.com/webgl/webgl_graphics_basics.html">https://www.yiibai.com/webgl/webgl_graphics_basics.html</a></p>
<h2 id="墨卡托投影"><a href="#墨卡托投影" class="headerlink" title="墨卡托投影"></a>墨卡托投影</h2><p>参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A2%A8%E5%8D%A1%E6%89%98%E6%8A%95%E5%BD%B1/5477927?fr=aladdin">https://baike.baidu.com/item/%E5%A2%A8%E5%8D%A1%E6%89%98%E6%8A%95%E5%BD%B1/5477927?fr=aladdin</a></p>
<h2 id="相机："><a href="#相机：" class="headerlink" title="相机："></a>相机：</h2><p>透视投影：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/stl112514/article/details/83927643">https://blog.csdn.net/stl112514/article/details/83927643</a></p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>webgl使用矩阵实现平移，缩放。参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1005103">https://cloud.tencent.com/developer/article/1005103</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/M_Swift153GLSL%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/M_Swift153GLSL%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">GLES语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-24 14:25:04" itemprop="dateCreated datePublished" datetime="2020-11-24T14:25:04+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 16:09:15" itemprop="dateModified" datetime="2021-04-12T16:09:15+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GLSL-着色器编程语言"><a href="#GLSL-着色器编程语言" class="headerlink" title="GLSL(着色器编程语言)"></a>GLSL(着色器编程语言)</h1><p>1、介绍<br>是一个和C语言语法比较类似的着色器变成语言<br>2、注释<br>和C语言一样<br>// this is a comment<br>/*</p>
<ul>
<li>  this is muti comment</li>
<li>/<br>备注：GLSL语言必须由ASCII码字符组成，如果包括非ascii码编译会出错<br>3、变量命名<br>GLSL的变量名必须以字母或者下划线开头，由英文字母，数字，_组成，且不能是gl_或__开头(都是系统预留的)，也不能是系统关键字<br>4、预处理指令<br>预处理指令以#开头，#号之前不能有除了空白字符之外的任何字符。每一个指令独占一行。内置的预处理指令如下：<br>#define<br>#undef<br>#if<br>#ifdef<br>#ifndef<br>#else<br>#elif<br>#endif<br>#error<br>#pragma<br>#extension<br>#version<br>#line</li>
</ul>
<p>#pragma<br>编译指示。用来控制编译器的一些行为，开发和调试时可以设置为off，默认设为on。</p>
<p>#pragma optimize(on)<br>#pragma optimize(off)</p>
<p>开发和调试时可以打开debug选项，以便获取更多的调试信息。默认设为off。<br>#pragma debug(on)<br>#pragma debug(off)</p>
<p>#extension<br>如果想使用GLGL默认不支持的操作，则必须启用对应的扩展，启用一个扩展可以使用下面的命令：</p>
<p>#extension : behavior<br>#extension all : behavior<br>其中，extension_name是扩展的名称，all是指所有的编译器支持的扩展。<br>behavior是指对该扩展的具体操作。比如启用、禁用等等。详情如下：<br>behavior                                    作用<br>require                         启用该扩展。如果不支持，则报错。<br>enable                          启用该扩展。如果不支持，则会警告。extension_name是all的时候会报错。<br>warn                            启用该扩展。但是会检测到所有使用该扩展的地方，提出警告。<br>disable                         禁用该扩展。如果该扩展不被支持，则提出警告。</p>
<p>5、预定义的变量<br>除此之外，还预定义了一些变量：<br><strong>LINE</strong> ：int类型，当前的行号，也就是在Source String中是第一行<br><strong>FILE</strong> ：int类型，当前Source String的唯一ID标识<br><strong>VERSION</strong> ：int类型，GLGL的版本<br>GL_ES ：对于嵌入式系统（Embed System，简称 ES），它的值为1，否则为0</p>
<p>6、运算符及其优先级<br>| 1 |()<br>| 从右往左 |<br>| 3 | 乘除法 | * / % | 从左往右 |<br>| 4 | 加减法 | + - | 从左往右 |<br>| 5 | 位运算 移位 | &lt;&lt; &gt;&gt; | 从左往右 |<br>| 6 | 大小关系 | &lt; &gt; &lt;= &gt;= | 从左往右 |<br>| 7 | 相等性判断 | == != | 从左往右 |<br>| 8 | 位运算 与 | &amp; | 从左往右 |<br>| 9 | 位或算 非 | ^ | 从左往右 |<br>| 10 | 位或算 或 | | | 从左往右 |<br>| 11 | 逻辑与 | &amp;&amp; | 从左往右 |<br>| 12 | 逻辑或 | || | 从左往右 |</p>
<p>7、关键词<br>列举一下GLSL中的关键词，这些全部是系统保留的，不可私自篡改。</p>
<p>attribute const uniform varying<br>break continue do for while<br>if else<br>in out inout<br>float int void bool true false<br>lowp mediump highp precision invariant<br>discard return<br>mat2 mat3 mat4<br>vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4<br>sampler2D samplerCube<br>struct</p>
<p>asm<br>class union enum typedef template this packed<br>goto switch default<br>inline noinline volatile public static extern external interface flat<br>long short double half fixed unsigned superp<br>input output<br>hvec2 hvec3 hvec4 dvec2 dvec3 dvec4 fvec2 fvec3 fvec4<br>sampler1D sampler3D<br>sampler1DShadow sampler2DShadow<br>sampler2DRect sampler3DRect sampler2DRectShadow<br>sizeof cast<br>namespace using</p>
<p>除此之外，所有的以”__”开头的变量全部是预留的，自定义的变量不能以“__”开头。</p>
<h1 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hankern/article/details/85316476">https://blog.csdn.net/hankern/article/details/85316476</a><br>1.1 Vertex Shader<br>对于发送给GPU的每一个Vertex(顶点)，都要执行一次Vertex Shader。其功能是把每个顶点在虚拟空间中的三维坐标变换为可以在屏幕上显示的二维坐标，并带有用于z-buffer的深度信息。Vertex Shader可以操作的属性有：位置、颜色、纹理坐标，但是不能创建新的顶点。</p>
<p>vertex shader主要完成以下工作：1).基于点操作的矩阵乘法位置变换；2).根据光照公式计算每点的color值；3).生成或者转换纹理坐标。<br>Vertex Shader输入数据如下：<br>1).Attributes：由 vertext array 提供的顶点数据，如空间位置，法向量，纹理坐标以及顶点颜色，它是针对每一个顶点的数据。属性只在顶点着色器中才有，片元着色器中没有属性。属性可以理解为针对每一个顶点的输入数据。OpenGL ES 2.0 规定了所有实现应该支持的最大属性个数不能少于 8 个。<br>注：Vertex Attributes 是每点的属性数据。与一个index序号绑定。外部程序可通过 glBindAttribLocation将一个attribute 名与一个index绑定起来。当然，OPENGL ES 内部会自动绑定所有attributes.外部程序只需通过 glGetAttribLocation获取指定attribute名的index。 给Attribute传值可以通过 glVertexAttribPointer函数或者glVertexAttrib4fv</p>
<p>2).Uniforms：uniforms保存由应用程序传递给着色器的只读常量数据。在顶点着色器中，这些数据通常是变换矩阵，光照参数，颜色等。由 uniform 修饰符修饰的变量属于全局变量，该全局性对顶点着色器与片元着色器均可见，也就是说，这两个着色器如果被连接到同一 个program Object，则它们共享同一份 uniform 全局变量集。因此如果在这两个着色器中都声明了同名的 uniform 变量，要保证这对同名变量完全相同：同名+同类型，因为它们实际是同一个变量。此外，uniform 变量存储在常量存储区，因此限制了 uniform 变量的个数，OpenGL ES 2.0 也规定了所有实现应该支持的最大顶点着色器 uniform 变量个数不能少于 128 个，最大的片元着色器 uniform 变量个数不能少于 16 个。</p>
<p>3).Samplers：一种特殊的 uniform，在vertex shader中是可选的，用于呈现纹理。sampler 可用于顶点着色器和片元着色器。</p>
<p>4).Shader program：由 main 声明的一段程序源码，描述在顶点上执行的操作：如坐标变换，计算光照公式来产生 per-vertex 颜色或计算纹理坐标。</p>
<p>1.2 Fragment Shader<br>Pixel Shader(像素着色器)就是众所周知的Fragment Shader(片元着色器)，它计算每个像素的颜色和其它属性。它通过应用光照值、凹凸贴图，阴影，镜面高光，半透明等处理来计算像素的颜色并输出。它也可改变像素的深度(z-buffering)或在多个渲染目标被激活的状态下输出多种颜色。一个Pixel Shader不能产生复杂的效果，因为它只在一个像素上进行操作，而不知道场景的几何形状。</p>
<p>Fragment Shader输入数据如下：<br>1).Varyings：这个在前面已经讲过了，顶点着色器阶段输出的 varying 变量在光栅化阶段被线性插值计算之后输出到片元着色器中作为它的输入，即上图中的 gl_FragCoord，gl_FrontFacing 和 gl_PointCoord。OpenGL ES 2.0 也规定了所有实现应该支持的最大 varying 变量个数不能少于 8 个。<br>2).Uniforms：前面也已经讲过，这里是用于片元着色器的常量，如雾化参数，纹理参数等；OpenGL ES 2.0 也规定了所有实现应该支持的最大的片元着色器 uniform 变量个数不能少于 16 个。<br>3).Samples：一种特殊的 uniform，用于呈现纹理。<br>4).Shader program：由 main 申明的一段程序源码，描述在片元上执行的操作。<br>FragmentShader输出为：<br>在顶点着色器阶段只有唯一的 varying 输出变量-即内建变量：gl_FragColor</p>
<h1 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jxw167/article/details/55098260">https://blog.csdn.net/jxw167/article/details/55098260</a><br> 在游戏中模型的渲染显示，当模型被加载后，在引擎底层需要DX库或者OpenGL库提供数据缓冲从而将数据传输到GPU中渲染绘制，模型都是由数据组成的，这些数据需要OpenGL图形库渲染它们时开辟一块缓冲内存进行存放，OpenGL为我们开发者提供了很多函数接口供我们使用，作为开发者熟悉这些关于缓冲数据操作的接口对于学习Shader编程也非常有帮助，市面上的Unity引擎和UE4虚幻引擎也是基于这些函数开发的，本片博客主要是为读者揭秘OpenGL中的数据缓冲原理。<br> 在OpenGL中缓冲只是一块儿内存区域的对象，当把缓冲绑定到一个特定缓冲对象时，我们就给缓冲赋予了一个特殊的意义。当我们绑定到GL_ARRAY_BUFFER的时候，这个缓冲就是一个顶点数组缓冲，我们也可以简单地绑定到GL_ELEMENT_ARRAY_BUFFER。OpenGL内部为每个目标（target）储存一个缓冲，并基于目标来处理不同的缓冲。<br> 我们使用glBufferData函数填充缓冲对象管理的内存，这个函数分配了一块内存空间，然后把数据存入其中。如果我们向它的data这个参数传递的是NULL，那么OpenGL只会帮我们分配内存，而不会填充它。如果我们先打算开辟一些内存，稍后回到这个缓冲一点一点的填充数据，有些时候会很有用。</p>
<p> 我们还可以调用glBufferSubData函数填充特定区域的缓冲，而不是一次填充整个缓冲。这个函数需要一个缓冲目标（target），一个偏移量（offset），数据的大小以及数据本身作为参数。这个函数新的功能是我们可以给它一个偏移量（offset）来指定我们打算填充缓冲的位置与起始位置之间的偏移量。这样我们就可以插入/更新指定区域的缓冲内存空间了。一定要确保修改的缓冲要有足够的内存分配，所以在调用glBufferSubData之前，调用glBufferData是必须的。注意，glBufferData函数接口在Shader编程中使用的非常广泛。它的函数接口如下所示：</p>
<p> float data[] = {<br>   0.5f, 1.0f, -0.35f<br>   …<br> };</p>
<p> glBindBuffer(GL_ARRAY_BUFFER, buffer);<br> // 获取当前绑定缓存buffer的内存地址<br> void* ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);<br> // 向缓冲中写入数据<br> memcpy(ptr, data, sizeof(data));<br> // 完成够别忘了告诉OpenGL我们不再需要它了<br> glUnmapBuffer(GL_ARRAY_BUFFER);</p>
<p>调用glUnmapBuffer函数可以告诉OpenGL我们已经用完指针了，OpenGL会知道你已经做完了。通过解映射（unmapping），指针会不再可用，如果OpenGL可以把你的数据映射到缓冲上，就会返回GL_TRUE。</p>
<p>把数据直接映射到缓冲上使用glMapBuffer很有用，因为不用把它储存在临时内存里。你可以从文件读取数据然后直接复制到缓冲的内存里。</p>
<p>使用glVertexAttribPointer函数可以指定缓冲内容的顶点数组的属性的布局(Layout)。我们已经知道，通过使用顶点属性指针我们可以交叉(Interleave)属性，也就是说我们可以把每个顶点的位置、法线、纹理坐标放在彼此挨着的地方。现在我们了解了更多的缓冲的内容，可以采取另一种方式了。我们可以做的是把每种类型的属性的所有向量数据批量保存在一个布局，而不是交叉布局。</p>
<p>当从文件加载顶点数据时你通常获取一个位置数组，一个法线数组和一个纹理坐标数组。需要花点力气才能把它们结合为交叉数据。使用 glBufferSubData 可以简单的实现分批处理方式：<br>缓冲满足的条件：</p>
<p>建构一个完整的帧缓冲必须满足以下条件：</p>
<p>我们必须往里面加入至少一个附件（颜色、深度、模板缓冲）。<br>其中至少有一个是颜色附件。<br>所有的附件都应该是已经完全做好的（已经存储在内存之中）。<br>每个缓冲都应该有同样数目的样本。</p>
<h1 id="投影相机"><a href="#投影相机" class="headerlink" title="投影相机"></a>投影相机</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/M_Swift156OpenGLES%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/M_Swift156OpenGLES%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">OpenGL常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-24 10:32:44" itemprop="dateCreated datePublished" datetime="2020-11-24T10:32:44+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 16:09:51" itemprop="dateModified" datetime="2021-04-12T16:09:51+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创建buffers"><a href="#创建buffers" class="headerlink" title="创建buffers"></a>创建buffers</h1><p>1、void glGenFramebuffers(GLsizei n,GLuint * framebuffers);<br>创建frame buffers<br>2、void glDeleteFramebuffers(GLsizei n,const GLuint * framebuffers);<br>删除frame buffers<br>n表示buffers数量,framebuffers 表示buffer的数组<br>3、void glGenRenderbuffers(GLsizei n,GLuint * renderbuffers);<br>创建render buffers<br>4、void glDeleteRenderbuffers(GLsizei n,const GLuint * renderbuffers);<br>删除 render buffers<br>5、void glFramebufferRenderbuffer(GLenum target,GLenum attachment,GLenum renderbuffertarget,GLuint renderbuffer);<br>将render buffer关联到GL_FRAMEBUFFER常量上面<br>target:取值必须为GL_FRAMEBUFFER<br>attachment:取值为GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT, or GL_STENCIL_ATTACHMENT。一般视频渲染取GL_COLOR_ATTACHMENT0<br>renderbuffertarget:取值必须为GL_RENDERBUFFER<br>renderbuffer:要关联的render buffer的id(由glGenRenderbuffers()函数生成)<br>6、GLenum glCheckFramebufferStatus(GLenum target);<br>检查frame buffer相关是否成功，再glFramebufferRenderbuffer()之后调用去检查<br>tagert:GL_FRAMEBUFFER;<br>7.glEnableVertexAttribArray()或 者glDisableVertexAttribArray()<br>//— 告 诉 OpenGL ES 在接下来的渲染中是否使用缓存中的数据<br>glEnableVertexAttribArray(GLKVertexAttribPosition);</p>
<h1 id="着色器相关函数"><a href="#着色器相关函数" class="headerlink" title="着色器相关函数"></a>着色器相关函数</h1><p>1、GLuint glCreateShader(GLenum shaderType);<br>创建着色器程序的句柄；成功返回非0整数<br>shaderType:着色器类型，顶点和片元；取值GL_VERTEX_SHADER和GL_FRAGMENT_SHADER<br>2、void glShaderSource(GLuint shader,GLsizei count,const GLchar * const *string,const GLint *length);<br>为着色器句柄添加GLSL源代码<br>shader:前面创建的着色器句柄<br>count:源代码个数<br>string:源代码字符串<br>lenght:源代码字符串长度<br>3、void glCompileShader(GLuint shader);<br>编译着色器GLSL源码<br>4、void glGetShaderiv(GLuint shader,GLenum pname,GLint *params);<br>获取着色器编译过程中的日志和检测是否编译成功<br>// 检查编译中日志,logLenght&gt;0则说明有日志<br>glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;logLenght);<br>// 检查编译是否成功,成功status==GLTRUE<br>glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;status);<br>5、GLuint glCreateProgram(void);<br>创建用于生成顶点着色器和片元着色器最终程序的句柄<br>6、void glAttachShader(GLuint program,GLuint shader);<br>添加顶点着色器和片元着色器<br>program:第五步创建的program<br>shader:为前面编译成功的着色器句柄<br>7、void glLinkProgram(GLuint program);<br>连接程序,就像C语言的连接一样，这里将顶点着色器和片元着色器连接起来<br>8、void glGetProgramiv(GLuint program,GLenum pname,GLint *params);<br>输出连接过程中的日志和检查连接是否成功<br>// 检查编译中日志,logLenght&gt;0则说明有日志<br>glGetProgramiv(filterProgram, GL_INFO_LOG_LENGTH, &amp;logLength);<br>// 检查编译是否成功,成功status==GLTRUE<br>glGetProgramiv(filterProgram, GL_LINK_STATUS, &amp;status);<br>9、void glUseProgram(GLuint program);<br>调用此函数后着色器程序才能正常使用，就相当于生成可执行程序后还得点击一下让其运行起来一样；之后才能使用第10个之后的函数<br>10、GLint glGetAttribLocation(GLuint program,const GLchar *name);<br>获取顶点着色器中的attribute修饰的变量的句柄，后面就可以通过该句柄从应用端向GLSL对应的变量传值了<br>program:对应的GLSL程序，该函数必须在GLSL程序运行后才能使用(即调用了glUseProgram()函数)<br>name:GLSL中attribute修饰的变量名<br>11、GLint glGetUniformLocation(GLuint program,const GLchar *name);<br>获取片元着色器中uniform sampler2D修饰的变量的句柄，后面就可以将该句柄和对应的纹理单元关联起来<br>program:对应的GLSL程序，该函数必须在GLSL程序运行后才能使用(即调用了glUseProgram()函数)<br>name:GLSL中uniform sampler2D修饰的变量名</p>
<h1 id="视窗有关函数"><a href="#视窗有关函数" class="headerlink" title="视窗有关函数"></a>视窗有关函数</h1><p>1、void glClearColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha);<br>设置清屏的颜色,四个参数的范围都是0-1的浮点数，表示RGBA的组合<br>2、void glClear(GLbitfield mask);<br>用前面glClearColor(),glClearDepthf(),and glClearStencil()设置的颜色清除buffers;<br>mask在这个函数中的取值要与上面三个函数一一对应，可取值如下：<br>GL_COLOR_BUFFER_BIT:color buffer，前面如果调用了glClearColor()，则设置包含该值<br>GL_DEPTH_BUFFER_BIT：depth buffer，前面如果调用了glClearDepthf()，则设置包含该值<br>GL_STENCIL_BUFFER_BIT：stencil buffer，前面如果调用了glClearStencil()，则设置包含该值<br>mask可以是上面几个值的组合,比如GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT,但前提是前面分别调用了glClearColor()和glClearDepthf()设置颜色</p>
<p>3、void glViewport(GLint x,GLint y,GLsizei width,GLsizei height);<br>以当前视图的大小为基础(当前视图的左下角为坐标原点)在开辟一个(x,y,width,height)的渲染区域，该区域将作为后面顶点坐标等的参考坐标系。</p>
<h1 id="纹理操作相关函数-应用端和opengl-es传值相关函数"><a href="#纹理操作相关函数-应用端和opengl-es传值相关函数" class="headerlink" title="纹理操作相关函数,应用端和opengl es传值相关函数"></a>纹理操作相关函数,应用端和opengl es传值相关函数</h1><p>4、void glPixelStorei(GLenum pname,GLint param);<br>设置像素的对齐方式；<br>pname:为GL_PACK_ALIGNMENT,会影响glReadPixels()函数从opengl es缓存中读取像素数据到app中的字节对齐方式<br>pname:为GL_UNPACK_ALIGNMENT，会影响glTexImage2D() 和 glTexSubImage2D()函数从app发送像素数据到opengl es的字节对齐方式<br>param:表示每次读取或者发送的像素数据是param的整数倍;举个例子，比如param为4，想要通过glTexImage2D()传输5x5像素的一张图片(25不是4的整数倍，所以需要手<br>动添加padding即添加3个字节到这个图片buf中,这样读取时才不会出错，如果param为1就没有这样的烦恼，但是可能性能会低，值越大吞吐量就越大，效率也越高。<br>那么上面两种方式的取值含义都是一样的,<br>默认值为4；取值如下：<br>1 (byte-alignment),<br>2 (rows aligned to even-numbered bytes),<br>4 (word-alignment),<br>8 (rows start on double-word boundaries).</p>
<p>5、void glDrawArrays(GLenum mode,GLint first,GLsizei count);<br>确定要绘制的几何形状；通过mode指定，可取值如下：<br>GL_POINTS:绘制点，那么顶点着色器还需要有gl_PointSize内建变量指定顶点的大小<br>GL_LINES:绘制线<br>GL_TRIANGLE_STRIP:绘制三角形，比如绘制纹理图片就是这种类型<br>它处于渲染管线的第一阶段</p>
<p>6、void glVertexAttribPointer(GLuint index,GLint size,GLenum type,GLboolean normalized,GLsizei stride,const GLvoid * pointer);<br>用一个数组的方式给GLSL中attribute修饰的属性变量赋值;<br>index:前面获取的GLSL变量的句柄<br>size:表示每几个元素表示一个attribute修饰的变量;比如对于attribute vec4 position;修饰的顶点,就表示四个数据(x,y,z,w)才能表示一个顶点坐标，如果这里size为<br>2，那么x,y有值，z，w将默认为0,依次类推。<br>type:每个元素的数据类型，取值为GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_FIXED, or GL_FLOAT<br>normalized:是否要对pointer中的数据进行归一化处理成(-1.0,1.0)范围的浮点型类型,如果已经是浮点型，这里传GL_FALSE即可。<br>stride:获取每一个元素是否需要跳字节，如果前面的type类型pointer中元素类型一致，这里传0<br>pointer:几何形状的各个顶点组成的数组;对于矩形来说，数组中顶点顺序为(左下角，右下角，左上角，右上角)<br>该赋值得用glEnableVertexAttribArray()函数启用后才会生效</p>
<p>7、void glUniform1i(GLint location,GLint v0);<br>给片段着色器中的uniform sampler2D 修饰的纹理变量赋值，只有该函数调用后,片元着色器中的texture2D()函数才能正确工作<br>location:为片元着色器中uniform sampler2D 修饰的变量句柄<br>v0的取值为纹理单元的索引；比如想让激活的GL_TEXTURE2和上面的变量关联，则v0取值为2，那么片元着色器中的texture2D()函数将从该纹理单元对应的纹理里面查找像素</p>
<p>8、void glEnableVertexAttribArray(GLuint index);<br>   void glDisableVertexAttribArray(GLuint index);<br>启用和禁用给attribute变量的赋值</p>
<p>9、void glGetIntegerv(GLenum pname,GLint * params);<br>获取指定类型的值<br>GL_ACTIVE_TEXTURE:获取设备支持的纹理单元数目<br>GL_MAX_TEXTURE_SIZE:获取设备支持的纹理能渲染的最大的长或宽大小，超过此大小则必须先压缩再传给opengl es，否则opengl es无法渲染</p>
<p>10、void glGenTextures(GLsizei n,GLuint * textures);<br>    void glDeleteTextures(GLsizei n,const GLuint * textures);<br>创建纹理Id和删除纹理Id<br>调用删除纹理Id函数会解除它与纹理类型对象的绑定</p>
<p>11、void glActiveTexture(GLenum texture);<br>选择指定的纹理单元，texture取值范围GL_TEXTUREi(i取值为0-GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1)，其中GL_TEXTURE0默认激活的<br>方式一、glActioveTexture(GL_TEXTUREi);只能到GL_TEXTURE31<br>方式二、glActioveTexture(GL_TEXTURE0+i);i可以取值到GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1</p>
<p>12、void glBindTexture(GLenum target,GLuint texture);<br>绑定纹理，当绑定完后，如果用其它texture再次与target绑定，则先前的绑定失效。或者调用glDeleteTextures()函数后，该绑定也将失效<br>target:纹理类型，可取值：GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP<br>texture:纹理id，由glGenTextures()函数生成<br>函数10和11的工作流程用伪代码表示如下：<br>GLenum curentTexutre;<br>GLESObj globalObj;<br>glActiveTexture(GLenum texture)<br>{<br>curentTexutre = texture;<br>}<br>glBindTexture(GLenum target,GLuint texture)<br>{<br>TextureUnit *texUnit = globalObj[curentTexutre];<br>switch(target)<br>{<br>case GL_TEXTURE_1D: texUnit-&gt;targetTexture1D = textureObject; break;<br>case GL_TEXTURE_2D: texUnit-&gt;targetTexture2D = textureObject; break;<br>case GL_TEXTURE_3D: texUnit-&gt;targetTexture3D = textureObject; break;<br>case GL_TEXTURE_CUBEMAP: texUnit-&gt;targetTextureCube = textureObject; break;<br>}<br>glTexImage2D(….)<br>{<br>    TextureUnit *texUnit = globalObj[curentTexutre];<br>    texUnit-&gt;targetTexture2D-&gt;TexImage2D(…);<br>    ……<br>}<br>所以如果调用glActiveTexture()之后不调用glBindTexture()函数，其实后面的glxxx()系列函数设置的参数只是对curentTexutre有效，会造成值被覆盖</p>
<p>13、void glTexParameteri(GLenum target,GLenum pname,GLint param);<br>给指定的纹理类型对象设定参数<br>warping<br>纹理坐标的范围是(0,1)当给定的纹理坐标超过这个范围时，将通过如下方式对超过的纹理坐标进行采样<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_WARP_S,GL_REPEAT) S轴方向<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_WARP_T,GL_REPEAT) T轴方向<br>GL_REPEAT,GL_MIRRODED_REPEAT    (经过试验，此这两种方式视乎无效，GL_REPEAT默认)<br>GL_CLAMP_TO_EDGE 超出的部分坐标被设置成0或者1，行程边缘色<br>filter<br>实际纹理的分辨率大小与要显示的屏幕区域的分辨率大小往往不相等，也就是要根据屏幕的实际大小对纹理进行放大和缩小，这里就需要用到filter，取值如下：<br>GL_NEAREST:最邻近插值，取最近的纹素像素<br>GL_LINEAR:线性插值，取最近的点的线性平均值 (性能消耗较大)<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR)<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR)<br>mipmaps<br>它也是一种纹理过滤算法，按我的理解它是以空间换时间的一种技巧，具体原理就是事先根据纹理生成长和宽逐渐除以2的小纹理，比如原始纹理大小128x128，<br>采用此方法后，会生成64x64 32x32 16x16 8x8 4x4 2x2 1x1的一系列纹理，如果需要20x18的纹理，则取最近的32x32 16x16进行平均<br>该方法很好的解决了如下问题：<br>1、当纹理很大，但是屏幕区域很小，渲染出现的闪烁问题，因为根据最邻近插值和线性插值都无法很快计算出合理的像素<br>它可以取的值如下：<br>GL_NEAREST_MIPMAP_NEAREST 选择最近的mipmap层，然后再用最邻近过滤插值<br>GL_LINEAR_MIPMAP_NEAREST    选择最近mipmap层，然后再用线性插值<br>GL_NEAREST_MIPMAP_LINEAR    选择最近的2层mipmap用最邻近过滤插值<br>GL_LINEAR_MIPMAP_LINEAR       选择最邻近的2层mipmap用线性插值<br>使用如下函数生成mipmaps<br>glGenerateMipmap(GLenum target);</p>
<p>14、void glTexImage2D(GLenum target,    // 纹理对象类型，取值GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z或者<br>GLint level,    // 纹理压缩等级，0代表不压缩，默认0<br>GLint internalformat,// 内部每个像素的构成格式,取值GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_RGBA.<br>GLsizei width,  // 纹理的宽，单位像素<br>GLsizei height, // 纹理的高，单位像素<br>GLint border,   // 设置为0 即可<br>GLenum format,  // data中每个像素的构成格式，必须与internalformat保持一直，取值为GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.<br>GLenum type,    // data中像素数据的组织方式,取值 GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, and GL_UNSIGNED_SHORT_5_5_5_1.<br>const GLvoid * data // 代表一张图片的像素数据<br>);<br>GL_ALPHA<br>表示data中每个像素只有一个透明通道，当它传递给opengl es时，自动将RGB填充为0。<br>GL_RGB<br>表示data中每个像素只由RGB三个数组成，当它传递给opengl es时，自动将Alpha填充为1。<br>GL_RGBA<br>表示data中每个像素只由RGBA四个数组成，传递给Opengl es时，原封不动的传递<br>GL_LUMINANCE<br>表示data中每个像素只有一个值组成，当它传递给opengl es时，自动将RGB填充为该值，alpha填充为1<br>GL_LUMINANCE_ALPHA<br>表示data中每个像素只有一个值组成，当它传递给opengl es时，自动将RGB填充为该值，alpha原封不动<br>GL_UNSIGNED_BYTE<br>表示组成每个像素的通道占用8位该值可以与前面任何格式搭配使用<br>GL_UNSIGNED_SHORT_5_6_5<br>表示RGB分别占用6 6 5位,一个像素两个字节，该值只能与前面GL_RGB搭配<br>GL_UNSIGNED_SHORT_4_4_4_4，<br>表示RGBA 分别占用4位，一个像素两个字节，该值只能与前面GL_RGB搭配GL_RGBA<br>GL_UNSIGNED_SHORT_5_5_5_1，<br>表示RGBA 分别占用 5551位，一个像素两个字节，该值只能与前面GL_RGB搭配GL_RGBA</p>
<p>15、void glTexSubImage2D(    GLenum target,<br>GLint level,<br>GLint xoffset,<br>GLint yoffset,<br>GLsizei width,<br>GLsizei height,<br>GLenum format,<br>GLenum type,<br>const GLvoid * data);<br>用法和第15个函数一样，只不过可以选取data中的部分数据传递，更加灵活</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/41/">41</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">403</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
