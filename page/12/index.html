<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift149%E4%BD%8D%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift149%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">位运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:46" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:46+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>异或求或</p>
<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><pre><code>public int hammingWeight(int n) &#123;
    int bits = 0;
    int mask = 1;
    for (int i = 0; i &lt; 32; i++) &#123;
        if ((n &amp; mask) != 0) &#123;
            bits++;
        &#125;
        mask &lt;&lt;= 1;
    &#125;
    return bits;
&#125;
方法 2：位操作的小技巧
我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把答案加一。当数字变成 
0 的时候偶，我们就知道它没有 1 的位了，此时返回答案

public int hammingWeight(int n) &#123;
    int sum = 0;
    while (n != 0) &#123;
        sum++;
        n &amp;= (n - 1);
    &#125;
    return sum;
&#125;
</code></pre>
<h2 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h2><pre><code>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次
的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
方法一：分组异或
class Solution &#123;
    public int[] singleNumbers(int[] nums) &#123;
        //用于将所有的数异或起来
        int k = 0;
    
    for(int num: nums) &#123;
        k ^= num;
    &#125;
    
    //获得k中最低位的1
    int mask = 1;

    //mask = k &amp; (-k) 这种方法也可以得到mask，具体原因百度 哈哈哈哈哈
    while((k &amp; mask) == 0) &#123;
        mask &lt;&lt;= 1;
    &#125;
    
    int a = 0;
    int b = 0;
    
    for(int num: nums) &#123;
        if((num &amp; mask) == 0) &#123;
            a ^= num;
        &#125; else &#123;
            b ^= num;
        &#125;
    &#125;
    
    return new int[]&#123;a, b&#125;;
&#125;
</code></pre>
<p>}</p>
<h2 id="圆圈中最后剩下的数字-约瑟夫环问题"><a href="#圆圈中最后剩下的数字-约瑟夫环问题" class="headerlink" title="圆圈中最后剩下的数字  约瑟夫环问题"></a>圆圈中最后剩下的数字  约瑟夫环问题</h2><pre><code>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个
数字。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数
字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
Java解决约瑟夫环问题，告诉你为什么模拟会超时！
总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。
class Solution &#123;
    public int lastRemaining(int n, int m) &#123;
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推
        for (int i = 2; i &lt;= n; i++) &#123;
            ans = (ans + m) % i;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
<h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><pre><code>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
class Solution &#123;
    public int add(int a, int b) &#123;
        while(b != 0) &#123; // 当进位为 0 时跳出
            int c = (a &amp; b) &lt;&lt; 1;  // c = 进位
            a ^= b; // a = 非进位和
            b = c; // b = 进位
        &#125;
        return a;
    &#125;
&#125;
</code></pre>
<h2 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h2><pre><code>给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。
方法一：排序
class Solution &#123;
    public int missingNumber(int[] nums) &#123;
        Arrays.sort(nums);

    // 判断 n 是否出现在末位
    if (nums[nums.length-1] != nums.length) &#123;
        return nums.length;
    &#125;
    // 判断 0 是否出现在首位
    else if (nums[0] != 0) &#123;
        return 0;
    &#125;

    // 此时缺失的数字一定在 (0, n) 中
    for (int i = 1; i &lt; nums.length; i++) &#123;
        int expectedNum = nums[i-1] + 1;
        if (nums[i] != expectedNum) &#123;
            return expectedNum;
        &#125;
    &#125;

    // 未缺失任何数字（保证函数有返回值）
    return -1;
&#125;
&#125;
方法二：哈希表
class Solution &#123;
    public int missingNumber(int[] nums) &#123;
        Set&lt;Integer&gt; numSet = new HashSet&lt;Integer&gt;();
        for (int num : nums) numSet.add(num);

    int expectedNumCount = nums.length + 1;
    for (int number = 0; number &lt; expectedNumCount; number++) &#123;
        if (!numSet.contains(number)) &#123;
            return number;
        &#125;
    &#125;
    return -1;
&#125;
&#125;
方法三：位运算
class Solution &#123;
    public int missingNumber(int[] nums) &#123;
        int missing = nums.length;
        for (int i = 0; i &lt; nums.length; i++) &#123;
            missing ^= i ^ nums[i];
        &#125;
        return missing;
    &#125;
&#125;
方法四：数学
我们可以用 高斯求和公式 求出 [0..n] 的和，减去数组中所有数的和，就得到了缺失的数字。高斯求和公式即
class Solution &#123;
    public int missingNumber(int[] nums) &#123;
        int expectedSum = nums.length*(nums.length + 1)/2;
        int actualSum = 0;
        for (int num : nums) actualSum += num;
        return expectedSum - actualSum;
    &#125;
&#125;
</code></pre>
<h2 id="判断一个数是不是2的指数"><a href="#判断一个数是不是2的指数" class="headerlink" title="判断一个数是不是2的指数"></a>判断一个数是不是2的指数</h2><pre><code>一个数如果是2的指数，那么他的二进制表示中一定y只含有一个1
2^0 = 1 = 0b0001;
2^1 = 2 = 0b0010;
</code></pre>
<h2 id="给定一个整数，写一个函数来判断它是否是-3-的幂次方。"><a href="#给定一个整数，写一个函数来判断它是否是-3-的幂次方。" class="headerlink" title="给定一个整数，写一个函数来判断它是否是 3 的幂次方。"></a>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</h2><pre><code>方法一：循环迭代
public class Solution &#123;
    public boolean isPowerOfThree(int n) &#123;
        if (n &lt; 1) &#123;
            return false;
        &#125;

    while (n % 3 == 0) &#123;
        n /= 3;
    &#125;

    return n == 1;
&#125;
&#125;
方法二：基准转换
我们所要做的就是将数字转换为以3为底的基数 ，并检查它是否为前导1，后跟所有 0
public class Solution &#123;
    public boolean isPowerOfThree(int n) &#123;
        return Integer.toString(n, 3).matches(&quot;^10*$&quot;);
    &#125;
&#125;
方法三：运算法
public class Solution &#123;
    public boolean isPowerOfThree(int n) &#123;
        return (Math.log10(n) / Math.log10(3)) % 1 == 0;
    &#125;
&#125;
方法四：整数限制
 n 的类型是 int 在 Java 中说明了该变量是四个字节，他的最大值为 2147483647
我们现在可以推断出 n 的最大值，也就是 3 的幂，是 1162261467
因此我们只需要将 3的19次方  除以 n。若余数为 0 意味着 n 是 的除数，因此是 3 的幂
public class Solution &#123;
    public boolean isPowerOfThree(int n) &#123;
        return n &gt; 0 &amp;&amp; 1162261467 % n == 0;
    &#125;
&#125;
</code></pre>
<h2 id="给定一个Excel表格中的列名称，返回其相应的列序号。"><a href="#给定一个Excel表格中的列名称，返回其相应的列序号。" class="headerlink" title="给定一个Excel表格中的列名称，返回其相应的列序号。"></a>给定一个Excel表格中的列名称，返回其相应的列序号。</h2><pre><code>    本质就是26进制呗
    A -&gt; 1
        B -&gt; 2
        C -&gt; 3
    AA -&gt; 27
        AB -&gt; 28 
    class Solution &#123;
        public int titleToNumber(String s) &#123;
            int ans = 0;
            for(int i=0;i&lt;s.length();i++) &#123;
                int num = s.charAt(i) - &#39;A&#39; + 1;
                ans = ans * 26 + num;
            &#125;
            return ans;
        &#125;
    &#125;
</code></pre>
<h2 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a>阶乘后的零</h2><pre><code>    方法1:一步一步的乘
    方法2:因子5，看有多少对 5 的因子。
    public int trailingZeroes(int n) &#123;
            
        // Calculate n!
            BigInteger nFactorial = BigInteger.ONE;
            for (int i = 2; i &lt;= n; i++) &#123;
                nFactorial = nFactorial.multiply(BigInteger.valueOf(i));
            &#125;
                            
            // Count how many 0&#39;s are on the end.
            int zeroCount = 0;
            
            while (nFactorial.mod(BigInteger.TEN).equals(BigInteger.ZERO)) &#123;
                nFactorial = nFactorial.divide(BigInteger.TEN);
                zeroCount++;
            &#125;
            
            return zeroCount;
            
    &#125;
</code></pre>
<h2 id="颠倒给定的-32-位无符号整数的二进制位。"><a href="#颠倒给定的-32-位无符号整数的二进制位。" class="headerlink" title="颠倒给定的 32 位无符号整数的二进制位。"></a>颠倒给定的 32 位无符号整数的二进制位。</h2><pre><code>    输入: 00000010100101000001111010011100
    输出: 00111001011110000010100101000000
    解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
         因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
    解法1 取模求和
    public class Solution &#123;
        // you need treat n as an unsigned value
        public int reverseBits(int n) &#123;
            int res = 0;
            for (int i = 0; i &lt; 32; i++) &#123;
                res = (res &lt;&lt; 1) + (n &amp; 1);
                n &gt;&gt;= 1;
            &#125;
            return res;
        &#125;
    &#125;
    解法2 按位翻转
    public class Solution &#123;
        // you need treat n as an unsigned value
        public int reverseBits(int n) &#123;
            int res = 0;
            for (int i = 0; i &lt;= 31; i++) &#123;            
                // res += (n &amp; (1 &lt;&lt; i)) != 0 ? 1 &lt;&lt; (31 - i) : 0;
                // res |= (n &amp; (1 &lt;&lt; i)) != 0 ? 1 &lt;&lt; (31 - i) : 0;
                res ^= (n &amp; (1 &lt;&lt; i)) != 0 ? 1 &lt;&lt; (31 - i) : 0;
            &#125;
            return res;
        &#125;
    &#125;
    解法3:分治合并
    既然知道 int 值一共32位，那么可以采用分治思想，反转左右16位，然后反转每个16位中的左右8位，依次类推，最后反转2位，反转后合并即可，同时可以利用位运算在原地反转。
    public class Solution &#123;
        // you need treat n as an unsigned value
        public int reverseBits(int n) &#123;
            n = (n &gt;&gt;&gt; 16) | (n &lt;&lt; 16); 
            n = ((n &amp; 0xff00ff00) &gt;&gt;&gt; 8) | ((n &amp; 0x00ff00ff) &lt;&lt; 8); 
            n = ((n &amp; 0xf0f0f0f0) &gt;&gt;&gt; 4) | ((n &amp; 0x0f0f0f0f) &lt;&lt; 4); 
            n = ((n &amp; 0xcccccccc) &gt;&gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2); 
            n = ((n &amp; 0xaaaaaaaa) &gt;&gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1); 
            return n;
        &#125;
    &#125;
</code></pre>
<h2 id="汉明重量"><a href="#汉明重量" class="headerlink" title="汉明重量"></a>汉明重量</h2><pre><code>    编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。
    输入：00000000000000000000000000001011
    输出：3
    解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。
    方法 1：循环和位移动
    public int hammingWeight(int n) &#123;
        int bits = 0;
        int mask = 1;
        for (int i = 0; i &lt; 32; i++) &#123;
            if ((n &amp; mask) != 0) &#123;
                bits++;
            &#125;
            mask &lt;&lt;= 1;
        &#125;
        return bits;
    &#125;
    方法 2：位操作的小技巧
    我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把答案加一。当数字变成 
    0 的时候偶，我们就知道它没有 1 的位了，此时返回答案

    public int hammingWeight(int n) &#123;
        int sum = 0;
        while (n != 0) &#123;
            sum++;
            n &amp;= (n - 1);
        &#125;
        return sum;
    &#125;
</code></pre>
<h2 id="统计所有小于非负整数-n-的质数的数量。"><a href="#统计所有小于非负整数-n-的质数的数量。" class="headerlink" title="统计所有小于非负整数 n 的质数的数量。"></a>统计所有小于非负整数 n 的质数的数量。</h2><pre><code>    输入: 10
    输出: 4
    解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

    int countPrimes(int n) &#123;
        boolean[] isPrim = new boolean[n];
        Arrays.fill(isPrim, true);
        for (int i = 2; i * i &lt; n; i++) 
            if (isPrim[i]) 
                for (int j = i * i; j &lt; n; j += i) 
                    isPrim[j] = false;
    
    int count = 0;
    for (int i = 2; i &lt; n; i++)
        if (isPrim[i]) count++;
    
    return count;
    &#125;
</code></pre>
<h2 id="两数交换"><a href="#两数交换" class="headerlink" title="两数交换"></a>两数交换</h2><pre><code>1.给两个int a, b不用temp将数值调换；
int a= 1, b = 2;
a ^=b;
b^ = a;
a^ = b;
</code></pre>
<h2 id="利用或-操作大写转小写"><a href="#利用或-操作大写转小写" class="headerlink" title="利用或|操作大写转小写"></a>利用或|操作大写转小写</h2><pre><code>(&#39;a&#39; | &#39; &#39;) = &#39;a&#39;
(&#39;A&#39;|&#39; &#39;) =&#39;a&#39;
</code></pre>
<h2 id="利用与-amp-操作和下划线转大写"><a href="#利用与-amp-操作和下划线转大写" class="headerlink" title="利用与&amp;操作和下划线转大写"></a>利用与&amp;操作和下划线转大写</h2><pre><code>(&#39;b&#39; &amp; &#39;_&#39;) = &#39;B&#39;
</code></pre>
<h2 id="利用异或-和空格进行大小写互换"><a href="#利用异或-和空格进行大小写互换" class="headerlink" title="利用异或^和空格进行大小写互换"></a>利用异或^和空格进行大小写互换</h2><pre><code>‘d’ ^ &#39; &#39; = &#39;D&#39;
&#39;D&#39; ^ &#39; &#39; = &#39;d&#39;
</code></pre>
<h2 id="判断两个数是否异或"><a href="#判断两个数是否异或" class="headerlink" title="判断两个数是否异或"></a>判断两个数是否异或</h2><pre><code>int x = -1,y = 2;
bool  f = ((x ^ y) &lt; 0) // true
</code></pre>
<h2 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h2><pre><code>n = -~n;
</code></pre>
<h2 id="减一"><a href="#减一" class="headerlink" title="减一"></a>减一</h2><pre><code>n = ~-n;
</code></pre>
<h2 id="消除数字n的二进制表示的最后一个1"><a href="#消除数字n的二进制表示的最后一个1" class="headerlink" title="消除数字n的二进制表示的最后一个1"></a>消除数字n的二进制表示的最后一个1</h2><pre><code>n&amp;(n-1)
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift148%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift148%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:42" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:42+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>一般是求值问题，核心是穷举找状态转移方程
剪绳子最大乘积、大数求余
推论一： 将绳子 以相等的长度等分为多段 ，得到的乘积最大。
推论二： 尽可能将绳子以长度 3 等分为多段时，乘积最大。
最优3等分，次优，剩下个2。最差，剩下个1，将最后一个3，分成2 + 2
快速幂解析
当我们计算出来 x^2 之后就可以只进行三次乘法就可以了，相对于之前的 7 次乘法，时间大大减少了。
正则表达式匹配  
表示数值的字符串  
把数字翻译成字符串 
最长不含重复字符的子字符串  
n个骰子的点数  
股票买卖问题
打家劫舍问题
nSum问题
高楼扔鸡蛋问题
子集背包问题
完全背包问题
汉洛塔
三个人分别点了三家外卖，又一个外卖小哥配送，他有多少种配送方式
写个算法，输出2~100的素数
赛马题，网上能搜到
问一个有关花开通知蜜蜂，花关通知蜜蜂的问题；
要求想一个时间复杂度为O1的解法，来解决一个2的平方的算法题（答 无限空间换时间的策略）如何计算x^n
ACID银行家算法
一个不多于5位数的整数，反序处理problem；
一个多边形分割方法
从篮子里如何取苹果的一个算法;
火星文字
基本计算器
分治
</code></pre>
<h2 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h2><pre><code>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
</code></pre>
<p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br>并每次 向右 或者 向下 移动一格<br>class Solution {<br>    public int maxValue(int[][] grid) {<br>        int m = grid.length, n = grid[0].length;<br>        for(int i = 0; i &lt; m; i++) {<br>            for(int j = 0; j &lt; n; j++) {<br>                if(i == 0 &amp;&amp; j == 0) continue;<br>                if(i == 0) grid[i][j] += grid[i][j - 1] ;<br>                else if(j == 0) grid[i][j] += grid[i - 1][j];<br>                else grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]);<br>            }<br>        }<br>        return grid[m - 1][n - 1];<br>    }<br>}<br>递归<br>    斐波那契数列<br>斐波那契数列<br>递归法：<br>    function Fibonacci(int n) {<br>        if(n &lt; 0){<br>            return 0;<br>        }<br>        if(n == 0){<br>            return 0;<br>        }else if(n == 1){<br>            return 1;<br>        }else return Fibonacci(n-1)+ Fibonacci(n-2);<br>    }<br>动态规划：<br>class Solution {<br>    public int fib(int n) {<br>        int a = 0, b = 1, sum;<br>        for(int i = 0; i &lt; n; i++){<br>            sum = (a + b) % 1000000007;<br>            a = b;<br>            b = sum;<br>        }<br>        return a;<br>    }<br>}<br>    青蛙跳台阶问题（本质是求斐波那契数列）<br>问用递归写一个阶乘算法</p>
<p>n个骰子的点数<br>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>使用动态规划解决问题一般分为三步：<br>表示状态<br>找出状态转移方程<br>边界处理</p>
<h2 id="掷骰子"><a href="#掷骰子" class="headerlink" title="掷骰子"></a>掷骰子</h2><p>首先用数组的第一维来表示阶段，也就是投掷完了几枚骰子。<br>然后用第二维来表示投掷完这些骰子后，可能出现的点数。<br>数组的值就表示，该阶段各个点数出现的次数。<br>class Solution {<br>public:<br>    vector<double> twoSum(int n) {<br>        int dp[15][70];<br>        memset(dp, 0, sizeof(dp));<br>        for (int i = 1; i &lt;= 6; i ++) {<br>            dp[1][i] = 1;<br>        }<br>        for (int i = 2; i &lt;= n; i ++) {<br>            for (int j = i; j &lt;= 6*i; j ++) {<br>                for (int cur = 1; cur &lt;= 6; cur ++) {<br>                    if (j - cur &lt;= 0) {<br>                        break;<br>                    }<br>                    dp[i][j] += dp[i-1][j-cur];<br>                }<br>            }<br>        }<br>        int all = pow(6, n);<br>        vector<double> ret;<br>        for (int i = n; i &lt;= 6 * n; i ++) {<br>            ret.push_back(dp[n][i] * 1.0 / all);<br>        }<br>        return ret;<br>    }<br>};<br>使用随机数<br>使得n-1点数概率数组和1点数概率数组元素两两相乘，并将乘积结果加到n点数概率数组上。<br>基本思路如上，然后我们可以根据动态规划的套路：<br>1.构造dp数组：tmp[]为n个骰子的点数概率数组，pre[]为n-1个骰子的点数概率数组，一个骰子的点数概率数组显然是6个六分之一,不需要另设数组。<br>2.初始化dp数组：pre[]={1/6d,1/6d,1/6d,1/6d,1/6d,1/6d}<br>3.构造状态转移方程:tmp[x+y]+=pre[x]<em>num[y];<br>    public double[] twoSum(int n) {<br>        double pre[]={1/6d,1/6d,1/6d,1/6d,1/6d,1/6d};<br>        for(int i=2;i&lt;=n;i++){<br>            double tmp[]=new double[5</em>i+1];<br>            for(int j=0;j&lt;pre.length;j++)<br>                for(int x=0;x&lt;6;x++)<br>                    tmp[j+x]+=pre[j]/6;<br>            pre=tmp;<br>        }<br>        return pre;<br>    }</p>
<h2 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h2><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。<br>方法一： 集合 Set + 遍历</p>
<p>遍历五张牌，遇到大小王（即 0直接跳过。<br>判别重复： 利用 Set 实现遍历判重， Set<br>获取最大 / 最小的牌： 借助辅助变量 ma 和 mi ，遍历统计即可。<br>class Solution {<br>    public boolean isStraight(int[] nums) {<br>        Set<Integer> repeat = new HashSet&lt;&gt;();<br>        int max = 0, min = 14;<br>        for(int num : nums) {<br>            if(num == 0) continue; // 跳过大小王<br>            max = Math.max(max, num); // 最大牌<br>            min = Math.min(min, num); // 最小牌<br>            if(repeat.contains(num)) return false; // 若有重复，提前返回 false<br>            repeat.add(num); // 添加此牌至 Set<br>        }<br>        return max - min &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子<br>    }<br>}<br>方法二：排序 + 遍历<br>class Solution {<br>    public boolean isStraight(int[] nums) {<br>        int joker = 0;<br>        Arrays.sort(nums); // 数组排序<br>        for(int i = 0; i &lt; 4; i++) {<br>            if(nums[i] == 0) joker++; // 统计大小王数量<br>            else if(nums[i] == nums[i + 1]) return false; // 若有重复，提前返回 false<br>        }<br>        return nums[4] - nums[joker] &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子<br>    }<br>}</p>
<h2 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p>class Solution {<br>    public int maxProfit(int[] prices) {<br>        int cost = Integer.MAX_VALUE, profit = 0;<br>        for(int price : prices) {<br>            cost = Math.min(cost, price);<br>            profit = Math.max(profit, price - cost);<br>        }<br>        return profit;<br>    }<br>}</p>
<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br>class Solution {<br>    public int nthUglyNumber(int n) {<br>        int a = 0, b = 0, c = 0;<br>        int[] dp = new int[n];<br>        dp[0] = 1;<br>        for(int i = 1; i &lt; n; i++) {<br>            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;<br>            dp[i] = Math.min(Math.min(n2, n3), n5);<br>            if(dp[i] == n2) a++;<br>            if(dp[i] == n3) b++;<br>            if(dp[i] == n5) c++;<br>        }<br>        return dp[n - 1];<br>    }<br>}</p>
<h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2><p>动态规划<br>遍历数组时计算当前最大值，不断更新<br>class Solution {<br>    public int maxProduct(int[] nums) {<br>        int max = Integer.MIN_VALUE, imax = 1, imin = 1;<br>        for(int i=0; i&lt;nums.length; i++){<br>            if(nums[i] &lt; 0){<br>              int tmp = imax;<br>              imax = imin;<br>              imin = tmp;<br>            }<br>            imax = Math.max(imax<em>nums[i], nums[i]);<br>            imin = Math.min(imin</em>nums[i], nums[i]);</p>
<pre><code>        max = Math.max(max, imax);
    &#125;
    return max;
&#125;
</code></pre>
<p>}</p>
<h2 id="实现一个基本的计算器来计算一个简单的字符串表达式的值。"><a href="#实现一个基本的计算器来计算一个简单的字符串表达式的值。" class="headerlink" title="实现一个基本的计算器来计算一个简单的字符串表达式的值。"></a>实现一个基本的计算器来计算一个简单的字符串表达式的值。</h2><p>先把乘除法的值计算出来，最终将所有的运算简化成只有加法。<br>将表达式（中缀）转化为后缀<br>将后缀计算出结果<br>class Solution {<br>    public int calculate(String s) {<br>        Stack<Integer> numStack = new Stack&lt;&gt;();</p>
<pre><code>    char lastOp = &#39;+&#39;;
    char[] arr = s.toCharArray();
    for(int i = 0; i &lt; arr.length; i ++)&#123;
        if(arr[i] == &#39; &#39;) continue;

        if(Character.isDigit(arr[i]))&#123;
            int tempNum = arr[i] - &#39;0&#39;;
            while(++i &lt; arr.length &amp;&amp; Character.isDigit(arr[i]))&#123;
                tempNum = tempNum * 10 + (arr[i] - &#39;0&#39;);
            &#125; i--;

            if(lastOp == &#39;+&#39;) numStack.push(tempNum);
            else if(lastOp == &#39;-&#39;) numStack.push(-tempNum);
            else numStack.push(res(lastOp, numStack.pop(), tempNum));
        &#125; else lastOp = arr[i];
    &#125;

    int ans = 0;
    for(int num : numStack) ans += num;
    return ans;
&#125;

private int res(char op, int a, int b)&#123;
    if(op == &#39;*&#39;) return a * b;
    else if(op == &#39;/&#39;) return a / b;
    else if(op == &#39;+&#39;) return a + b; //其实加减运算可以忽略
    else return a - b;
&#125;
</code></pre>
<p>}</p>
<h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>class LRUCache {<br>    // key -&gt; Node(key, val)<br>    private HashMap&lt;Integer, Node&gt; map;<br>    // Node(k1, v1) &lt;-&gt; Node(k2, v2)…<br>    private DoubleList cache;<br>    // 最大容量<br>    private int cap;</p>
<pre><code>public LRUCache(int capacity) &#123;
    this.cap = capacity;
    map = new HashMap&lt;&gt;();
    cache = new DoubleList();
&#125;

public int get(int key) &#123;
    if (!map.containsKey(key))
        return -1;
    int val = map.get(key).val;
    // 利用 put 方法把该数据提前
    put(key, val);
    return val;
&#125;

public void put(int key, int val) &#123;
    // 先把新节点 x 做出来
    Node x = new Node(key, val);
    
    if (map.containsKey(key)) &#123;
        // 删除旧的节点，新的插到头部
        cache.remove(map.get(key));
        cache.addFirst(x);
        // 更新 map 中对应的数据
        map.put(key, x);
    &#125; else &#123;
        if (cap == cache.size()) &#123;
            // 删除链表最后一个数据
            Node last = cache.removeLast();
            map.remove(last.key);
        &#125;
        // 直接添加到头部
        cache.addFirst(x);
        map.put(key, x);
    &#125;
&#125;
</code></pre>
<p>}</p>
<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><pre><code>输入一个字符串，打印出该字符串中字符的所有排列。
输入：s = &quot;abc&quot;
输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]
    回溯法
     对于一个长度为 n 的字符串（假设字符互不重复）n×(n−1)×(n−2)…×2×1 种方案
 根据字符串排列的特点，考虑深度优先搜索所有排列方案。
重复方案与剪枝： 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。
     * 回溯算法框架：解决一个问题，实际上就是一个决策树的遍历过程：
 * 1. 路径：做出的选择
 * 2. 选择列表：当前可以做的选择
 * 3. 结束条件：到达决策树底层，无法再做选择的条件
字符串的排列可以抽象为一棵决策树：
    List&lt;String&gt; res = new LinkedList&lt;&gt;();
    char[] c;
    public String[] permutation(String s) &#123;
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    &#125;
    void dfs(int x) &#123;
        if(x == c.length - 1) &#123;
            res.add(String.valueOf(c)); // 添加排列方案
            return;
        &#125;
        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
        for(int i = x; i &lt; c.length; i++) &#123;
            if(set.contains(c[i])) continue; // 重复，因此剪枝
            set.add(c[i]);
            swap(i, x); // 交换，将 c[i] 固定在第 x 位 
            dfs(x + 1); // 开启固定第 x + 1 位字符
            swap(i, x); // 恢复交换
        &#125;
    &#125;
    void swap(int a, int b) &#123;
        char tmp = c[a];
        c[a] = c[b];
        c[b] = tmp;
    &#125;
</code></pre>
<h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><p>List&lt;List<Integer>&gt; res = new LinkedList&lt;&gt;();</p>
<p>/* 主函数，输入一组不重复的数字，返回它们的全排列 */<br>List&lt;List<Integer>&gt; permute(int[] nums) {<br>    // 记录「路径」<br>    LinkedList<Integer> track = new LinkedList&lt;&gt;();<br>    backtrack(nums, track);<br>    return res;<br>}</p>
<p>// 路径：记录在 track 中<br>// 选择列表：nums 中不存在于 track 的那些元素<br>// 结束条件：nums 中的元素全都在 track 中出现<br>void backtrack(int[] nums, LinkedList<Integer> track) {<br>    // 触发结束条件<br>    if (track.size() == nums.length) {<br>        res.add(new LinkedList(track));<br>        return;<br>    }</p>
<pre><code>for (int i = 0; i &lt; nums.length; i++) &#123;
    // 排除不合法的选择
    if (track.contains(nums[i]))
        continue;
    // 做选择
    track.add(nums[i]);
    // 进入下一层决策树
    backtrack(nums, track);
    // 取消选择
    track.removeLast();
&#125;
</code></pre>
<p>}</p>
<h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h2><p>给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。<br>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。<br>vector&lt;vector<string>&gt; res;</p>
<p>/* 输入棋盘边长 n，返回所有合法的放置 */<br>vector&lt;vector<string>&gt; solveNQueens(int n) {<br>    // ‘.’ 表示空，’Q’ 表示皇后，初始化空棋盘。<br>    vector<string> board(n, string(n, ‘.’));<br>    backtrack(board, 0);<br>    return res;<br>}</p>
<p>// 路径：board 中小于 row 的那些行都已经成功放置了皇后<br>// 选择列表：第 row 行的所有列都是放置皇后的选择<br>// 结束条件：row 超过 board 的最后一行<br>void backtrack(vector<string>&amp; board, int row) {<br>    // 触发结束条件<br>    if (row == board.size()) {<br>        res.push_back(board);<br>        return;<br>    }</p>
<pre><code>int n = board[row].size();
for (int col = 0; col &lt; n; col++) &#123;
    // 排除不合法选择
    if (!isValid(board, row, col)) 
        continue;
    // 做选择
    board[row][col] = &#39;Q&#39;;
    // 进入下一行决策
    backtrack(board, row + 1);
    // 撤销选择
    board[row][col] = &#39;.&#39;;
&#125;
</code></pre>
<p>}<br>/* 是否可以在 board[row][col] 放置皇后？ */<br>bool isValid(vector<string>&amp; board, int row, int col) {<br>    int n = board.size();<br>    // 检查列是否有皇后互相冲突<br>    for (int i = 0; i &lt; n; i++) {<br>        if (board[i][col] == ‘Q’)<br>            return false;<br>    }<br>    // 检查右上方是否有皇后互相冲突<br>    for (int i = row - 1, j = col + 1;<br>            i &gt;= 0 &amp;&amp; j &lt; n; i–, j++) {<br>        if (board[i][j] == ‘Q’)<br>            return false;<br>    }<br>    // 检查左上方是否有皇后互相冲突<br>    for (int i = row - 1, j = col - 1;<br>            i &gt;= 0 &amp;&amp; j &gt;= 0; i–, j–) {<br>        if (board[i][j] == ‘Q’)<br>            return false;<br>    }<br>    return true;<br>}</p>
<p>int openLock(String[] deadends, String target) {<br>    // 记录需要跳过的死亡密码<br>    Set<String> deads = new HashSet&lt;&gt;();<br>    for (String s : deadends) deads.add(s);<br>    // 记录已经穷举过的密码，防止走回头路<br>    Set<String> visited = new HashSet&lt;&gt;();<br>    Queue<String> q = new LinkedList&lt;&gt;();<br>    // 从起点开始启动广度优先搜索<br>    int step = 0;<br>    q.offer(“0000”);<br>    visited.add(“0000”);</p>
<pre><code>while (!q.isEmpty()) &#123;
    int sz = q.size();
    /* 将当前队列中的所有节点向周围扩散 */
    for (int i = 0; i &lt; sz; i++) &#123;
        String cur = q.poll();

        /* 判断是否到达终点 */
        if (deads.contains(cur))
            continue;
        if (cur.equals(target))
            return step;

        /* 将一个节点的未遍历相邻节点加入队列 */
        for (int j = 0; j &lt; 4; j++) &#123;
            String up = plusOne(cur, j);
            if (!visited.contains(up)) &#123;
                q.offer(up);
                visited.add(up);
            &#125;
            String down = minusOne(cur, j);
            if (!visited.contains(down)) &#123;
                q.offer(down);
                visited.add(down);
            &#125;
        &#125;
    &#125;
    /* 在这里增加步数 */
    step++;
&#125;
// 如果穷举完都没找到目标密码，那就是找不到了
return -1;
</code></pre>
<p>}</p>
<h2 id="给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。"><a href="#给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。" class="headerlink" title="给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。"></a>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</h2><p>输入: [10,2]<br>输出: 210<br>想法<br>为了构建最大数字，我们希望越高位的数字越大越好。<br>当数字是多位时，我们构建s1，s2，将s1+s2 和s2 + s1 进行比较，哪个大哪个放前面<br>class Solution {<br>    private class LargerNumberComparator implements Comparator<String> {<br>        @Override<br>        public int compare(String a, String b) {<br>            String order1 = a + b;<br>            String order2 = b + a;<br>           return order2.compareTo(order1);<br>        }<br>    }</p>
<pre><code>public String largestNumber(int[] nums) &#123;
    // Get input integers as strings.
    String[] asStrs = new String[nums.length];
    for (int i = 0; i &lt; nums.length; i++) &#123;
        asStrs[i] = String.valueOf(nums[i]);
    &#125;

    // Sort strings according to custom comparator.
    Arrays.sort(asStrs, new LargerNumberComparator());

    // If, after being sorted, the largest number is `0`, the entire number
    // is zero.
    if (asStrs[0].equals(&quot;0&quot;)) &#123;
        return &quot;0&quot;;
    &#125;

    // Build largest number from sorted array.
    String largestNumberStr = new String();
    for (String numAsStr : asStrs) &#123;
        largestNumberStr += numAsStr;
    &#125;

    return largestNumberStr;
&#125;
</code></pre>
<p>}</p>
<h2 id="摆动排序"><a href="#摆动排序" class="headerlink" title="摆动排序"></a>摆动排序</h2><p>输入: nums = [1, 5, 1, 1, 6, 4]<br>输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]</p>
<ol>
<li><p>解法1：排序<br>首先，我们可以很容易想到一种简单的解法：将数组进行排序，然后从中间位置进行等分（如果数组长度为奇数，则将中间的元素分到前面），然后将两个数组进行穿插。<br>但是这一解法有一个问题，例如，对于数组[1, 2, 2, 3]，按照这种做法求得的结果仍为[1, 2, 2, 3]<br>为了方便阅读，我们在下文中定义较小的子数组为数组A，较大的子数组为数组B。显然，出现上述现象是因为nums中存在重复元素。实际上，由于穿插之后，相邻元素必来自不同子数组，所以A或B内部出现重复元素是不会出现上述现象的。所以，出现上述情况其实是因为数组A和数组B出现了相同元素，我们用r来表示这一元素。而且我们可以很容易发现，如果A和B都存在r，那么r一定是A的最大值，B的最小值，这意味着r一定出现在A的尾部，B的头部。其实，如果这一数字的个数较少，不会出现这一现象，只有当这一数字个数达到原数组元素总数的一半，才会在穿插后的出现在相邻位置。<br>class Solution {</p>
<p> /**</p>
<ul>
<li>先排序再穿插</li>
<li>O(nlogn)+O(n)=O(nlogn)</li>
<li>@param nums</li>
<li>/<br>public void wiggleSort(int[] nums) {<br>  //排序<br>  Arrays.sort(nums);<br>  int len=nums.length,i = 0;<br>  int[] smaller=new int[len%2==0?len/2:(len/2+1)],bigger=new int[len/2];<br>  //复制<br>  System.arraycopy(nums,0,smaller,0,smaller.length);<br>  System.arraycopy(nums,smaller.length,bigger,0,len/2);<br>  //穿插<br>  for (; i &lt; len / 2; i++) {<pre><code>  nums[2*i]=smaller[smaller.length-1-i];
  nums[2*i+1]=bigger[len/2-1-i];
</code></pre>
  }<br>  if (len%2!=0) nums[2*i]=smaller[smaller.length-1-i];<br>}<br>}<h2 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="计算右侧小于当前元素的个数"></a>计算右侧小于当前元素的个数</h2>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。<br>输入：[5,2,6,1]<br>输出：[2,1,1,0]<br>解释：<br>5 的右侧有 2 个更小的元素 (2 和 1)<br>2 的右侧仅有 1 个更小的元素 (1)<br>6 的右侧有 1 个更小的元素 (1)<br>1 的右侧有 0 个更小的元素<br>方法一：离散化树状数组<br>class Solution {<br>private int[] c;<br>private int[] a;</li>
</ul>
<p> public List<Integer> countSmaller(int[] nums) {</p>
<pre><code> List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;(); 
 discretization(nums);
 init(nums.length + 5);
 for (int i = nums.length - 1; i &gt;= 0; --i) &#123;
     int id = getId(nums[i]);
     resultList.add(query(id - 1));
     update(id);
 &#125;
 Collections.reverse(resultList);
 return resultList;
</code></pre>
<p> }</p>
<p> private void init(int length) {</p>
<pre><code> c = new int[length];
 Arrays.fill(c, 0);
</code></pre>
<p> }</p>
<p> private int lowBit(int x) {</p>
<pre><code> return x &amp; (-x);
</code></pre>
<p> }</p>
<p> private void update(int pos) {</p>
<pre><code> while (pos &lt; c.length) &#123;
     c[pos] += 1;
     pos += lowBit(pos);
 &#125;
</code></pre>
<p> }</p>
<p> private int query(int pos) {</p>
<pre><code> int ret = 0;
 while (pos &gt; 0) &#123;
     ret += c[pos];
     pos -= lowBit(pos);
 &#125;

 return ret;
</code></pre>
<p> }</p>
<p> private void discretization(int[] nums) {</p>
<pre><code> Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
 for (int num : nums) &#123;
     set.add(num);
 &#125;
 int size = set.size();
 a = new int[size];
 int index = 0;
 for (int num : set) &#123;
     a[index++] = num;
 &#125;
 Arrays.sort(a);
</code></pre>
<p> }</p>
<p> private int getId(int x) {</p>
<pre><code> return Arrays.binarySearch(a, x) + 1;
</code></pre>
<p> }<br>}</p>
<h2 id="小偷问题"><a href="#小偷问题" class="headerlink" title="小偷问题"></a>小偷问题</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<br>方法一：动态规划 + 滚动数组<br>class Solution {<br> public int rob(int[] nums) {</p>
<pre><code> if (nums == null || nums.length == 0) &#123;
     return 0;
 &#125;
 int length = nums.length;
 if (length == 1) &#123;
     return nums[0];
 &#125;
 int[] dp = new int[length];
 dp[0] = nums[0];
 dp[1] = Math.max(nums[0], nums[1]);
 for (int i = 2; i &lt; length; i++) &#123;
     dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
 &#125;
 return dp[length - 1];
</code></pre>
<p> }<br>}</p>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p>动态规划<br>public class Solution {<br> public int lengthOfLIS(int[] nums) {</p>
<pre><code> if (nums.length == 0) &#123;
     return 0;
 &#125;
 int[] dp = new int[nums.length];
 dp[0] = 1;
 int maxans = 1;
 for (int i = 1; i &lt; dp.length; i++) &#123;
     int maxval = 0;
     for (int j = 0; j &lt; i; j++) &#123;
         if (nums[i] &gt; nums[j]) &#123;
             maxval = Math.max(maxval, dp[j]);
         &#125;
     &#125;
     dp[i] = maxval + 1;
     maxans = Math.max(maxans, dp[i]);
 &#125;
 return maxans;
</code></pre>
<p> }<br>}<br>贪心 + 二分查找<br>class Solution {<br>public:<br> int lengthOfLIS(vector<int>&amp; nums) {</p>
<pre><code> int len = 1, n = (int)nums.size();
 if (n == 0) return 0;
 vector&lt;int&gt; d(n + 1, 0);
 d[len] = nums[0];
 for (int i = 1; i &lt; n; ++i) &#123;
     if (nums[i] &gt; d[len]) d[++len] = nums[i];
     else&#123;
         int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
         while (l &lt;= r) &#123;
             int mid = (l + r) &gt;&gt; 1;
             if (d[mid] &lt; nums[i]) &#123;
                 pos = mid;
                 l = mid + 1;
             &#125;
             else r = mid - 1;
         &#125;
         d[pos + 1] = nums[i];
     &#125;
 &#125;
 return len;
</code></pre>
<p> }<br>};</p>
<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<br>方法一、搜索回溯 [超出时间限制]<br>public class Solution {</p>
</li>
</ol>
<p>  public int coinChange(int[] coins, int amount) {<br>    return coinChange(0, coins, amount);<br>  }</p>
<p>  private int coinChange(int idxCoin, int[] coins, int amount) {<br>    if (amount == 0)<br>      return 0;<br>    if (idxCoin &lt; coins.length &amp;&amp; amount &gt; 0) {<br>      int maxVal = amount / coins[idxCoin];<br>      int minCost = Integer.MAX_VALUE;<br>      for (int x = 0; x &lt;= maxVal; x++) {<br>        if (amount &gt;= x * coins[idxCoin]) {<br>          int res = coinChange(idxCoin + 1, coins, amount - x * coins[idxCoin]);<br>          if (res != -1)<br>            minCost = Math.min(minCost, res + x);<br>        }<br>      }<br>      return (minCost == Integer.MAX_VALUE)? -1: minCost;<br>    }<br>    return -1;<br>  }<br>}<br>方法二、动态规划-自上而下 [通过]<br>public class Solution {</p>
<p>  public int coinChange(int[] coins, int amount) {<br>    if (amount &lt; 1) return 0;<br>    return coinChange(coins, amount, new int[amount]);<br>  }</p>
<p>  private int coinChange(int[] coins, int rem, int[] count) {<br>    if (rem &lt; 0) return -1;<br>    if (rem == 0) return 0;<br>    if (count[rem - 1] != 0) return count[rem - 1];<br>    int min = Integer.MAX_VALUE;<br>    for (int coin : coins) {<br>      int res = coinChange(coins, rem - coin, count);<br>      if (res &gt;= 0 &amp;&amp; res &lt; min)<br>        min = 1 + res;<br>    }<br>    count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;<br>    return count[rem - 1];<br>  }<br>}<br>方法三、动态规划：自下而上 [通过]<br>public class Solution {<br>  public int coinChange(int[] coins, int amount) {<br>    int max = amount + 1;<br>    int[] dp = new int[amount + 1];<br>    Arrays.fill(dp, max);<br>    dp[0] = 0;<br>    for (int i = 1; i &lt;= amount; i++) {<br>      for (int j = 0; j &lt; coins.length; j++) {<br>        if (coins[j] &lt;= i) {<br>          dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);<br>        }<br>      }<br>    }<br>    return dp[amount] &gt; amount ? -1 : dp[amount];<br>  }<br>}</p>
<h2 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a>矩阵中的最长递增路径</h2><p>本文面向高阶读者者。它引入了以下概念：深度优先搜索，记忆化，动态规划和拓扑排序。本文解释了动态规划和拓扑排序的关系。</p>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p>
<p>输出: 5</p>
<p>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>     返回它的长度 5。<br>我们将问题抽象在一个无向无权图中，每个单词作为节点，差距只有一个字母的两个单词之间连一条边。问题变成找到从起点到终点的最短路径，如果存在的话。因此可以使用广度优先搜索方法。<br>方法 1：广度优先搜索<br>class Solution {<br>  public int ladderLength(String beginWord, String endWord, List<String> wordList) {</p>
<pre><code>// Since all words are of same length.
int L = beginWord.length();

// Dictionary to hold combination of words that can be formed,
// from any given word. By changing one letter at a time.
Map&lt;String, List&lt;String&gt;&gt; allComboDict = new HashMap&lt;&gt;();

wordList.forEach(
    word -&gt; &#123;
      for (int i = 0; i &lt; L; i++) &#123;
        // Key is the generic word
        // Value is a list of words which have the same intermediate generic word.
        String newWord = word.substring(0, i) + &#39;*&#39; + word.substring(i + 1, L);
        List&lt;String&gt; transformations = allComboDict.getOrDefault(newWord, new ArrayList&lt;&gt;());
        transformations.add(word);
        allComboDict.put(newWord, transformations);
      &#125;
    &#125;);

// Queue for BFS
Queue&lt;Pair&lt;String, Integer&gt;&gt; Q = new LinkedList&lt;&gt;();
Q.add(new Pair(beginWord, 1));

// Visited to make sure we don&#39;t repeat processing same word.
Map&lt;String, Boolean&gt; visited = new HashMap&lt;&gt;();
visited.put(beginWord, true);

while (!Q.isEmpty()) &#123;
  Pair&lt;String, Integer&gt; node = Q.remove();
  String word = node.getKey();
  int level = node.getValue();
  for (int i = 0; i &lt; L; i++) &#123;

    // Intermediate words for current word
    String newWord = word.substring(0, i) + &#39;*&#39; + word.substring(i + 1, L);

    // Next states are all the words which share the same intermediate state.
    for (String adjacentWord : allComboDict.getOrDefault(newWord, new ArrayList&lt;&gt;())) &#123;
      // If at any point if we find what we are looking for
      // i.e. the end word - we can return with the answer.
      if (adjacentWord.equals(endWord)) &#123;
        return level + 1;
      &#125;
      // Otherwise, add it to the BFS Queue. Also mark it visited
      if (!visited.containsKey(adjacentWord)) &#123;
        visited.put(adjacentWord, true);
        Q.add(new Pair(adjacentWord, level + 1));
      &#125;
    &#125;
  &#125;
&#125;

return 0;
</code></pre>
<p>  }<br>}</p>
<h2 id="计算网格中岛屿的数量"><a href="#计算网格中岛屿的数量" class="headerlink" title="计算网格中岛屿的数量"></a>计算网格中岛屿的数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。<br>输入:<br>[<br>[‘1’,’1’,’1’,’1’,’0’],<br>[‘1’,’1’,’0’,’1’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’0’,’0’,’0’]<br>]<br>输出: 1<br>方法一：深度优先搜索<br>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。</p>
<h2 id="找出那个只出现了一次的元素"><a href="#找出那个只出现了一次的元素" class="headerlink" title="找出那个只出现了一次的元素"></a>找出那个只出现了一次的元素</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>方法一：位运算<br>class Solution {<br>    public int singleNumber(int[] nums) {<br>        int single = 0;<br>        for (int num : nums) {<br>            single ^= num;<br>        }<br>        return single;<br>    }<br>}</p>
<p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。<br>如果小数部分为循环小数，则将循环的部分括在括号内。<br>不需要复杂的数学知识，只需要数学的基本知识。了解长除法的运算规则。<br>注意边界情况！列出所有你可以想到的测试数据并验证你的代码。<br>长除法：核心思想是当余数出现循环的时候，对应的商也会循环。<br>需要用一个哈希表记录余数出现在小数部分的位置，当你发现已经出现的余数，就可以将重复出现的小数部分用括号括起来。</p>
<h2 id="找到若干个完全平方数"><a href="#找到若干个完全平方数" class="headerlink" title="找到若干个完全平方数"></a>找到若干个完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。<br>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.<br>class Solution {</p>
<p>  public int numSquares(int n) {<br>    int dp[] = new int[n + 1];<br>    Arrays.fill(dp, Integer.MAX_VALUE);<br>    // bottom case<br>    dp[0] = 0;</p>
<pre><code>// pre-calculate the square numbers.
int max_square_index = (int) Math.sqrt(n) + 1;
int square_nums[] = new int[max_square_index];
for (int i = 1; i &lt; max_square_index; ++i) &#123;
  square_nums[i] = i * i;
&#125;

for (int i = 1; i &lt;= n; ++i) &#123;
  for (int s = 1; s &lt; max_square_index; ++s) &#123;
    if (i &lt; square_nums[s])
      break;
    dp[i] = Math.min(dp[i], dp[i - square_nums[s]] + 1);
  &#125;
&#125;
return dp[n];
</code></pre>
<p>  }<br>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift147%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift147%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:38" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:38+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字母异位词"><a href="#字母异位词" class="headerlink" title="字母异位词"></a>字母异位词</h2><pre><code>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;
输出: true
方法一：排序
public boolean isAnagram(String s, String t) &#123;
    if (s.length() != t.length()) &#123;
        return false;
    &#125;
    char[] str1 = s.toCharArray();
    char[] str2 = t.toCharArray();
    Arrays.sort(str1);
    Arrays.sort(str2);
    return Arrays.equals(str1, str2);
&#125;
方法二：哈希表
public boolean isAnagram(String s, String t) &#123;
    if (s.length() != t.length()) &#123;
        return false;
    &#125;
    int[] counter = new int[26];
    for (int i = 0; i &lt; s.length(); i++) &#123;
        counter[s.charAt(i) - &#39;a&#39;]++;
        counter[t.charAt(i) - &#39;a&#39;]--;
    &#125;
    for (int count : counter) &#123;
        if (count != 0) &#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;
</code></pre>
<h2 id="是否可以被空格拆分为一个或多个"><a href="#是否可以被空格拆分为一个或多个" class="headerlink" title="是否可以被空格拆分为一个或多个"></a>是否可以被空格拆分为一个或多个</h2><pre><code>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
输出: true
解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。
public class Solution &#123;
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;
        Set&lt;String&gt; wordDictSet = new HashSet(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i &lt;= s.length(); i++) &#123;
            for (int j = 0; j &lt; i; j++) &#123;
                if (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;
                    dp[i] = true;
                    break;
                &#125;
            &#125;
        &#125;
        return dp[s.length()];
    &#125;
&#125;
</code></pre>
<h2 id="实现一个-Trie-前缀树"><a href="#实现一个-Trie-前缀树" class="headerlink" title="实现一个 Trie (前缀树)"></a>实现一个 Trie (前缀树)</h2><pre><code>包含 insert, search, 和 startsWith 这三个操作
class Trie &#123;
    private TrieNode root;

public Trie() &#123;
    root = new TrieNode();
&#125;

public void insert(String word) &#123;
    TrieNode node = root;
    for (int i = 0; i &lt; word.length(); i++) &#123;
        char currentChar = word.charAt(i);
        if (!node.containsKey(currentChar)) &#123;
            node.put(currentChar, new TrieNode());
        &#125;
        node = node.get(currentChar);
    &#125;
    node.setEnd();
&#125;
private TrieNode searchPrefix(String word) &#123;
    TrieNode node = root;
    for (int i = 0; i &lt; word.length(); i++) &#123;
       char curLetter = word.charAt(i);
       if (node.containsKey(curLetter)) &#123;
           node = node.get(curLetter);
       &#125; else &#123;
           return null;
       &#125;
    &#125;
    return node;
&#125;
public boolean search(String word) &#123;
   TrieNode node = searchPrefix(word);
   return node != null &amp;&amp; node.isEnd();
&#125;
public boolean startsWith(String prefix) &#123;
    TrieNode node = searchPrefix(prefix);
    return node != null;
&#125;

&#125;
</code></pre>
<h2 id="第一个不重复的字符"><a href="#第一个不重复的字符" class="headerlink" title="第一个不重复的字符"></a>第一个不重复的字符</h2><pre><code>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
方法一： 线性时间复杂度解法
class Solution &#123;
    public int firstUniqChar(String s) &#123;
        HashMap&lt;Character, Integer&gt; count = new HashMap&lt;Character, Integer&gt;();
        int n = s.length();
        // build hash map : character and how often it appears
        for (int i = 0; i &lt; n; i++) &#123;
            char c = s.charAt(i);
            count.put(c, count.getOrDefault(c, 0) + 1);
        &#125;
    
    // find the index
    for (int i = 0; i &lt; n; i++) &#123;
        if (count.get(s.charAt(i)) == 1) 
            return i;
    &#125;
    return -1;
&#125;
&#125;
</code></pre>
<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><pre><code>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
双指针
class Solution &#123;
    public void reverseString(char[] s) &#123;
        if(s == null || s.length == 0) return;

    int left = 0;
    int right = s.length-1;
    while(left &lt; right)&#123;  //奇数个的时候中间元素不动
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        left ++;
        right --;
    &#125;
&#125;
&#125;
</code></pre>
<h2 id="回文串验证"><a href="#回文串验证" class="headerlink" title="回文串验证"></a>回文串验证</h2><pre><code>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
方法一：筛选 + 判断
最简单的方法是对字符串 s 进行一次遍历，并将其中的字母和数字字符进行保留
判断的方法有两种。一种是将字符串进行翻转，然后判断字符串是不是相同，第二种是使用双指针
class Solution &#123;
    public boolean isPalindrome(String s) &#123;
        StringBuffer sgood = new StringBuffer();
        int length = s.length();
        for (int i = 0; i &lt; length; i++) &#123;
            char ch = s.charAt(i);
            if (Character.isLetterOrDigit(ch)) &#123;
                sgood.append(Character.toLowerCase(ch));
            &#125;
        &#125;
        StringBuffer sgood_rev = new StringBuffer(sgood).reverse();
        return sgood.toString().equals(sgood_rev.toString());
    &#125;
&#125;
</code></pre>
<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><pre><code>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。
本题做法较多，本文主要介绍 “字符串切片” ， “列表遍历拼接” ， “字符串遍历拼接” 三种方法。
由于本题的多解法涉及到了 字符串为不可变对象 的相关概念，导致效率区别较大。因此，单列一节 三种方法的效率分析 ，望对各位有所帮助。
方法一：字符串切片
class Solution &#123;
    public String reverseLeftWords(String s, int n) &#123;
        return s.substring(n, s.length()) + s.substring(0, n);
    &#125;
&#125;
方法二：列表遍历拼接
class Solution &#123;
    public String reverseLeftWords(String s, int n) &#123;
        StringBuilder res = new StringBuilder();
        for(int i = n; i &lt; s.length(); i++)
            res.append(s.charAt(i));
        for(int i = 0; i &lt; n; i++)
            res.append(s.charAt(i));
        return res.toString();
    &#125;
&#125;
方法三：字符串遍历拼接
class Solution &#123;
    public String reverseLeftWords(String s, int n) &#123;
        String res = &quot;&quot;;
        for(int i = n; i &lt; s.length(); i++)
            res += s.charAt(i);
        for(int i = 0; i &lt; n; i++)
            res += s.charAt(i);
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h2><pre><code>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。

方法一：双指针
class Solution &#123;
public String reverseWords(String s) &#123;
    s = s.trim(); // 删除首尾空格
    int j = s.length() - 1, i = j;
    StringBuilder res = new StringBuilder();
    while(i &gt;= 0) &#123;
        while(i &gt;= 0 &amp;&amp; s.charAt(i) != &#39; &#39;) i--; // 搜索首个空格
        res.append(s.substring(i + 1, j + 1) + &quot; &quot;); // 添加单词
        while(i &gt;= 0 &amp;&amp; s.charAt(i) == &#39; &#39;) i--; // 跳过单词间空格
        j = i; // j 指向下个单词的尾字符
    &#125;
    return res.toString().trim(); // 转化为字符串并返回
&#125;
&#125;
方法二：分割 + 倒序
class Solution &#123;
    public String reverseWords(String s) &#123;
        String[] strs = s.trim().split(&quot; &quot;); // 删除首尾空格，分割字符串
        StringBuilder res = new StringBuilder();
        for(int i = strs.length - 1; i &gt;= 0; i--) &#123; // 倒序遍历单词列表
            if(strs[i].equals(&quot;&quot;)) continue; // 遇到空单词则跳过
            res.append(strs[i] + &quot; &quot;); // 将单词拼接至 StringBuilder
        &#125;
        return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回
    &#125;
&#125;
</code></pre>
<h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><pre><code>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
方法一：动态规划 + 哈希表
class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        Map&lt;Character, Integer&gt; dic = new HashMap&lt;&gt;();
        int res = 0, tmp = 0;
        for(int j = 0; j &lt; s.length(); j++) &#123;
            int i = dic.getOrDefault(s.charAt(j), -1); // 获取索引 i
            dic.put(s.charAt(j), j); // 更新哈希表
            tmp = tmp &lt; j - i ? tmp + 1 : j - i; // dp[j - 1] -&gt; dp[j]
            res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
        &#125;
        return res;
    &#125;
&#125;
方法二： 动态规划 + 线性遍历
class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        Map&lt;Character, Integer&gt; dic = new HashMap&lt;&gt;();
        int res = 0, tmp = 0;
        for(int j = 0; j &lt; s.length(); j++) &#123;
            int i = j - 1;
            while(i &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j)) i--; // 线性查找 i
            tmp = tmp &lt; j - i ? tmp + 1 : j - i; // dp[j - 1] -&gt; dp[j]
            res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
        &#125;
        return res;
    &#125;
&#125;
方法三：双指针 + 哈希表
class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        Map&lt;Character, Integer&gt; dic = new HashMap&lt;&gt;();
        int i = -1, res = 0;
        for(int j = 0; j &lt; s.length(); j++) &#123;
            if(dic.containsKey(s.charAt(j)))
                i = Math.max(i, dic.get(s.charAt(j))); // 更新左指针 i
            dic.put(s.charAt(j), j); // 哈希表记录
            res = Math.max(res, j - i); // 更新结果
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h2><pre><code>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
字符串的第 i 位置：

可以单独作为一位来翻译
如果第 i−1 位和第 i 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译
class Solution &#123;
    public int translateNum(int num) &#123;
        String src = String.valueOf(num);
        int p = 0, q = 0, r = 1;
        for (int i = 0; i &lt; src.length(); ++i) &#123;
            p = q; 
            q = r; 
            r = 0;
            r += q;
            if (i == 0) &#123;
                continue;
            &#125;
            String pre = src.substring(i - 1, i + 1);
            if (pre.compareTo(&quot;25&quot;) &lt;= 0 &amp;&amp; pre.compareTo(&quot;10&quot;) &gt;= 0) &#123;
                r += p;
            &#125;
        &#125;
        return r;
    &#125;
&#125;
</code></pre>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><pre><code>    将字符串转成char的数组，声明一个3倍长度的数组，遍历字符串数组当为空格时，添加%20
输入：s = &quot;We are happy.&quot;
    输出：&quot;We%20are%20happy.&quot;
    由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。
    public String replaceSpace(String s) &#123;
        int length = s.length();
        char[] array = new char[length * 3];
        int size = 0;
        for (int i = 0; i &lt; length; i++) &#123;
            char c = s.charAt(i);
            if (c == &#39; &#39;) &#123;
                array[size++] = &#39;%&#39;;
                array[size++] = &#39;2&#39;;
                array[size++] = &#39;0&#39;;
            &#125; else &#123;
                array[size++] = c;
            &#125;
        &#125;
        String newStr = new String(array, 0, size);
        return newStr;
    &#125;
</code></pre>
<h2 id="字符串的排列组合方式（决策树）"><a href="#字符串的排列组合方式（决策树）" class="headerlink" title="字符串的排列组合方式（决策树）"></a>字符串的排列组合方式（决策树）</h2><pre><code>class Solution &#123;
    List&lt;String&gt; res = new LinkedList&lt;&gt;();
    char[] c;
    public String[] permutation(String s) &#123;
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    &#125;
    void dfs(int x) &#123;
        if(x == c.length - 1) &#123;
            res.add(String.valueOf(c)); // 添加排列方案
            return;
        &#125;
        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
        for(int i = x; i &lt; c.length; i++) &#123;
            if(set.contains(c[i])) continue; // 重复，因此剪枝
            set.add(c[i]);
            swap(i, x); // 交换，将 c[i] 固定在第 x 位 
            dfs(x + 1); // 开启固定第 x + 1 位字符
            swap(i, x); // 恢复交换
        &#125;
    &#125;
    void swap(int a, int b) &#123;
        char tmp = c[a];
        c[a] = c[b];
        c[b] = tmp;
    &#125;
&#125;
</code></pre>
<h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><pre><code>首部空格： 删除之即可；
符号位： 三种情况，即 &#39;+&#39;−&#39;&#39; , &#39;&#39;无符号&quot; ；新建一个变量保存符号位，返回前判断正负即可。
非数字字符： 遇到首个非数字的字符时，应立即返回。
数字字符：
class Solution &#123;
    public int strToInt(String str) &#123;
        char[] c = str.trim().toCharArray();
        if(c.length == 0) return 0;
        int res = 0, bndry = Integer.MAX_VALUE / 10;
        int i = 1, sign = 1;
        if(c[0] == &#39;-&#39;) sign = -1;
        else if(c[0] != &#39;+&#39;) i = 0;
        for(int j = i; j &lt; c.length; j++) &#123;
            if(c[j] &lt; &#39;0&#39; || c[j] &gt; &#39;9&#39;) break;
            if(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; &#39;7&#39;) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            res = res * 10 + (c[j] - &#39;0&#39;);
        &#125;
        return sign * res;
    &#125;
&#125;
</code></pre>
<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><pre><code>输入：&quot;aabcccccaaa&quot;
输出：&quot;a2b1c5a3&quot;
public String compressString(String S) &#123;
    int N = S.length();
    int i = 0;
    StringBuilder sb = new StringBuilder();
    while (i &lt; N) &#123;
        int j = i;
        while (j &lt; N &amp;&amp; S.charAt(j) == S.charAt(i)) &#123;
            j++;
        &#125;
        sb.append(S.charAt(i));
        sb.append(j - i);
        i = j;
    &#125;

String res = sb.toString();
if (res.length() &lt; S.length()) &#123;
    return res;
&#125; else &#123;
    return S;
&#125;
&#125;
</code></pre>
<h2 id="无重复子串最大长度"><a href="#无重复子串最大长度" class="headerlink" title="无重复子串最大长度"></a>无重复子串最大长度</h2><pre><code>int lengthOfLongestSubstring(string s) &#123;
        // 哈希集合，记录每个字符是否出现过
        unordered_set&lt;char&gt; occ;
        int n = s.size();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        // 枚举左指针的位置，初始值隐性地表示为 -1
        for (int i = 0; i &lt; n; ++i) &#123;
            if (i != 0) &#123;
                // 左指针向右移动一格，移除一个字符
                occ.erase(s[i - 1]);
            &#125;
            while (rk + 1 &lt; n &amp;&amp; !occ.count(s[rk + 1])) &#123;
                // 不断地移动右指针
                occ.insert(s[rk + 1]);
                ++rk;
            &#125;
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1);
        &#125;
        return ans;
    &#125;
</code></pre>
<h2 id="最大上升子序列"><a href="#最大上升子序列" class="headerlink" title="最大上升子序列"></a>最大上升子序列</h2><pre><code>思想：
创建一个额外的数组，用于存放字串到当前位置的最大值
遍历数组，每次都和之前的数进行比较，获取最大字串，然后加1，
public int lengthOfLIS(int[] nums) &#123;
   if (nums.length == 0) &#123;
       return 0;
   &#125;
   int[] dp = new int[nums.length]; // 创建一个额外的数组，用于存放字串到当前位置的最大值
   dp[0] = 1; // 默认为1
   int maxans = 1;
   for (int i = 1; i &lt; dp.length; i++) &#123;
       int maxval = 0;
       for (int j = 0; j &lt; i; j++) &#123;
           if (nums[i] &gt; nums[j]) &#123; 
               maxval = Math.max(maxval, dp[j]); // 比较dp中值和mavl的值，取最大值
           &#125;
       &#125;
       dp[i] = maxval + 1; // 当前值加1
       maxans = Math.max(maxans, dp[i]);
   &#125;
   return maxans;
   &#125;
</code></pre>
<h2 id="字符串查找问题；"><a href="#字符串查找问题；" class="headerlink" title="字符串查找问题；"></a>字符串查找问题；</h2><pre><code>字符串查找问题---长字符串查找短字符串
String 1: ABCDEFGHLMNOPQRS
String 2: DCGSRQPOM
答案是true，所有在string2里的字母string1也都有。
解法，HashTable
查找某个字符或字符段在字符串中出现的次数
给一个数组，找出这样一些数，这个数左边的数都比它小，右边的数都比它大
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
1.双重遍历，两两相加
2.生成一个map集合，然后遍历nums，用target - nums 在map集合中是否存在，如果存在，则找到了
3.跟第二个相似，一次遍历，添加到map中的是target - nums[i] ,只要后续遍历中存在这样的key，就是找到了
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。
    新建一个数组，将元素插入到数组的对应位置，如果大于数组id直接舍弃，不存在的位置用0代替，范围位置id
寻找两个数组的中位数，排好序
分析：分治+二分查找
在两个有序数组中寻找k小的数
获取中位数的位置，两个数组和的一半
剪枝处理
特殊情况
分析完了正常的情况，那么就要分析一下特殊情况；
  1)如果有一个数组是空的，直接返回另一个不为空的数组中的中位数
  2)如果两个数组元素的个数相等，并且两个数组的中位数相等，直接返回其中一个中位数。
  3)有可能在进行二分查找的时候出现了数组越界的情况，只需要定义一个最大值和一个最小值，这样可以按照正常的情况来处理了。

double findMedianSortedArrays(int nums1[], int nums2[])&#123;
int m = m1.length;
int n = m2.length;
int k = (m+n) / 2;

if((m+n) %2 == 1)&#123;
return findKth(nums1,0,m-1,nums2,0,n-1,k+1);
&#125;else&#123;
    return (findKth(nums1,0,m-1,nums2,0,n-1,k)+
    findKth(nums1,0,m-1,nums2,0,n-1,k+1))/2.0
&#125;
&#125;

double findKth(int[] nums1,int l1,int h1,int[] nums2,int l2,int h2,int k)&#123;
int m = h1-l1+1;
int n = h2-l2+1;
if(m &gt;n) &#123;
return findKth(nums2,l2,h2,nums1,l1,h1,k);
&#125;
if(m==0) &#123;
return nums2[l2+k-1];
&#125;
&#125;


/*分清 起始位置 和 第几个元素 */
int findKthNumber(vector&lt;int&gt;&amp; nums1,int i ,vector&lt;int&gt;&amp; nums2,int j,int k)&#123;
    if(i &gt;= nums1.size())   return nums2[j+k-1];
    if(j &gt;= nums2.size())   return nums1[i+k-1];
    //if(k ==1) return (double(nums1[i] + nums2[j]));wrong
    if(k == 1) return min(nums1[i],nums2[j]);
    //查找有没有k/2个元素的位置     i + k/2 -1 
    int midVal1 = (i+k/2-1 &lt; nums1.size())?nums1[i+k/2-1]:INT_MAX;
    int midVal2 = (j+k/2-1 &lt; nums2.size())?nums2[j+k/2-1]:INT_MAX;
    if(midVal1 &lt; midVal2)
        return findKthNumber(nums1,i+k/2,nums2,j,k-k/2);
    else
        return findKthNumber(nums1,i,nums2,j+k/2,k-k/2);  
&#125;
class Solution &#123;
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        int m = nums1.size(),n = nums2.size();
        int left = (m+n+1)/2,right = (m+n+2)/2;
        return        (findKthNumber(nums1,0,nums2,0,left)+findKthNumber(nums1,0,nums2,0,right))/2.0;
    &#125;

&#125;
如果没有排序
快速选择算法
随机选择一个数作为基准值，以基准值分成两个部分
如果基准值==k，那么基准值位置就是k
如果基准值小于k，就忘后搜索
如果基准值大于k，就往前搜索

public  int findKthLargest(int[] nums, int k)&#123;
    return quickSelect(nums,nums.length - 1,k);
&#125;
int quickSelect(int[] nums,int low,int high,int k) &#123;
    int pivot = low;
    for (int j = low; j &lt; hight ; j++) &#123;
        if (nums[j] &lt;= nums[high]) &#123;
        swap(nums,pivot++,j);
    &#125;
    &#125;
    swap(nums,pivot,high);
&#125;
void swap(int[] nums1, int[] nums2,int i, int j) &#123;
int m = num.length;
if(i&lt;m&amp;&amp;j&lt;m)&#123;
swap(nums1,i,j);
&#125;else if(i &gt;=m &amp;&amp; j&gt;=m)&#123;
swap(nums2,i-m,j-m)
&#125;else if (i &lt;m &amp;&amp; j &gt;= m) &#123;
int temp = nums1[i];
nums1[1] = nums2[j-m];
nums2[j-m] = temp;
&#125;
&#125;
void swap (int[] nums, int i, int j) &#123;
int temp = nums[i];
nums[i] = nums[j];
nums[j] = temp;
&#125;
分布式大数据问题
每台服务器的复杂度限制
服务器之间通信的网络带宽限时
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift146%E6%A0%88%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift146%E6%A0%88%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:33" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:33+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><pre><code>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
可通过建立辅助栈实现，栈A用于存储所有元素，栈B中中存储栈 A中非严格降序 的元素，栈A中最小元素始终位于栈B的顶端
Stack&lt;Integer&gt; A, B;
    public MinStack() &#123;
        A = new Stack&lt;&gt;();
        B = new Stack&lt;&gt;();
    &#125;
    public void push(int x) &#123;
        A.add(x);
        if(B.empty() || B.peek() &gt;= x)
            B.add(x);
    &#125;
    public void pop() &#123;
        if(A.pop().equals(B.peek()))
            B.pop();
    &#125;
    public int top() &#123;
        return A.peek();
    &#125;
    public int min() &#123;
        return B.peek();
    &#125;
</code></pre>
<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><pre><code>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
输入：
[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[3],[],[]]
输出：[null,null,3,-1]
class CQueue &#123;
    Deque&lt;Integer&gt; stack1;
    Deque&lt;Integer&gt; stack2;

public CQueue() &#123;
    stack1 = new LinkedList&lt;Integer&gt;();
    stack2 = new LinkedList&lt;Integer&gt;();
&#125;

public void appendTail(int value) &#123;
    stack1.push(value);
&#125;

public int deleteHead() &#123;
    // 如果第二个栈为空
    if (stack2.isEmpty()) &#123;
        while (!stack1.isEmpty()) &#123;
            stack2.push(stack1.pop());
        &#125;
    &#125; 
    if (stack2.isEmpty()) &#123;
        return -1;
    &#125; else &#123;
        int deleteItem = stack2.pop();
        return deleteItem;
    &#125;
&#125;
</code></pre>
<p>}</p>
<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><pre><code>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。
考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。
 public boolean validateStackSequences(int[] pushed, int[] popped) &#123;
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int i = 0;
        for(int num : pushed) &#123;
            stack.push(num); // num 入栈
            while(!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) &#123; // 循环判断与出栈
                stack.pop();
                i++;
            &#125;
        &#125;
        return stack.isEmpty();
    &#125;
</code></pre>
<h2 id="栈排序"><a href="#栈排序" class="headerlink" title="栈排序"></a>栈排序</h2><pre><code>对栈进行排序使最小元素位于栈顶
用一个辅助栈

class SortedStack &#123;

private Stack&lt;Integer&gt; data = new Stack&lt;&gt;();
private Stack&lt;Integer&gt; help = new Stack&lt;&gt;();

public SortedStack() &#123;
    super();
&#125;

public void push(int val) &#123;
    if(isEmpty()) &#123; // 如果data ，没有数据，添加数据，添加help中数据
        data.push(val);
        while(!help.isEmpty()) &#123;
            data.push(help.pop());
        &#125;
    &#125; else &#123; // 获取data 顶部元素。比较大小，如果大于，那么添加元素，否则help添加元素
        int top = peek();
        if(top &gt;= val) &#123;
            data.push(val);
            while(!help.isEmpty()) &#123;
                data.push(help.pop());
            &#125;
        &#125; else &#123;
            help.push(data.pop());
            push(val);
        &#125;
    &#125;
&#125;

public void pop() &#123;
    if(!isEmpty()) &#123;
        data.pop();
    &#125;
&#125;

public int peek() &#123;
    if(isEmpty()) &#123;
        return -1;
    &#125; else &#123;
        return data.peek();
    &#125;
&#125;

public boolean isEmpty() &#123;
    return data.isEmpty();
&#125;
&#125;
</code></pre>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><pre><code>class MyStack &#123;
           private Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();
           private Queue&lt;Integer&gt; q2 = new LinkedList&lt;&gt;();
           int top = 0;
           MyStack() &#123;
           &#125;
           public void push(int x) &#123;
               q1.add(x);
               top = x;
           &#125;
           public int pop() &#123;
                while (q1.size() &gt; 1) &#123;
                       top = q1.remove();
                       q2.add(top);
               &#125;
               int a = q1.remove();
               Queue&lt;Integer&gt; temp = q1;
               q1 = q2;  
               q2 = temp;
               return a;
           &#125;
           public int top() &#123;
               return top;
           &#125;
           public boolean empty() &#123;
               return q1.isEmpty();
           &#125;
&#125;;
</code></pre>
<h2 id="三合一"><a href="#三合一" class="headerlink" title="三合一"></a>三合一</h2><pre><code>描述如何只用一个数组来实现三个栈。
首先要构建数组，3倍长度的size
然后让另一个3的数组，存放和管理下标
然后在根据结构分析
class TripleInOne &#123;

int[] a;
int[] tt = new int[3];
int size;
public TripleInOne(int statckSize)&#123;
    a = new int[3 * statckSize + 10];
    size = statckSize;
    for(int i = 0; i &lt; 3; i++)&#123;
        tt[i] = i * statckSize - 1;
    &#125;
&#125;

public boolean isFull(int stackNum)&#123;
    return tt[stackNum] &gt;= size * (stackNum + 1) - 1;

&#125;

public void push(int stackNum, int value)&#123;
    if(isFull(stackNum))    return;
    a[++tt[stackNum]] = value;
&#125;

public int pop(int stackNum)&#123;
    if(isEmpty(stackNum)) return -1;
    tt[stackNum]--;
    return a[tt[stackNum] + 1];
&#125;

public int peek(int stackNum)&#123;
    if(isEmpty(stackNum))   return -1;
    return a[tt[stackNum]];
&#125;

public boolean isEmpty(int stackNum)&#123;
    return tt[stackNum] &lt; stackNum * size;
&#125;
</code></pre>
<p>}</p>
<h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><pre><code>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
解题思路：递归与分治
    public void hanota(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) &#123;
        hanoi(A.size(), A, B, C);
    &#125;

public void hanoi(int n, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)&#123;
    
    if(n == 1)&#123;
        C.add(A.get(A.size() - 1));
        A.remove(A.size() - 1);
    &#125;else&#123;
        //把A经过辅助C放到B上
        hanoi(n - 1, A, C, B);
        //把A放到C上
        C.add(A.get(A.size() - 1));
        A.remove(A.size() - 1);
        //把B经过辅助A放到C上
        hanoi(n - 1, B, A, C);
    &#125;
&#125;
</code></pre>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="用两个栈实现队列-1"><a href="#用两个栈实现队列-1" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><pre><code>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
输入：
[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[3],[],[]]
输出：[null,null,3,-1]
class CQueue &#123;
    Deque&lt;Integer&gt; stack1;
    Deque&lt;Integer&gt; stack2;

public CQueue() &#123;
    stack1 = new LinkedList&lt;Integer&gt;();
    stack2 = new LinkedList&lt;Integer&gt;();
&#125;

public void appendTail(int value) &#123;
    stack1.push(value);
&#125;

public int deleteHead() &#123;
    // 如果第二个栈为空
    if (stack2.isEmpty()) &#123;
        while (!stack1.isEmpty()) &#123;
            stack2.push(stack1.pop());
        &#125;
    &#125; 
    if (stack2.isEmpty()) &#123;
        return -1;
    &#125; else &#123;
        int deleteItem = stack2.pop();
        return deleteItem;
    &#125;
&#125;
&#125;
</code></pre>
<h2 id="数据流中的中位数-（优先队列）"><a href="#数据流中的中位数-（优先队列）" class="headerlink" title="数据流中的中位数  （优先队列）"></a>数据流中的中位数  （优先队列）</h2><pre><code>优先队列 / 堆， 小顶堆，保存较大的一半， 大顶堆，保存较小的一半，堆顶的平均数即为中位数
    class MedianFinder &#123;
    Queue&lt;Integer&gt; A, B;
    public MedianFinder() &#123;
        A = new PriorityQueue&lt;&gt;(); // 小顶堆，保存较大的一半
        B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，保存较小的一半
    &#125;
    public void addNum(int num) &#123;
        if(A.size() != B.size()) &#123;
            A.add(num);
            B.add(A.poll());
        &#125; else &#123;
            B.add(num);
            A.add(B.poll());
        &#125;
    &#125;
    public double findMedian() &#123;
        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;
    &#125;
&#125;
</code></pre>
<h2 id="滑动窗口的最大值-单调队列"><a href="#滑动窗口的最大值-单调队列" class="headerlink" title="滑动窗口的最大值  单调队列"></a>滑动窗口的最大值  单调队列</h2><pre><code>    我们维护一个单调的双向队列，窗口在每次滑动的时候，我就从队列头部取当前窗口中的最大值，每次窗口新进来一个元素的时候，我就将它与队列中的元素进行大小比较
    如果刚刚进来的元素比队列的尾部元素大，那么先将队列尾部的元素弹出，然后把刚刚进来的元素添到队列的尾部；
    如果刚刚进来的元素比队列的尾部元素小，那么把刚刚进来的元素直接添到队列的尾部即可。
    方法二：构建双端队列
       保持队列大小不超过窗口，以及最大值在出端
       读取新数据，入端操作，和之前的进入的数据比较，之前的数据小则剔除，直到比它大则停止，最大值还在出端
       循环上面步骤，直到结束
       public int[] maxSlidingWindow(int[] nums, int k) &#123;
               if(nums.length == 0 || k == 0) return new int[0];
               Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); // 队列
               int[] res = new int[nums.length - k + 1];
               for(int j = 0, i = 1 - k; j &lt; nums.length; i++, j++) &#123;
                   if(i &gt; 0 &amp;&amp; deque.peekFirst() == nums[i - 1])
                       deque.removeFirst(); // 删除 deque 中对应的 nums[i-1]
                   while(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])
                       deque.removeLast(); // 保持 deque 递减
                   deque.addLast(nums[j]);
                   if(i &gt;= 0)
                       res[i] = deque.peekFirst();  // 记录窗口最大值
               &#125;
               return res;
           &#125;
</code></pre>
<h2 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h2><pre><code>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
方法二：维护一个单调的双端队列
public class MaxQueue &#123;

    Queue&lt;Integer&gt; queue;
    LinkedList&lt;Integer&gt; max;
    public MaxQueue() &#123;
        queue = new LinkedList&lt;&gt;();
        max = new LinkedList&lt;&gt;();//LinkedList是双端链表
    &#125;
    
    public int max_value() &#123;
        return max.size()==0?-1:max.getFirst();
    &#125;
    
    public void push_back(int value) &#123;
        queue.add(value);
        while(max.size()!=0&amp;&amp;max.getLast()&lt;value)&#123;//注意：这里第二个判断条件不能带等号，即max中对于当前queue中的具有相同值的元素会全部存储，而不是存储最近的那个。只添加递增
            max.removeLast();
        &#125;
        max.add(value);
    &#125;
    
    public int pop_front() &#123;
        if(max.size()!=0&amp;&amp;queue.peek().equals(max.getFirst()))//Integer类型的值的比较不能直接使用==
            max.removeFirst();
        return queue.size()==0?-1:queue.poll();
    &#125;
&#125;
</code></pre>
<p>优先队列的主要操作<br>优先队列辅助操作<br>返回优先队列中键值为第k个最小最大的元素<br>返回优先队列的元素个数<br>基于键值的优先级将优先队列的元素进行排序<br>应用</p>
<p>最短路径算法：Dijkstra算法<br>最小生成树算法：Prim算法<br>事件驱动仿真：顾客排队算法<br>选择问题：查找第k个最小元素</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift145%E4%BA%8C%E5%88%86%E5%8F%8A%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift145%E4%BA%8C%E5%88%86%E5%8F%8A%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">二分查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:29" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:29+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h2><p>峰值元素是指其值大于左右相邻值的元素<br>方法一: 线性扫描<br> public int findPeakElement(int[] nums) {<br>        for (int i = 0; i &lt; nums.length - 1; i++) {<br>            if (nums[i] &gt; nums[i + 1])<br>                return i;<br>        }<br>        return nums.length - 1;<br>    }<br>方法二：递归二分查找<br>我们可以将 nums 数组中的任何给定序列视为交替的升序和降序序列。通过利用这一点，以及“可以返回任何一个峰作为结果”的要求，我们可以利用二分查找来找到所需的峰值元素。<br>我们对二分查找进行一点修改。首先从数组 nums 中找到中间的元素 mid若该元素恰好位于降序序列或者一个局部下降坡度中，则说明峰值会在本元素的左边<br>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素<br>public class Solution {<br>    public int findPeakElement(int[] nums) {<br>        return search(nums, 0, nums.length - 1);<br>    }<br>    public int search(int[] nums, int l, int r) {<br>        if (l == r)<br>            return l;<br>        int mid = (l + r) / 2;<br>        if (nums[mid] &gt; nums[mid + 1])<br>            return search(nums, l, mid);<br>        return search(nums, mid + 1, r);<br>    }<br>}</p>
<h2 id="找出这个重复的数"><a href="#找出这个重复的数" class="headerlink" title="找出这个重复的数"></a>找出这个重复的数</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br>方法一：二分查找<br>class Solution {<br>    public int findDuplicate(int[] nums) {<br>        int n = nums.length;<br>        int l = 1, r = n - 1, ans = -1;<br>        while (l &lt;= r) {<br>            int mid = (l + r) &gt;&gt; 1;<br>            int cnt = 0;<br>            for (int i = 0; i &lt; n; ++i) {<br>                if (nums[i] &lt;= mid) {<br>                    cnt++;<br>                }<br>            }<br>            if (cnt &lt;= mid) {<br>                l = mid + 1;<br>            } else {<br>                r = mid - 1;<br>                ans = mid;<br>            }<br>        }<br>        return ans;</p>
<pre><code>&#125;
</code></pre>
<p>}<br>最优<br> int temp;<br>        for(int i=0;i&lt;nums.length;i++){<br>            while (nums[i]!=i){<br>                if(nums[i]==nums[nums[i]]){<br>                    return nums[i];<br>                }<br>                temp=nums[i];<br>                nums[i]=nums[temp];<br>                nums[temp]=temp;<br>            }<br>        }<br>        return -1;</p>
<p>方法二：二进制<br>这个方法我们来将所有数二进制展开按位考虑如何找出重复的数，如果我们能确定重复数每一位是 1 还是 0 就可以按位还原出重复的数是什么。<br>class Solution {<br>    public int findDuplicate(int[] nums) {<br>        int n = nums.length, ans = 0;<br>        int bit_max = 31;<br>        while (((n - 1) &gt;&gt; bit_max) == 0) {<br>            bit_max -= 1;<br>        }<br>        for (int bit = 0; bit &lt;= bit_max; ++bit) {<br>            int x = 0, y = 0;<br>            for (int i = 0; i &lt; n; ++i) {<br>                if ((nums[i] &amp; (1 &lt;&lt; bit)) != 0) {<br>                    x += 1;<br>                }<br>                if (i &gt;= 1 &amp;&amp; ((i &amp; (1 &lt;&lt; bit)) != 0)) {<br>                    y += 1;<br>                }<br>            }<br>            if (x &gt; y) {<br>                ans |= 1 &lt;&lt; bit;<br>            }<br>        }<br>        return ans;<br>    }<br>}<br>方法三：快慢指针<br>我们先设置慢指针<br>slow 和快指针<br>fast ，慢指针每次走一步，快指针每次走两步<br>class Solution {<br>    public int findDuplicate(int[] nums) {<br>        int slow = 0, fast = 0;<br>        do {<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        } while (slow != fast);<br>        slow = 0;<br>        while (slow != fast) {<br>            slow = nums[slow];<br>            fast = nums[fast];<br>        }<br>        return slow;<br>    }<br>}</p>
<h2 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a>0～n-1中缺失的数字</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。<br>二分法<br>class Solution {<br>    public int missingNumber(int[] nums) {<br>        int i = 0, j = nums.length - 1;<br>        while(i &lt;= j) {<br>            int m = (i + j) / 2;<br>            if(nums[m] == m) i = m + 1;<br>            else j = m - 1;<br>        }<br>        return i;<br>    }<br>}</p>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>排序数组的查找问题首先考虑使用 二分法 解决，其可将遍历法的 线性级别 时间复杂度降低至 对数级别<br>public int minArray(int[] numbers) {<br>        int i = 0, j = numbers.length - 1;<br>        while (i &lt; j) {<br>            int m = (i + j) / 2;<br>            if (numbers[m] &gt; numbers[j]) i = m + 1;//m 一定在 左排序数组<br>            else if (numbers[m] &lt; numbers[j]) j = m;//m 一定在 右排序数组 中<br>            else j–;<br>        }<br>        return numbers[i];<br>        }</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：<br>int binary_search(int[] nums, int target) {<br>    int left = 0, right = nums.length - 1;<br>    while(left &lt;= right) {<br>        int mid = left + (right - left) / 2;<br>        if (nums[mid] &lt; target) {<br>            left = mid + 1;<br>        } else if (nums[mid] &gt; target) {<br>            right = mid - 1;<br>        } else if(nums[mid] == target) {<br>            // 直接返回<br>            return mid;<br>        }<br>    }<br>    // 直接返回<br>    return -1;<br>}</p>
<h2 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h2><p>二分查找，找到左右闭合区间即可<br>重点在边界的限制上<br>class Solution {<br>    public int search(int[] nums, int target) {<br>        // 搜索右边界 right<br>        int i = 0, j = nums.length - 1;<br>        while(i &lt;= j) {<br>            int m = (i + j) / 2;<br>            if(nums[m] &lt;= target) i = m + 1;<br>            else j = m - 1;<br>        }<br>        int right = i;<br>        // 若数组中无 target ，则提前返回<br>        if(j &gt;= 0 &amp;&amp; nums[j] != target) return 0;<br>        // 搜索左边界 right<br>        i = 0; j = nums.length - 1;<br>        while(i &lt;= j) {<br>            int m = (i + j) / 2;<br>            if(nums[m] &lt; target) i = m + 1;<br>            else j = m - 1;<br>        }<br>        int left = j;<br>        return right - left - 1;<br>    }<br>}</p>
<h2 id="查找value下标"><a href="#查找value下标" class="headerlink" title="查找value下标"></a>查找value下标</h2><p>给定一个有序的数组，查找value第一次出现的下标，不存在返回-1。</p>
<p>int BinarySearch(int array[], int n, int value)<br>{<br>    int left = 0;<br>    int right = n - 1;</p>
<pre><code>while (left &lt;= right)  
&#123;
    int middle = left + ((right - left) &gt;&gt; 1);
    if (array[middle] &gt;= value)  //因为是找到最小的等值下标，所以等于号放在这里
        right = middle - 1;
    else
        left = middle + 1;
&#125;
return array[right + 1] == value ? right + 1 : -1;
</code></pre>
<p>}<br>如果问题改为查找value最后一次出现的下标呢？只需改动两个位置：<br>1.if (array[middle] &gt;= value)中的等号去掉；<br>2.return中right+1改为left-1。<br>给定一个有序的数组，查找最接近value且大于value的数的下标（如果该数存在多个，返回第一个下标），不存在返回-1。</p>
<p>int BinarySearch(int array[], int n, int value)<br>{<br>    int left = 0;<br>    int right = n - 1;</p>
<pre><code>while (left &lt;= right)  
&#123;
    int middle = left + ((right - left) &gt;&gt; 1);
    if (array[middle] &gt; value)
        right = middle - 1;
    else
        left = middle + 1;
&#125;
return array[right + 1] &gt; value ? right + 1 : -1;
</code></pre>
<p>}<br>如果问题改为查找最接近value且小于value的数的下标（如果该数存在多个，返回最后一个下标）呢？只需改动两个位置：<br>1.if (array[middle] &gt; value)加入一个等号；<br>2.return array[right + 1] &gt; value ? right + 1 : -1;改为return array[left-1] &lt; value ? left - 1 : -1;。</p>
<p>总结</p>
<p>  二分算法所操作的区间，是左闭右开，还是左闭右闭，需要在循环体跳出判断中，以及每次修改left,，right区间值这两个地方保持一致，否则就可能出错。</p>
<p>给一个数组，找出这样一些数，这个数左边的数都比它小，右边的数都比它大</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>    思想：每次遍历，相邻两个比较大小，修改位置
       复杂度：n平方
       function maopao(arr) &#123;
           for (var i = 0; i &lt; arr.length; i++) &#123;
               for (var j = 0; j &lt; arr.length; j++) &#123;
                   if (arr[i] &gt; arr[j]) &#123;
                       var temp = arr[i];
                       arr[i] = arr[j];
                       arr[j] = temp;
                   &#125;
               &#125;
           &#125;
       &#125;
</code></pre>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre><code>    思想：每次往最小数组里插入一个数据，并保证数组是排序的
       (1) 将这个序列的第一个元素R0视为一个有序序列； 
       (2) 依次把 , , … ,  插入到这个有序序列中； 
       (3) 将插入到有序序列中时，前 i-1 个数是有序的，将和 ~ 从后往前进行比较，确定要插入的位置。
        public static int[] insertSOrt(int[] arr) &#123;
              int len = arr.length;
              int preIndex,cur;
              for (int i = 0; i &lt; len; i++) &#123;
                 preIndex = i - 1;
                 cur = arr[i];
                 while (preIndex &gt; 0 &amp;&amp; arr[preIndex] &gt; cur) &#123;
                      arr[preIndex +1] = arr[preIndex];
                      preIndex--;
                 &#125;
                 arr[preIndex+1] = cur;
              &#125;
              return arr;
          &#125;
</code></pre>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code>    作为一种典型的分而治之思想的算法应用
    将一个数组排序，可以先递归的将它分成两半分别排序，然后再将结果归并起来。
    缺点：需要额外的空间
    从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这
    些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得
    到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。
    这样就得到了我们想要的排序结果
     public int[] sort(int[] sourceArray) throws Exception &#123;
           // 对 arr 进行拷贝，不改变参数内容
           int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

           if (arr.length &lt; 2) &#123;
               return arr;
           &#125;
           int middle = (int) Math.floor(arr.length / 2);
           // 分开
           int[] left = Arrays.copyOfRange(arr, 0, middle);
           int[] right = Arrays.copyOfRange(arr, middle, arr.length);
           // 合并
           return merge(sort(left), sort(right));
    &#125;

    protected int[] merge(int[] left, int[] right) &#123;
           int[] result = new int[left.length + right.length];
           int i = 0;
           while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123;
               if (left[0] &lt;= right[0]) &#123;
                   result[i++] = left[0];
                   left = Arrays.copyOfRange(left, 1, left.length);
               &#125; else &#123;
                   result[i++] = right[0];
                   right = Arrays.copyOfRange(right, 1, right.length);
               &#125;
           &#125;

           while (left.length &gt; 0) &#123;
               result[i++] = left[0];
               left = Arrays.copyOfRange(left, 1, left.length);
           &#125;

           while (right.length &gt; 0) &#123;
               result[i++] = right[0];
               right = Arrays.copyOfRange(right, 1, right.length);
           &#125;

           return result;
       &#125;
</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code>    分而治之思想在排序算法。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。
       先是把第一个挖出来，作为基值；然后先是从右向左，对比基值，如果如果小，那么放到坑里；然后在从左往右对比基值，如果大，那么放到坑里；当换完一轮了后，把基值放到坑里；然后在根据基值，分左右两组，递归排序；
       通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比
       另外一部分的所有数据都要小，继续对长度较短的序列进行同样的分割，最后到
       达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故
       减少了比较次数，降低了排序时间。
      private static void quickSort(int[] arr, int low, int high) &#123;

          if (low &lt; high) &#123;
              // 找寻基准数据的正确索引位置
              int index = getIndex(arr, low, high);
              // 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序
              quickSort(arr, low, index - 1); // 左半边排序
              quickSort(arr, index + 1, high); // 右半边排序
          &#125;

      &#125;

      private static int getIndex(int[] arr, int low, int high) &#123;
          // 基准数据
          int tmp = arr[low];
          while (low &lt; high) &#123;
              // 当队尾的元素大于等于基准数据时,向前挪动high指针
              while (low &lt; high &amp;&amp; arr[high] &gt;= tmp) &#123;
                  high--;
              &#125;
              // 如果队尾元素小于tmp了,需要将其赋值给low
              arr[low] = arr[high];
              // 当队首元素小于等于tmp时,向前挪动low指针
              while (low &lt; high &amp;&amp; arr[low] &lt;= tmp) &#123;
                  low++;
              &#125;
              // 当队首元素大于tmp时,需要将其赋值给high
              arr[high] = arr[low];

          &#125;
          // 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置
          // 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low]
          arr[low] = tmp;
          return low; // 返回tmp的正确位置
      &#125;
</code></pre>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><pre><code>    它是对有向图的顶点排成一个线性序列。
</code></pre>
<h2 id="堆排序（大顶堆、小顶堆）"><a href="#堆排序（大顶堆、小顶堆）" class="headerlink" title="堆排序（大顶堆、小顶堆）"></a>堆排序（大顶堆、小顶堆）</h2><pre><code>    堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
     大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列
     小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列
     堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大
     值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将
     剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执
     行，便能得到一个有序序列了
     
     var len;    //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

     function buildMaxHeap(arr) &#123;   //建立大顶堆
         len = arr.length;
         for (var i = Math.floor(len/2); i &amp;gt;= 0; i--) &#123;
             heapify(arr, i);
         &#125;
     &#125;

     function heapify(arr, i) &#123;     //堆调整
         var left = 2 * i + 1,
             right = 2 * i + 2,
             largest = i;

         if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;
             largest = left;
         &#125;

         if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;
             largest = right;
         &#125;

         if (largest != i) &#123;
             swap(arr, i, largest);
             heapify(arr, largest);
         &#125;
     &#125;

     function swap(arr, i, j) &#123;
         var temp = arr[i];
         arr[i] = arr[j];
         arr[j] = temp;
     &#125;

     function heapSort(arr) &#123;
         buildMaxHeap(arr);

         for (var i = arr.length-1; i &gt; 0; i--) &#123;
             swap(arr, 0, i);
             len--;
             heapify(arr, 0);
         &#125;
         return arr;
     &#125;
</code></pre>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><pre><code>    知道最大最小值，可以生成一个最大最小值的一个桶的map，key是值，value是出现的次数
    for(i=1;i&lt;=n;i++)//循环读入n个数，并进行桶排序
   &#123;
       scanf(&quot;%d&quot;,&amp;t);  //把每一个数读到变量t中
       book[t]++;  //进行计数，对编号为t的桶放一个小旗子
   &#125;
   for(i=1000;i&gt;=0;i--)  //依次判断编号1000~0的桶
       for(j=1;j&lt;=book[i];j++)  //出现了几次就将桶的编号打印几次
            printf(&quot;%d &quot;,i);
   getchar();getchar();
</code></pre>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h2 id="按指定要求排序后输出"><a href="#按指定要求排序后输出" class="headerlink" title="按指定要求排序后输出"></a>按指定要求排序后输出</h2><p>给字符串，内含很多整数，按指定要求排序后输出指定位置上的整数；<br>两个有序数组，找出合并后的中位数<br>获取数组中最值（最大值/最小值）<br> 分治 + 最小堆排序的思想<br>        局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，<br>        与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除<br>        ，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。<br>        原理是最小堆排序<br>        <a target="_blank" rel="noopener" href="https://blog.csdn.net/zyq522376829/article/details/47686867">https://blog.csdn.net/zyq522376829/article/details/47686867</a><br> 求数组中第k大的数<br>        建立一个大小为K的最小堆，堆顶就是第K大的数<br>        例如，假设有10个数，要求求第3大的数，第一步选取任意的3个数，比如说是前3个，<br>        将这3个数建成最小堆，然后从第4个数开始，与堆顶<br>        的数比较，如果比堆顶的数要小，那么这个数就不要，如果比堆顶的数大，<br>        则舍弃当前的堆顶而将这个数作为新的堆顶，并再去维护堆</p>
<h2 id="旋转数组查找；"><a href="#旋转数组查找；" class="headerlink" title="旋转数组查找；"></a>旋转数组查找；</h2><pre><code>public static int minNumberInRotateArray(int[] rotateArray)
   &#123;
       if (rotateArray.Length == 0) return 0;
       else if (rotateArray.Length == 1||rotateArray[0]&lt;rotateArray[rotateArray.Length-1]) return rotateArray[0];
       else
       &#123;
           int low = 0;
           int high = rotateArray.Length - 1;
           while (low&lt;=high)
           &#123;
               int mid = (int)Math.Floor((double)(low + high) / 2);
               if (rotateArray[mid] &gt; rotateArray[0]) low = mid + 1;
               else if (rotateArray[mid] &lt; rotateArray[0]) high = mid - 1;
               else low = low + 1;
           &#125;

           return low == rotateArray.Length ? rotateArray[low - 1] : rotateArray[low];
       &#125;
   &#125;
</code></pre>
<p>##常见算法<br>广度优先搜索<br>深度优先搜索<br>递归<br>回溯<br>贪婪算法<br>动态规划<br>线性规划<br>区间规划<br>约束规划<br>自底向上<br>自定向下</p>
<h2 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h2><p>回溯<br>递归<br>剪枝</p>
<h2 id="基础技巧"><a href="#基础技巧" class="headerlink" title="基础技巧"></a>基础技巧</h2><p>分治<br>倍增<br>二分<br>贪心</p>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><ol start="134">
<li>加油站</li>
<li>LRU缓存机制</li>
<li>快乐数</li>
<li>生命游戏</li>
<li>两整数之和</li>
<li>Fizz Buzz<br>两个人掷硬币，先得到正面的人赢，游戏到有人赢结束。问先掷硬币的人赢的概率</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift144%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift144%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">二叉树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:26" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:26+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h2><pre><code>void traverse(TreeNode root) &#123;
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
&#125;
非递归前序遍历
void preorder(TreeNode *root, vector&lt;int&gt;&amp; res)
&#123;
    stack&lt; pair&lt;TreeNode*, bool&gt; &gt; s;
    s.push(make_pair(root, false));
    bool visited;
    while(!s.empty()) &#123;
        root = s.top().first;
        visited = s.top().second;
        s.pop();
        if(root == NULL) &#123;
            continue;
        &#125;
        if(visited) &#123;
            res.push_back(root-&gt;val);
        &#125; else &#123;
            // 后序遍历
            s.push(make_pair(root-&gt;right, false));
            // 中序遍历
            s.push(make_pair(root-&gt;left, false));
            // 前序遍历
            s.push(make_pair(root, true));
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的广度优先搜索-（从上到下打印二叉树）"><a href="#二叉树的广度优先搜索-（从上到下打印二叉树）" class="headerlink" title="二叉树的广度优先搜索 （从上到下打印二叉树）"></a>二叉树的广度优先搜索 （从上到下打印二叉树）</h2><pre><code>本质上是前序遍历，用一个队列存储二叉树的（先入先出）
public int[] levelOrder(TreeNode root) &#123;
    if(root == null) return new int[0];
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;
    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
    while(!queue.isEmpty()) &#123;
        TreeNode node = queue.poll();
        ans.add(node.val);
        if(node.left != null) queue.add(node.left);
        if(node.right != null) queue.add(node.right);
    &#125;
    int[] res = new int[ans.size()];
    for(int i = 0; i &lt; ans.size(); i++)
        res[i] = ans.get(i);
    return res;
&#125;
</code></pre>
<h2 id="二叉树的深度优先搜索"><a href="#二叉树的深度优先搜索" class="headerlink" title="二叉树的深度优先搜索"></a>二叉树的深度优先搜索</h2><pre><code>本质上是二叉树的后续遍历，用栈存储（先入后出）
public class Solution &#123;
public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;
    ArrayList&lt;Integer&gt; lists=new ArrayList&lt;Integer&gt;();
    if(root==null)
        return lists;
    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();
    stack.push(root);
    while(!stack.isEmpty())&#123;
        TreeNode tree=stack.pop();
　　　 //先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。
            if(tree.right!=null)
                stack.push(tree.right);
            if(tree.left!=null)
                stack.push(tree.left);
            lists.add(tree.val);
        &#125;
        return lists;
    &#125;
&#125;
</code></pre>
<h2 id="树的子结构-（判断B是不是A的子结构。）"><a href="#树的子结构-（判断B是不是A的子结构。）" class="headerlink" title="树的子结构 （判断B是不是A的子结构。）"></a>树的子结构 （判断B是不是A的子结构。）</h2><pre><code>本质是二叉树的递归遍历（递归判断左右子树是不是相同）
代码步骤：A和B不能是Null，A和B相同、A的左边和B相同、A的右边和B相同
public boolean isSubStructure(TreeNode A, TreeNode B) &#123;
      return (A != null &amp;&amp; B != null) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    &#125;
    boolean recur(TreeNode A, TreeNode B) &#123;
        if(B == null) return true;
        if(A == null || A.val != B.val) return false;
        return recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);
    &#125;
</code></pre>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><pre><code>本质是二叉树的递归遍历 （交换left和right）
代码步骤：判断是否是空、交换左右的遍历结果
public TreeNode mirrorTree(TreeNode root) &#123;
        if(root == null) return null;
        TreeNode tmp = root.left;
        root.left = mirrorTree(root.right);
        root.right = mirrorTree(tmp);
        return root;
    &#125;
方法二：辅助栈（或队列）
利用栈（或队列）遍历树的所有节点 node ，并交换每个 node 的左 / 右子节点。
 public TreeNode mirrorTree(TreeNode root) &#123;
        if(root == null) return null;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
        while(!stack.isEmpty()) &#123;
            TreeNode node = stack.pop();
            if(node.left != null) stack.add(node.left);
            if(node.right != null) stack.add(node.right);
            TreeNode tmp = node.left;
            node.left = node.right;
            node.right = tmp;
        &#125;
        return root;
    &#125;
</code></pre>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><pre><code>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树
二叉树的先序遍历
// 判断左右两个数的左边和右边是不是一样，递归调用前序遍历
public boolean isSymmetric(TreeNode root) &#123;
        //方法调用
        return isSymmetric(root,root);
    &#125;

public boolean isSymmetric(TreeNode root1,TreeNode root2)&#123;
    if(root1 == null &amp;&amp; root2 == null)&#123;
        return true;
    &#125;

    //某结点只有一个子结点，故不对称，所以返回false
    if(root1 == null || root2 == null)&#123;
        return false;
    &#125;

    //对称结点存在，但是值不相同
    if(root1.val != root2.val)&#123;
        return false;
    &#125;

    //递归调用左子节点和右子节点
    return isSymmetric(root1.left, root2.right) &amp;&amp; isSymmetric(root1.right,root2.left);
&#125;
</code></pre>
<h2 id="从上到下打印二叉树-同一层的节点按从左到右的顺序打印"><a href="#从上到下打印二叉树-同一层的节点按从左到右的顺序打印" class="headerlink" title="从上到下打印二叉树 同一层的节点按从左到右的顺序打印"></a>从上到下打印二叉树 同一层的节点按从左到右的顺序打印</h2><pre><code>前序遍历，用队列存储每一层的值
将每一层数据存放到队列中
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) &#123;
            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();
            for(int i = queue.size(); i &gt; 0; i--) &#123;
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            &#125;
            res.add(tmp);
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="从上到下打印二叉树-之字形顺序打印二叉树"><a href="#从上到下打印二叉树-之字形顺序打印二叉树" class="headerlink" title="从上到下打印二叉树 之字形顺序打印二叉树"></a>从上到下打印二叉树 之字形顺序打印二叉树</h2><pre><code>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
方法一：层序遍历 + 双端队列
利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列），奇数层 则添加至 尾部，偶数层添加至头部
 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) &#123;
            LinkedList&lt;Integer&gt; tmp = new LinkedList&lt;&gt;();
            for(int i = queue.size(); i &gt; 0; i--) &#123;
                TreeNode node = queue.poll();
                if(res.size() % 2 == 0) tmp.addLast(node.val); // 偶数层 -&gt; 队列头部
                else tmp.addFirst(node.val); // 奇数层 -&gt; 队列尾部
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            &#125;
            res.add(tmp);
        &#125;
        return res;
    &#125;
</code></pre>
<h2 id="二叉搜索树的后序"><a href="#二叉搜索树的后序" class="headerlink" title="二叉搜索树的后序"></a>二叉搜索树的后序</h2><pre><code>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。
每一层判断左右子树和根节点的大小关系，如果满足则继续向下判断；否则直接返回失败
递归分治 / 单调栈， 遍历顺序为 “左、右、根” 
    二叉搜索树定义： 左子树中所有节点的值 &lt; 根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。
    public boolean verifyPostorder(int[] postorder) &#123;
        return recur(postorder, 0, postorder.length - 1);
    &#125;
    boolean recur(int[] postorder, int i, int j) &#123;
        if(i &gt;= j) return true;
        int p = i;
        while(postorder[p] &lt; postorder[j]) p++;
        int m = p;
        while(postorder[p] &gt; postorder[j]) p++;
        return p == j &amp;&amp; recur(postorder, i, m - 1) &amp;&amp; recur(postorder, m, j - 1);
    &#125;
</code></pre>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><pre><code>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。
前序遍历：从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
 LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();
    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); 
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;
        recur(root, sum);
        return res;
    &#125;
    void recur(TreeNode root, int tar) &#123;
        if(root == null) return;
        path.add(root.val);
        tar -= root.val;
        if(tar == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)
            res.add(new LinkedList(path));
        recur(root.left, tar);
        recur(root.right, tar);
        path.removeLast();
    &#125;
</code></pre>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><pre><code>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
本文解法基于性质：二叉搜索树的中序遍历为 递增序列 。排序链表，双向链表。循环链表\
并在访问每个节点时构建 
cur 和前驱节点   pre 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可
中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 
head 和  pre 的双向节点引用即可。
Node pre, head;
    public Node treeToDoublyList(Node root) &#123;
        if(root == null) return null;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    &#125;
    void dfs(Node cur) &#123;
        if(cur == null) return;
        dfs(cur.left);
        if(pre != null) pre.right = cur;
        else head = cur;
        cur.left = pre;
        pre = cur;
        dfs(cur.right);
    &#125;
</code></pre>
<h2 id="序列化二叉树-层序遍历-BFS"><a href="#序列化二叉树-层序遍历-BFS" class="headerlink" title="序列化二叉树  层序遍历 BFS"></a>序列化二叉树  层序遍历 BFS</h2><pre><code>定义 StringBuilder 前序遍历拼接，删除最后一个逗号
 public String serialize(TreeNode root) &#123;
        if(root == null) return &quot;[]&quot;;
        StringBuilder res = new StringBuilder(&quot;[&quot;);
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
        while(!queue.isEmpty()) &#123;
            TreeNode node = queue.poll();
            if(node != null) &#123;
                res.append(node.val + &quot;,&quot;);
                queue.add(node.left);
                queue.add(node.right);
            &#125;
            else res.append(&quot;null,&quot;);
        &#125;
        res.deleteCharAt(res.length() - 1);
        res.append(&quot;]&quot;);
        return res.toString();
    &#125;

public TreeNode deserialize(String data) &#123;
    if(data.equals(&quot;[]&quot;)) return null;
    String[] vals = data.substring(1, data.length() - 1).split(&quot;,&quot;);
    TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
    int i = 1;
    while(!queue.isEmpty()) &#123;
        TreeNode node = queue.poll();
        if(!vals[i].equals(&quot;null&quot;)) &#123;
            node.left = new TreeNode(Integer.parseInt(vals[i]));
            queue.add(node.left);
        &#125;
        i++;
        if(!vals[i].equals(&quot;null&quot;)) &#123;
            node.right = new TreeNode(Integer.parseInt(vals[i]));
            queue.add(node.right);
        &#125;
        i++;
    &#125;
    return root;
&#125;
</code></pre>
<h2 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h2><pre><code>第k小的话，我觉得可以反过来遍历
class Solution &#123;
    int res, k;
    public int kthLargest(TreeNode root, int k) &#123;
        this.k = k;
        dfs(root);
        return res;
    &#125;
    void dfs(TreeNode root) &#123;
        if(root == null) return;
        dfs(root.right);
        if(k == 0) return;
        if(--k == 0) res = root.val;
        dfs(root.left);
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h2><pre><code>BST 的特性：BST 的中序遍历是升序序列。
通过构造 BST 的中序遍历序列，则第 k-1 个元素就是第 k 小的元素
方法一：递归
class Solution &#123;
  public ArrayList&lt;Integer&gt; inorder(TreeNode root, ArrayList&lt;Integer&gt; arr) &#123;
    if (root == null) return arr;
    inorder(root.left, arr);
    arr.add(root.val);
    inorder(root.right, arr);
    return arr;
  &#125;

  public int kthSmallest(TreeNode root, int k) &#123;
    ArrayList&lt;Integer&gt; nums = inorder(root, new ArrayList&lt;Integer&gt;());
    return nums.get(k - 1);
  &#125;
&#125;
</code></pre>
<h2 id="二叉树的深度（后序遍历）"><a href="#二叉树的深度（后序遍历）" class="headerlink" title="二叉树的深度（后序遍历）"></a>二叉树的深度（后序遍历）</h2><pre><code>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
方法一：后序遍历（DFS）
  public int maxDepth(TreeNode root) &#123;
        if(root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    &#125;

方法二：层序遍历（BFS）
class Solution &#123;
    public int maxDepth(TreeNode root) &#123;
        if(root == null) return 0;
        List&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;
        int res = 0;
        while(!queue.isEmpty()) &#123;
            tmp = new LinkedList&lt;&gt;();
            for(TreeNode node : queue) &#123;
                if(node.left != null) tmp.add(node.left);
                if(node.right != null) tmp.add(node.right);
            &#125;
            queue = tmp;
            res++;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><pre><code>递归，0.1，
class Solution &#123;
  public int minDepth(TreeNode root) &#123;
    if (root == null) &#123;
      return 0;
    &#125;

    if ((root.left == null) &amp;&amp; (root.right == null)) &#123;
      return 1;
    &#125;

    int min_depth = Integer.MAX_VALUE;
    if (root.left != null) &#123;
      min_depth = Math.min(minDepth(root.left), min_depth);
    &#125;
    if (root.right != null) &#123;
      min_depth = Math.min(minDepth(root.right), min_depth);
    &#125;

    return min_depth + 1;
  &#125;
&#125;
方法2:广度优先搜索迭代
class Solution &#123;
  public int minDepth(TreeNode root) &#123;
    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root == null) &#123;
      return 0;
    &#125;
    else &#123;
      stack.add(new Pair(root, 1));
    &#125;

    int current_depth = 0;
    while (!stack.isEmpty()) &#123;
      Pair&lt;TreeNode, Integer&gt; current = stack.poll();
      root = current.getKey();
      current_depth = current.getValue();
      if ((root.left == null) &amp;&amp; (root.right == null)) &#123;
        break;
      &#125;
      if (root.left != null) &#123;
        stack.add(new Pair(root.left, current_depth + 1));
      &#125;
      if (root.right != null) &#123;
        stack.add(new Pair(root.right, current_depth + 1));
      &#125;
    &#125;
    return current_depth;
  &#125;
&#125;
</code></pre>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><pre><code>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
方法一：后序遍历 + 剪枝 （从底至顶）
class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        return recur(root) != -1;
    &#125;

private int recur(TreeNode root) &#123;
    if (root == null) return 0;
    int left = recur(root.left);
    if(left == -1) return -1;
    int right = recur(root.right);
    if(right == -1) return -1;
    return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1;
&#125;
&#125;
方法二：先序遍历 + 判断深度 （从顶至底）
class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);
    &#125;

    private int depth(TreeNode root) &#123;
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><pre><code>用集合遍历根树，保存Hashmap
用set保存一个二叉树在集合中的结果
遍历另一个二叉树，看set中是否有，有则为最近公共祖先
方法一：迭代
class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        if(p.val &gt; q.val) &#123; // 保证 p.val &lt; q.val
            TreeNode tmp = p;
            p = q;
            q = tmp;
        &#125;
        while(root != null) &#123;
            if(root.val &lt; p.val) // p,q 都在 root 的右子树中
                root = root.right; // 遍历至右子节点
            else if(root.val &gt; q.val) // p,q 都在 root 的左子树中
                root = root.left; // 遍历至左子节点
            else break;
        &#125;
        return root;
    &#125;
&#125;
方法二：递归
class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)
            return lowestCommonAncestor(root.right, p, q);
        if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)
            return lowestCommonAncestor(root.left, p, q);
        return root;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h2><h2 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a>最小高度树</h2><pre><code>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。
二分，拿到中间元素，然后递归创建左右子树
class Solution &#123;
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        return createTree(nums, 0, n - 1);
    &#125;
    TreeNode* createTree(vector&lt;int&gt;&amp; nums, int start, int end) &#123;
        if (start &gt; end) return nullptr;
        int mid = (start + end) &gt;&gt; 1;
        TreeNode* root = new TreeNode(nums[mid]);
        root-&gt;left = createTree(nums, start, mid - 1);
        root-&gt;right = createTree(nums, mid + 1, end);
        return root;
    &#125;
&#125;;
</code></pre>
<h2 id="合法二叉搜索树"><a href="#合法二叉搜索树" class="headerlink" title="合法二叉搜索树"></a>合法二叉搜索树</h2><pre><code>实现一个函数，检查一棵二叉树是否为二叉搜索树。
双百，递归遍历树，分别检查左右根节点的大小
    public boolean isValidBST(TreeNode root) &#123;
        if(root==null) return true;
        return isValidBSThelp(root.left,Long.MIN_VALUE,root.val)&amp;&amp;isValidBSThelp(root.right,root.val,Long.MAX_VALUE);
    &#125;
    private boolean isValidBSThelp(TreeNode root,long min,long max)&#123;
        if(root==null) return true;
        if(root.val&lt;=min||root.val&gt;=max) return false;
        boolean left = isValidBSThelp(root.left,min,root.val);
        boolean right = isValidBSThelp(root.right,root.val,max);
        return left &amp;&amp; right;
    &#125;
</code></pre>
<h2 id="二叉树中最大路径和"><a href="#二叉树中最大路径和" class="headerlink" title="二叉树中最大路径和"></a>二叉树中最大路径和</h2><pre><code>给定一个非空二叉树，返回其最大路径和。
递归计算，更新max，（递归中返回较大的）
class Solution &#123;
    int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) &#123;
    maxGain(root);
    return maxSum;
&#125;

public int maxGain(TreeNode node) &#123;
    if (node == null) &#123;
        return 0;
    &#125;
    
    // 递归计算左右子节点的最大贡献值
    // 只有在最大贡献值大于 0 时，才会选取对应子节点
    int leftGain = Math.max(maxGain(node.left), 0);
    int rightGain = Math.max(maxGain(node.right), 0);

    // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
    int priceNewpath = node.val + leftGain + rightGain;

    // 更新答案
    maxSum = Math.max(maxSum, priceNewpath);

    // 返回节点的最大贡献值
    return node.val + Math.max(leftGain, rightGain);
&#125;
&#125;
</code></pre>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><pre><code>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
输入: 
    Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
         3
        / \
       4   5
      / \   \ 
     5   4   7
public class Solution &#123;
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;
        if (t1 == null)
            return t2;
        if (t2 == null)
            return t1;
        t1.val += t2.val;
        t1.left = mergeTrees(t1.left, t2.left);
        t1.right = mergeTrees(t1.right, t2.right);
        return t1;
    &#125;
&#125;
</code></pre>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><pre><code>public TreeNode invertTree(TreeNode root) &#123;
    if (root == null) &#123;
        return null;
    &#125;
    TreeNode right = invertTree(root.right);
    TreeNode left = invertTree(root.left);
    root.left = right;
    root.right = left;
    return root;
&#125;
</code></pre>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><pre><code>给定一个二叉树，我们在树的节点上安装摄像头。
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
计算监控树的所有节点所需的最小摄像头数量。
根据每个节点的左右子节点来判断当前节点的状态，因此左右根后续遍历
class Solution &#123;
public:
    //记录需要放置摄像头的数量
    int res = 0;
    int minCameraCover(TreeNode* root) 
    &#123;
        //后序遍历，从下自上遍历。
        //若遍历至最上面，root标志为0，则多加一个摄像头
        if(dfs(root) == 0)
        &#123;
            res++;  
        &#125;
        return res;
    &#125;
    int dfs(TreeNode* root)
    &#123;

    //0：未被覆盖(当前节点未被照到)
    //1：已被覆盖(摄像头已经照到这个节点)
    //2：需放置摄像头

    //到根节点，
    if(root == NULL) return 1;
    //遍历左节点
    int left = dfs(root-&gt;left);
    //遍历右节点
    int right = dfs(root-&gt;right);
    //一个节点左右确定后，判断左右节点情况
    //所有情况00,01,02,11,12,22
    //左右孩子中有一个未被覆盖，则当前节点需要放置摄像头，当前节点标志为2
    if(left ==0 || right==0)
    &#123;
        res++;
        return 2;
    &#125;
    //左右孩子均为已覆盖状态,则当前节点未被覆盖，标志为0
    if(left == 1 &amp;&amp; right == 1)
    &#123;
        return 0;
    &#125;
    //若左右孩子为一个覆盖一个放置了摄像头，则当前节点为已被覆盖，标志为1
    if(left+right &gt;= 3)
    &#123;
        return 1;
    &#125;
    //此时已经组合完了根节点所有情况，随便返回一个整数即可
    return 0;
&#125;
&#125;;
</code></pre>
<h2 id="验证二叉树"><a href="#验证二叉树" class="headerlink" title="验证二叉树"></a>验证二叉树</h2><pre><code>如果一棵树是一个二叉树的话 必定除了根节点 每个非空节点的入度都为1
样例还给了某一个节点被两个&quot;父节点&quot;引用的例子 那这个节点的入度就为2了 也就不能构成二叉树

public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) &#123;
    int[] in = new int[n];
    for (int i = 0; i &lt; n; i++) &#123;
        if (leftChild[i] != -1) in[leftChild[i]]++;
        if (rightChild[i] != -1) in[rightChild[i]]++;
    &#125;

    int count0 = 0;
    int countOther = 0;
    for (int temp : in) &#123;
        if (temp == 0) count0++;
        if (temp &gt; 1) countOther++;
    &#125;
    return count0 == 1 &amp;&amp; countOther == 0;
&#125;
</code></pre>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><pre><code>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：
二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。
public class Solution &#123;
    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;
        return construct(nums, 0, nums.length);
    &#125;
    public TreeNode construct(int[] nums, int l, int r) &#123;
        if (l == r)
            return null;
        int max_i = max(nums, l, r);
        TreeNode root = new TreeNode(nums[max_i]);
        root.left = construct(nums, l, max_i);
        root.right = construct(nums, max_i + 1, r);
        return root;
    &#125;
    public int max(int[] nums, int l, int r) &#123;
        int max_i = l;
        for (int i = l; i &lt; r; i++) &#123;
            if (nums[max_i] &lt; nums[i])
                max_i = i;
        &#125;
        return max_i;
    &#125;
&#125;
</code></pre>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><pre><code>给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。
class Solution &#123;
  public boolean helper(TreeNode node, Integer lower, Integer upper) &#123;
    if (node == null) return true;
    int val = node.val;
    if (lower != null &amp;&amp; val &lt;= lower) return false;
    if (upper != null &amp;&amp; val &gt;= upper) return false;

    if (! helper(node.right, val, upper)) return false;
    if (! helper(node.left, lower, val)) return false;
    return true;
&#125;

public boolean isValidBST(TreeNode root) &#123;
    return helper(root, null, null);
  &#125;
&#125;
</code></pre>
<h2 id="单值二叉树"><a href="#单值二叉树" class="headerlink" title="单值二叉树"></a>单值二叉树</h2><pre><code>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
我们先进行一次深度优先搜索，获取这颗树中的所有节点的值。然后，就可以判断所有节点的值是不是都相等了。
class Solution &#123;
    List&lt;Integer&gt; vals;
    public boolean isUnivalTree(TreeNode root) &#123;
        vals = new ArrayList();
        dfs(root);
        for (int v: vals)
            if (v != vals.get(0))
                return false;
        return true;
    &#125;

public void dfs(TreeNode node) &#123;
    if (node != null) &#123;
        vals.add(node.val);
        dfs(node.left);
        dfs(node.right);
    &#125;
&#125;
&#125;
方法二：递归
思路与算法
一颗树是单值的，当且仅当根节点的子节点所在的子树也是单值的，同时根节点的值与子节点的值相同。
class Solution &#123;
    public boolean isUnivalTree(TreeNode root) &#123;
        boolean left_correct = (root.left == null ||
                (root.val == root.left.val &amp;&amp; isUnivalTree(root.left)));
        boolean right_correct = (root.right == null ||
                (root.val == root.right.val &amp;&amp; isUnivalTree(root.right)));
        return left_correct &amp;&amp; right_correct;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><pre><code>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
方法：深度优先搜索
首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。
而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。
class Solution &#123;
    int ans;
    public int diameterOfBinaryTree(TreeNode root) &#123;
        ans = 1;
        depth(root);
        return ans - 1;
    &#125;
    public int depth(TreeNode node) &#123;
        if (node == null) return 0; // 访问到空节点了，返回0
        int L = depth(node.left); // 左儿子为根的子树的深度
        int R = depth(node.right); // 右儿子为根的子树的深度
        ans = Math.max(ans, L+R+1); // 计算d_node即L+R+1 并更新ans
        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的坡度"><a href="#二叉树的坡度" class="headerlink" title="二叉树的坡度"></a>二叉树的坡度</h2><pre><code>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。
整个树的坡度就是其所有节点的坡度之和。
输入：
         1
       /   \
      2     3
输出：1
解释：
结点 2 的坡度: 0
结点 3 的坡度: 0
结点 1 的坡度: |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1
方法：递归
我们需要求出该结点的左子树上所有结点和以及其右子树上全部结点和的差值。
在任何结点调用该函数，都会返回当前结点下面（包括其自身）的结点和。借助于任何结点的左右子结点的这一和值，我们可以直接获得该结点所对应的坡度。
public class Solution &#123;
    int tilt=0;
    public int findTilt(TreeNode root) &#123;
        traverse(root);
        return tilt;
    &#125;
    public int traverse(TreeNode root)
    &#123;
        if(root==null )
            return 0;
        int left=traverse(root.left);
        int right=traverse(root.right);
        tilt+=Math.abs(left-right);
        return left+right+root.val;
    &#125;
&#125;
</code></pre>
<h2 id="恢复一棵-BST"><a href="#恢复一棵-BST" class="headerlink" title="恢复一棵 BST"></a>恢复一棵 BST</h2><pre><code>二叉搜索树中的两个节点被错误地交换。
请在不改变其结构的情况下，恢复这棵树。
方法一：对数组进行排序
我们直到 BST 的中序遍历是升序序列。下面展示了如何计算中序遍历。
这里被交换了两个节点，因此中序遍历是一个几乎排好序的数组，其中有两个元素被交换。识别排序数组中两个交换元素是可以在线性时间内解决的经典问题。
public int[] findTwoSwapped(List&lt;Integer&gt; nums) &#123;
  int n = nums.size();
  int x = -1, y = -1;
  for(int i = 0; i &lt; n - 1; ++i) &#123;
    if (nums.get(i + 1) &lt; nums.get(i)) &#123;
      y = nums.get(i + 1);
      // first swap occurence
      if (x == -1) x = nums.get(i);
      // second swap occurence
      else break;
    &#125;
  &#125;
  return new int[]&#123;x, y&#125;;
&#125;
方法二：递归中序遍历
class Solution &#123;
  TreeNode x = null, y = null, pred = null;

  public void swap(TreeNode a, TreeNode b) &#123;
    int tmp = a.val;
    a.val = b.val;
    b.val = tmp;
  &#125;

  public void findTwoSwapped(TreeNode root) &#123;
    if (root == null) return;
    findTwoSwapped(root.left);
    if (pred != null &amp;&amp; root.val &lt; pred.val) &#123;
      y = root;
      if (x == null) x = pred;
      else return;
    &#125;
    pred = root;
    findTwoSwapped(root.right);
  &#125;

  public void recoverTree(TreeNode root) &#123;
    findTwoSwapped(root);
    swap(x, y);
  &#125;
&#125;
</code></pre>
<h2 id="求二叉树中叶子节点的个数"><a href="#求二叉树中叶子节点的个数" class="headerlink" title="求二叉树中叶子节点的个数"></a>求二叉树中叶子节点的个数</h2><pre><code>class Solution &#123;
    public int getLeafCount(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        if (root.left == null &amp;&amp; root.right == null) &#123;
            // 输出叶子节点
            System.out.println(&quot;leaf nodes:&quot; + root.val);
            return 1;
        &#125;
        return getLeafCount(root.left) + getLeafCount(root.right);
    &#125;
&#125;
</code></pre>
<h2 id="求二叉树第K层的节点个数"><a href="#求二叉树第K层的节点个数" class="headerlink" title="求二叉树第K层的节点个数"></a>求二叉树第K层的节点个数</h2><pre><code>  if (level == k)
    &#123;
        ++num;
        return num;
    &#125;
    _FindKLevel(root-&gt;_left, k, level + 1);
    _FindKLevel(root-&gt;_right, k, level + 1);
</code></pre>
<h2 id="求二叉树中最远的两个节点的距离"><a href="#求二叉树中最远的两个节点的距离" class="headerlink" title="求二叉树中最远的两个节点的距离"></a>求二叉树中最远的两个节点的距离</h2><pre><code>（1）如果具有最远距离的两个节点经过了根节点，那么最远的距离就是左边最深的深度加上右边最深的深度之和。
（2）如果具有最远距离的两个节点之间的路径不经过根节点，那么最远的距离就在根节点的其中一个子树上的两个叶子结点。

 int _Height(Node* root, int&amp; distance)
       &#123;
              if (root == NULL)
              &#123;
                     return 0;
              &#125;
              int leftH = _Height(root-&gt;_left);
              int rightH = _Height(root-&gt;_right);
              if (leftH+rightH &gt; distance)
              &#123;
                     distance = leftH + rightH;
              &#125;
              return leftH &gt; rightH ? leftH+1 : rightH+1;
</code></pre>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><pre><code>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
class Solution &#123;
    private TreeNode pre = null;
    private int[] ret;
    private int retCount = 0;
    private int maxCount = 0;
    private int currCount = 0;

public int[] findMode(TreeNode root) &#123;
    inOrder(root);
    pre = null;
    ret = new int[retCount];
    retCount = 0;
    currCount = 0;
    inOrder(root);
    return ret;
&#125;

private void inOrder(TreeNode root) &#123;
    if (root == null)
        return;
    inOrder(root.left);
    if (pre != null &amp;&amp; pre.val == root.val)
        currCount++;
    else
        currCount = 1;
    if (currCount &gt; maxCount) &#123;
        maxCount = currCount;
        retCount = 1;
    &#125;
    else if (currCount == maxCount) &#123;
        if (ret != null)
            ret[retCount] = root.val;
        retCount++;
    &#125;
    pre = root;
    inOrder(root.right);
&#125;
&#125;
</code></pre>
<h2 id="还原一棵二叉树"><a href="#还原一棵二叉树" class="headerlink" title="还原一棵二叉树"></a>还原一棵二叉树</h2><pre><code>根据前序遍历和中序遍历的结果还原一棵二叉树
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

前序遍历的第一个节点是根节点，只要找到根节点在中序遍历中的位置，在根节点之前被访
问的节点都位于左子树，在根节点之后被访问的节点都位于右子树，由此可知左子树和右子树分别有多少个节点。
不要看这个函数的参数很多，只是为了控制数组索引而已，本质上该算法也就是一个前序遍历。
class Solution &#123;
    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        if (preorder == null || preorder.length == 0) &#123;
            return null;
        &#125;
        Map&lt;Integer, Integer&gt; indexMap = new HashMap&lt;Integer, Integer&gt;(); // 存储位置
        int length = preorder.length;
        for (int i = 0; i &lt; length; i++) &#123;
            indexMap.put(inorder[i], i);
        &#125;
        TreeNode root = buildTree(preorder, 0, length - 1, inorder, 0, length - 1, indexMap);
        return root;
    &#125;

public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd, int[] inorder, int inorderStart, int inorderEnd, Map&lt;Integer, Integer&gt; indexMap) &#123;
    if (preorderStart &gt; preorderEnd) &#123;
        return null;
    &#125;
    int rootVal = preorder[preorderStart];
    TreeNode root = new TreeNode(rootVal);
    if (preorderStart == preorderEnd) &#123;
        return root;
    &#125; else &#123;
        int rootIndex = indexMap.get(rootVal);
        int leftNodes = rootIndex - inorderStart, rightNodes = inorderEnd - rootIndex;
        TreeNode leftSubtree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);
        TreeNode rightSubtree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);
        root.left = leftSubtree;
        root.right = rightSubtree;
        return root;
    &#125;
&#125;
&#125;
</code></pre>
<h2 id="二叉搜索树序列"><a href="#二叉搜索树序列" class="headerlink" title="二叉搜索树序列"></a>二叉搜索树序列</h2><pre><code>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉搜索树，输出所有可能生成此树的数组。
给定如下二叉树

        2
       / \
      1   3
返回：

[
   [2,1,3],
   [2,3,1]
]
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;vector&lt;int&gt;&gt; BSTSequences(TreeNode* root) &#123;
    
    if(root == nullptr) return &#123;&#123;&#125;&#125;;

    // queue 数据结构 并不是一个好的选项 
    // queue&lt;TreeNode*&gt; q;  // q 用于保存 前后顺序不影响最终BST结果的 节点
    deque&lt;TreeNode*&gt; q;
    vector&lt;int&gt; path;
    q.push_back(root);

    dfs(q, path);
    return res;
&#125;

void dfs(deque&lt;TreeNode*&gt;&amp; q, vector&lt;int&gt;&amp; path)&#123;
    // cout &lt;&lt; &quot;size of path:&quot; &lt;&lt; path.size() &lt;&lt;endl;
    if(q.empty()) &#123;
        res.push_back(path);
        return;
    &#125;

    int size = q.size();
    cout &lt;&lt; &quot;***&quot; &lt;&lt; q.size() &lt;&lt; endl;
    for(int i = 0; i &lt; size; i++)&#123;
        auto curr = q.front();
        q.pop_front();

        path.push_back(curr-&gt;val);
        if(curr &amp;&amp; curr-&gt;left) q.push_back(curr-&gt;left);
        if(curr &amp;&amp; curr-&gt;right) q.push_back(curr-&gt;right);
        
        dfs(q, path);

        // 回溯要保证 状态还原
        if(curr &amp;&amp; curr-&gt;left) q.pop_back();
        if(curr &amp;&amp; curr-&gt;right) q.pop_back();
        q.push_back(curr);
        
        path.pop_back();
    &#125;
&#125;
&#125;;
</code></pre>
<h2 id="二叉搜索树总结"><a href="#二叉搜索树总结" class="headerlink" title="二叉搜索树总结"></a>二叉搜索树总结</h2><pre><code>void BST(TreeNode root,int target) &#123;
    if(root.val == target) 
        //找到目标，做点什么
    if(root.val &lt; target) 
        BST(root.right, target);
    if(root.val &gt; target) 
        BST(root.left, target);
&#125;
</code></pre>
<h2 id="在BST中插入一个元素，在BST删除一个元素"><a href="#在BST中插入一个元素，在BST删除一个元素" class="headerlink" title="在BST中插入一个元素，在BST删除一个元素"></a>在BST中插入一个元素，在BST删除一个元素</h2><h2 id="快速计算完全二叉树的节点"><a href="#快速计算完全二叉树的节点" class="headerlink" title="快速计算完全二叉树的节点"></a>快速计算完全二叉树的节点</h2><h2 id="单调栈、单调队列的作用"><a href="#单调栈、单调队列的作用" class="headerlink" title="单调栈、单调队列的作用"></a>单调栈、单调队列的作用</h2><h2 id="双指针的使用技巧"><a href="#双指针的使用技巧" class="headerlink" title="双指针的使用技巧"></a>双指针的使用技巧</h2><pre><code>快慢指针：判断是否有环、环的起始位置、链表的中心点、链表的倒数第k的元素、去除有序数组的重复元素
左右指针：二分查找、翻转数组、
滑动窗口
</code></pre>
<h2 id="位运算相关"><a href="#位运算相关" class="headerlink" title="位运算相关"></a>位运算相关</h2><p>前缀和<br>字符串乘法<br>贪心：跳跃游戏<br>k个一组翻转链表<br>深度优先<br>1、全排列问题<br>2、一个环由个圈组成，把自然数1，2，…，N分别放在每一个圆内，数字的在两个相邻圈之和应该是一个素数。 注意：第一圈数应始终为1。<br>3、油田问题<br>4、棋盘问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift143%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift143%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:21" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:21+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><pre><code>本题的难点在于如何处理数组，一个是开辟另一个数组进行处理，另一个是多次旋转数组实现
方法 1：暴力
最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。
public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        int temp, previous;
        for (int i = 0; i &lt; k; i++) &#123;
            previous = nums[nums.length - 1];
            for (int j = 0; j &lt; nums.length; j++) &#123;
                temp = nums[j];
                nums[j] = previous;
                previous = temp;
            &#125;
        &#125;
    &#125;
&#125;
方法 2：使用额外的数组
public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        int[] a = new int[nums.length];
        for (int i = 0; i &lt; nums.length; i++) &#123;
            a[(i + k) % nums.length] = nums[i];
        &#125;
        for (int i = 0; i &lt; nums.length; i++) &#123;
            nums[i] = a[i];
        &#125;
    &#125;
&#125;
方法 3：使用环状替换
public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        k = k % nums.length;
        int count = 0;
        for (int start = 0; count &lt; nums.length; start++) &#123;
            int current = start;
            int prev = nums[start];
            do &#123;
                int next = (current + k) % nums.length;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
                count++;
            &#125; while (start != current);
        &#125;
    &#125;
&#125;
方法 4：使用反转
原始数组                  : 1 2 3 4 5 6 7
反转所有数字后             : 7 6 5 4 3 2 1
反转前 k 个数字后          : 5 6 7 4 3 2 1
反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果

public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    &#125;
    public void reverse(int[] nums, int start, int end) &#123;
        while (start &lt; end) &#123;
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h2><pre><code>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。
列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。
输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。

public class NestedIterator implements Iterator&lt;Integer&gt; &#123;
Queue&lt;Integer&gt; res = new LinkedList&lt;&gt;();

public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;
    for(NestedInteger temp : nestedList)
        DFS(temp);
&#125;

@Override
public Integer next() &#123;
    return res.poll();
&#125;

@Override
public boolean hasNext() &#123;
    if(res.isEmpty())
        return false;
    return true;
    
&#125;
public void DFS(NestedInteger Node)&#123;
    /* 深度遍历 */
    if(Node.isInteger())
        res.offer(Node.getInteger());
    for(NestedInteger temp :Node.getList())
        DFS(temp);
&#125;
&#125;
</code></pre>
<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><pre><code>本题的难点在入如何交换数据，采用i，j双指针，直到都不为奇偶才交换
public int[] exchange(int[] nums) &#123;
       if(nums.length == 0) return nums;
       int i = 0,j = nums.length-1;
       while(i != j)&#123;
           while(nums[i] %2 != 0 &amp;&amp; i&lt;j )&#123;
               i++;
           &#125;
           while(nums[j] %2 == 0 &amp;&amp; i&lt;j )&#123;
               j--;
           &#125;
           if(i&lt;j)&#123;
               int temp = nums[i];
               nums[i] = nums[j];
               nums[j] = temp;
           &#125;
       &#125;
       return nums;
   &#125;
</code></pre>
<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><pre><code>   哈希表统计法，用 HashMap 统计各数字的数量
   数组排序法：由于众数的数量超过数组长度一半，
   因此 数组中点的元素 一定为众数
   摩尔投票法：核心理念为 “正负抵消” 
   当 n=x ： 抵消的所有数字中，有一半是众数    
   n不等x ： 抵消的所有数字中，少于或等于一半是众数 x
   利用此特性，每轮假设都可以 缩小剩余数组区间 。当遍历完成时，最后一轮假
   设的数字即为众数（由于众数超过一半，最后一轮的票数和必为正数）

   public int majorityElement(int[] nums) &#123;
       int x = 0, votes = 0;
       for(int num : nums)&#123;
           if(votes == 0) x = num;
           votes += num == x ? 1 : -1;
       &#125;
       return x;
   &#125;
</code></pre>
<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><pre><code>    这种最适合动态规划了，慢慢的变化，将前面的结构给到nums[i]
       输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
   class Solution &#123;
       public int maxSubArray(int[] nums) &#123;
           int res = nums[0];
           for(int i = 1; i &lt; nums.length; i++) &#123;
               nums[i] += Math.max(nums[i - 1], 0);
               res = Math.max(res, nums[i]);
           &#125;
           return res;
       &#125;
   &#125;
</code></pre>
<h2 id="1～n整数中1出现的次数"><a href="#1～n整数中1出现的次数" class="headerlink" title="1～n整数中1出现的次数"></a>1～n整数中1出现的次数</h2><pre><code>从个位到最高位的变量递推公式为
# 当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出
# 将 cur 加入 low ，组成下轮 low
# 下轮 cur 是本轮 high 的最低位
# 将本轮 high 最低位删除，得到下轮 high
# 位因子每轮 × 10
   class Solution &#123;
       public int countDigitOne(int n) &#123;
           int digit = 1, res = 0;
           int high = n / 10, cur = n % 10, low = 0;
           while(high != 0 || cur != 0) &#123;
               if(cur == 0) res += high * digit;
               else if(cur == 1) res += high * digit + low + 1;
               else res += (high + 1) * digit;
               low += cur * digit;
               cur = high % 10;
               high /= 10;
               digit *= 10;
           &#125;
           return res;
       &#125;
   &#125;
</code></pre>
<h2 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h2><pre><code>   数字以0123456789101112131415…的格式序列化到一个字符序列中
   迭代 + 求整 / 求余
       count=9×start×digit，num = start + (n - 1)

       class Solution &#123;
       public int findNthDigit(int n) &#123;
           int digit = 1;
           long start = 1;
           long count = 9;
           while (n &gt; count) &#123; // 1.
               n -= count;
               digit += 1;
               start *= 10;
               count = digit * start * 9;
           &#125;
           long num = start + (n - 1) / digit; // 2.
           return Long.toString(num).charAt((n - 1) % digit) - &#39;0&#39;; // 3.
       &#125;
   &#125;
</code></pre>
<h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><pre><code>        双指针法，分别指向数组的两端，如果两个数的和大于target则j--如果小于target则i++，直至相等 
class Solution &#123;
    public int[] twoSum(int[] nums, int target) &#123;
        int i = 0, j = nums.length - 1;
        while(i &lt; j) &#123;
            int s = nums[i] + nums[j];
            if(s &lt; target) i++;
            else if(s &gt; target) j--;
            else return new int[] &#123; nums[i], nums[j] &#125;;
        &#125;
        return new int[0];
    &#125;
&#125;
</code></pre>
<h2 id="给定两个数组，编写一个函数来计算它们的交集。"><a href="#给定两个数组，编写一个函数来计算它们的交集。" class="headerlink" title="给定两个数组，编写一个函数来计算它们的交集。"></a>给定两个数组，编写一个函数来计算它们的交集。</h2><pre><code>方法一：哈希表
首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。
为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。
class Solution &#123;
    public int[] intersect(int[] nums1, int[] nums2) &#123;
        if (nums1.length &gt; nums2.length) &#123;
            return intersect(nums2, nums1);
        &#125;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for (int num : nums1) &#123;
            int count = map.getOrDefault(num, 0) + 1;
            map.put(num, count);
        &#125;
        int[] intersection = new int[nums1.length];
        int index = 0;
        for (int num : nums2) &#123;
            int count = map.getOrDefault(num, 0);
            if (count &gt; 0) &#123;
                intersection[index++] = num;
                count--;
                if (count &gt; 0) &#123;
                    map.put(num, count);
                &#125; else &#123;
                    map.remove(num);
                &#125;
            &#125;
        &#125;
        return Arrays.copyOfRange(intersection, 0, index);
    &#125;
&#125;
方法二：排序
如果两个数组是有序的，则可以便捷地计算两个数组的交集。
class Solution &#123;
    public int[] intersect(int[] nums1, int[] nums2) &#123;
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int length1 = nums1.length, length2 = nums2.length;
        int[] intersection = new int[Math.min(length1, length2)];
        int index1 = 0, index2 = 0, index = 0;
        while (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;
            if (nums1[index1] &lt; nums2[index2]) &#123;
                index1++;
            &#125; else if (nums1[index1] &gt; nums2[index2]) &#123;
                index2++;
            &#125; else &#123;
                intersection[index] = nums1[index1];
                index1++;
                index2++;
                index++;
            &#125;
        &#125;
        return Arrays.copyOfRange(intersection, 0, index);
    &#125;
&#125;
</code></pre>
<h2 id="给定一个未排序的数组，判断这个数组中是否存在长度为-3-的递增子序列。"><a href="#给定一个未排序的数组，判断这个数组中是否存在长度为-3-的递增子序列。" class="headerlink" title="给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。"></a>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</h2><pre><code>class Solution &#123;
public:
    bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;
        int first = INT_MAX, sec = INT_MAX;     
        for(int n : nums)                       //
        &#123;
            if(n &lt;= first)  first = n;          
            else
            &#123;
                if(n &lt;= sec )   sec = n;        
                else   return true;
            &#125;
        &#125;
        return false;

    &#125;
&#125;;
</code></pre>
<h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><pre><code>是一种后缀表达式，所谓后缀就是指算符写在后面。
平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
class Solution &#123;
    //纯数组模拟栈实现(推荐)   3 ms    36 MB
    public static int evalRPN(String[] tokens) &#123;
        int[] numStack = new int[tokens.length / 2 + 1];
        int index = 0;
        for (String s : tokens) &#123;
            switch (s) &#123;
            case &quot;+&quot;:
                numStack[index - 2] += numStack[--index];
                break;
            case &quot;-&quot;:
                numStack[index - 2] -= numStack[--index];
                break;
            case &quot;*&quot;:
                numStack[index - 2] *= numStack[--index];
                break;
            case &quot;/&quot;:
                numStack[index - 2] /= numStack[--index];
                break;
            default:
                // numStack[index++] = Integer.valueOf(s);
                //valueOf改为parseInt，减少自动拆箱装箱操作
                numStack[index++] = Integer.parseInt(s);
                break;
            &#125;
        &#125;
        return numStack[0];
    &#125;
&#125;
class Solution &#123;
    // 栈实现   8 ms    36.7 MB    
    public static int evalRPN(String[] tokens) &#123;
        Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;();
        Integer op1, op2;
        for (String s : tokens) &#123;
            switch (s) &#123;
            case &quot;+&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 + op2);
                break;
            case &quot;-&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 - op2);
                break;
            case &quot;*&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 * op2);
                break;
            case &quot;/&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 / op2);
                break;
            default:
                numStack.push(Integer.valueOf(s));
                break;
            &#125;
        &#125;
        return numStack.pop();
    &#125;
&#125;
</code></pre>
<h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h2><pre><code>输入: [1,2,3,4]
输出: [24,12,8,6]
方法一：左右乘积列表
我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。
class Solution &#123;
    public int[] productExceptSelf(int[] nums) &#123;
        int length = nums.length;

    // L 和 R 分别表示左右两侧的乘积列表
    int[] L = new int[length];
    int[] R = new int[length];

    int[] answer = new int[length];

    // L[i] 为索引 i 左侧所有元素的乘积
    // 对于索引为 &#39;0&#39; 的元素，因为左侧没有元素，所以 L[0] = 1
    L[0] = 1;
    for (int i = 1; i &lt; length; i++) &#123;
        L[i] = nums[i - 1] * L[i - 1];
    &#125;

    // R[i] 为索引 i 右侧所有元素的乘积
    // 对于索引为 &#39;length-1&#39; 的元素，因为右侧没有元素，所以 R[length-1] = 1
    R[length - 1] = 1;
    for (int i = length - 2; i &gt;= 0; i--) &#123;
        R[i] = nums[i + 1] * R[i + 1];
    &#125;

    // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积
    for (int i = 0; i &lt; length; i++) &#123;
        answer[i] = L[i] * R[i];
    &#125;

    return answer;
&#125;
&#125;
方法二：空间复杂度 
第一个循环应该是表示下三角中自上而下对每一行做连乘，而第二个循环是对上三角自下而上的连乘
class Solution &#123;
    public int[] productExceptSelf(int[] nums) &#123;
        int length = nums.length;
        int[] answer = new int[length];

    // answer[i] 表示索引 i 左侧所有元素的乘积
    // 因为索引为 &#39;0&#39; 的元素左侧没有元素， 所以 answer[0] = 1
    answer[0] = 1;
    for (int i = 1; i &lt; length; i++) &#123;
        answer[i] = nums[i - 1] * answer[i - 1];
    &#125;

    // R 为右侧所有元素的乘积
    // 刚开始右边没有元素，所以 R = 1
    int R = 1;
    for (int i = length - 1; i &gt;= 0; i--) &#123;
        // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
        answer[i] = answer[i] * R;
        // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
        R *= nums[i];
    &#125;
    return answer;
&#125;
&#125;
</code></pre>
<h2 id="和为s的连续正数序列-（滑动窗口）"><a href="#和为s的连续正数序列-（滑动窗口）" class="headerlink" title="和为s的连续正数序列  （滑动窗口）"></a>和为s的连续正数序列  （滑动窗口）</h2><pre><code>    窗口的左边界和右边界永远只能向右移动
    当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动
    当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
什么是滑动窗口
滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。
窗口的左边界和右边界永远只能向右移动
第一个问题，窗口何时扩大，何时缩小？
第二个问题，滑动窗口能找到全部的解吗？
当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动
当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动
public int[][] findContinuousSequence(int target) &#123;
    int i = 1; // 滑动窗口的左边界
    int j = 1; // 滑动窗口的右边界
    int sum = 0; // 滑动窗口中数字的和
    List&lt;int[]&gt; res = new ArrayList&lt;&gt;();

while (i &lt;= target / 2) &#123;
    if (sum &lt; target) &#123;
        // 右边界向右移动
        sum += j;
        j++;
    &#125; else if (sum &gt; target) &#123;
        // 左边界向右移动
        sum -= i;
        i++;
    &#125; else &#123;
        // 记录结果
        int[] arr = new int[j-i];
        for (int k = i; k &lt; j; k++) &#123;
            arr[k-i] = k;
        &#125;
        res.add(arr);
        // 左边界向右移动
        sum -= i;
        i++;
    &#125;
&#125;

return res.toArray(new int[res.size()][]);
</code></pre>
<p>}</p>
<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><pre><code>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
单调队列
我们先看什么是单调的双向队列，双向队列大家都知道，既能在头部进行插入、删除操作，也能在尾部进行插入删除操作，而所谓的单调，就是我们人为规定从队列的头部到尾部，所存储的元素是依次递减（或依次递增）的。如下所示：

也就是说，我们维护一个单调的双向队列，窗口在每次滑动的时候，我就从队列头部取当前窗口中的最大值，每次窗口新进来一个元素的时候，我就将它与队列中的元素进行大小比较：

如果刚刚进来的元素比队列的尾部元素大，那么先将队列尾部的元素弹出，然后把刚刚进来的元素添到队列的尾部；
如果刚刚进来的元素比队列的尾部元素小，那么把刚刚进来的元素直接添到队列的尾部即可。

class Solution &#123;
    public int[] maxSlidingWindow(int[] nums, int k) &#123;
        if (nums == null || k &lt; 1 || nums.length &lt; k) &#123;
            return new int[0];
        &#125;

    int index = 0;
    int[] res = new int[nums.length - k + 1];
    LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();

    for (int i = 0; i &lt; nums.length; i++) &#123;
        // 在队列不为空的情况下，如果队列尾部的元素要比当前的元素小，或等于当前的元素
        // 那么为了维持从大到小的原则，我必须让尾部元素弹出
        while (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;= nums[i]) &#123;
            queue.pollLast();
        &#125;
        // 不走 while 的话，说明我们正常在队列尾部添加元素
        queue.addLast(i);
        // 如果滑动窗口已经略过了队列中头部的元素，则将头部元素弹出
        if (queue.peekFirst() == (i - k)) &#123;
            queue.pollFirst();
        &#125;
        // 看看窗口有没有形成，只有形成了大小为 k 的窗口，我才能收集窗口内的最大值
        if (i &gt;= (k - 1)) &#123;
            res[index++] = nums[queue.peekFirst()];
        &#125;
    &#125;
    return res;
&#125;
</code></pre>
<p>}</p>
<h2 id="将数组中所有-0-移动到数组末尾。"><a href="#将数组中所有-0-移动到数组末尾。" class="headerlink" title="将数组中所有 0 移动到数组末尾。"></a>将数组中所有 0 移动到数组末尾。</h2><pre><code>方法一：空间局部优化
class Solution &#123;
    public void moveZeroes(int[] nums) &#123;
        if(nums==null) &#123;
            return;
        &#125;
        //第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]
        int j = 0;
        for(int i=0;i&lt;nums.length;++i) &#123;
            if(nums[i]!=0) &#123;
                nums[j++] = nums[i];
            &#125;
        &#125;
        //非0元素统计完了，剩下的都是0了
        //所以第二次遍历把末尾的元素都赋为0即可
        for(int i=j;i&lt;nums.length;++i) &#123;
            nums[i] = 0;
        &#125;
    &#125;
&#125;    
方法二：空间最优，操作局部优化（双指针）
class Solution &#123;
    public void moveZeroes(int[] nums) &#123;
        if(nums==null) &#123;
            return;
        &#125;
        //两个指针i和j
        int j = 0;
        for(int i=0;i&lt;nums.length;i++) &#123;
            //当前元素!=0，就把其交换到左边，等于0的交换到右边
            if(nums[i]!=0) &#123;
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j++] = tmp;
            &#125;
        &#125;
    &#125;
&#125;    
</code></pre>
<h2 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h2><pre><code>方法一： 暴力 【通过】
暴力算法简单的来说就是把每个数放在一个 ”帽子“ 里面，每次从 ”帽子“ 里面随机摸一个数出来
class Solution &#123;
    private int[] array;
    private int[] original;

private Random rand = new Random();

private List&lt;Integer&gt; getArrayCopy() &#123;
    List&lt;Integer&gt; asList = new ArrayList&lt;Integer&gt;();
    for (int i = 0; i &lt; array.length; i++) &#123;
        asList.add(array[i]);
    &#125;
    return asList;
&#125;

public Solution(int[] nums) &#123;
    array = nums;
    original = nums.clone();
&#125;

public int[] reset() &#123;
    array = original;
    original = original.clone();
    return array;
&#125;

public int[] shuffle() &#123;
    List&lt;Integer&gt; aux = getArrayCopy();

    for (int i = 0; i &lt; array.length; i++) &#123;
        int removeIdx = rand.nextInt(aux.size());
        array[i] = aux.get(removeIdx);
        aux.remove(removeIdx);
    &#125;

    return array;
&#125;
</code></pre>
<p>}<br>    方法二： Fisher-Yates 洗牌算法 【通过】<br>    Fisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换 - 这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。</p>
<pre><code>class Solution &#123;
    private int[] array;
    private int[] original;

Random rand = new Random();

private int randRange(int min, int max) &#123;
    return rand.nextInt(max - min) + min;
&#125;

private void swapAt(int i, int j) &#123;
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
&#125;

public Solution(int[] nums) &#123;
    array = nums;
    original = nums.clone();
&#125;

public int[] reset() &#123;
    array = original;
    original = original.clone();
    return original;
&#125;

public int[] shuffle() &#123;
    for (int i = 0; i &lt; array.length; i++) &#123;
        swapAt(i, randRange(i, array.length));
    &#125;
    return array;
&#125;
&#125;
</code></pre>
<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><pre><code>public class Solution &#123;

public int reversePairs(int[] nums) &#123;
    int len = nums.length;

    if (len &lt; 2) &#123;
        return 0;
    &#125;

    int[] copy = new int[len];
    for (int i = 0; i &lt; len; i++) &#123;
        copy[i] = nums[i];
    &#125;

    int[] temp = new int[len];
    return reversePairs(copy, 0, len - 1, temp);
&#125;

/**
 * nums[left..right] 计算逆序对个数并且排序
 *
 * @param nums
 * @param left
 * @param right
 * @param temp
 * @return
 */
private int reversePairs(int[] nums, int left, int right, int[] temp) &#123;
    if (left == right) &#123;
        return 0;
    &#125;

    int mid = left + (right - left) / 2;
    int leftPairs = reversePairs(nums, left, mid, temp);
    int rightPairs = reversePairs(nums, mid + 1, right, temp);

    if (nums[mid] &lt;= nums[mid + 1]) &#123;
        return leftPairs + rightPairs;
    &#125;

    int crossPairs = mergeAndCount(nums, left, mid, right, temp);
    return leftPairs + rightPairs + crossPairs;
&#125;

/**
 * nums[left..mid] 有序，nums[mid + 1..right] 有序
 *
 * @param nums
 * @param left
 * @param mid
 * @param right
 * @param temp
 * @return
 */
private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) &#123;
    for (int i = left; i &lt;= right; i++) &#123;
        temp[i] = nums[i];
    &#125;

    int i = left;
    int j = mid + 1;

    int count = 0;
    for (int k = left; k &lt;= right; k++) &#123;

        if (i == mid + 1) &#123;
            nums[k] = temp[j];
            j++;
        &#125; else if (j == right + 1) &#123;
            nums[k] = temp[i];
            i++;
        &#125; else if (temp[i] &lt;= temp[j]) &#123;
            nums[k] = temp[i];
            i++;
        &#125; else &#123;
            nums[k] = temp[j];
            j++;
            count += (mid - i + 1);
        &#125;
    &#125;
    return count;
&#125;
&#125;
</code></pre>
<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><pre><code>    用快排最最最高效解决 TopK 问题：
    大根堆(前 K 小) / 小根堆（前 K 大),Java中有现成的 PriorityQueue，实现起来最简单：
    二叉搜索树也可以 解决 TopK 问题哦
    数据范围有限时直接计数排序就行了：
class Solution &#123;
    public int[] getLeastNumbers(int[] arr, int k) &#123;
        if (k == 0 || arr.length == 0) &#123;
            return new int[0];
        &#125;
        // 最后一个参数表示我们要找的是下标为k-1的数
        return quickSearch(arr, 0, arr.length - 1, k - 1);
    &#125;

private int[] quickSearch(int[] nums, int lo, int hi, int k) &#123;
    // 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；
    int j = partition(nums, lo, hi);
    if (j == k) &#123;
        return Arrays.copyOf(nums, j + 1);
    &#125;
    // 否则根据下标j与k的大小关系来决定继续切分左段还是右段。
    return j &gt; k? quickSearch(nums, lo, j - 1, k): quickSearch(nums, j + 1, hi, k);
&#125;

// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。
private int partition(int[] nums, int lo, int hi) &#123;
    int v = nums[lo];
    int i = lo, j = hi + 1;
    while (true) &#123;
        while (++i &lt;= hi &amp;&amp; nums[i] &lt; v);
        while (--j &gt;= lo &amp;&amp; nums[j] &gt; v);
        if (i &gt;= j) &#123;
            break;
        &#125;
        int t = nums[j];
        nums[j] = nums[i];
        nums[i] = t;
    &#125;
    nums[lo] = nums[j];
    nums[j] = v;
    return j;
&#125;
&#125;
我们用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。
// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：
// 1. 若目前堆的大小小于K，将当前数字放入堆中。
// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；
//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。
class Solution &#123;
    public int[] getLeastNumbers(int[] arr, int k) &#123;
        if (k == 0 || arr.length == 0) &#123;
            return new int[0];
        &#125;
        // 默认是小根堆，实现大根堆需要重写一下比较器。
        Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);
        for (int num: arr) &#123;
            if (pq.size() &lt; k) &#123;
                pq.offer(num);
            &#125; else if (num &lt; pq.peek()) &#123;
                pq.poll();
                pq.offer(num);
            &#125;
        &#125;
        
        // 返回堆中的元素
        int[] res = new int[pq.size()];
        int idx = 0;
        for(int num: pq) &#123;
            res[idx++] = num;
        &#125;
        return res;
    &#125;
&#125;
二叉搜索树也可以 O(NlogK)解决 TopK 问题哦
与前两种方法相比，BST 有一个好处是求得的前K大的数字是有序的。
class Solution &#123;
public int[] getLeastNumbers(int[] arr, int k) &#123;
    if (k == 0 || arr.length == 0) &#123;
        return new int[0];
    &#125;
    // TreeMap的key是数字, value是该数字的个数。
    // cnt表示当前map总共存了多少个数字。
    TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();
    int cnt = 0;
    for (int num: arr) &#123;
        // 1. 遍历数组，若当前map中的数字个数小于k，则map中当前数字对应个数+1
        if (cnt &lt; k) &#123;
            map.put(num, map.getOrDefault(num, 0) + 1);
            cnt++;
            continue;
        &#125; 
        // 2. 否则，取出map中最大的Key（即最大的数字), 判断当前数字与map中最大数字的大小关系：
        //    若当前数字比map中最大的数字还大，就直接忽略；
        //    若当前数字比map中最大的数字小，则将当前数字加入map中，并将map中的最大数字的个数-1。
        Map.Entry&lt;Integer, Integer&gt; entry = map.lastEntry();
        if (entry.getKey() &gt; num) &#123;
            map.put(num, map.getOrDefault(num, 0) + 1);
            if (entry.getValue() == 1) &#123;
                map.pollLastEntry();
            &#125; else &#123;
                map.put(entry.getKey(), entry.getValue() - 1);
            &#125;
        &#125;
    
&#125;

    // 最后返回map中的元素
    int[] res = new int[k];
    int idx = 0;
    for (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;
        int freq = entry.getValue();
        while (freq-- &gt; 0) &#123;
            res[idx++] = entry.getKey();
        &#125;
    &#125;
    return res;
&#125;
&#125;
四、数据范围有限时直接计数排序就行了：
class Solution &#123;
    public int[] getLeastNumbers(int[] arr, int k) &#123;
        if (k == 0 || arr.length == 0) &#123;
            return new int[0];
        &#125;
        // 统计每个数字出现的次数
        int[] counter = new int[10001];
        for (int num: arr) &#123;
            counter[num]++;
        &#125;
        // 根据counter数组从头找出k个数作为返回结果
        int[] res = new int[k];
        int idx = 0;
        for (int num = 0; num &lt; counter.length; num++) &#123;
            while (counter[num]-- &gt; 0 &amp;&amp; idx &lt; k) &#123;
                res[idx++] = num;
            &#125;
            if (idx == k) &#123;
                break;
            &#125;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><pre><code>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
    输入: [10,2]
    输出: &quot;102&quot;
    此题求拼接起来的 “最小数字” ，本质上是一个排序问题。
class Solution &#123;
    public String minNumber(int[] nums) &#123;
        String[] strs = new String[nums.length];
        for(int i = 0; i &lt; nums.length; i++)
            strs[i] = String.valueOf(nums[i]);
        fastSort(strs, 0, strs.length - 1);
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    &#125;
    void fastSort(String[] strs, int l, int r) &#123;
        if(l &gt;= r) return;
        int i = l, j = r;
        String tmp = strs[i];
        while(i &lt; j) &#123;
            while((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= 0 &amp;&amp; i &lt; j) j--;
            while((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= 0 &amp;&amp; i &lt; j) i++;
            tmp = strs[i];
            strs[i] = strs[j];
            strs[j] = tmp;
        &#125;
        strs[i] = strs[l];
        strs[l] = tmp;
        fastSort(strs, l, i - 1);
        fastSort(strs, i + 1, r);
    &#125;
&#125;
方法二：内置函数
public String minNumber(int[] nums) &#123;
        String[] strs = new String[nums.length];
        for(int i = 0; i &lt; nums.length; i++) 
            strs[i] = String.valueOf(nums[i]);
        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    &#125;
</code></pre>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><pre><code>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
    由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。

从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能

class Solution &#123;
    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;
            return false;
        &#125;
        int rows = matrix.length, columns = matrix[0].length;
        int row = 0, column = columns - 1;
        while (row &lt; rows &amp;&amp; column &gt;= 0) &#123;
            int num = matrix[row][column];
            if (num == target) &#123;
                return true;
            &#125; else if (num &gt; target) &#123;
                column--;
            &#125; else &#123;
                row++;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><pre><code>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],
[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],
[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]
    算法原理：
    深度优先搜索
class Solution &#123;
    public boolean exist(char[][] board, String word) &#123;
        char[] words = word.toCharArray();
        for(int i = 0; i &lt; board.length; i++) &#123;
            for(int j = 0; j &lt; board[0].length; j++) &#123;
                if(dfs(board, words, i, j, 0)) return true;
            &#125;
        &#125;
        return false;
    &#125;
    boolean dfs(char[][] board, char[] word, int i, int j, int k) &#123;
        if(i &gt;= board.length || i &lt; 0 || j &gt;= board[0].length || j &lt; 0 || board[i][j] != word[k]) return false;
        if(k == word.length - 1) return true;
        char tmp = board[i][j];
        board[i][j] = &#39;/&#39;;
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = tmp;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><pre><code>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
    本文选择使用广度优先搜索的方法来讲解。
    public int movingCount(int m, int n, int k) &#123;
        boolean[][] visited = new boolean[m][n];
        return dfs(0, 0, m, n, k, visited);
    &#125;
    public int dfs(int i, int j, int m, int n, int k, boolean[][] visited) &#123;
        if(i &gt;= m || j &gt;= n || k &lt; getSum(i) + getSum(j) || visited[i][j]) &#123;
            return 0;
        &#125;
        visited[i][j] = true;
        return 1 + dfs(i + 1, j, m, n, k, visited) + dfs(i, j + 1, m, n, k, visited);
    &#125;

private int getSum(int a) &#123;
    int sum = a % 10;
    int tmp = a / 10;
    while(tmp &gt; 0) &#123;
        sum += tmp % 10;
        tmp /= 10;
    &#125;
    return sum;
&#125;
    
</code></pre>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><pre><code>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
可以模拟打印矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，则顺时针旋转，进入下一个方向。
判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素
表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。
如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数
量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。
 public int[] spiralOrder(int[][] matrix) &#123;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;
            return new int[0];
        &#125;
        int rows = matrix.length, columns = matrix[0].length;
        boolean[][] visited = new boolean[rows][columns];
        int total = rows * columns;
        int[] order = new int[total];
        int row = 0, column = 0;
        int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;
        int directionIndex = 0;
        for (int i = 0; i &lt; total; i++) &#123;
            order[i] = matrix[row][column];
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow &lt; 0 || nextRow &gt;= rows || nextColumn &lt; 0 || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123;
                directionIndex = (directionIndex + 1) % 4;
            &#125;
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        &#125;
        return order;
    &#125;
</code></pre>
<h2 id="给定一个-n-x-n-矩阵，其中每行和每列元素均按升序排序，找到矩阵中第-k-小的元素。"><a href="#给定一个-n-x-n-矩阵，其中每行和每列元素均按升序排序，找到矩阵中第-k-小的元素。" class="headerlink" title="给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。"></a>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。</h2><pre><code>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
最直接的做法是将这个二维数组另存为为一维数组，并对该一维数组进行排序。最后这个一维数组中的第 k个数即为答案。
class Solution &#123;
    public int kthSmallest(int[][] matrix, int k) &#123;
        int rows = matrix.length, columns = matrix[0].length;
        int[] sorted = new int[rows * columns];
        int index = 0;
        for (int[] row : matrix) &#123;
            for (int num : row) &#123;
                sorted[index++] = num;
            &#125;
        &#125;
        Arrays.sort(sorted);
        return sorted[k - 1];
    &#125;
&#125;
方法二：归并排序
这个矩阵的每一行均为一个有序数组。问题即转化为从这 n 个有序数组中找第 
k 大的数，可以想到利用归并排序的做法，归并到第 k 个数即可停止。

class Solution &#123;
    public int kthSmallest(int[][] matrix, int k) &#123;
        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;
            public int compare(int[] a, int[] b) &#123;
                return a[0] - b[0];
            &#125;
        &#125;);
        int n = matrix.length;
        for (int i = 0; i &lt; n; i++) &#123;
            pq.offer(new int[]&#123;matrix[i][0], i, 0&#125;);
        &#125;
        for (int i = 0; i &lt; k - 1; i++) &#123;
            int[] now = pq.poll();
            if (now[2] != n - 1) &#123;
                pq.offer(new int[]&#123;matrix[now[1]][now[2] + 1], now[1], now[2] + 1&#125;);
            &#125;
        &#125;
        return pq.poll()[0];
    &#125;
&#125;
方法三：二分查找
那么矩阵中不大于 mid 的数，肯定全部分布在矩阵的左上角。
class Solution &#123;
    public int kthSmallest(int[][] matrix, int k) &#123;
        int n = matrix.length;
        int left = matrix[0][0];
        int right = matrix[n - 1][n - 1];
        while (left &lt; right) &#123;
            int mid = left + ((right - left) &gt;&gt; 1);
            if (check(matrix, mid, k, n)) &#123;
                right = mid;
            &#125; else &#123;
                left = mid + 1;
            &#125;
        &#125;
        return left;
    &#125;

    public boolean check(int[][] matrix, int mid, int k, int n) &#123;
        int i = n - 1;
        int j = 0;
        int num = 0;
        while (i &gt;= 0 &amp;&amp; j &lt; n) &#123;
            if (matrix[i][j] &lt;= mid) &#123;
                num += i + 1;
                j++;
            &#125; else &#123;
                i--;
            &#125;
        &#125;
        return num &gt;= k;
    &#125;
&#125;

可以将矩阵看成若干层，首先打印最外层的元素，其次打印次外层的元素，直到打印最内层的元素。
定义4个顶点的坐标位置left、right、top、bottom
1.从左到右遍历上侧元素， 当到达右顶点时停止
2.从上到下遍历右侧元素，当到达下右顶点时停止
3.从右向左侧遍历
4.从下向上遍历
遍历完毕后，四个顶点位置进行内缩
left和top分别加一
right和bottom分别减一，然后再遍历，直到遍历完所有元素为止。
 public int[] spiralOrder(int[][] matrix) &#123;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;
            return new int[0];
        &#125;
        int rows = matrix.length, columns = matrix[0].length;
        int[] order = new int[rows * columns];
        int index = 0;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;
            for (int column = left; column &lt;= right; column++) &#123;
                order[index++] = matrix[top][column];
            &#125;
            for (int row = top + 1; row &lt;= bottom; row++) &#123;
                order[index++] = matrix[row][right];
            &#125;
            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;
                for (int column = right - 1; column &gt; left; column--) &#123;
                    order[index++] = matrix[bottom][column];
                &#125;
                for (int row = bottom; row &gt; top; row--) &#123;
                    order[index++] = matrix[row][left];
                &#125;
            &#125;
            left++;
            right--;
            top++;
            bottom--;
        &#125;
        return order;
    &#125;
</code></pre>
<h2 id="编写一个高效的算法来搜索-m-x-n-矩阵-matrix-中的一个目标值-target。"><a href="#编写一个高效的算法来搜索-m-x-n-矩阵-matrix-中的一个目标值-target。" class="headerlink" title="编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。"></a>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。</h2><pre><code>该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
方法一：暴力法
方法二：二分法搜索
class Solution &#123;
    private boolean binarySearch(int[][] matrix, int target, int start, boolean vertical) &#123;
        int lo = start;
        int hi = vertical ? matrix[0].length-1 : matrix.length-1;

    while (hi &gt;= lo) &#123;
        int mid = (lo + hi)/2;
        if (vertical) &#123; // searching a column
            if (matrix[start][mid] &lt; target) &#123;
                lo = mid + 1;
            &#125; else if (matrix[start][mid] &gt; target) &#123;
                hi = mid - 1;
            &#125; else &#123;
                return true;
            &#125;
        &#125; else &#123; // searching a row
            if (matrix[mid][start] &lt; target) &#123;
                lo = mid + 1;
            &#125; else if (matrix[mid][start] &gt; target) &#123;
                hi = mid - 1;
            &#125; else &#123;
                return true;
            &#125;
        &#125;
    &#125;

    return false;
&#125;

public boolean searchMatrix(int[][] matrix, int target) &#123;
    // an empty matrix obviously does not contain `target`
    if (matrix == null || matrix.length == 0) &#123;
        return false;
    &#125;

    // iterate over matrix diagonals
    int shorterDim = Math.min(matrix.length, matrix[0].length);
    for (int i = 0; i &lt; shorterDim; i++) &#123;
        boolean verticalFound = binarySearch(matrix, target, i, true);
        boolean horizontalFound = binarySearch(matrix, target, i, false);
        if (verticalFound || horizontalFound) &#123;
            return true;
        &#125;
    &#125;
    
    return false; 
&#125;
&#125;
方法三修剪矩阵
首先，我们初始化一个指向矩阵左下角的 
(row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 
(row，col) 为止，我们执行以下操作：如果当前指向的值大于目标值，则可以 “向上” 移动一行。 否则，如果当前指向的值小于目标值，则可以移动一列。不难理解为什么这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。 因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大。也可以对列进行非常类似的论证，因此这种搜索方式将始终在矩阵中找到目标（如果存在）。
class Solution &#123;
    public boolean searchMatrix(int[][] matrix, int target) &#123;
        // start our &quot;pointer&quot; in the bottom-left
        int row = matrix.length-1;
        int col = 0;

    while (row &gt;= 0 &amp;&amp; col &lt; matrix[0].length) &#123;
        if (matrix[row][col] &gt; target) &#123;
            row--;
        &#125; else if (matrix[row][col] &lt; target) &#123;
            col++;
        &#125; else &#123; // found it
            return true;
        &#125;
    &#125;

    return false;
&#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift127NSObject%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift127NSObject%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">NSObject数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:19" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:19+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="object-class"><a href="#object-class" class="headerlink" title="object_class"></a>object_class</h2><p>继承:objc_object<br>内部：<br>Class superClass; 父类<br>cache_t cache;  缓存<br>class_data_bits_t bits  数据</p>
<p>isa指针关系<br>实例对象其指针指向类对象<br>类对象其指针指向元类对象</p>
<p>cache_t<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/45d409e77806">https://www.jianshu.com/p/45d409e77806</a><br>用散列表(哈希表)来缓存曾经调用过的方法，可以提高方法的查找速度，底层结构如下：<br>用于快速查找方法执行函数<br>是可增量扩展的哈希表结构<br>是局部性原理的最佳应用<br>cache 本质是一个 Hash表。存储bucket_t<br>bucket_t存储<br>cache_key_t _key;//@selector()<br>IMP _imp;//函数地址<br>哈希查找：发现当发生碰撞的时候，索引会+1，查找下一个。<br>槽位如果不够，_mask 会变换，变为原来的2倍，并且扩展槽位的时候，会清空数组里原有的缓存内容<br>子类没有实现方法会调用父类的方法，会将父类方法加入到子类自己的cache 里。<br>为什么要创建新的新的buckets来替换原有的buckets并抹掉原有的buckets的方案，而不是在在原有buckets的基础上进行扩容？<br>减少对方法快速查找流程的影响：调用objc_msgSend时会触发方法快速查找，如果进行扩容需要做一些读写操作，对快速查找影响比较大。<br>对性能要求比较高：开辟新的buckets空间并抹掉原有buckets的消耗比在原有buckets上进行扩展更加高效<br>当扩容后，会把新mask设置为newCapacity长度减一，然后清空缓存。<br>所有散列表(哈希表)的原理都是一样的，都是通过一个函数，这个函数传入一个key，通过这个key算出一个索引，如果索引冲突了就加一或者减一，直至不冲突为止，不同的就是算法不一样。</p>
<p>struct class_rw_t {<br>    uint32_t flags;<br>    uint32_t version;</p>
<pre><code>const class_ro_t *ro;

method_array_t methods;
property_array_t properties; //属性，和变量的区别，属性是名称，变量是值
protocol_array_t protocols;

Class firstSubclass;
Class nextSiblingClass;
</code></pre>
<p>};<br>class_rw_t结构体内有一个指向class_ro_t结构体的指针。</p>
<p>细看两个结构体的成员变量会发现很多相同的地方，他们都存放着当前类的属性、实例变量、方法、协议等等。区别在于：class_ro_t存放的是编译期间就确定的；而class_rw_t是在runtime时才确定，它会先将class_ro_t的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说class_rw_t是class_ro_t的超集，当然实际访问类的方法、属性等也都是访问的class_rw_t中的内容</p>
<p>哈希碰撞<br>开放地址法<br>链地址法</p>
<p>struct method_t {<br>    SEL name; //函数名<br>    const char *types; //编码（返回值类型、参数类型）<br>    IMP imp;//指向函数的指针（函数地址）<br>};</p>
<p>instance对象的isa指向class对象<br>class对象的isa指向meta-class对象<br>meta-class对象的isa指向基类的meta-class对象</p>
<p>发消息的步骤<br>检查target是不是nil    ObjC的特性允许对一个nil对象发消息而不会崩溃<br>通过isa，<br>对象方法查找类对象（类对象及继承链上找方法）<br>方法缓存列表，hashMap的结构，查找速度快<br>方法缓存找不到就查找类对象的方法列表中遍历class_rw_t，从后向前的遍历<br>查找父类的类对象—-同上，直至nsobjcect<br>类方法查找元类对象（元类对象及继承链上找方法）<br>方法缓存列表，hashMap的结构，查找速度快<br>方法缓存找不到就查找元类对象的方法列表中遍历class_rw_t，从后向前的遍历</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift143%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift143%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:16" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:16+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><pre><code>栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。


public int[] reversePrint(ListNode head) &#123;
    Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;();
    ListNode temp = head;
    while (temp != null) &#123;
        stack.push(temp);
        temp = temp.next;
    &#125;
    int size = stack.size();
    int[] print = new int[size];
    for (int i = 0; i &lt; size; i++) &#123;
        print[i] = stack.pop().val;
    &#125;
    return print;
&#125;
</code></pre>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><pre><code>class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* a=nullptr;
        ListNode* b=head;
        while(b!=nullptr)&#123;
            ListNode* temp = b-&gt;next; // 拿到下一个
            b-&gt;next = a; // 将当前反转
            a=b; // 获取上一个指针
            b=temp; // 获取下一个指针
        &#125;
        return a;
    &#125;
&#125;;
递归
public ListNode reverseList(ListNode head) &#123;
    if (head == null || head.next == null) return head;
    ListNode p = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
&#125;
</code></pre>
<h2 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h2><pre><code>class Solution &#123;
    //双指针
    public ListNode deleteNode(ListNode head, int val) &#123;
        if(head.val == val)&#123;
            return head.next;
        &#125;
        ListNode cur = head;
        ListNode se = cur.next ;
        while(se != null)&#123;
            if(se.val == val)&#123;
                cur.next = se.next;
                se = null;
                break;
            &#125;
            cur = se;
            se = se.next; 
        &#125;
        return head;
        &#125;
    //单指针
    public ListNode deleteNode(ListNode head, int val) &#123;
        if(head.val == val)&#123;
            return head.next;
        &#125;
        ListNode cur = head;
        while(cur.next != null)&#123;
            if(cur.next.val == val)&#123;
                cur.next = cur.next.next;
                break;
            &#125;
            cur = cur.next;
        &#125;
        return head;
    &#125;
&#125;
</code></pre>
<h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><pre><code>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
双指针，前面的指针先走k步，然后两个指针一起走，知道走到最后，两个指针之间的位置就是 
     public ListNode getKthFromEnd(ListNode head, int k) &#123;
        ListNode former = head, latter = head;
        for(int i = 0; i &lt; k; i++)
            former = former.next;
        while(former != null) &#123;
            former = former.next;
            latter = latter.next;
        &#125;
        return latter;
    &#125;
</code></pre>
<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><pre><code>双指针遍历两个链表，进行比较，小的放入新的链表中，直到两个链表都遍历完毕
public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;
        ListNode dum = new ListNode(0), cur = dum;
        while(l1 != null &amp;&amp; l2 != null) &#123;
            if(l1.val &lt; l2.val) &#123;
                cur.next = l1;
                l1 = l1.next;
            &#125;
            else &#123;
                cur.next = l2;
                l2 = l2.next;
            &#125;
            cur = cur.next;
        &#125;
        cur.next = l1 != null ? l1 : l2;
        return dum.next;
    &#125;
</code></pre>
<h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><pre><code>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
大家的题解都是双指针双百解法。
我来说一个这题的实际应用：
求两个类最低一层的公共父类，就是两个树节点最低一层的公共祖先节点。
这里的树节点内容不是left和right，而是指向父节点的指针。
两个类都用.getSuperclass()方法生成直到Object的两个链表，
再调用这个题的方法就求出了第一个公共祖先。
我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。
这样，当它们相遇时，所指向的结点就是第一个公共结点。
public class Solution &#123;
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
        if(headA == null || headB == null) return null;
        ListNode a = headA, b = headB;
        int len1 = 0, len2 = 0, sum = 0;
        while(a != null &amp;&amp; ++len1 &gt; 0) a = a.next;
        while(b != null &amp;&amp; ++len2 &gt; 0) b = b.next;
        a = headA;
        b = headB;
        while (a != b)&#123;
            if(a.next == null) a = headB;
            else a = a.next;
            if(b.next == null) b = headA;
            else b = b.next;
            if(sum++ &gt; len1 + len2) return null;
        &#125;
        return a;
    &#125;
&#125;
</code></pre>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><pre><code>class Node &#123;
    int val;
    Node next;
    Node random;

    public Node(int val) &#123;
        this.val = val;
        this.next = null;
        this.random = null;
    &#125;
&#125;
public Node copyRandomList(Node head) &#123;
        HashMap&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); //创建HashMap集合
        Node cur=head;
        //复制结点值
        while(cur!=null)&#123;
            //存储put:&lt;key,value1&gt;
            map.put(cur,new Node(cur.val)); //顺序遍历，存储老结点和新结点(先存储新创建的结点值)
            cur=cur.next;
        &#125;
        //复制结点指向
        cur = head;
        while(cur!=null)&#123;
            //得到get:&lt;key&gt;.value2,3
            map.get(cur).next = map.get(cur.next); //新结点next指向同旧结点的next指向
            map.get(cur).random = map.get(cur.random); //新结点random指向同旧结点的random指向
            cur = cur.next;
        &#125;

        //返回复制的链表
        return map.get(head);


    &#125;
</code></pre>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><pre><code>getIndex
addHead
addLast
addAtIndex
deleteIndex
  public class ListNode &#123;
      int val;
      ListNode next;
      ListNode(int x) &#123; val = x; &#125;
    &#125;

class MyLinkedList &#123;
  int size;
  ListNode head;  // sentinel node as pseudo-head
  public MyLinkedList() &#123;
    size = 0;
    head = new ListNode(0);
  &#125;

  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
  public int get(int index) &#123;
    // if index is invalid
    if (index &lt; 0 || index &gt;= size) return -1;

    ListNode curr = head;
    // index steps needed 
    // to move from sentinel node to wanted index
    for(int i = 0; i &lt; index + 1; ++i) curr = curr.next;
    return curr.val;
  &#125;

  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
  public void addAtHead(int val) &#123;
    addAtIndex(0, val);
  &#125;

  /** Append a node of value val to the last element of the linked list. */
  public void addAtTail(int val) &#123;
    addAtIndex(size, val);
  &#125;

  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
  public void addAtIndex(int index, int val) &#123;
    // If index is greater than the length, 
    // the node will not be inserted.
    if (index &gt; size) return;

    // [so weird] If index is negative, 
    // the node will be inserted at the head of the list.
    if (index &lt; 0) index = 0;

    ++size;
    // find predecessor of the node to be added
    ListNode pred = head;
    for(int i = 0; i &lt; index; ++i) pred = pred.next;

    // node to be added
    ListNode toAdd = new ListNode(val);
    // insertion itself
    toAdd.next = pred.next;
    pred.next = toAdd;
  &#125;

  /** Delete the index-th node in the linked list, if the index is valid. */
  public void deleteAtIndex(int index) &#123;
    // if the index is invalid, do nothing
    if (index &lt; 0 || index &gt;= size) return;

    size--;
    // find predecessor of the node to be deleted
    ListNode pred = head;
    for(int i = 0; i &lt; index; ++i) pred = pred.next;

    // delete pred.next 
    pred.next = pred.next.next;
  &#125;
&#125;
</code></pre>
<h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><pre><code>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。
public class Solution &#123;
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
        ListNode t1 = headA;
        ListNode t2 = headB;
        while(t1 != t2)&#123;
            t1 = t1 != null ? t1.next : headB;
            t2 = t2 != null ? t2.next : headA;
        &#125;
        return t2;
    &#125;
&#125;
</code></pre>
<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><pre><code>方法一：哈希表
public boolean hasCycle(ListNode head) &#123;
    Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();
    while (head != null) &#123;
        if (nodesSeen.contains(head)) &#123;
            return true;
        &#125; else &#123;
            nodesSeen.add(head);
        &#125;
        head = head.next;
    &#125;
    return false;
&#125;
方法二：双指针
通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。
public boolean hasCycle(ListNode head) &#123;
    if (head == null || head.next == null) &#123;
        return false;
    &#125;
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) &#123;
        if (fast == null || fast.next == null) &#123;
            return false;
        &#125;
        slow = slow.next;
        fast = fast.next.next;
    &#125;
    return true;
&#125;
</code></pre>
<h2 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h2><pre><code>输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295
输出：2 -&gt; 1 -&gt; 9，即912
class Solution &#123;
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;
        //初始进位为0
        int pre = 0;
        //操作数
        ListNode mid = new ListNode(0);
        //返回头节点
        ListNode anws = mid ;
        //当l1和l2都不为null时进入while循环
        while(l1!=null&amp;&amp;l2!=null)&#123;
            //操作数赋值
            mid.val = (l1.val+l2.val+pre)%10;
            //更新进位
            pre = (l1.val+l2.val+pre)/10;
            //更新头节点
            l1 = l1.next;
            l2=l2.next;
            //头节点更新后判断是否为空
            if(l1==null)&#123;
                //如果l1头节点为空且进位为0，则操作数的next直接为l2剩下的
                if(pre==0) &#123;
                    mid.next = l2;
                    return anws;
                &#125;else &#123;
                    //如果有进位，则递归调用addTwoNumbers方法
                    mid.next = addTwoNumbers(l2,new ListNode(pre));
                    return anws;
                &#125;
            &#125;
            //同上
            if(l2 == null)&#123;
                if(pre==0) &#123;
                    mid.next = l1;
                    return anws;
                &#125;else &#123;
                    mid.next = addTwoNumbers(l1,new ListNode(pre));
                    return anws;
                &#125;
            &#125;
            //l1 l2更新后都不为null，则设置操作数为0 进入下一次while循环
            mid.next =new ListNode(0);
            mid = mid.next;
        &#125;
        //l1为null，直接不能进入上面while循环的情况下，直接返回l2
        if(l1==null)&#123;
            return l2;
        &#125;//同上
        else if(l2 ==null)&#123;
            return l1;
        &#125;
        return anws;
    &#125;
&#125;
</code></pre>
<h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><pre><code>1，采用快慢两个指针去寻找链表的中间节点；
2，根据链表的中间节点反转后一半的链表；
class Solution &#123;
    public boolean isPalindrome(ListNode head) &#123;
        if(head == null) return true;

    ListNode midNode = findMidNode(head);
    ListNode secondHalfHead = reverseLinked(midNode.next);
    ListNode curr1 = head;
    ListNode curr2 = secondHalfHead;

    boolean palindrome = true;
    while(palindrome &amp;&amp; curr2 != null)&#123;
        if(curr1.val != curr2.val) palindrome = false;
        curr1 = curr1.next;
        curr2 = curr2.next;
    &#125;

    return palindrome;
&#125;

/* 反转链表 */
private ListNode reverseLinked(ListNode head)&#123;
    ListNode cur = head;
    ListNode prev = null;
    while(cur != null)&#123;
        ListNode nextTemp = cur.next;
        cur.next = prev;
        prev = cur;
        cur = nextTemp;
    &#125;
    return prev;
&#125;

/* 快慢指针寻找中间节点 */
private ListNode findMidNode(ListNode head)&#123;
    ListNode fast = head;
    ListNode low = head;
    while(fast.next != null &amp;&amp; fast.next.next != null)&#123;
        fast = fast.next.next;
        low = low.next;
    &#125;
    return low;
&#125;

&#125;
</code></pre>
<h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><pre><code>先将链表闭合成环
找到相应的位置断开这个环，确定新的链表头和链表尾
class Solution &#123;
  public ListNode rotateRight(ListNode head, int k) &#123;
    // base cases
    if (head == null) return null;
    if (head.next == null) return head;

// close the linked list into the ring
ListNode old_tail = head;
int n;
for(n = 1; old_tail.next != null; n++)
  old_tail = old_tail.next;
old_tail.next = head;

// find new tail : (n - k % n - 1)th node
// and new head : (n - k % n)th node
ListNode new_tail = head;
for (int i = 0; i &lt; n - k % n - 1; i++)
  new_tail = new_tail.next;
ListNode new_head = new_tail.next;

// break the ring
new_tail.next = null;

return new_head;
  &#125;
&#125;
</code></pre>
<h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><pre><code>归并排序（递归法）
解答一：归并排序（递归法）
分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；
合并 merge 环节： 将两个排序链表合并，转化为一个排序链表
class Solution &#123;
    public ListNode sortList(ListNode head) &#123;
        if (head == null || head.next == null)
            return head;
        ListNode fast = head.next, slow = head;
        while (fast != null &amp;&amp; fast.next != null) &#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        ListNode tmp = slow.next;
        slow.next = null;
        ListNode left = sortList(head);
        ListNode right = sortList(tmp);
        ListNode h = new ListNode(0);
        ListNode res = h;
        while (left != null &amp;&amp; right != null) &#123;
            if (left.val &lt; right.val) &#123;
                h.next = left;
                left = left.next;
            &#125; else &#123;
                h.next = right;
                right = right.next;
            &#125;
            h = h.next;
        &#125;
        h.next = left != null ? left : right;
        return res.next;
    &#125;
&#125;
</code></pre>
<h2 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h2><pre><code>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起
将奇节点放在一个链表里，偶链表放在另一个链表里。然后把偶链表接在奇链表的尾部。
public class Solution &#123;
    public ListNode oddEvenList(ListNode head) &#123;
        if (head == null) return null;
        ListNode odd = head, even = head.next, evenHead = even;
        while (even != null &amp;&amp; even.next != null) &#123;
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        &#125;
        odd.next = evenHead;
        return head;
    &#125;
&#125;
</code></pre>
<h2 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a>链表的中间结点</h2><pre><code>方法一：数组
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        ListNode[] A = new ListNode[100];
        int t = 0;
        while (head != null) &#123;
            A[t++] = head;
            head = head.next;
        &#125;
        return A[t / 2];
    &#125;
&#125;
方法二：单指针法
我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        int n = 0;
        ListNode cur = head;
        while (cur != null) &#123;
            ++n;
            cur = cur.next;
        &#125;
        int k = 0;
        cur = head;
        while (k &lt; n / 2) &#123;
            ++k;
            cur = cur.next;
        &#125;
        return cur;
    &#125;
&#125;
方法三：快慢指针法
slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        ListNode slow = head, fast = head;
        while (fast != null &amp;&amp; fast.next != null) &#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        return slow;
    &#125;
&#125;
</code></pre>
<h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><pre><code>主要考虑翻转后如何链接
const myReverse = (head, tail) =&gt; &#123;
    let prev = tail.next;
    let p = head;
    while (prev !== tail) &#123;
        const nex = p.next;
        p.next = prev;
        prev = p;
        p = nex;
    &#125;
    return [tail, head];
&#125;
var reverseKGroup = function(head, k) &#123;
    const hair = new ListNode(0);
    hair.next = head;
    let pre = hair;

    while (head) &#123;
        let tail = pre;
        // 查看剩余部分长度是否大于等于 k
        for (let i = 0; i &lt; k; ++i) &#123;
            tail = tail.next;
            if (!tail) &#123;
                return hair.next;
            &#125;
        &#125;
        const nex = tail.next;
        [head, tail] = myReverse(head, tail);
        // 把子链表重新接回原链表
        pre.next = head;
        tail.next = nex;
        pre = tail;
        head = tail.next;
    &#125;
    return hair.next;
&#125;;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift142HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift142HashMap/" class="post-title-link" itemprop="url">HashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:12" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:12+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）"><a href="#HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）" class="headerlink" title="HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）"></a>HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）</h1><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><pre><code>由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的
数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到
的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。
public int findRepeatNumber(int[] nums) &#123;
    Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    int repeat = -1;
    for (int num : nums) &#123;
        if (!set.add(num)) &#123;
            repeat = num;
            break;
        &#125;
    &#125;
    return repeat;
&#125;
</code></pre>
<h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><pre><code>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
本题考察 哈希表 的使用，本文介绍 “哈希表” 和 “有序哈希表” 两种解法。其中
，在字符串很长时， “有序哈希表” 解法理论上效率更高。
public char firstUniqChar(String s) &#123;
    HashMap&lt;Character, Boolean&gt; dic = new HashMap&lt;&gt;();
    char[] sc = s.toCharArray();
    for(char c : sc)
        dic.put(c, !dic.containsKey(c));
    for(char c : sc)
        if(dic.get(c)) return c;
    return &#39; &#39;;
&#125;

在哈希表的基础上，有序哈希表中的键值对是 按照插入顺序排序 的。
基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 1 的字符”。
public char firstUniqChar(String s) &#123;
    Map&lt;Character, Boolean&gt; dic = new LinkedHashMap&lt;&gt;();
    char[] sc = s.toCharArray();
    for(char c : sc)
        dic.put(c, !dic.containsKey(c));
    for(Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())&#123;
       if(d.getValue()) return d.getKey();
    &#125;
    return &#39; &#39;;
&#125;
</code></pre>
<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><pre><code>首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，
然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，
则将该数字添加到答案，并减少哈希表中该数字出现的次数。
为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现
的次数，然后遍历较长的数组得到交集。
public int[] intersect(int[] nums1, int[] nums2) &#123;
    if (nums1.length &gt; nums2.length) &#123;
        return intersect(nums2, nums1);
    &#125;
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
    for (int num : nums1) &#123;
        int count = map.getOrDefault(num, 0) + 1;
        map.put(num, count);
    &#125;
    int[] intersection = new int[nums1.length];
    int index = 0;
    for (int num : nums2) &#123;
        int count = map.getOrDefault(num, 0);
        if (count &gt; 0) &#123;
            intersection[index++] = num;
            count--;
            if (count &gt; 0) &#123;
                map.put(num, count);
            &#125; else &#123;
                map.remove(num);
            &#125;
        &#125;
    &#125;
    return Arrays.copyOfRange(intersection, 0, index);
&#125;
</code></pre>
<h2 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h2><pre><code>class Node &#123;
    public int val;
    public Node next;
    public Node random;

    public Node() &#123;&#125;

    public Node(int _val,Node _next,Node _random) &#123;
        val = _val;
        next = _next;
        random = _random;
    &#125;
&#125;;
public Node copyRandomList(Node head) &#123;
    if(head==null) &#123;
        return null;
    &#125;
    //创建一个哈希表，key是原节点，value是新节点
    Map&lt;Node,Node&gt; map = new HashMap&lt;Node,Node&gt;();
    Node p = head;
    //将原节点和新节点放入哈希表中
    while(p!=null) &#123;
        Node newNode = new Node(p.val);
        map.put(p,newNode);
        p = p.next;
    &#125;
    p = head;
    //遍历原链表，设置新节点的next和random
    while(p!=null) &#123;
        Node newNode = map.get(p);
        //p是原节点，map.get(p)是对应的新节点，p.next是原节点的下一个
        //map.get(p.next)是原节点下一个对应的新节点
        if(p.next!=null) &#123;
            newNode.next = map.get(p.next);
        &#125;
        //p.random是原节点随机指向
        //map.get(p.random)是原节点随机指向  对应的新节点 
        if(p.random!=null) &#123;
            newNode.random = map.get(p.random);
        &#125;
        p = p.next;
    &#125;
    //返回头结点，即原节点对应的value(新节点)
    return map.get(head);
&#125;
</code></pre>
<h2 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h2><pre><code>我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。
public boolean hasCycle(ListNode head) &#123;
    Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();
    while (head != null) &#123;
        if (nodesSeen.contains(head)) &#123;
            return true;
        &#125; else &#123;
            nodesSeen.add(head);
        &#125;
        head = head.next;
    &#125;
    return false;
&#125;
</code></pre>
<h2 id="找树中两个指定节点的最近公共祖先。"><a href="#找树中两个指定节点的最近公共祖先。" class="headerlink" title="找树中两个指定节点的最近公共祖先。"></a>找树中两个指定节点的最近公共祖先。</h2><pre><code>哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点
开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已
经访问过的节点，那么这个节点就是我们要找的最近公共祖先。
class Solution &#123;
Map&lt;Integer, TreeNode&gt; parent = new HashMap&lt;Integer, TreeNode&gt;();
Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;();

public void dfs(TreeNode root) &#123;
    if (root.left != null) &#123;
        parent.put(root.left.val, root);
        dfs(root.left);
    &#125;
    if (root.right != null) &#123;
        parent.put(root.right.val, root);
        dfs(root.right);
    &#125;
&#125;

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
    dfs(root);
    while (p != null) &#123;
        visited.add(p.val);
        p = parent.get(p.val);
    &#125;
    while (q != null) &#123;
        if (visited.contains(q.val)) &#123;
            return q;
        &#125;
        q = parent.get(q.val);
    &#125;
    return null;
&#125;
&#125;
</code></pre>
<h2 id="缺失数字"><a href="#缺失数字" class="headerlink" title="缺失数字"></a>缺失数字</h2><pre><code>给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。
public int missingNumber(int[] nums) &#123;
    Set&lt;Integer&gt; numSet = new HashSet&lt;Integer&gt;();
    for (int num : nums) numSet.add(num);

    int expectedNumCount = nums.length + 1;
    for (int number = 0; number &lt; expectedNumCount; number++) &#123;
        if (!numSet.contains(number)) &#123;
            return number;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<h2 id="找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）"><a href="#找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）" class="headerlink" title="找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）"></a>找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）</h2><pre><code>public int longestConsecutive(int[] nums) &#123;
    Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;();
    for (int num : nums) &#123;
        num_set.add(num);
    &#125;

    int longestStreak = 0;

    for (int num : num_set) &#123;
        if (!num_set.contains(num - 1)) &#123;
            int currentNum = num;
            int currentStreak = 1;

            while (num_set.contains(currentNum + 1)) &#123;
                currentNum += 1;
                currentStreak += 1;
            &#125;

            longestStreak = Math.max(longestStreak, currentStreak);
        &#125;
    &#125;

    return longestStreak;
&#125;
</code></pre>
<h2 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h2><pre><code>遍历五张牌，遇到大小王（即 0直接跳过。
判别重复： 利用 Set 实现遍历判重， Set 
获取最大 / 最小的牌： 借助辅助变量 ma 和 mi ，遍历统计即可。
public boolean isStraight(int[] nums) &#123;
    Set&lt;Integer&gt; repeat = new HashSet&lt;&gt;();
    int max = 0, min = 14;
    for(int num : nums) &#123;
        if(num == 0) continue; // 跳过大小王
        max = Math.max(max, num); // 最大牌
        min = Math.min(min, num); // 最小牌
        if(repeat.contains(num)) return false; // 若有重复，提前返回 false
        repeat.add(num); // 添加此牌至 Set
    &#125;
    return max - min &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子
&#125;
</code></pre>
<h2 id="四数相加（HashMap存一组，另一组和HashMap进行比对）"><a href="#四数相加（HashMap存一组，另一组和HashMap进行比对）" class="headerlink" title="四数相加（HashMap存一组，另一组和HashMap进行比对）"></a>四数相加（HashMap存一组，另一组和HashMap进行比对）</h2><pre><code>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组和为0
采用分为两组，HashMap存一组，另一组和HashMap进行比对。
public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    int res = 0;
    for(int i = 0;i&lt;A.length;i++)&#123;
        for(int j= 0;j&lt;B.length;j++)&#123;
            int sumAB = A[i]+B[j];
            if(map.containsKey(sumAB)) map.put(sumAB,map.get(sumAB)+1);
            else map.put(sumAB,1);
        &#125;
    &#125;

    for(int i = 0;i&lt;C.length;i++)&#123;
        for(int j = 0;j&lt;D.length;j++)&#123;
            int sumCD = -(C[i]+D[j]);
            if(map.containsKey(sumCD)) res += map.get(sumCD);
        &#125;
    &#125;
    return res;
&#125;
</code></pre>
<h2 id="至少有K个重复字符的最长子串"><a href="#至少有K个重复字符的最长子串" class="headerlink" title="至少有K个重复字符的最长子串"></a>至少有K个重复字符的最长子串</h2><pre><code>先用hash表统计s中每个字符出现的次数，显然如果字符c出现的次数小于k
，c必然不在最长子串里面，根据这个特性可以将原始s分割成多个子串递归地求解问
题，我们用一个split数组依次来存放每个分割点的索引，对每个分割区间同样求
解该问题(多路的分治问题)，并取结果的最大值保存在变量ans中，此处有一个小trick
（如果当前求解的子串长度比已存在的ans还要小，则没有必要求解
该区间，这样可以减少不必要的计算），最后递归的结束点就是当前求
解的字符串s符合最长子串的要求。
public:
    int longestSubstring(string s, int k) &#123;
        unordered_map&lt;char, int&gt; umap;
        for (auto c : s) umap[c]++;
        vector&lt;int&gt; split;
        for (int i = 0; i &lt; s.size(); i++) &#123;
            if (umap[s[i]] &lt; k) split.push_back(i);
        &#125;
        if (split.size() == 0) return s.length();
        int ans = 0, left= 0;
        split.push_back(s.length());
        for (int i = 0; i &lt; split.size(); i++) &#123;
            int len = split[i] - left;
            if (len &gt; ans) ans = max(ans, longestSubstring(s.substr(left, len), k));
            left = split[i]+1;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h2 id="给定两个字符串-s-和-t-，编写一个函数来判断-t-是否是-s-的字母异位词。"><a href="#给定两个字符串-s-和-t-，编写一个函数来判断-t-是否是-s-的字母异位词。" class="headerlink" title="给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。"></a>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</h2><pre><code>public boolean isAnagram(String s, String t) &#123;
    if (s.length() != t.length()) &#123;
        return false;
    &#125;
    int[] counter = new int[26];
    for (int i = 0; i &lt; s.length(); i++) &#123;
        counter[s.charAt(i) - &#39;a&#39;]++;
        counter[t.charAt(i) - &#39;a&#39;]--;
    &#125;
    for (int count : counter) &#123;
        if (count != 0) &#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;
</code></pre>
<h2 id="给定一个字符串，找到它的第一个不重复的字符"><a href="#给定一个字符串，找到它的第一个不重复的字符" class="headerlink" title="给定一个字符串，找到它的第一个不重复的字符"></a>给定一个字符串，找到它的第一个不重复的字符</h2><pre><code>public int firstUniqChar(String s) &#123;
    HashMap&lt;Character, Integer&gt; count = new HashMap&lt;Character, Integer&gt;();
    int n = s.length();
    for (int i = 0; i &lt; n; i++) &#123;
        char c = s.charAt(i);
        count.put(c, count.getOrDefault(c, 0) + 1);
    &#125;
    
    for (int i = 0; i &lt; n; i++) &#123;
        if (count.get(s.charAt(i)) == 1) 
            return i;
    &#125;
    return -1;
&#125;
</code></pre>
<h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><pre><code>public int lengthOfLongestSubstring(String s) &#123;
    Map&lt;Character, Integer&gt; dic = new HashMap&lt;&gt;();
    int res = 0, tmp = 0;
    for(int j = 0; j &lt; s.length(); j++) &#123;
        int i = dic.getOrDefault(s.charAt(j), -1); // 获取索引 i
        dic.put(s.charAt(j), j); // 更新哈希表
        tmp = tmp &lt; j - i ? tmp + 1 : j - i; // dp[j - 1] -&gt; dp[j]
        res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
    &#125;
    return res;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">338</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
