<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/19/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/07/03/E_Android18%E6%8E%A7%E4%BB%B6%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/03/E_Android18%E6%8E%A7%E4%BB%B6%E7%B1%BB/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-03 17:22:51" itemprop="dateCreated datePublished" datetime="2019-07-03T17:22:51+08:00">2019-07-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android控件类"><a href="#Android控件类" class="headerlink" title="Android控件类"></a>Android控件类</h1><pre><code>名称    类名    出处
颜色    Color    
可变字符串    Spannable、SpannableString    
风格区域、URL区域    StyleSpan、URLSpan    
状态图形    Drawable、StateListDrawable    
形状图形    ShapeDrawable    
点九图形    NinePatchDrawable    
画布、画笔    Canvas、Paint    
透明度动画    AlphaAnimation    
过渡图形    TransitionDrawable    
旋转动画    RotateAnimation    
帧动画    AnimationDrawable    
梯度图形    GradientDrawable    
标签页    TabHost、TabWidget    
标题栏    ActionBar    
溢出菜单    OverflowMenu    
导航栏    Navigation    
定制视图    CustomView    
搜索视图    SearchView    
翻页视图    ViewPager    
翻页标题    PagerTabStrip、PagerTitleStrip    
飞掠视图    ViewFlipper    
翻页适配器    PagerAdapter、FragmentStatePagerAdapter    
日期和时间控件    DatePicker、TimePicker    
对话框碎片    DialogFragment    
布局视图    LinearLayout、RelativeLayout、FrameLayout    
滚动视图    ScrollView、HorizontalScrollView    
基本视图    View、ViewGroup    
文本框、图像视图    TextView、EditText、ImageView    
按钮、图像按钮    Button、ImageButton    
复合按钮    CompoundButton    
复选框、开关、单选框    CheckBox、Switch、RadioGroup、RadioButton    
下拉框、列表视图、网格视图    Spinner、ListView、GridView    
适配器视图    AdapterView、Adapter    
基本适配器    BaseAdapter、ArrayAdapter、SimpleAdapter    
自动完成编辑框    AutoCompleteTextView    
进度条、进度对话框    ProgressBar、ProgressDialog    
远程视图    RemoteViews    
表面视图    SurfaceView、SurfaceHolder    
媒体录制器、媒体播放器    MediaRecorder、MediaPlayer    
拖动条    SeekBar    
网页视图    WebView、WebSettings    
网页视图客户端    WebViewClient、WebChromeClient    
菜单、选项菜单、上下文菜单    Menu、OptionsMenu、ContextMenu    
弹窗    PopupWindow    
对话框    AlertDialog、Dialog    
碎片    Fragment    
占位视图    ViewStub    
风格、主题    Style、Theme    
汉字转拼音    HanziToPinyin    
位图    Bitmap、BitmapDrawable    
集合动画    AnimationSet    
属性动画    ObjectAnimator、AnimatorSet    
路径、矩阵    Path、Matrix    
折叠列表视图    ExpandableListView、ExpandableListAdapter    
列表碎片    ListFragment    
文字转语音    TextToSpeech    
参数设置碎片    PreferenceFragment    
工具栏、搜索框    Toolbar、SearchView    
侧滑布局    DrawerLayout、SlidingPaneLayout    
弹出菜单、列表弹窗    PopupMenu、ListPopupWindow    
循环器视图    RecyclerView    
下拉刷新布局    SwipeRefreshLayout    
画廊    Gallery   
图像切换器    ImageSwitcher    
调色板    Palette  
卡片视图    CardView    
视频视图    VideoView   
媒体控制条    MediaController    
音频录制    AudioRecord    
音轨播放    AudioTrack    
声音池    SoundPool    
提示窗    Toast、Snackbar    
裁剪图形    ClipDrawable    
缩放图形    ScaleDrawable  
旋转图形    RotateDrawable
水波图形    RippleDrawable
矢量图形    VectorDrawable
矢量动画    AnimatedVectorDrawable
导航视图    NavigationView    
协调布局    CoordinatorLayout
悬浮按钮    FloatingActionButton 
底部弹窗    BottomSheetBehavior
应用栏布局    AppBarLayout    
嵌套滚动视图    NestedScrollView 
可折叠工具栏布局    CollapsingToolbarLayout  
文本输入布局    TextInputLayout    
文本输入编辑框    TextInputEditText   
碎片标签组    FragmentTabHost    
栈视图    StackView    
标签布局    TabLayout    
约束布局    ConstraintLayout   
OpenGL表面视图    GLSurfaceView 
OpenGL画笔    GL10
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/07/03/E_Android17%E5%B8%B8%E7%94%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/03/E_Android17%E5%B8%B8%E7%94%A8%E7%B1%BB/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-03 17:17:08" itemprop="dateCreated datePublished" datetime="2019-07-03T17:17:08+08:00">2019-07-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android常用类"><a href="#Android常用类" class="headerlink" title="Android常用类"></a>Android常用类</h1><pre><code>名称    类名    
基本数据类型    String、Integer、Double、BigDecimal    
格式化工具    Formatter、DecimalFormat、NumberFormat    
样式、匹配器    Pattern、Matcher    
日期、日历    Date、SimpleDateFormat、Calendar    
向量、队列、链表    Set/HashSet、ArrayList、LinkedList    
矢量、栈    Vector、Stack    
映射、哈希表    Map/HashMap、Hashtable    
迭代器    Iterator  
序列化结构    Serializable   
文件    File    
文件流    FileOutputStream、FileInputStream    
缓存流    BufferedOutputStream、BufferedInputStream    
任务    Runnable    
线程    Thread    
定时器    Timer、TimerTask   
反射    reflect    
xml解析    XmlPullParser、dom、sax、SAXParser    
输入输出流    InputStream、OutputStream    
http连接    HttpURLConnection、HttpClient    
URL编码和解码    URLEncoder、URLDecoder    
BASE64编码和解码    BASE64Encoder、BASE64Decoder    
加密算法    Cipher、KeyGenerator、SecretKey、MessageDigest    
线程池    Executors、ThreadPoolExecutor    
定时器线程池    ScheduledExecutorService    
异常    Exception  
键值对属性    Properties    
加锁    ReentrantLock、ReentrantReadWriteLock    
字符串建造者    StringBuilder    
数组、容器组    Arrays、Collections    
数学函数    Math    
套接字、网络地址    Socket、SocketServer、InetAddress
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/06/07/M_Swift152GLSL-%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/07/M_Swift152GLSL-%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-07 02:24:40" itemprop="dateCreated datePublished" datetime="2019-06-07T02:24:40+08:00">2019-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 16:08:49" itemprop="dateModified" datetime="2021-04-12T16:08:49+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h2 id="title-OpenGL-变量和类型"><a href="#title-OpenGL-变量和类型" class="headerlink" title="title :OpenGL 变量和类型"></a>title :OpenGL 变量和类型</h2><p>1、变量类型<br>变量种类            变量类型                                描述<br>空                       void                                       用于无返回值的函数或者参数为空的函数<br>标量                   float, int, bool                        浮点型，整型，布尔型的标量数据类型<br>浮点型向量        vec2, vec3, vec4                   包含2，3，4个元素的浮点型向量<br>整数型向量        ivec2, ivec3, ivec4                 包含2，3，4个元素的整型向量<br>布尔型向量        bvec2, bvec3, bvec4             包含1，2，3，4个元素的布尔型向量<br>矩阵                   mat2, mat3, mat4                  尺寸为2x2，3x3，4x4的浮点型矩阵<br>纹理句柄            sampler2D, samplerCube     分别表示操作2D和cube的句柄<br>备注：GLSL中没有指针类型，大小写敏感的<br>对于变量类型，GLSL有着非常严格的规则，进行赋值，加减乘除运算必须类型一直，否则会出现语法错误。如果不一致则必须进行强制类型转换<br>float myFloat = 1.0;<br>bool myBool = true;<br>float result = myFloat + myBool(myBool);</p>
<p>2、Structures 结构体<br>GLSL支持结构体，把一些系统定义的类型聚到一起，组成自定义的类型，也可以包括事先声明的结构体，但是不能定义嵌套结构体。例如：<br>struct myStruct<br>{<br>    float f1;<br>    bool f2;<br>    vec3 v3;<br>}<br>声明结构体变量<br>myStruct lightVar2;<br>struct myStruct2<br>{<br>    float f1;<br>    myStruct st1;   //合法<br>    struct str2{        // 不合法<br>        bool b1;<br>        float f2;<br>    }<br>}<br>3、Arrays 数组<br>GLSL中的数组和C的数组很类似，支持最基本类型，也支持结构体的数组。例如：</p>
<p>float frequencies[3];<br>uniform vec4 lightPosition[4];<br>const int numLights = 2;<br>light lights[numLights];<br>备注 GLSL的数组无法在声明的时候初始化。</p>
<p>4、存储限定符<br>const           常量，或者是函数的只读参数<br>attribute       只能在顶点着色器中定义，只读属性，由应用程序赋值初始化<br>uniform        只能定义为全局变量，只读属性，可以由应用程序和opengl 初始化<br>varying         提供顶点着色器和片段着色器的连接点，只能是float, vec2, vec3, vec4, mat2, mat3, and mat4类型的变量<br>5、vector变量操作方式<br>向量的元素有固定的名字去访问，分别有三组{x,y,z,w}、{r,g,b,a}、{s,t,p,q}，访问时下表对应长度不能超过l向量的长度<br>vec2 v = vec2(3.0);<br>v.x //正确<br>v.z // 错误<br>向量的元素可以放在一起<br>vec4 v = vec4(1,2,3,4);<br>v.zy    // 等于 vec2(3,2)<br>vec3 v3 = v.xyz // 等于vec3(1,2,3)<br>v.rgba  // 此种方式不正确，下表同时只能使用一个集合中的名称<br>v.yx = vec2(3,0)    // 将y和x的位置互换并给他们的赋值为新的值，将变成 vec4(3,0,3,4);<br>6、矩阵元素的操作方式<br>用[]访问元素<br>mat4 m;<br>m[1] = vec4(2.0);   // sets the 4th element of the third column to 2.0<br>m[0][0] = 1.0;  // sets the upper left element to 1.0<br>m[2][3] = 2.0;  // sets the second column to all 2.0<br>7、向量和矩阵的操作<br>vec3 v, u; float f;<br>v = u + f;<br>等价于<br>v.x = u.x + f;<br>v.y = u.y + f;<br>v.z = u.z + f;</p>
<p>vec3 v, u, w;<br>w = v + u;<br>等价于<br>w.x = v.x + u.x;<br>w.y = v.y + u.y;<br>w.z = v.z + u.z;</p>
<p>vec3 v, u;<br>mat3 m;<br>u = v * m;<br>等价于<br>u.x = dot(v, m[0]);<br>u.y = dot(v, m[1]);<br>u.z = dot(v, m[2]);</p>
<p>u = m * v;<br>等价于<br>u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z; u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z; u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;</p>
<p>mat m, n, r;<br>r = m * n;<br>等价于<br>r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;<br>r[1].x = m[0].x * n[1].x + m[1].x * n[0].y + m[2].y * n[0].z;<br>r[2].x = m[0].x * n[2].x + m[1].x * n[0].y + m[2].z * n[0].z;</p>
<p>r[0].y = m[0].y * n[0].x + m[1].y * n[1].y + m[2].x * n[1].z;<br>r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;<br>r[2].y = m[0].y * n[2].x + m[1].y * n[1].y + m[2].z * n[1].z;</p>
<p>r[0].z = m[0].z * n[0].x + m[1].z * n[2].y + m[2].x * n[2].z;<br>r[1].z = m[0].z * n[1].x + m[1].z * n[2].y + m[2].y * n[2].z;<br>r[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/12/13/M_Swift119%E5%92%8C%E7%BA%A6%E8%BD%A6%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/13/M_Swift119%E5%92%8C%E7%BA%A6%E8%BD%A6%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">和约车简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-13 11:57:07" itemprop="dateCreated datePublished" datetime="2018-12-13T11:57:07+08:00">2018-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>经过两个多星期的奋战，和约车差不多成型了总感觉缺少点什么，但是无所谓了，服务的事情能解决应该就不要客户端去调整了。<br>这两天写了一下开发申请单，也完善了一下功能模块。<br>在写申请单的时候，也对工程有了一个规划，模块分的也更详细了<br>从工程角度来讲，我觉得是有收获的，以后再开发一个东西的时候，我们会更方便的了解这个东西，也能更全面的去分析项目，也能更全面的把握项目，不至于手忙脚乱，不至于代码写的一团糟。<br>和约车功能模块<br>    工程配置<br>    网络服务<br>    第三方SDK<br>    资源文件<br>    app业务模块<br>和地图APP模块名称<br>    主页<br>        主页面<br>    添加路线<br>        添加路线页面<br>    消息<br>        我的消息页面<br>        聊天页面<br>    我的<br>        个人中心页面<br>        历史订单页面<br>        历史评价页面<br>        个人信息页面<br>        修改昵称页面<br>        设置页面<br>        关于页面<br>        上下班设置页面<br>    车主认证<br>        车主认证页面<br>        车型选择页面<br>    发单<br>        发单页面<br>    订单<br>        等待接单页面<br>        订单详情页面<br>        订单支付页面<br>    登录<br>        验证码登录页面<br>        密码登录页面<br>        密码修改页面<br>        服务协议页面<br>    选点<br>        地图选点搜索页面</p>
<p>资源文件<br>        统一登录SDK<br>        极光推送SDK<br>        高德搜索SDK<br>        地图SDK<br>Libs<br>        网络请求<br>        列表空试图显示<br>        日志输出<br>        Toast<br>images<br>        图片资源</p>
<p>工程描述<br>    数据存储<br>        因为项目不是特别的大，所以数据存储这方面我全部使用了NSUserdefult，专门写了一个类，用户所有数据存储，提供接口，外面调用<br>    常量<br>        项目中不免会用到一些配置的东西，我都是写在这里，一些sdk的key，版本号，通用的颜色，通知名称，屏幕宽高等等<br>        此外还包括了一些常用的类，方便头文件中写太多。<br>    单例<br>        在开发中不免使用到单例，我想和约车选择起点和终点用单例是再好不过了，因为我们不用考虑那么多了，在进程生命周期内也会一直存在。<br>    时间处理<br>        这个有点坑，说实话，我到现在也有点晕，很多时候获取的时间老是不准。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/12/13/M_Swift118%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/13/M_Swift118%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">新项目总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-13 11:56:41" itemprop="dateCreated datePublished" datetime="2018-12-13T11:56:41+08:00">2018-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天可能需要休息一下，并没有那么忙碌了。<br>临时的话，手里的工作没有那么多了，所以想写点东西<br>前段时间写了一个ios的app，感觉重新写iOS的感觉就是爽。<br>很快就写完了，可能并没有那么复杂吧，但是我觉得很爽，虽然加了很多的班，但是感觉是值得的。<br>突然就想说，一个iOS开发者，一个安卓开发者，一个前端的综合开发者，应该具备什么样的能力，也许我能力还浅，但是我很想说一下，很想在说的同时对自己也有提高吧。<br>感觉其实，经常在写东西，但是只是熟悉，真的是收获很少。<br>有的时候，感觉学不到。<br>不过写起来还是挺爽的，我基本上坚持了使用代码去写，很少的使用xib，我知道xib使用多了，就一定会发生卡顿，所以，我想我的坚持是对的，xib那种东西其实没有太多的技术含量，我觉得不能用太多，特别是一个控制器里的多个view，我们如果用多了，真的不好。<br>再说说开发吧，我觉得iOS开发还是要快捷很多，无论是连手机测试，还是打端点编译，都非常的快捷便利，android真的是让人头疼，我每次运行android一段时间以后我一定要关一下电脑，不关的话真的是卡的要命，电脑嗡嗡的响的时候，编译一直过不去的时候，真的是脑袋都炸掉了。<br>再看一下现在互联网行业吧，真的是让人头疼，感觉现在给钱的都是大公司，小公司真的是扣的要命，一分钱都要分好几份话的样子。<br>有的时候一直在想，我应该怎么办，有的时候一直在想，我能有什么样的后路，这真的是让人头疼的问题。<br>回家吧幸福，回家看一看父母。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/15/M_Swift115AndroidStdio%E5%BF%AB%E6%8D%B7%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/15/M_Swift115AndroidStdio%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="post-title-link" itemprop="url">Android Stdio 快捷键</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-15 16:45:54" itemprop="dateCreated datePublished" datetime="2018-10-15T16:45:54+08:00">2018-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>快速定位类名：Cmd + O<br>查看本类中方法：Cmd + Fn + F12<br>查看方法被调用的位置：Option + Fn + F7<br>项目内全局搜索：Cmd + Shift + F<br>格式化代码：Cmd + Option + L<br>快速定位所有类名及其中的方法名：Cmd + Option + O<br>清除无效包引用：Ctrl + Option + O（自动清除无用包，加载有用包，Android Studio基本自动执行了）<br>显示Version Control面板：Cmd + Shift + 9</p>
<p>复制当前行：Cmd + D<br>查找：Cmd + F<br>构造方法，set get方法等生成的快捷菜单：Cmd + N<br>查找+替换：Cmd + R<br>删除行：Cmd + Delete<br>注释代码(//)：Cmd + /<br>导包（提示错误解决方案）：Option + Enter<br>重命名变量：⇧F6</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/15/M_Swift116%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/15/M_Swift116%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">小程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-15 16:40:14" itemprop="dateCreated datePublished" datetime="2018-10-15T16:40:14+08:00">2018-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>api地址：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/">https://developers.weixin.qq.com/miniprogram/dev/component/</a></p>
<p>1.小程序配置 app.json<br>    app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。<br>    {<br>        “pages”:[<br>            “pages/index/index”,<br>        ],<br>        “window”:{<br>            “backgroundTextStyle”:”light”,<br>            “navigationBarBackgroundColor”: “#fff”,<br>            “navigationBarTitleText”: “WeChat”,<br>            “navigationBarTextStyle”:”black”<br>        }<br>    }<br>2.pages小程序页面<br>    小程序页面包含4个部分<br>    wxml： 是用来描述当前这个页面的结构<br>    wxss：用来描述页面的样子<br>    js：通常是用来处理这个页面和用户的交互<br>    json：页面配置，页面中配置项会覆盖 app.json 的 window 中相同的配置项。<br>3.数据绑定js交互<br>    <view></view><br>    Page({<br>        clickMe: function() {<br>        this.setData({ msg: “Hello World” })<br>        }<br>    })<br>4.小程序的启动<br>    默认第一个配置就是启动页面<br>5.页面 Page<br>    data    Object    页面的初始数据<br>    生命周期函数等等<br>6.页面跳转<br>    打开新页面    调用 API wx.navigateTo<br>    页面重定向    调用 API wx.redirectTo<br>    页面返回    调用 API wx.navigateBack<br>    Tab 切换    调用 API wx.switchTab<br>    重启动    调用 API wx.reLaunch<br>7.组件<br>    view、label、text等等<br>8.微信开放api</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/10/15/M_Swift117web%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/15/M_Swift117web%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">web百度地图使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-15 16:38:51" itemprop="dateCreated datePublished" datetime="2018-10-15T16:38:51+08:00">2018-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前段时间写了一个前端的页面，今天没事总结一下吧，前端使用百度地图，后段使用php，比较简短，也没有丰富的web前端开发经验，就简单写一下开发流程吧，作为自己一个经验<br>1.考虑地图上要放很多数据，我最后我发现有2万8千个数据，那么同时在百度地图上展示是否卡顿，最后决定使用百度聚合api这个接口展示还是比较不错的，缩放显示也比较美观，我也就选择了这个。<br>2.数据使用，一开始思考了很多，数据如何使用在百度地图上让我费了很大的功夫，用php做了很久，最后终于实现了，也是通过判断一些经纬度是不是在行政区域内来做的。耗时比较长，当时忙忙碌碌的，也算是弄的头疼。<br>3.数据做好之后，我便开发php接口了，比较简单，只要把数据吐出来就可以了，基本上没有多少逻辑判断<br>4.页面开发，最后就是页面了，因为我html和css的功底不行，所以我也是经过百度了很多效果，最后展示出来这个样式。<br>页面地址：<a target="_blank" rel="noopener" href="http://www.heqinuc.com/bigdata/shenyang/beijingpublic.html">http://www.heqinuc.com/bigdata/shenyang/beijingpublic.html</a><br>5.页面逻辑，页面展示涉及一些地图操作逻辑，不是太难，就是麻烦一些。<br>这些所有的东西我基本上三天搞定了，感觉挺累，纪念十月一之前的这些日子吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/16/M_Swift110%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/16/M_Swift110%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">算法-查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-16 19:39:30" itemprop="dateCreated datePublished" datetime="2018-08-16T19:39:30+08:00">2018-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字符串转化为整数"><a href="#字符串转化为整数" class="headerlink" title="字符串转化为整数"></a>字符串转化为整数</h2><pre><code>首先判断字符串是否为空，返回0
考虑前面的是否是空格，使用trim()去掉，然后判断长度是否为0，是的话，返回0
判断第一个字符是不是+和-，设置变量sign记录
循环取得字符串的数字，考虑字符串中有非数字，遇到就退出，保留前面的数字
考虑溢出的情况，溢出返回Integer的最大值或最小值
public static int myAutoNumber(String str)&#123;
    //首先判断空值
    if(str == null)&#123;
        return 0;
    &#125;
    //去掉空格的情况
    str = str.trim();
    if(str.length() == 0)
    return 0;
    //正负数标志
    int sign = 1;
    int index = 0;
    if(str.charAt(index) == &#39;+&#39;)
        index ++;
    else if(str.charAt(index) == &#39;-&#39;)&#123;
        index ++;
        sign = -1;
    &#125;
    //取得数字部分，遇到溢出和非数字退出
    long number = 0;
    for(; index &lt; str.length();index++)&#123;
        if(str.charAt(index) &lt; &#39;0&#39; &amp;&amp; str.charAt(index) &gt; &#39;9&#39;)&#123;
        break;
    &#125;
    number = number * 10 + (str.charAt(index) - &#39;0&#39;);
    if(number &gt;= Integer.MAX_VALUE)
        break;
    &#125;
    if(number * sign &lt;= Integer.MIN_VALUE)
    return Integer.MIN_VALUE;
    if(number * sign &gt;= Integer.MAX_VALUE)
    return Integer.MAX_VALUE;
    return (int) number * sign;
&#125;
</code></pre>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><pre><code>// 顺序存储结构的递归先序遍历
var tree = [1, 2, 3, 4, 5, , 6, , , 7];
void function preOrderTraverse(x, visit) &#123;
    visit(tree[x]);
    if (tree[2 * x + 1]) preOrderTraverse(2 * x + 1, visit);
    if (tree[2 * x + 2]) preOrderTraverse(2 * x + 2, visit);
    &#125;(0, function (value) &#123;
        console.log(value);
&#125;);

// 链式存储结构的递归先序遍历
BinaryTree.prototype.preOrderTraverse = function preOrderTraverse(visit) &#123;
visit(this.data);
if (this.leftChild) preOrderTraverse.call(this.leftChild, visit);
if (this.rightChild) preOrderTraverse.call(this.rightChild, visit);
&#125;;
非递归
// 链式存储的非递归先序遍历
// 方法1
BinaryTree.prototype.preOrder_stack = function (visit) &#123;
var stack = new Stack();
stack.push(this);
while (stack.top) &#123;
var p;
// 向左走到尽头
while ((p = stack.peek())) &#123;
    p.data &amp;&amp; visit(p.data);
    stack.push(p.leftChild);
&#125;
stack.pop();
if (stack.top) &#123;
    p = stack.pop();
    stack.push(p.rightChild);
&#125;
// 方法2
BinaryTree.prototype.preOrder_stack2 = function (visit) &#123;
var stack = new Stack();
var p = this;
while (p || stack.top) &#123;
    if (p) &#123;
        stack.push(p);
        p.data &amp;&amp; visit(p.data);
        p = p.leftChild;
    &#125; else &#123;
        p = stack.pop();
        p = p.rightChild;
    &#125;
&#125;
</code></pre>
<h2 id="查询链表第N个元素"><a href="#查询链表第N个元素" class="headerlink" title="查询链表第N个元素"></a>查询链表第N个元素</h2><pre><code>第一种方法先求出元素个数，在遍历元素个数-n个，时间复杂度为：O(N+N-、
n)=O(2N-n)。
第二种设置俩个指针，第一个先走N步，第二个开始走。俩者速度一样，时间复
杂度为O(N)。
代码如下：
/** 
* 获取单链表倒数第N个元素 
* @author xiucai 
*/  
public class SingleLinkedList_LastN &#123;  
/** 
* 第一种方法先求出元素个数，在遍历元素个数-n个 
* 时间复杂度为：O(N+N-n)=O(2N-n) 
* @param list 
* @param n 
* @return 
* @throws Exception 
*/  
public static&lt;T&gt; T getLastN1(SingleLinkedList&lt;T&gt; list,int n) throws Exception&#123;  
int count=0;  
Node&lt;T&gt; node=list.head;  
while(node.next!=null)&#123;  
count++;  
node=node.next;  
&#125;  
if(count&lt;n)  
throw new Exception(&quot;单链表元素个数小于 &quot;+n+&quot; !&quot;);  
node=list.head;  
for(int i=0;i&lt;count-n;i++)&#123;  
node=node.next;  
&#125;  
return (T)node.data;  
&#125;  

/** 
* 设置俩个指针，第一个先走N步，第二个开始走。俩者速度一样 
* 时间复杂度为O(N) 
* @param list 
* @param n 
* @return 
* @throws Exception  
*/  
public static&lt;T&gt; T getLastN2(SingleLinkedList&lt;T&gt; list,int n) throws Exception&#123;  
//fastN先走N步，slowN等fastN走N步后在开始走  
Node&lt;T&gt; fastN=list.head,slowN=list.head;  
for(int i=0;i&lt;n;i++)&#123;  
if(fastN.next==null)&#123;  
throw new Exception(&quot;单链表元素个数小于 &quot;+n+&quot; ！&quot;);  
/*try &#123; 

&#125; catch (Exception e) &#123; 
// TODO Auto-generated catch block 
e.printStackTrace(); 
&#125;*/  
&#125;  
fastN=fastN.next;  
&#125;  
while(fastN.next!=null)&#123;  
fastN=fastN.next;  
slowN=slowN.next;  
&#125;  
return (T)slowN.data;  
&#125; 
</code></pre>
<h2 id="100个球三种颜色多少种情况"><a href="#100个球三种颜色多少种情况" class="headerlink" title="100个球三种颜色多少种情况"></a>100个球三种颜色多少种情况</h2><pre><code>//假设白球1个，红球和黄球任意组合，那么有 1，98，98，1
//98 个可能，猜测，觉得应该不对
//那么98 * 98 = 9604
</code></pre>
<h2 id="集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡"><a href="#集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡" class="headerlink" title="集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡"></a>集合中第一个只出现一次的字符，考虑时间效率与空间效率之间的平衡</h2><pre><code>为了解决这个问题，我们可以定义一个哈希表（外部空间），其键值（Key）是
字符，而值（Value）是该字符出现的次数。
同时我们还需要从头开始扫描字符串两次：
1）第一次扫描字符串时，每扫描到一个字符就在哈希表的对应项中把次数加1。
（时间效率O(n)）
2）第二次扫描时，每扫描到一个字符就能从哈希表中得到该字符出现的次数。
这样第一个只出现一次的字符就是符合要求的输出。（时间效率O(n)）
这样算起来，总的时间复杂度仍然是O(n)，满足了题目要求，擦一擦汗，感
叹：这*装得真有点技术！
public class Solution &#123;
public int FirstNotRepeatingChar(String str) &#123;
　if(str == null || str.length() == 0)
    　return -1;
    　int[] sign = new int[256];
    　char[] array = str.toCharArray();
    　for(int i=0;i&lt;array.length;i++)&#123;
    　if(sign[array[i]] &lt; 2)
    　sign[array[i]] ++ ;
　&#125;
　for(int i=0;i&lt;array.length;i++)&#123;
    　if(sign[array[i]] == 1)
    　   return i;
    　&#125;
　   return -1;
　&#125;
&#125;
</code></pre>
<h2 id="最长无重复字符的子串"><a href="#最长无重复字符的子串" class="headerlink" title="最长无重复字符的子串"></a>最长无重复字符的子串</h2><pre><code>思路：[pre,i]表示一个无重复子串，用hash表记录子串中每个字符的出现次
数。初始pre = 0，i = 0，i从左往右扫描字符串，maxLength保存当前最
大长度。每扫描一个字符，根据对应的值来判断这个字符是否已经出现。
如果A[i]已存在, 将pre与当前字符A[i]位置的下一个位置进行比较，选择最
大者作为最新pre所指位置，然后再更新maxLength；   
如果不存在，则继续扫描，(i - pre + 1)与最大长度进行比较，更新
maxLength。   
将A[i]以及对应的位置i保存，更新字符最近出现的位置。
int longestSubstring(string A, int n) &#123;
    map&lt;char, int&gt; m; 
    //map中的键key存放字符串中出现的字符，值value存放该字符当前的位置  
    int maxLength = 0;  //保存最长字串长度  
    int pre = 0;        //记录头指针位置 
    for(int i=0; i&lt;n; i++ )&#123;  
    map&lt;char, int&gt;::iterator iter=m.find(A[i]);
    if(iter!=m.end())&#123;//如果map中已存在当前字符   m[A[i]]
    //更新当前指针位置，如果当前指针大，则使用当前指针，否则使用该指
    针下一个字符的位置
    pre = max(pre, (m[A[i]]+1));
    &#125; 
    maxLength = max(maxLength, i-pre+1);//更新最长字串的长度
    m[A[i]]=i;//修改当前字符的value，记录最新位置     
    &#125;  
    return maxLength; 
&#125;
另一种类似：
int longestSubstring(string A, int n) &#123;
    map&lt;char, int&gt; m; //表示字符串中每个字符是否出现，初始化为
    0，表示未出现  
    int start = 1,MAX = 0;  
    //遍历该字符串，每遍历一个字母时，利用map去找该字母最近一次出现
    是什么时候  
    //中间这一段便是无重复字符的字符串。  
    for (int i = 1; i &lt;= n; i++)&#123;  
    char c = A[i - 1];    
    if (m[c] &gt;= start)&#123;    
    start = m[c] + 1;   
    &#125;
    MAX = max(MAX, i - start + 1); 
    m[c] = i;   //map添加数据  mapStudent[char] = int 
    &#125;    
    return MAX;
&#125;
</code></pre>
<h2 id="二分查找法查找多少次"><a href="#二分查找法查找多少次" class="headerlink" title="二分查找法查找多少次"></a>二分查找法查找多少次</h2><h2 id="寻找距离最近的公共父视图，已知两个节点和根节点"><a href="#寻找距离最近的公共父视图，已知两个节点和根节点" class="headerlink" title="寻找距离最近的公共父视图，已知两个节点和根节点"></a>寻找距离最近的公共父视图，已知两个节点和根节点</h2><pre><code>二叉树查找
栈的push和pop的时间复杂度，实现O（1）的找出栈中最小值的算法（栈只在一端操作，以空间换时间）
</code></pre>
<h2 id="Hash碰撞冲突"><a href="#Hash碰撞冲突" class="headerlink" title="Hash碰撞冲突"></a>Hash碰撞冲突</h2><pre><code>我们知道，对象Hash的前提是实现equals()和hashCode()两个方法，那么
HashCode()的作用就是保证对象返回唯一hash值，但当两个对象计算值一样
时，这就发生了碰撞冲突。如下将介绍如何处理冲突，当然其前提是一致性
hash。
1.开放地址法
开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)
其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为
1,2,3,…m-1，称线性探测再散列。
如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为
1,-1,2,-2,4,-4,9,-9,16,-16,…k*k,-k*k(k&lt;=m/2)，称二次探测再散
列。
如果di取值可能为伪随机数列。称伪随机探测再散列。
2.再哈希法
当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺
点：计算时间增加。
比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第
二位进行哈希，再冲突，第三位，直到不冲突为止
3.链地址法（拉链法）
NSMutableArray以及NSMutableDictionary的设计不是多线程安全的，
当然这种设计的好处是处理速度快，不需要任何锁进行同步，所以我们在使用
Objective-C的这些容器的时候需要注意，在哪个线程中创建它们就在哪个线
程中对它们进行操作。不过在某些情况下，我们由于一些算法或业务需求，需要
在多个线程中共享一个NSMutableArray容器对象，这时候我们需要通过一些
同步机制来实现多线程操作的安全性。
一个对象的引用计数记录在一个hash表中的话，如何保证多线程的时候计数的
准确性？（从上到下加锁消耗太大，可以采用分治，每十个加一个锁）
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/08/16/M_Swift114UI%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/16/M_Swift114UI%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">UI相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-16 19:39:30" itemprop="dateCreated datePublished" datetime="2018-08-16T19:39:30+08:00">2018-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="UIView绘制原理"><a href="#UIView绘制原理" class="headerlink" title="UIView绘制原理"></a>UIView绘制原理</h2><pre><code>当UIView调用setNeedDisplay之后,系统会调用view对应layer的 
setNeedsDisplay方法,相当于在当前layer上打上了一个脏标记,然后会在
当前runloop即将结束的时候调用CALayer的display方法,才会真正的进入
当前视图的绘制流程当中,所以视图的绘制时机,是在当前runloop即将结束的
时候才会开始.
CALayer的display方法的内部实现,首先会判断layer的delegete是否响
应display方法,如果代理不响应就会进入到系统的绘制流程当中,如果响应,实
际上就为我们提供了异步绘制的接口,这样就构成了UIView的绘制原理
进行异步绘制,其实就是基于系统给我们开的口子layer.delegate,如果遵从
或者实现了displayLayer方法,我们就可以进入到异步绘制流程当中,在异步
绘制的过程当中
1.就由delegete去负责生成bitmap位图
2.设置改bitmap作为layer.content属性的值
</code></pre>
<h2 id="Masonry"><a href="#Masonry" class="headerlink" title="Masonry"></a>Masonry</h2><pre><code>https://www.cnblogs.com/ludashi/archive/2016/07/11/5591572.html
是一个对系统NSLayoutConstraint进行封装的第三方自动布局框架，采用链
式编程的方式提供给开发者API
UIView的对象可以直接调用mas_makeConstraints方法来为相应的View对
象添加约束。因为mas_makeConstraints方法位于UIView的
View+MASAdditions类目中，所以UIView的对象可以直接调用。同样在
View+MASAdditions类目还有其他方法供UIView的对象使用
MASViewAttribute这个类名中我们就能看出，这个类是对UIView和
NSLayoutAttribute的封装。使用等式来表示就是MASViewAttribute = 
UIView + NSLayoutAttribute + item。在MASViewAttribute类中
的view属性表示所约束的对象，而item就是该对象上可以被约束的部分。
MASViewConstraint做的最核心的一件事情就是初始化
NSLayoutConstriant对象，并将该对象添加在相应的视图上
MASConstraintMaker类。该类就是一个工厂类，负责创建MASConstraint
类型的对象（依赖于MASConstraint接口，而不依赖于具体实现）
</code></pre>
<h2 id="圆角性能问题"><a href="#圆角性能问题" class="headerlink" title="圆角性能问题"></a>圆角性能问题</h2><pre><code>OpenGL中，GPU屏幕渲染有以下两种方式：
On-Screen Rendering
意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。
Off-Screen Rendering
意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。
相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：
创建新缓冲区
要想进行离屏渲染，首先要创建一个新的缓冲区。
上下文切换
离屏渲染触发方式
设置了以下属性时，都会触发离屏绘制：
shouldRasterize（光栅化）
masks（遮罩）
shadows（阴影）
edge antialiasing（抗锯齿）
group opacity（不透明）
实现圆角cornerRadius要比mask高效很多。
方案：
直接使用setCornerRadius
这种就是最常用的，也是最耗性能的。
setCornerRadius设置圆角之后，shouldRasterize=YES光栅化
avatarImageView.clipsToBounds = YES;
[avatarImageView.layer setCornerRadius:50];
avatarImageView.layer.shouldRasterize = YES;
avatarImageViewUrl.layer.rasterizationScale=[UIScreen mainScreen].scale;
直接覆盖一张中间为圆形透明的图片（推荐使用）
这种方法就是多加了一张透明的图片，GPU计算多层的混合渲染blending也是会消耗一点性能的，但比第一种方法还是好上很多的。
Core Graphics绘制圆角
这种方式GPU损耗最低，但是UIButton上不知道怎么绘制，可以用UIimageView添加个点击手势当做UIButton使用。
可以用Instruments的 GPU Driver进行测试：
</code></pre>
<h2 id="Target-Action-设计模式"><a href="#Target-Action-设计模式" class="headerlink" title="Target-Action 设计模式"></a>Target-Action 设计模式</h2><pre><code>Target-Action，意为 目标-行为，行为即要调用的方法，目标即消息的接收
对象（Objective-C 语言使用消息机制，类似但不同于方法调用，该两种概
念可能未来会进行探讨）。整个过程为：用户点击按钮，触发某事件发生，该消
息由按钮传到另外的接收对象，接收对象再做相应处理。接收对象可以为任何对
象，但通常为控制器
[self.btnCooking addTarget:self    
action:@selector(pressCooking:) 
forControlEvents:UIControlEventTouchUpInside];
1、self 指目标对象为当前对象，及WViewController； 
2、action 即 在目标对象上的点击方法； 
3、何时调用该方法，UIControlEventTouchUpInside即单击时。 
</code></pre>
<h2 id="layer与view的区别"><a href="#layer与view的区别" class="headerlink" title="layer与view的区别"></a>layer与view的区别</h2><pre><code>UIView相比CALayer最大区别是UIView可以响应用户事件，
而CALayer不可以。UIView侧重于对显示内容的管理，CALayer侧重于对内
容的绘制。
UIView的继承结构为: UIResponder : NSObject。 
UIResponder是用来响应事件的，也就是UIView可以响应用户事件。
CALayer的继承结构为： NSObject。 
直接从 NSObject继承，因为缺少了UIResponder类，所以CALayer悲催的
不能响应任何用户事件。 
CALayer定义了position、size、transform、animations 等基本属
性。
View和CALayer的Frame映射及View如何创建CALayer.
一个 Layer 的 frame 是由它的 anchorPoint,position,bounds,和 
transform 共同决定的，而一个 View 的 frame 只是简单的返回 Layer
的 frame，同样 View 的 center和 bounds 也是返回 Layer 的一些属
性。
</code></pre>
<h2 id="viewController-push生命周期"><a href="#viewController-push生命周期" class="headerlink" title="viewController push生命周期"></a>viewController push生命周期</h2><pre><code>------------------------PUSH---------------------------
A-willDisappear --&gt; B-willAppear --&gt; A-didDisappear --&gt; B-didAppear
---------------------NormalPresent---------------------
A-willDisappear --&gt; B-willAppear --&gt; B-didAppear --&gt; A-didDisappear
-----------------------TabBar切换------------------------
B-willAppear --&gt; A-willDisappear --&gt; A-didDisappear --&gt; B-didAppear
</code></pre>
<h2 id="轮播图实现原理"><a href="#轮播图实现原理" class="headerlink" title="轮播图实现原理"></a>轮播图实现原理</h2><pre><code>第一种：基于collectionView进行的封装（推荐）
这种方式应该是实现起来最简单的一种方式了，也是个人最喜欢的一种封装方
式。它的原理就是几个collectionView，至于无限轮播，很简单，只需要你
的轮播数组给collectionView赋值的时候乘以一个较大的数字即可（例如
100），collectionView本身处理了重用等一系列问题。
第二种：基于scrollView的无限轮播（首尾各多创建一个展示图片的
ImageView）
这种实现方式个人感觉是最麻烦，而且还需要考虑重用等性能问题的一种。基本
的原理就是在根据你轮播数组的个数在首尾各多创建一个ImageView，当然首
位之前多创建一个展示轮播数组最后一个的ImageView，而尾部多创建一个展
示轮播数组第一个的ImageView。
第三种：同样是基于scrollView的无限轮播（总共就创建三个ImageView）
这种实现方式比第二种的好处就是不需要考虑重用问题，不论数组是多少个轮播
图，我只创建三个ImageView。它与第二种的不同之处是其实用户每次看到的
一直都是中间那张的ImageView,只是上边的内容改变了。其内部实现其实是在
不断的改变那个轮播数组。    
</code></pre>
<h2 id="xib的约束，拖出线后系统默认为什么是weak"><a href="#xib的约束，拖出线后系统默认为什么是weak" class="headerlink" title="xib的约束，拖出线后系统默认为什么是weak"></a>xib的约束，拖出线后系统默认为什么是weak</h2><pre><code>IBOutlet的属性一般可以设为weak是因为它已经被view引用了，除非view
被释放，否则IBOutlet的属性也不会被释放，另外IBOutlet属性的生命周期
和view应该是一致的，所以IBOutlet属性一般设为weak。
从storyboard或者xib上创建控件，在控件放在view上的时候，已经形成了
如下的引用关系,以UIButton为例：
UIViewController-&gt;UIView-&gt;subView-&gt;UIButton
然后你为这个UIButton声明一个weak属性
@property(nonatomic,weak) IBOOutlet UIButton *btn;
相当于xib/sb对这个Button是强引用，你声明的属性对它是弱引用。
</code></pre>
<h2 id="label只设置上和左的约束正常，UIview这样设置为什么会有约束警告"><a href="#label只设置上和左的约束正常，UIview这样设置为什么会有约束警告" class="headerlink" title="label只设置上和左的约束正常，UIview这样设置为什么会有约束警告"></a>label只设置上和左的约束正常，UIview这样设置为什么会有约束警告</h2><pre><code>大概意思是并不是所有的View都有Intrinsic Content Size,而拥有
Intrinsic Content Size的view有这样的特征：它们可以根据view中的
内容来确定view的size。例如Button，我们可以不用指定它们已经计算好的
size，只需要指定position即可。在Masonry中，UIButton的布局我们可
以这样子写：
Content Compression Resistance即为抗压缩阻力，而Content 
Hugging即为抗拉伸阻力
View    Intrinsic content size
UIView and NSView    No intrinsic content size.
Sliders    Defines only the width (iOS).
Labels, buttons, switches, and text fields    Defines both the height and the width.
Text views and image views    Intrinsic content size can vary.
</code></pre>
<h2 id="position与anchorPoint"><a href="#position与anchorPoint" class="headerlink" title="position与anchorPoint"></a>position与anchorPoint</h2><pre><code>每一个UIView内部都默认关联着一个CALayer, UIView有frame、bounds
和center三个属性，CALayer也有类似的属性，分别为frame、bounds、
position、anchorPoint。frame和bounds比较好理解，bounds可以视为
x坐标和y坐标都为0的frame，那position、anchorPoint是什么呢？先看
看两者的原型，可知都是CGPoint点。
position是layer中的anchorPoint点在superLayer中的位置坐标。因此
可以说, position点是相对suerLayer的，anchorPoint点是相对layer
的，两者是相对不同的坐标空间的一个重合点。
总结
1、position是layer中的anchorPoint在superLayer中的位置坐标。 
2、互不影响原则：单独修改position与anchorPoint中任何一个属性都不
影响另一个属性。
anchorPoint 是相对于自身的位置，而 position 是相对于父图层的，改
变 anchorPoint 只是更改了图层自身旋转地位置，但始终还是要通过改变 
frame 使 anchorPoint 和 position 重合
</code></pre>
<h2 id="显示动画和隐式动画区别"><a href="#显示动画和隐式动画区别" class="headerlink" title="显示动画和隐式动画区别"></a>显示动画和隐式动画区别</h2><pre><code>显式动画是指用户自己通过beginAnimations:context:和
commitAnimations创建的动画。    
隐式动画是指通过UIView的animateWithDuration:animations:方法创
建的动画。
区别就是使用隐式动画后，View会暂时不能接收用户的触摸、滑动等手势。这
就造成了当一个列表滚动时，如果对其中的view使用了隐式动画，就会感觉滚
动无法主动停止下来，必须等动画结束了才能停止。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">365</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
