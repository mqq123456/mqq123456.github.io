<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift147%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift147%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:38" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:38+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字母异位词"><a href="#字母异位词" class="headerlink" title="字母异位词"></a>字母异位词</h2><pre><code>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;
输出: true
方法一：排序
public boolean isAnagram(String s, String t) &#123;
    if (s.length() != t.length()) &#123;
        return false;
    &#125;
    char[] str1 = s.toCharArray();
    char[] str2 = t.toCharArray();
    Arrays.sort(str1);
    Arrays.sort(str2);
    return Arrays.equals(str1, str2);
&#125;
方法二：哈希表
public boolean isAnagram(String s, String t) &#123;
    if (s.length() != t.length()) &#123;
        return false;
    &#125;
    int[] counter = new int[26];
    for (int i = 0; i &lt; s.length(); i++) &#123;
        counter[s.charAt(i) - &#39;a&#39;]++;
        counter[t.charAt(i) - &#39;a&#39;]--;
    &#125;
    for (int count : counter) &#123;
        if (count != 0) &#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;
</code></pre>
<h2 id="是否可以被空格拆分为一个或多个"><a href="#是否可以被空格拆分为一个或多个" class="headerlink" title="是否可以被空格拆分为一个或多个"></a>是否可以被空格拆分为一个或多个</h2><pre><code>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
输出: true
解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。
public class Solution &#123;
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;
        Set&lt;String&gt; wordDictSet = new HashSet(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i &lt;= s.length(); i++) &#123;
            for (int j = 0; j &lt; i; j++) &#123;
                if (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;
                    dp[i] = true;
                    break;
                &#125;
            &#125;
        &#125;
        return dp[s.length()];
    &#125;
&#125;
</code></pre>
<h2 id="实现一个-Trie-前缀树"><a href="#实现一个-Trie-前缀树" class="headerlink" title="实现一个 Trie (前缀树)"></a>实现一个 Trie (前缀树)</h2><pre><code>包含 insert, search, 和 startsWith 这三个操作
class Trie &#123;
    private TrieNode root;

public Trie() &#123;
    root = new TrieNode();
&#125;

public void insert(String word) &#123;
    TrieNode node = root;
    for (int i = 0; i &lt; word.length(); i++) &#123;
        char currentChar = word.charAt(i);
        if (!node.containsKey(currentChar)) &#123;
            node.put(currentChar, new TrieNode());
        &#125;
        node = node.get(currentChar);
    &#125;
    node.setEnd();
&#125;
private TrieNode searchPrefix(String word) &#123;
    TrieNode node = root;
    for (int i = 0; i &lt; word.length(); i++) &#123;
       char curLetter = word.charAt(i);
       if (node.containsKey(curLetter)) &#123;
           node = node.get(curLetter);
       &#125; else &#123;
           return null;
       &#125;
    &#125;
    return node;
&#125;
public boolean search(String word) &#123;
   TrieNode node = searchPrefix(word);
   return node != null &amp;&amp; node.isEnd();
&#125;
public boolean startsWith(String prefix) &#123;
    TrieNode node = searchPrefix(prefix);
    return node != null;
&#125;

&#125;
</code></pre>
<h2 id="第一个不重复的字符"><a href="#第一个不重复的字符" class="headerlink" title="第一个不重复的字符"></a>第一个不重复的字符</h2><pre><code>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
方法一： 线性时间复杂度解法
class Solution &#123;
    public int firstUniqChar(String s) &#123;
        HashMap&lt;Character, Integer&gt; count = new HashMap&lt;Character, Integer&gt;();
        int n = s.length();
        // build hash map : character and how often it appears
        for (int i = 0; i &lt; n; i++) &#123;
            char c = s.charAt(i);
            count.put(c, count.getOrDefault(c, 0) + 1);
        &#125;
    
    // find the index
    for (int i = 0; i &lt; n; i++) &#123;
        if (count.get(s.charAt(i)) == 1) 
            return i;
    &#125;
    return -1;
&#125;
&#125;
</code></pre>
<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><pre><code>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
双指针
class Solution &#123;
    public void reverseString(char[] s) &#123;
        if(s == null || s.length == 0) return;

    int left = 0;
    int right = s.length-1;
    while(left &lt; right)&#123;  //奇数个的时候中间元素不动
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        left ++;
        right --;
    &#125;
&#125;
&#125;
</code></pre>
<h2 id="回文串验证"><a href="#回文串验证" class="headerlink" title="回文串验证"></a>回文串验证</h2><pre><code>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
方法一：筛选 + 判断
最简单的方法是对字符串 s 进行一次遍历，并将其中的字母和数字字符进行保留
判断的方法有两种。一种是将字符串进行翻转，然后判断字符串是不是相同，第二种是使用双指针
class Solution &#123;
    public boolean isPalindrome(String s) &#123;
        StringBuffer sgood = new StringBuffer();
        int length = s.length();
        for (int i = 0; i &lt; length; i++) &#123;
            char ch = s.charAt(i);
            if (Character.isLetterOrDigit(ch)) &#123;
                sgood.append(Character.toLowerCase(ch));
            &#125;
        &#125;
        StringBuffer sgood_rev = new StringBuffer(sgood).reverse();
        return sgood.toString().equals(sgood_rev.toString());
    &#125;
&#125;
</code></pre>
<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><pre><code>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。
本题做法较多，本文主要介绍 “字符串切片” ， “列表遍历拼接” ， “字符串遍历拼接” 三种方法。
由于本题的多解法涉及到了 字符串为不可变对象 的相关概念，导致效率区别较大。因此，单列一节 三种方法的效率分析 ，望对各位有所帮助。
方法一：字符串切片
class Solution &#123;
    public String reverseLeftWords(String s, int n) &#123;
        return s.substring(n, s.length()) + s.substring(0, n);
    &#125;
&#125;
方法二：列表遍历拼接
class Solution &#123;
    public String reverseLeftWords(String s, int n) &#123;
        StringBuilder res = new StringBuilder();
        for(int i = n; i &lt; s.length(); i++)
            res.append(s.charAt(i));
        for(int i = 0; i &lt; n; i++)
            res.append(s.charAt(i));
        return res.toString();
    &#125;
&#125;
方法三：字符串遍历拼接
class Solution &#123;
    public String reverseLeftWords(String s, int n) &#123;
        String res = &quot;&quot;;
        for(int i = n; i &lt; s.length(); i++)
            res += s.charAt(i);
        for(int i = 0; i &lt; n; i++)
            res += s.charAt(i);
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h2><pre><code>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。

方法一：双指针
class Solution &#123;
public String reverseWords(String s) &#123;
    s = s.trim(); // 删除首尾空格
    int j = s.length() - 1, i = j;
    StringBuilder res = new StringBuilder();
    while(i &gt;= 0) &#123;
        while(i &gt;= 0 &amp;&amp; s.charAt(i) != &#39; &#39;) i--; // 搜索首个空格
        res.append(s.substring(i + 1, j + 1) + &quot; &quot;); // 添加单词
        while(i &gt;= 0 &amp;&amp; s.charAt(i) == &#39; &#39;) i--; // 跳过单词间空格
        j = i; // j 指向下个单词的尾字符
    &#125;
    return res.toString().trim(); // 转化为字符串并返回
&#125;
&#125;
方法二：分割 + 倒序
class Solution &#123;
    public String reverseWords(String s) &#123;
        String[] strs = s.trim().split(&quot; &quot;); // 删除首尾空格，分割字符串
        StringBuilder res = new StringBuilder();
        for(int i = strs.length - 1; i &gt;= 0; i--) &#123; // 倒序遍历单词列表
            if(strs[i].equals(&quot;&quot;)) continue; // 遇到空单词则跳过
            res.append(strs[i] + &quot; &quot;); // 将单词拼接至 StringBuilder
        &#125;
        return res.toString().trim(); // 转化为字符串，删除尾部空格，并返回
    &#125;
&#125;
</code></pre>
<h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><pre><code>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
方法一：动态规划 + 哈希表
class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        Map&lt;Character, Integer&gt; dic = new HashMap&lt;&gt;();
        int res = 0, tmp = 0;
        for(int j = 0; j &lt; s.length(); j++) &#123;
            int i = dic.getOrDefault(s.charAt(j), -1); // 获取索引 i
            dic.put(s.charAt(j), j); // 更新哈希表
            tmp = tmp &lt; j - i ? tmp + 1 : j - i; // dp[j - 1] -&gt; dp[j]
            res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
        &#125;
        return res;
    &#125;
&#125;
方法二： 动态规划 + 线性遍历
class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        Map&lt;Character, Integer&gt; dic = new HashMap&lt;&gt;();
        int res = 0, tmp = 0;
        for(int j = 0; j &lt; s.length(); j++) &#123;
            int i = j - 1;
            while(i &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j)) i--; // 线性查找 i
            tmp = tmp &lt; j - i ? tmp + 1 : j - i; // dp[j - 1] -&gt; dp[j]
            res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
        &#125;
        return res;
    &#125;
&#125;
方法三：双指针 + 哈希表
class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        Map&lt;Character, Integer&gt; dic = new HashMap&lt;&gt;();
        int i = -1, res = 0;
        for(int j = 0; j &lt; s.length(); j++) &#123;
            if(dic.containsKey(s.charAt(j)))
                i = Math.max(i, dic.get(s.charAt(j))); // 更新左指针 i
            dic.put(s.charAt(j), j); // 哈希表记录
            res = Math.max(res, j - i); // 更新结果
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h2><pre><code>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
字符串的第 i 位置：

可以单独作为一位来翻译
如果第 i−1 位和第 i 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译
class Solution &#123;
    public int translateNum(int num) &#123;
        String src = String.valueOf(num);
        int p = 0, q = 0, r = 1;
        for (int i = 0; i &lt; src.length(); ++i) &#123;
            p = q; 
            q = r; 
            r = 0;
            r += q;
            if (i == 0) &#123;
                continue;
            &#125;
            String pre = src.substring(i - 1, i + 1);
            if (pre.compareTo(&quot;25&quot;) &lt;= 0 &amp;&amp; pre.compareTo(&quot;10&quot;) &gt;= 0) &#123;
                r += p;
            &#125;
        &#125;
        return r;
    &#125;
&#125;
</code></pre>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><pre><code>    将字符串转成char的数组，声明一个3倍长度的数组，遍历字符串数组当为空格时，添加%20
输入：s = &quot;We are happy.&quot;
    输出：&quot;We%20are%20happy.&quot;
    由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。
    public String replaceSpace(String s) &#123;
        int length = s.length();
        char[] array = new char[length * 3];
        int size = 0;
        for (int i = 0; i &lt; length; i++) &#123;
            char c = s.charAt(i);
            if (c == &#39; &#39;) &#123;
                array[size++] = &#39;%&#39;;
                array[size++] = &#39;2&#39;;
                array[size++] = &#39;0&#39;;
            &#125; else &#123;
                array[size++] = c;
            &#125;
        &#125;
        String newStr = new String(array, 0, size);
        return newStr;
    &#125;
</code></pre>
<h2 id="字符串的排列组合方式（决策树）"><a href="#字符串的排列组合方式（决策树）" class="headerlink" title="字符串的排列组合方式（决策树）"></a>字符串的排列组合方式（决策树）</h2><pre><code>class Solution &#123;
    List&lt;String&gt; res = new LinkedList&lt;&gt;();
    char[] c;
    public String[] permutation(String s) &#123;
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    &#125;
    void dfs(int x) &#123;
        if(x == c.length - 1) &#123;
            res.add(String.valueOf(c)); // 添加排列方案
            return;
        &#125;
        HashSet&lt;Character&gt; set = new HashSet&lt;&gt;();
        for(int i = x; i &lt; c.length; i++) &#123;
            if(set.contains(c[i])) continue; // 重复，因此剪枝
            set.add(c[i]);
            swap(i, x); // 交换，将 c[i] 固定在第 x 位 
            dfs(x + 1); // 开启固定第 x + 1 位字符
            swap(i, x); // 恢复交换
        &#125;
    &#125;
    void swap(int a, int b) &#123;
        char tmp = c[a];
        c[a] = c[b];
        c[b] = tmp;
    &#125;
&#125;
</code></pre>
<h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><pre><code>首部空格： 删除之即可；
符号位： 三种情况，即 &#39;+&#39;−&#39;&#39; , &#39;&#39;无符号&quot; ；新建一个变量保存符号位，返回前判断正负即可。
非数字字符： 遇到首个非数字的字符时，应立即返回。
数字字符：
class Solution &#123;
    public int strToInt(String str) &#123;
        char[] c = str.trim().toCharArray();
        if(c.length == 0) return 0;
        int res = 0, bndry = Integer.MAX_VALUE / 10;
        int i = 1, sign = 1;
        if(c[0] == &#39;-&#39;) sign = -1;
        else if(c[0] != &#39;+&#39;) i = 0;
        for(int j = i; j &lt; c.length; j++) &#123;
            if(c[j] &lt; &#39;0&#39; || c[j] &gt; &#39;9&#39;) break;
            if(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; &#39;7&#39;) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            res = res * 10 + (c[j] - &#39;0&#39;);
        &#125;
        return sign * res;
    &#125;
&#125;
</code></pre>
<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><pre><code>输入：&quot;aabcccccaaa&quot;
输出：&quot;a2b1c5a3&quot;
public String compressString(String S) &#123;
    int N = S.length();
    int i = 0;
    StringBuilder sb = new StringBuilder();
    while (i &lt; N) &#123;
        int j = i;
        while (j &lt; N &amp;&amp; S.charAt(j) == S.charAt(i)) &#123;
            j++;
        &#125;
        sb.append(S.charAt(i));
        sb.append(j - i);
        i = j;
    &#125;

String res = sb.toString();
if (res.length() &lt; S.length()) &#123;
    return res;
&#125; else &#123;
    return S;
&#125;
&#125;
</code></pre>
<h2 id="无重复子串最大长度"><a href="#无重复子串最大长度" class="headerlink" title="无重复子串最大长度"></a>无重复子串最大长度</h2><pre><code>int lengthOfLongestSubstring(string s) &#123;
        // 哈希集合，记录每个字符是否出现过
        unordered_set&lt;char&gt; occ;
        int n = s.size();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        // 枚举左指针的位置，初始值隐性地表示为 -1
        for (int i = 0; i &lt; n; ++i) &#123;
            if (i != 0) &#123;
                // 左指针向右移动一格，移除一个字符
                occ.erase(s[i - 1]);
            &#125;
            while (rk + 1 &lt; n &amp;&amp; !occ.count(s[rk + 1])) &#123;
                // 不断地移动右指针
                occ.insert(s[rk + 1]);
                ++rk;
            &#125;
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1);
        &#125;
        return ans;
    &#125;
</code></pre>
<h2 id="最大上升子序列"><a href="#最大上升子序列" class="headerlink" title="最大上升子序列"></a>最大上升子序列</h2><pre><code>思想：
创建一个额外的数组，用于存放字串到当前位置的最大值
遍历数组，每次都和之前的数进行比较，获取最大字串，然后加1，
public int lengthOfLIS(int[] nums) &#123;
   if (nums.length == 0) &#123;
       return 0;
   &#125;
   int[] dp = new int[nums.length]; // 创建一个额外的数组，用于存放字串到当前位置的最大值
   dp[0] = 1; // 默认为1
   int maxans = 1;
   for (int i = 1; i &lt; dp.length; i++) &#123;
       int maxval = 0;
       for (int j = 0; j &lt; i; j++) &#123;
           if (nums[i] &gt; nums[j]) &#123; 
               maxval = Math.max(maxval, dp[j]); // 比较dp中值和mavl的值，取最大值
           &#125;
       &#125;
       dp[i] = maxval + 1; // 当前值加1
       maxans = Math.max(maxans, dp[i]);
   &#125;
   return maxans;
   &#125;
</code></pre>
<h2 id="字符串查找问题；"><a href="#字符串查找问题；" class="headerlink" title="字符串查找问题；"></a>字符串查找问题；</h2><pre><code>字符串查找问题---长字符串查找短字符串
String 1: ABCDEFGHLMNOPQRS
String 2: DCGSRQPOM
答案是true，所有在string2里的字母string1也都有。
解法，HashTable
查找某个字符或字符段在字符串中出现的次数
给一个数组，找出这样一些数，这个数左边的数都比它小，右边的数都比它大
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
1.双重遍历，两两相加
2.生成一个map集合，然后遍历nums，用target - nums 在map集合中是否存在，如果存在，则找到了
3.跟第二个相似，一次遍历，添加到map中的是target - nums[i] ,只要后续遍历中存在这样的key，就是找到了
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。
    新建一个数组，将元素插入到数组的对应位置，如果大于数组id直接舍弃，不存在的位置用0代替，范围位置id
寻找两个数组的中位数，排好序
分析：分治+二分查找
在两个有序数组中寻找k小的数
获取中位数的位置，两个数组和的一半
剪枝处理
特殊情况
分析完了正常的情况，那么就要分析一下特殊情况；
  1)如果有一个数组是空的，直接返回另一个不为空的数组中的中位数
  2)如果两个数组元素的个数相等，并且两个数组的中位数相等，直接返回其中一个中位数。
  3)有可能在进行二分查找的时候出现了数组越界的情况，只需要定义一个最大值和一个最小值，这样可以按照正常的情况来处理了。

double findMedianSortedArrays(int nums1[], int nums2[])&#123;
int m = m1.length;
int n = m2.length;
int k = (m+n) / 2;

if((m+n) %2 == 1)&#123;
return findKth(nums1,0,m-1,nums2,0,n-1,k+1);
&#125;else&#123;
    return (findKth(nums1,0,m-1,nums2,0,n-1,k)+
    findKth(nums1,0,m-1,nums2,0,n-1,k+1))/2.0
&#125;
&#125;

double findKth(int[] nums1,int l1,int h1,int[] nums2,int l2,int h2,int k)&#123;
int m = h1-l1+1;
int n = h2-l2+1;
if(m &gt;n) &#123;
return findKth(nums2,l2,h2,nums1,l1,h1,k);
&#125;
if(m==0) &#123;
return nums2[l2+k-1];
&#125;
&#125;


/*分清 起始位置 和 第几个元素 */
int findKthNumber(vector&lt;int&gt;&amp; nums1,int i ,vector&lt;int&gt;&amp; nums2,int j,int k)&#123;
    if(i &gt;= nums1.size())   return nums2[j+k-1];
    if(j &gt;= nums2.size())   return nums1[i+k-1];
    //if(k ==1) return (double(nums1[i] + nums2[j]));wrong
    if(k == 1) return min(nums1[i],nums2[j]);
    //查找有没有k/2个元素的位置     i + k/2 -1 
    int midVal1 = (i+k/2-1 &lt; nums1.size())?nums1[i+k/2-1]:INT_MAX;
    int midVal2 = (j+k/2-1 &lt; nums2.size())?nums2[j+k/2-1]:INT_MAX;
    if(midVal1 &lt; midVal2)
        return findKthNumber(nums1,i+k/2,nums2,j,k-k/2);
    else
        return findKthNumber(nums1,i,nums2,j+k/2,k-k/2);  
&#125;
class Solution &#123;
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        int m = nums1.size(),n = nums2.size();
        int left = (m+n+1)/2,right = (m+n+2)/2;
        return        (findKthNumber(nums1,0,nums2,0,left)+findKthNumber(nums1,0,nums2,0,right))/2.0;
    &#125;

&#125;
如果没有排序
快速选择算法
随机选择一个数作为基准值，以基准值分成两个部分
如果基准值==k，那么基准值位置就是k
如果基准值小于k，就忘后搜索
如果基准值大于k，就往前搜索

public  int findKthLargest(int[] nums, int k)&#123;
    return quickSelect(nums,nums.length - 1,k);
&#125;
int quickSelect(int[] nums,int low,int high,int k) &#123;
    int pivot = low;
    for (int j = low; j &lt; hight ; j++) &#123;
        if (nums[j] &lt;= nums[high]) &#123;
        swap(nums,pivot++,j);
    &#125;
    &#125;
    swap(nums,pivot,high);
&#125;
void swap(int[] nums1, int[] nums2,int i, int j) &#123;
int m = num.length;
if(i&lt;m&amp;&amp;j&lt;m)&#123;
swap(nums1,i,j);
&#125;else if(i &gt;=m &amp;&amp; j&gt;=m)&#123;
swap(nums2,i-m,j-m)
&#125;else if (i &lt;m &amp;&amp; j &gt;= m) &#123;
int temp = nums1[i];
nums1[1] = nums2[j-m];
nums2[j-m] = temp;
&#125;
&#125;
void swap (int[] nums, int i, int j) &#123;
int temp = nums[i];
nums[i] = nums[j];
nums[j] = temp;
&#125;
分布式大数据问题
每台服务器的复杂度限制
服务器之间通信的网络带宽限时
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift146%E6%A0%88%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift146%E6%A0%88%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:33" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:33+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><pre><code>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
可通过建立辅助栈实现，栈A用于存储所有元素，栈B中中存储栈 A中非严格降序 的元素，栈A中最小元素始终位于栈B的顶端
Stack&lt;Integer&gt; A, B;
    public MinStack() &#123;
        A = new Stack&lt;&gt;();
        B = new Stack&lt;&gt;();
    &#125;
    public void push(int x) &#123;
        A.add(x);
        if(B.empty() || B.peek() &gt;= x)
            B.add(x);
    &#125;
    public void pop() &#123;
        if(A.pop().equals(B.peek()))
            B.pop();
    &#125;
    public int top() &#123;
        return A.peek();
    &#125;
    public int min() &#123;
        return B.peek();
    &#125;
</code></pre>
<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><pre><code>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
输入：
[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[3],[],[]]
输出：[null,null,3,-1]
class CQueue &#123;
    Deque&lt;Integer&gt; stack1;
    Deque&lt;Integer&gt; stack2;

public CQueue() &#123;
    stack1 = new LinkedList&lt;Integer&gt;();
    stack2 = new LinkedList&lt;Integer&gt;();
&#125;

public void appendTail(int value) &#123;
    stack1.push(value);
&#125;

public int deleteHead() &#123;
    // 如果第二个栈为空
    if (stack2.isEmpty()) &#123;
        while (!stack1.isEmpty()) &#123;
            stack2.push(stack1.pop());
        &#125;
    &#125; 
    if (stack2.isEmpty()) &#123;
        return -1;
    &#125; else &#123;
        int deleteItem = stack2.pop();
        return deleteItem;
    &#125;
&#125;
</code></pre>
<p>}</p>
<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><pre><code>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。
考虑借用一个辅助栈 stack ，模拟 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。
 public boolean validateStackSequences(int[] pushed, int[] popped) &#123;
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int i = 0;
        for(int num : pushed) &#123;
            stack.push(num); // num 入栈
            while(!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) &#123; // 循环判断与出栈
                stack.pop();
                i++;
            &#125;
        &#125;
        return stack.isEmpty();
    &#125;
</code></pre>
<h2 id="栈排序"><a href="#栈排序" class="headerlink" title="栈排序"></a>栈排序</h2><pre><code>对栈进行排序使最小元素位于栈顶
用一个辅助栈

class SortedStack &#123;

private Stack&lt;Integer&gt; data = new Stack&lt;&gt;();
private Stack&lt;Integer&gt; help = new Stack&lt;&gt;();

public SortedStack() &#123;
    super();
&#125;

public void push(int val) &#123;
    if(isEmpty()) &#123; // 如果data ，没有数据，添加数据，添加help中数据
        data.push(val);
        while(!help.isEmpty()) &#123;
            data.push(help.pop());
        &#125;
    &#125; else &#123; // 获取data 顶部元素。比较大小，如果大于，那么添加元素，否则help添加元素
        int top = peek();
        if(top &gt;= val) &#123;
            data.push(val);
            while(!help.isEmpty()) &#123;
                data.push(help.pop());
            &#125;
        &#125; else &#123;
            help.push(data.pop());
            push(val);
        &#125;
    &#125;
&#125;

public void pop() &#123;
    if(!isEmpty()) &#123;
        data.pop();
    &#125;
&#125;

public int peek() &#123;
    if(isEmpty()) &#123;
        return -1;
    &#125; else &#123;
        return data.peek();
    &#125;
&#125;

public boolean isEmpty() &#123;
    return data.isEmpty();
&#125;
&#125;
</code></pre>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><pre><code>class MyStack &#123;
           private Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();
           private Queue&lt;Integer&gt; q2 = new LinkedList&lt;&gt;();
           int top = 0;
           MyStack() &#123;
           &#125;
           public void push(int x) &#123;
               q1.add(x);
               top = x;
           &#125;
           public int pop() &#123;
                while (q1.size() &gt; 1) &#123;
                       top = q1.remove();
                       q2.add(top);
               &#125;
               int a = q1.remove();
               Queue&lt;Integer&gt; temp = q1;
               q1 = q2;  
               q2 = temp;
               return a;
           &#125;
           public int top() &#123;
               return top;
           &#125;
           public boolean empty() &#123;
               return q1.isEmpty();
           &#125;
&#125;;
</code></pre>
<h2 id="三合一"><a href="#三合一" class="headerlink" title="三合一"></a>三合一</h2><pre><code>描述如何只用一个数组来实现三个栈。
首先要构建数组，3倍长度的size
然后让另一个3的数组，存放和管理下标
然后在根据结构分析
class TripleInOne &#123;

int[] a;
int[] tt = new int[3];
int size;
public TripleInOne(int statckSize)&#123;
    a = new int[3 * statckSize + 10];
    size = statckSize;
    for(int i = 0; i &lt; 3; i++)&#123;
        tt[i] = i * statckSize - 1;
    &#125;
&#125;

public boolean isFull(int stackNum)&#123;
    return tt[stackNum] &gt;= size * (stackNum + 1) - 1;

&#125;

public void push(int stackNum, int value)&#123;
    if(isFull(stackNum))    return;
    a[++tt[stackNum]] = value;
&#125;

public int pop(int stackNum)&#123;
    if(isEmpty(stackNum)) return -1;
    tt[stackNum]--;
    return a[tt[stackNum] + 1];
&#125;

public int peek(int stackNum)&#123;
    if(isEmpty(stackNum))   return -1;
    return a[tt[stackNum]];
&#125;

public boolean isEmpty(int stackNum)&#123;
    return tt[stackNum] &lt; stackNum * size;
&#125;
</code></pre>
<p>}</p>
<h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><pre><code>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
解题思路：递归与分治
    public void hanota(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) &#123;
        hanoi(A.size(), A, B, C);
    &#125;

public void hanoi(int n, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)&#123;
    
    if(n == 1)&#123;
        C.add(A.get(A.size() - 1));
        A.remove(A.size() - 1);
    &#125;else&#123;
        //把A经过辅助C放到B上
        hanoi(n - 1, A, C, B);
        //把A放到C上
        C.add(A.get(A.size() - 1));
        A.remove(A.size() - 1);
        //把B经过辅助A放到C上
        hanoi(n - 1, B, A, C);
    &#125;
&#125;
</code></pre>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="用两个栈实现队列-1"><a href="#用两个栈实现队列-1" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><pre><code>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
输入：
[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[3],[],[]]
输出：[null,null,3,-1]
class CQueue &#123;
    Deque&lt;Integer&gt; stack1;
    Deque&lt;Integer&gt; stack2;

public CQueue() &#123;
    stack1 = new LinkedList&lt;Integer&gt;();
    stack2 = new LinkedList&lt;Integer&gt;();
&#125;

public void appendTail(int value) &#123;
    stack1.push(value);
&#125;

public int deleteHead() &#123;
    // 如果第二个栈为空
    if (stack2.isEmpty()) &#123;
        while (!stack1.isEmpty()) &#123;
            stack2.push(stack1.pop());
        &#125;
    &#125; 
    if (stack2.isEmpty()) &#123;
        return -1;
    &#125; else &#123;
        int deleteItem = stack2.pop();
        return deleteItem;
    &#125;
&#125;
&#125;
</code></pre>
<h2 id="数据流中的中位数-（优先队列）"><a href="#数据流中的中位数-（优先队列）" class="headerlink" title="数据流中的中位数  （优先队列）"></a>数据流中的中位数  （优先队列）</h2><pre><code>优先队列 / 堆， 小顶堆，保存较大的一半， 大顶堆，保存较小的一半，堆顶的平均数即为中位数
    class MedianFinder &#123;
    Queue&lt;Integer&gt; A, B;
    public MedianFinder() &#123;
        A = new PriorityQueue&lt;&gt;(); // 小顶堆，保存较大的一半
        B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，保存较小的一半
    &#125;
    public void addNum(int num) &#123;
        if(A.size() != B.size()) &#123;
            A.add(num);
            B.add(A.poll());
        &#125; else &#123;
            B.add(num);
            A.add(B.poll());
        &#125;
    &#125;
    public double findMedian() &#123;
        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;
    &#125;
&#125;
</code></pre>
<h2 id="滑动窗口的最大值-单调队列"><a href="#滑动窗口的最大值-单调队列" class="headerlink" title="滑动窗口的最大值  单调队列"></a>滑动窗口的最大值  单调队列</h2><pre><code>    我们维护一个单调的双向队列，窗口在每次滑动的时候，我就从队列头部取当前窗口中的最大值，每次窗口新进来一个元素的时候，我就将它与队列中的元素进行大小比较
    如果刚刚进来的元素比队列的尾部元素大，那么先将队列尾部的元素弹出，然后把刚刚进来的元素添到队列的尾部；
    如果刚刚进来的元素比队列的尾部元素小，那么把刚刚进来的元素直接添到队列的尾部即可。
    方法二：构建双端队列
       保持队列大小不超过窗口，以及最大值在出端
       读取新数据，入端操作，和之前的进入的数据比较，之前的数据小则剔除，直到比它大则停止，最大值还在出端
       循环上面步骤，直到结束
       public int[] maxSlidingWindow(int[] nums, int k) &#123;
               if(nums.length == 0 || k == 0) return new int[0];
               Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); // 队列
               int[] res = new int[nums.length - k + 1];
               for(int j = 0, i = 1 - k; j &lt; nums.length; i++, j++) &#123;
                   if(i &gt; 0 &amp;&amp; deque.peekFirst() == nums[i - 1])
                       deque.removeFirst(); // 删除 deque 中对应的 nums[i-1]
                   while(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])
                       deque.removeLast(); // 保持 deque 递减
                   deque.addLast(nums[j]);
                   if(i &gt;= 0)
                       res[i] = deque.peekFirst();  // 记录窗口最大值
               &#125;
               return res;
           &#125;
</code></pre>
<h2 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h2><pre><code>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
方法二：维护一个单调的双端队列
public class MaxQueue &#123;

    Queue&lt;Integer&gt; queue;
    LinkedList&lt;Integer&gt; max;
    public MaxQueue() &#123;
        queue = new LinkedList&lt;&gt;();
        max = new LinkedList&lt;&gt;();//LinkedList是双端链表
    &#125;
    
    public int max_value() &#123;
        return max.size()==0?-1:max.getFirst();
    &#125;
    
    public void push_back(int value) &#123;
        queue.add(value);
        while(max.size()!=0&amp;&amp;max.getLast()&lt;value)&#123;//注意：这里第二个判断条件不能带等号，即max中对于当前queue中的具有相同值的元素会全部存储，而不是存储最近的那个。只添加递增
            max.removeLast();
        &#125;
        max.add(value);
    &#125;
    
    public int pop_front() &#123;
        if(max.size()!=0&amp;&amp;queue.peek().equals(max.getFirst()))//Integer类型的值的比较不能直接使用==
            max.removeFirst();
        return queue.size()==0?-1:queue.poll();
    &#125;
&#125;
</code></pre>
<p>优先队列的主要操作<br>优先队列辅助操作<br>返回优先队列中键值为第k个最小最大的元素<br>返回优先队列的元素个数<br>基于键值的优先级将优先队列的元素进行排序<br>应用</p>
<p>最短路径算法：Dijkstra算法<br>最小生成树算法：Prim算法<br>事件驱动仿真：顾客排队算法<br>选择问题：查找第k个最小元素</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift145%E4%BA%8C%E5%88%86%E5%8F%8A%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift145%E4%BA%8C%E5%88%86%E5%8F%8A%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">二分查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:29" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:29+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h2><p>峰值元素是指其值大于左右相邻值的元素<br>方法一: 线性扫描<br> public int findPeakElement(int[] nums) {<br>        for (int i = 0; i &lt; nums.length - 1; i++) {<br>            if (nums[i] &gt; nums[i + 1])<br>                return i;<br>        }<br>        return nums.length - 1;<br>    }<br>方法二：递归二分查找<br>我们可以将 nums 数组中的任何给定序列视为交替的升序和降序序列。通过利用这一点，以及“可以返回任何一个峰作为结果”的要求，我们可以利用二分查找来找到所需的峰值元素。<br>我们对二分查找进行一点修改。首先从数组 nums 中找到中间的元素 mid若该元素恰好位于降序序列或者一个局部下降坡度中，则说明峰值会在本元素的左边<br>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素<br>public class Solution {<br>    public int findPeakElement(int[] nums) {<br>        return search(nums, 0, nums.length - 1);<br>    }<br>    public int search(int[] nums, int l, int r) {<br>        if (l == r)<br>            return l;<br>        int mid = (l + r) / 2;<br>        if (nums[mid] &gt; nums[mid + 1])<br>            return search(nums, l, mid);<br>        return search(nums, mid + 1, r);<br>    }<br>}</p>
<h2 id="找出这个重复的数"><a href="#找出这个重复的数" class="headerlink" title="找出这个重复的数"></a>找出这个重复的数</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br>方法一：二分查找<br>class Solution {<br>    public int findDuplicate(int[] nums) {<br>        int n = nums.length;<br>        int l = 1, r = n - 1, ans = -1;<br>        while (l &lt;= r) {<br>            int mid = (l + r) &gt;&gt; 1;<br>            int cnt = 0;<br>            for (int i = 0; i &lt; n; ++i) {<br>                if (nums[i] &lt;= mid) {<br>                    cnt++;<br>                }<br>            }<br>            if (cnt &lt;= mid) {<br>                l = mid + 1;<br>            } else {<br>                r = mid - 1;<br>                ans = mid;<br>            }<br>        }<br>        return ans;</p>
<pre><code>&#125;
</code></pre>
<p>}<br>最优<br> int temp;<br>        for(int i=0;i&lt;nums.length;i++){<br>            while (nums[i]!=i){<br>                if(nums[i]==nums[nums[i]]){<br>                    return nums[i];<br>                }<br>                temp=nums[i];<br>                nums[i]=nums[temp];<br>                nums[temp]=temp;<br>            }<br>        }<br>        return -1;</p>
<p>方法二：二进制<br>这个方法我们来将所有数二进制展开按位考虑如何找出重复的数，如果我们能确定重复数每一位是 1 还是 0 就可以按位还原出重复的数是什么。<br>class Solution {<br>    public int findDuplicate(int[] nums) {<br>        int n = nums.length, ans = 0;<br>        int bit_max = 31;<br>        while (((n - 1) &gt;&gt; bit_max) == 0) {<br>            bit_max -= 1;<br>        }<br>        for (int bit = 0; bit &lt;= bit_max; ++bit) {<br>            int x = 0, y = 0;<br>            for (int i = 0; i &lt; n; ++i) {<br>                if ((nums[i] &amp; (1 &lt;&lt; bit)) != 0) {<br>                    x += 1;<br>                }<br>                if (i &gt;= 1 &amp;&amp; ((i &amp; (1 &lt;&lt; bit)) != 0)) {<br>                    y += 1;<br>                }<br>            }<br>            if (x &gt; y) {<br>                ans |= 1 &lt;&lt; bit;<br>            }<br>        }<br>        return ans;<br>    }<br>}<br>方法三：快慢指针<br>我们先设置慢指针<br>slow 和快指针<br>fast ，慢指针每次走一步，快指针每次走两步<br>class Solution {<br>    public int findDuplicate(int[] nums) {<br>        int slow = 0, fast = 0;<br>        do {<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        } while (slow != fast);<br>        slow = 0;<br>        while (slow != fast) {<br>            slow = nums[slow];<br>            fast = nums[fast];<br>        }<br>        return slow;<br>    }<br>}</p>
<h2 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a>0～n-1中缺失的数字</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。<br>二分法<br>class Solution {<br>    public int missingNumber(int[] nums) {<br>        int i = 0, j = nums.length - 1;<br>        while(i &lt;= j) {<br>            int m = (i + j) / 2;<br>            if(nums[m] == m) i = m + 1;<br>            else j = m - 1;<br>        }<br>        return i;<br>    }<br>}</p>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>排序数组的查找问题首先考虑使用 二分法 解决，其可将遍历法的 线性级别 时间复杂度降低至 对数级别<br>public int minArray(int[] numbers) {<br>        int i = 0, j = numbers.length - 1;<br>        while (i &lt; j) {<br>            int m = (i + j) / 2;<br>            if (numbers[m] &gt; numbers[j]) i = m + 1;//m 一定在 左排序数组<br>            else if (numbers[m] &lt; numbers[j]) j = m;//m 一定在 右排序数组 中<br>            else j–;<br>        }<br>        return numbers[i];<br>        }</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：<br>int binary_search(int[] nums, int target) {<br>    int left = 0, right = nums.length - 1;<br>    while(left &lt;= right) {<br>        int mid = left + (right - left) / 2;<br>        if (nums[mid] &lt; target) {<br>            left = mid + 1;<br>        } else if (nums[mid] &gt; target) {<br>            right = mid - 1;<br>        } else if(nums[mid] == target) {<br>            // 直接返回<br>            return mid;<br>        }<br>    }<br>    // 直接返回<br>    return -1;<br>}</p>
<h2 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h2><p>二分查找，找到左右闭合区间即可<br>重点在边界的限制上<br>class Solution {<br>    public int search(int[] nums, int target) {<br>        // 搜索右边界 right<br>        int i = 0, j = nums.length - 1;<br>        while(i &lt;= j) {<br>            int m = (i + j) / 2;<br>            if(nums[m] &lt;= target) i = m + 1;<br>            else j = m - 1;<br>        }<br>        int right = i;<br>        // 若数组中无 target ，则提前返回<br>        if(j &gt;= 0 &amp;&amp; nums[j] != target) return 0;<br>        // 搜索左边界 right<br>        i = 0; j = nums.length - 1;<br>        while(i &lt;= j) {<br>            int m = (i + j) / 2;<br>            if(nums[m] &lt; target) i = m + 1;<br>            else j = m - 1;<br>        }<br>        int left = j;<br>        return right - left - 1;<br>    }<br>}</p>
<h2 id="查找value下标"><a href="#查找value下标" class="headerlink" title="查找value下标"></a>查找value下标</h2><p>给定一个有序的数组，查找value第一次出现的下标，不存在返回-1。</p>
<p>int BinarySearch(int array[], int n, int value)<br>{<br>    int left = 0;<br>    int right = n - 1;</p>
<pre><code>while (left &lt;= right)  
&#123;
    int middle = left + ((right - left) &gt;&gt; 1);
    if (array[middle] &gt;= value)  //因为是找到最小的等值下标，所以等于号放在这里
        right = middle - 1;
    else
        left = middle + 1;
&#125;
return array[right + 1] == value ? right + 1 : -1;
</code></pre>
<p>}<br>如果问题改为查找value最后一次出现的下标呢？只需改动两个位置：<br>1.if (array[middle] &gt;= value)中的等号去掉；<br>2.return中right+1改为left-1。<br>给定一个有序的数组，查找最接近value且大于value的数的下标（如果该数存在多个，返回第一个下标），不存在返回-1。</p>
<p>int BinarySearch(int array[], int n, int value)<br>{<br>    int left = 0;<br>    int right = n - 1;</p>
<pre><code>while (left &lt;= right)  
&#123;
    int middle = left + ((right - left) &gt;&gt; 1);
    if (array[middle] &gt; value)
        right = middle - 1;
    else
        left = middle + 1;
&#125;
return array[right + 1] &gt; value ? right + 1 : -1;
</code></pre>
<p>}<br>如果问题改为查找最接近value且小于value的数的下标（如果该数存在多个，返回最后一个下标）呢？只需改动两个位置：<br>1.if (array[middle] &gt; value)加入一个等号；<br>2.return array[right + 1] &gt; value ? right + 1 : -1;改为return array[left-1] &lt; value ? left - 1 : -1;。</p>
<p>总结</p>
<p>  二分算法所操作的区间，是左闭右开，还是左闭右闭，需要在循环体跳出判断中，以及每次修改left,，right区间值这两个地方保持一致，否则就可能出错。</p>
<p>给一个数组，找出这样一些数，这个数左边的数都比它小，右边的数都比它大</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>    思想：每次遍历，相邻两个比较大小，修改位置
       复杂度：n平方
       function maopao(arr) &#123;
           for (var i = 0; i &lt; arr.length; i++) &#123;
               for (var j = 0; j &lt; arr.length; j++) &#123;
                   if (arr[i] &gt; arr[j]) &#123;
                       var temp = arr[i];
                       arr[i] = arr[j];
                       arr[j] = temp;
                   &#125;
               &#125;
           &#125;
       &#125;
</code></pre>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre><code>    思想：每次往最小数组里插入一个数据，并保证数组是排序的
       (1) 将这个序列的第一个元素R0视为一个有序序列； 
       (2) 依次把 , , … ,  插入到这个有序序列中； 
       (3) 将插入到有序序列中时，前 i-1 个数是有序的，将和 ~ 从后往前进行比较，确定要插入的位置。
        public static int[] insertSOrt(int[] arr) &#123;
              int len = arr.length;
              int preIndex,cur;
              for (int i = 0; i &lt; len; i++) &#123;
                 preIndex = i - 1;
                 cur = arr[i];
                 while (preIndex &gt; 0 &amp;&amp; arr[preIndex] &gt; cur) &#123;
                      arr[preIndex +1] = arr[preIndex];
                      preIndex--;
                 &#125;
                 arr[preIndex+1] = cur;
              &#125;
              return arr;
          &#125;
</code></pre>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code>    作为一种典型的分而治之思想的算法应用
    将一个数组排序，可以先递归的将它分成两半分别排序，然后再将结果归并起来。
    缺点：需要额外的空间
    从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这
    些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得
    到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。
    这样就得到了我们想要的排序结果
     public int[] sort(int[] sourceArray) throws Exception &#123;
           // 对 arr 进行拷贝，不改变参数内容
           int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

           if (arr.length &lt; 2) &#123;
               return arr;
           &#125;
           int middle = (int) Math.floor(arr.length / 2);
           // 分开
           int[] left = Arrays.copyOfRange(arr, 0, middle);
           int[] right = Arrays.copyOfRange(arr, middle, arr.length);
           // 合并
           return merge(sort(left), sort(right));
    &#125;

    protected int[] merge(int[] left, int[] right) &#123;
           int[] result = new int[left.length + right.length];
           int i = 0;
           while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123;
               if (left[0] &lt;= right[0]) &#123;
                   result[i++] = left[0];
                   left = Arrays.copyOfRange(left, 1, left.length);
               &#125; else &#123;
                   result[i++] = right[0];
                   right = Arrays.copyOfRange(right, 1, right.length);
               &#125;
           &#125;

           while (left.length &gt; 0) &#123;
               result[i++] = left[0];
               left = Arrays.copyOfRange(left, 1, left.length);
           &#125;

           while (right.length &gt; 0) &#123;
               result[i++] = right[0];
               right = Arrays.copyOfRange(right, 1, right.length);
           &#125;

           return result;
       &#125;
</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code>    分而治之思想在排序算法。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。
       先是把第一个挖出来，作为基值；然后先是从右向左，对比基值，如果如果小，那么放到坑里；然后在从左往右对比基值，如果大，那么放到坑里；当换完一轮了后，把基值放到坑里；然后在根据基值，分左右两组，递归排序；
       通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比
       另外一部分的所有数据都要小，继续对长度较短的序列进行同样的分割，最后到
       达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故
       减少了比较次数，降低了排序时间。
      private static void quickSort(int[] arr, int low, int high) &#123;

          if (low &lt; high) &#123;
              // 找寻基准数据的正确索引位置
              int index = getIndex(arr, low, high);
              // 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序
              quickSort(arr, low, index - 1); // 左半边排序
              quickSort(arr, index + 1, high); // 右半边排序
          &#125;

      &#125;

      private static int getIndex(int[] arr, int low, int high) &#123;
          // 基准数据
          int tmp = arr[low];
          while (low &lt; high) &#123;
              // 当队尾的元素大于等于基准数据时,向前挪动high指针
              while (low &lt; high &amp;&amp; arr[high] &gt;= tmp) &#123;
                  high--;
              &#125;
              // 如果队尾元素小于tmp了,需要将其赋值给low
              arr[low] = arr[high];
              // 当队首元素小于等于tmp时,向前挪动low指针
              while (low &lt; high &amp;&amp; arr[low] &lt;= tmp) &#123;
                  low++;
              &#125;
              // 当队首元素大于tmp时,需要将其赋值给high
              arr[high] = arr[low];

          &#125;
          // 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置
          // 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low]
          arr[low] = tmp;
          return low; // 返回tmp的正确位置
      &#125;
</code></pre>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><pre><code>    它是对有向图的顶点排成一个线性序列。
</code></pre>
<h2 id="堆排序（大顶堆、小顶堆）"><a href="#堆排序（大顶堆、小顶堆）" class="headerlink" title="堆排序（大顶堆、小顶堆）"></a>堆排序（大顶堆、小顶堆）</h2><pre><code>    堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
     大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列
     小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列
     堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大
     值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将
     剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执
     行，便能得到一个有序序列了
     
     var len;    //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

     function buildMaxHeap(arr) &#123;   //建立大顶堆
         len = arr.length;
         for (var i = Math.floor(len/2); i &amp;gt;= 0; i--) &#123;
             heapify(arr, i);
         &#125;
     &#125;

     function heapify(arr, i) &#123;     //堆调整
         var left = 2 * i + 1,
             right = 2 * i + 2,
             largest = i;

         if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;
             largest = left;
         &#125;

         if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;
             largest = right;
         &#125;

         if (largest != i) &#123;
             swap(arr, i, largest);
             heapify(arr, largest);
         &#125;
     &#125;

     function swap(arr, i, j) &#123;
         var temp = arr[i];
         arr[i] = arr[j];
         arr[j] = temp;
     &#125;

     function heapSort(arr) &#123;
         buildMaxHeap(arr);

         for (var i = arr.length-1; i &gt; 0; i--) &#123;
             swap(arr, 0, i);
             len--;
             heapify(arr, 0);
         &#125;
         return arr;
     &#125;
</code></pre>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><pre><code>    知道最大最小值，可以生成一个最大最小值的一个桶的map，key是值，value是出现的次数
    for(i=1;i&lt;=n;i++)//循环读入n个数，并进行桶排序
   &#123;
       scanf(&quot;%d&quot;,&amp;t);  //把每一个数读到变量t中
       book[t]++;  //进行计数，对编号为t的桶放一个小旗子
   &#125;
   for(i=1000;i&gt;=0;i--)  //依次判断编号1000~0的桶
       for(j=1;j&lt;=book[i];j++)  //出现了几次就将桶的编号打印几次
            printf(&quot;%d &quot;,i);
   getchar();getchar();
</code></pre>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h2 id="按指定要求排序后输出"><a href="#按指定要求排序后输出" class="headerlink" title="按指定要求排序后输出"></a>按指定要求排序后输出</h2><p>给字符串，内含很多整数，按指定要求排序后输出指定位置上的整数；<br>两个有序数组，找出合并后的中位数<br>获取数组中最值（最大值/最小值）<br> 分治 + 最小堆排序的思想<br>        局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，<br>        与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除<br>        ，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。<br>        原理是最小堆排序<br>        <a target="_blank" rel="noopener" href="https://blog.csdn.net/zyq522376829/article/details/47686867">https://blog.csdn.net/zyq522376829/article/details/47686867</a><br> 求数组中第k大的数<br>        建立一个大小为K的最小堆，堆顶就是第K大的数<br>        例如，假设有10个数，要求求第3大的数，第一步选取任意的3个数，比如说是前3个，<br>        将这3个数建成最小堆，然后从第4个数开始，与堆顶<br>        的数比较，如果比堆顶的数要小，那么这个数就不要，如果比堆顶的数大，<br>        则舍弃当前的堆顶而将这个数作为新的堆顶，并再去维护堆</p>
<h2 id="旋转数组查找；"><a href="#旋转数组查找；" class="headerlink" title="旋转数组查找；"></a>旋转数组查找；</h2><pre><code>public static int minNumberInRotateArray(int[] rotateArray)
   &#123;
       if (rotateArray.Length == 0) return 0;
       else if (rotateArray.Length == 1||rotateArray[0]&lt;rotateArray[rotateArray.Length-1]) return rotateArray[0];
       else
       &#123;
           int low = 0;
           int high = rotateArray.Length - 1;
           while (low&lt;=high)
           &#123;
               int mid = (int)Math.Floor((double)(low + high) / 2);
               if (rotateArray[mid] &gt; rotateArray[0]) low = mid + 1;
               else if (rotateArray[mid] &lt; rotateArray[0]) high = mid - 1;
               else low = low + 1;
           &#125;

           return low == rotateArray.Length ? rotateArray[low - 1] : rotateArray[low];
       &#125;
   &#125;
</code></pre>
<p>##常见算法<br>广度优先搜索<br>深度优先搜索<br>递归<br>回溯<br>贪婪算法<br>动态规划<br>线性规划<br>区间规划<br>约束规划<br>自底向上<br>自定向下</p>
<h2 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h2><p>回溯<br>递归<br>剪枝</p>
<h2 id="基础技巧"><a href="#基础技巧" class="headerlink" title="基础技巧"></a>基础技巧</h2><p>分治<br>倍增<br>二分<br>贪心</p>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><ol start="134">
<li>加油站</li>
<li>LRU缓存机制</li>
<li>快乐数</li>
<li>生命游戏</li>
<li>两整数之和</li>
<li>Fizz Buzz<br>两个人掷硬币，先得到正面的人赢，游戏到有人赢结束。问先掷硬币的人赢的概率</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift144%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift144%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">二叉树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:26" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:26+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h2><pre><code>void traverse(TreeNode root) &#123;
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
&#125;
非递归前序遍历
void preorder(TreeNode *root, vector&lt;int&gt;&amp; res)
&#123;
    stack&lt; pair&lt;TreeNode*, bool&gt; &gt; s;
    s.push(make_pair(root, false));
    bool visited;
    while(!s.empty()) &#123;
        root = s.top().first;
        visited = s.top().second;
        s.pop();
        if(root == NULL) &#123;
            continue;
        &#125;
        if(visited) &#123;
            res.push_back(root-&gt;val);
        &#125; else &#123;
            // 后序遍历
            s.push(make_pair(root-&gt;right, false));
            // 中序遍历
            s.push(make_pair(root-&gt;left, false));
            // 前序遍历
            s.push(make_pair(root, true));
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的广度优先搜索-（从上到下打印二叉树）"><a href="#二叉树的广度优先搜索-（从上到下打印二叉树）" class="headerlink" title="二叉树的广度优先搜索 （从上到下打印二叉树）"></a>二叉树的广度优先搜索 （从上到下打印二叉树）</h2><pre><code>本质上是前序遍历，用一个队列存储二叉树的（先入先出）
public int[] levelOrder(TreeNode root) &#123;
    if(root == null) return new int[0];
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;
    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
    while(!queue.isEmpty()) &#123;
        TreeNode node = queue.poll();
        ans.add(node.val);
        if(node.left != null) queue.add(node.left);
        if(node.right != null) queue.add(node.right);
    &#125;
    int[] res = new int[ans.size()];
    for(int i = 0; i &lt; ans.size(); i++)
        res[i] = ans.get(i);
    return res;
&#125;
</code></pre>
<h2 id="二叉树的深度优先搜索"><a href="#二叉树的深度优先搜索" class="headerlink" title="二叉树的深度优先搜索"></a>二叉树的深度优先搜索</h2><pre><code>本质上是二叉树的后续遍历，用栈存储（先入后出）
public class Solution &#123;
public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;
    ArrayList&lt;Integer&gt; lists=new ArrayList&lt;Integer&gt;();
    if(root==null)
        return lists;
    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();
    stack.push(root);
    while(!stack.isEmpty())&#123;
        TreeNode tree=stack.pop();
　　　 //先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。
            if(tree.right!=null)
                stack.push(tree.right);
            if(tree.left!=null)
                stack.push(tree.left);
            lists.add(tree.val);
        &#125;
        return lists;
    &#125;
&#125;
</code></pre>
<h2 id="树的子结构-（判断B是不是A的子结构。）"><a href="#树的子结构-（判断B是不是A的子结构。）" class="headerlink" title="树的子结构 （判断B是不是A的子结构。）"></a>树的子结构 （判断B是不是A的子结构。）</h2><pre><code>本质是二叉树的递归遍历（递归判断左右子树是不是相同）
代码步骤：A和B不能是Null，A和B相同、A的左边和B相同、A的右边和B相同
public boolean isSubStructure(TreeNode A, TreeNode B) &#123;
      return (A != null &amp;&amp; B != null) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    &#125;
    boolean recur(TreeNode A, TreeNode B) &#123;
        if(B == null) return true;
        if(A == null || A.val != B.val) return false;
        return recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);
    &#125;
</code></pre>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><pre><code>本质是二叉树的递归遍历 （交换left和right）
代码步骤：判断是否是空、交换左右的遍历结果
public TreeNode mirrorTree(TreeNode root) &#123;
        if(root == null) return null;
        TreeNode tmp = root.left;
        root.left = mirrorTree(root.right);
        root.right = mirrorTree(tmp);
        return root;
    &#125;
方法二：辅助栈（或队列）
利用栈（或队列）遍历树的所有节点 node ，并交换每个 node 的左 / 右子节点。
 public TreeNode mirrorTree(TreeNode root) &#123;
        if(root == null) return null;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
        while(!stack.isEmpty()) &#123;
            TreeNode node = stack.pop();
            if(node.left != null) stack.add(node.left);
            if(node.right != null) stack.add(node.right);
            TreeNode tmp = node.left;
            node.left = node.right;
            node.right = tmp;
        &#125;
        return root;
    &#125;
</code></pre>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><pre><code>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树
二叉树的先序遍历
// 判断左右两个数的左边和右边是不是一样，递归调用前序遍历
public boolean isSymmetric(TreeNode root) &#123;
        //方法调用
        return isSymmetric(root,root);
    &#125;

public boolean isSymmetric(TreeNode root1,TreeNode root2)&#123;
    if(root1 == null &amp;&amp; root2 == null)&#123;
        return true;
    &#125;

    //某结点只有一个子结点，故不对称，所以返回false
    if(root1 == null || root2 == null)&#123;
        return false;
    &#125;

    //对称结点存在，但是值不相同
    if(root1.val != root2.val)&#123;
        return false;
    &#125;

    //递归调用左子节点和右子节点
    return isSymmetric(root1.left, root2.right) &amp;&amp; isSymmetric(root1.right,root2.left);
&#125;
</code></pre>
<h2 id="从上到下打印二叉树-同一层的节点按从左到右的顺序打印"><a href="#从上到下打印二叉树-同一层的节点按从左到右的顺序打印" class="headerlink" title="从上到下打印二叉树 同一层的节点按从左到右的顺序打印"></a>从上到下打印二叉树 同一层的节点按从左到右的顺序打印</h2><pre><code>前序遍历，用队列存储每一层的值
将每一层数据存放到队列中
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) &#123;
            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();
            for(int i = queue.size(); i &gt; 0; i--) &#123;
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            &#125;
            res.add(tmp);
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="从上到下打印二叉树-之字形顺序打印二叉树"><a href="#从上到下打印二叉树-之字形顺序打印二叉树" class="headerlink" title="从上到下打印二叉树 之字形顺序打印二叉树"></a>从上到下打印二叉树 之字形顺序打印二叉树</h2><pre><code>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
方法一：层序遍历 + 双端队列
利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列），奇数层 则添加至 尾部，偶数层添加至头部
 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) &#123;
            LinkedList&lt;Integer&gt; tmp = new LinkedList&lt;&gt;();
            for(int i = queue.size(); i &gt; 0; i--) &#123;
                TreeNode node = queue.poll();
                if(res.size() % 2 == 0) tmp.addLast(node.val); // 偶数层 -&gt; 队列头部
                else tmp.addFirst(node.val); // 奇数层 -&gt; 队列尾部
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            &#125;
            res.add(tmp);
        &#125;
        return res;
    &#125;
</code></pre>
<h2 id="二叉搜索树的后序"><a href="#二叉搜索树的后序" class="headerlink" title="二叉搜索树的后序"></a>二叉搜索树的后序</h2><pre><code>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。
每一层判断左右子树和根节点的大小关系，如果满足则继续向下判断；否则直接返回失败
递归分治 / 单调栈， 遍历顺序为 “左、右、根” 
    二叉搜索树定义： 左子树中所有节点的值 &lt; 根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。
    public boolean verifyPostorder(int[] postorder) &#123;
        return recur(postorder, 0, postorder.length - 1);
    &#125;
    boolean recur(int[] postorder, int i, int j) &#123;
        if(i &gt;= j) return true;
        int p = i;
        while(postorder[p] &lt; postorder[j]) p++;
        int m = p;
        while(postorder[p] &gt; postorder[j]) p++;
        return p == j &amp;&amp; recur(postorder, i, m - 1) &amp;&amp; recur(postorder, m, j - 1);
    &#125;
</code></pre>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><pre><code>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。
前序遍历：从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
 LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();
    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); 
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;
        recur(root, sum);
        return res;
    &#125;
    void recur(TreeNode root, int tar) &#123;
        if(root == null) return;
        path.add(root.val);
        tar -= root.val;
        if(tar == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)
            res.add(new LinkedList(path));
        recur(root.left, tar);
        recur(root.right, tar);
        path.removeLast();
    &#125;
</code></pre>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><pre><code>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
本文解法基于性质：二叉搜索树的中序遍历为 递增序列 。排序链表，双向链表。循环链表\
并在访问每个节点时构建 
cur 和前驱节点   pre 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可
中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 
head 和  pre 的双向节点引用即可。
Node pre, head;
    public Node treeToDoublyList(Node root) &#123;
        if(root == null) return null;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    &#125;
    void dfs(Node cur) &#123;
        if(cur == null) return;
        dfs(cur.left);
        if(pre != null) pre.right = cur;
        else head = cur;
        cur.left = pre;
        pre = cur;
        dfs(cur.right);
    &#125;
</code></pre>
<h2 id="序列化二叉树-层序遍历-BFS"><a href="#序列化二叉树-层序遍历-BFS" class="headerlink" title="序列化二叉树  层序遍历 BFS"></a>序列化二叉树  层序遍历 BFS</h2><pre><code>定义 StringBuilder 前序遍历拼接，删除最后一个逗号
 public String serialize(TreeNode root) &#123;
        if(root == null) return &quot;[]&quot;;
        StringBuilder res = new StringBuilder(&quot;[&quot;);
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
        while(!queue.isEmpty()) &#123;
            TreeNode node = queue.poll();
            if(node != null) &#123;
                res.append(node.val + &quot;,&quot;);
                queue.add(node.left);
                queue.add(node.right);
            &#125;
            else res.append(&quot;null,&quot;);
        &#125;
        res.deleteCharAt(res.length() - 1);
        res.append(&quot;]&quot;);
        return res.toString();
    &#125;

public TreeNode deserialize(String data) &#123;
    if(data.equals(&quot;[]&quot;)) return null;
    String[] vals = data.substring(1, data.length() - 1).split(&quot;,&quot;);
    TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
    int i = 1;
    while(!queue.isEmpty()) &#123;
        TreeNode node = queue.poll();
        if(!vals[i].equals(&quot;null&quot;)) &#123;
            node.left = new TreeNode(Integer.parseInt(vals[i]));
            queue.add(node.left);
        &#125;
        i++;
        if(!vals[i].equals(&quot;null&quot;)) &#123;
            node.right = new TreeNode(Integer.parseInt(vals[i]));
            queue.add(node.right);
        &#125;
        i++;
    &#125;
    return root;
&#125;
</code></pre>
<h2 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h2><pre><code>第k小的话，我觉得可以反过来遍历
class Solution &#123;
    int res, k;
    public int kthLargest(TreeNode root, int k) &#123;
        this.k = k;
        dfs(root);
        return res;
    &#125;
    void dfs(TreeNode root) &#123;
        if(root == null) return;
        dfs(root.right);
        if(k == 0) return;
        if(--k == 0) res = root.val;
        dfs(root.left);
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h2><pre><code>BST 的特性：BST 的中序遍历是升序序列。
通过构造 BST 的中序遍历序列，则第 k-1 个元素就是第 k 小的元素
方法一：递归
class Solution &#123;
  public ArrayList&lt;Integer&gt; inorder(TreeNode root, ArrayList&lt;Integer&gt; arr) &#123;
    if (root == null) return arr;
    inorder(root.left, arr);
    arr.add(root.val);
    inorder(root.right, arr);
    return arr;
  &#125;

  public int kthSmallest(TreeNode root, int k) &#123;
    ArrayList&lt;Integer&gt; nums = inorder(root, new ArrayList&lt;Integer&gt;());
    return nums.get(k - 1);
  &#125;
&#125;
</code></pre>
<h2 id="二叉树的深度（后序遍历）"><a href="#二叉树的深度（后序遍历）" class="headerlink" title="二叉树的深度（后序遍历）"></a>二叉树的深度（后序遍历）</h2><pre><code>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
方法一：后序遍历（DFS）
  public int maxDepth(TreeNode root) &#123;
        if(root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    &#125;

方法二：层序遍历（BFS）
class Solution &#123;
    public int maxDepth(TreeNode root) &#123;
        if(root == null) return 0;
        List&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;
        int res = 0;
        while(!queue.isEmpty()) &#123;
            tmp = new LinkedList&lt;&gt;();
            for(TreeNode node : queue) &#123;
                if(node.left != null) tmp.add(node.left);
                if(node.right != null) tmp.add(node.right);
            &#125;
            queue = tmp;
            res++;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><pre><code>递归，0.1，
class Solution &#123;
  public int minDepth(TreeNode root) &#123;
    if (root == null) &#123;
      return 0;
    &#125;

    if ((root.left == null) &amp;&amp; (root.right == null)) &#123;
      return 1;
    &#125;

    int min_depth = Integer.MAX_VALUE;
    if (root.left != null) &#123;
      min_depth = Math.min(minDepth(root.left), min_depth);
    &#125;
    if (root.right != null) &#123;
      min_depth = Math.min(minDepth(root.right), min_depth);
    &#125;

    return min_depth + 1;
  &#125;
&#125;
方法2:广度优先搜索迭代
class Solution &#123;
  public int minDepth(TreeNode root) &#123;
    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root == null) &#123;
      return 0;
    &#125;
    else &#123;
      stack.add(new Pair(root, 1));
    &#125;

    int current_depth = 0;
    while (!stack.isEmpty()) &#123;
      Pair&lt;TreeNode, Integer&gt; current = stack.poll();
      root = current.getKey();
      current_depth = current.getValue();
      if ((root.left == null) &amp;&amp; (root.right == null)) &#123;
        break;
      &#125;
      if (root.left != null) &#123;
        stack.add(new Pair(root.left, current_depth + 1));
      &#125;
      if (root.right != null) &#123;
        stack.add(new Pair(root.right, current_depth + 1));
      &#125;
    &#125;
    return current_depth;
  &#125;
&#125;
</code></pre>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><pre><code>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
方法一：后序遍历 + 剪枝 （从底至顶）
class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        return recur(root) != -1;
    &#125;

private int recur(TreeNode root) &#123;
    if (root == null) return 0;
    int left = recur(root.left);
    if(left == -1) return -1;
    int right = recur(root.right);
    if(right == -1) return -1;
    return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1;
&#125;
&#125;
方法二：先序遍历 + 判断深度 （从顶至底）
class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);
    &#125;

    private int depth(TreeNode root) &#123;
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><pre><code>用集合遍历根树，保存Hashmap
用set保存一个二叉树在集合中的结果
遍历另一个二叉树，看set中是否有，有则为最近公共祖先
方法一：迭代
class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        if(p.val &gt; q.val) &#123; // 保证 p.val &lt; q.val
            TreeNode tmp = p;
            p = q;
            q = tmp;
        &#125;
        while(root != null) &#123;
            if(root.val &lt; p.val) // p,q 都在 root 的右子树中
                root = root.right; // 遍历至右子节点
            else if(root.val &gt; q.val) // p,q 都在 root 的左子树中
                root = root.left; // 遍历至左子节点
            else break;
        &#125;
        return root;
    &#125;
&#125;
方法二：递归
class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)
            return lowestCommonAncestor(root.right, p, q);
        if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)
            return lowestCommonAncestor(root.left, p, q);
        return root;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h2><h2 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a>最小高度树</h2><pre><code>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。
二分，拿到中间元素，然后递归创建左右子树
class Solution &#123;
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        return createTree(nums, 0, n - 1);
    &#125;
    TreeNode* createTree(vector&lt;int&gt;&amp; nums, int start, int end) &#123;
        if (start &gt; end) return nullptr;
        int mid = (start + end) &gt;&gt; 1;
        TreeNode* root = new TreeNode(nums[mid]);
        root-&gt;left = createTree(nums, start, mid - 1);
        root-&gt;right = createTree(nums, mid + 1, end);
        return root;
    &#125;
&#125;;
</code></pre>
<h2 id="合法二叉搜索树"><a href="#合法二叉搜索树" class="headerlink" title="合法二叉搜索树"></a>合法二叉搜索树</h2><pre><code>实现一个函数，检查一棵二叉树是否为二叉搜索树。
双百，递归遍历树，分别检查左右根节点的大小
    public boolean isValidBST(TreeNode root) &#123;
        if(root==null) return true;
        return isValidBSThelp(root.left,Long.MIN_VALUE,root.val)&amp;&amp;isValidBSThelp(root.right,root.val,Long.MAX_VALUE);
    &#125;
    private boolean isValidBSThelp(TreeNode root,long min,long max)&#123;
        if(root==null) return true;
        if(root.val&lt;=min||root.val&gt;=max) return false;
        boolean left = isValidBSThelp(root.left,min,root.val);
        boolean right = isValidBSThelp(root.right,root.val,max);
        return left &amp;&amp; right;
    &#125;
</code></pre>
<h2 id="二叉树中最大路径和"><a href="#二叉树中最大路径和" class="headerlink" title="二叉树中最大路径和"></a>二叉树中最大路径和</h2><pre><code>给定一个非空二叉树，返回其最大路径和。
递归计算，更新max，（递归中返回较大的）
class Solution &#123;
    int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) &#123;
    maxGain(root);
    return maxSum;
&#125;

public int maxGain(TreeNode node) &#123;
    if (node == null) &#123;
        return 0;
    &#125;
    
    // 递归计算左右子节点的最大贡献值
    // 只有在最大贡献值大于 0 时，才会选取对应子节点
    int leftGain = Math.max(maxGain(node.left), 0);
    int rightGain = Math.max(maxGain(node.right), 0);

    // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
    int priceNewpath = node.val + leftGain + rightGain;

    // 更新答案
    maxSum = Math.max(maxSum, priceNewpath);

    // 返回节点的最大贡献值
    return node.val + Math.max(leftGain, rightGain);
&#125;
&#125;
</code></pre>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><pre><code>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
输入: 
    Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
         3
        / \
       4   5
      / \   \ 
     5   4   7
public class Solution &#123;
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;
        if (t1 == null)
            return t2;
        if (t2 == null)
            return t1;
        t1.val += t2.val;
        t1.left = mergeTrees(t1.left, t2.left);
        t1.right = mergeTrees(t1.right, t2.right);
        return t1;
    &#125;
&#125;
</code></pre>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><pre><code>public TreeNode invertTree(TreeNode root) &#123;
    if (root == null) &#123;
        return null;
    &#125;
    TreeNode right = invertTree(root.right);
    TreeNode left = invertTree(root.left);
    root.left = right;
    root.right = left;
    return root;
&#125;
</code></pre>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><pre><code>给定一个二叉树，我们在树的节点上安装摄像头。
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
计算监控树的所有节点所需的最小摄像头数量。
根据每个节点的左右子节点来判断当前节点的状态，因此左右根后续遍历
class Solution &#123;
public:
    //记录需要放置摄像头的数量
    int res = 0;
    int minCameraCover(TreeNode* root) 
    &#123;
        //后序遍历，从下自上遍历。
        //若遍历至最上面，root标志为0，则多加一个摄像头
        if(dfs(root) == 0)
        &#123;
            res++;  
        &#125;
        return res;
    &#125;
    int dfs(TreeNode* root)
    &#123;

    //0：未被覆盖(当前节点未被照到)
    //1：已被覆盖(摄像头已经照到这个节点)
    //2：需放置摄像头

    //到根节点，
    if(root == NULL) return 1;
    //遍历左节点
    int left = dfs(root-&gt;left);
    //遍历右节点
    int right = dfs(root-&gt;right);
    //一个节点左右确定后，判断左右节点情况
    //所有情况00,01,02,11,12,22
    //左右孩子中有一个未被覆盖，则当前节点需要放置摄像头，当前节点标志为2
    if(left ==0 || right==0)
    &#123;
        res++;
        return 2;
    &#125;
    //左右孩子均为已覆盖状态,则当前节点未被覆盖，标志为0
    if(left == 1 &amp;&amp; right == 1)
    &#123;
        return 0;
    &#125;
    //若左右孩子为一个覆盖一个放置了摄像头，则当前节点为已被覆盖，标志为1
    if(left+right &gt;= 3)
    &#123;
        return 1;
    &#125;
    //此时已经组合完了根节点所有情况，随便返回一个整数即可
    return 0;
&#125;
&#125;;
</code></pre>
<h2 id="验证二叉树"><a href="#验证二叉树" class="headerlink" title="验证二叉树"></a>验证二叉树</h2><pre><code>如果一棵树是一个二叉树的话 必定除了根节点 每个非空节点的入度都为1
样例还给了某一个节点被两个&quot;父节点&quot;引用的例子 那这个节点的入度就为2了 也就不能构成二叉树

public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) &#123;
    int[] in = new int[n];
    for (int i = 0; i &lt; n; i++) &#123;
        if (leftChild[i] != -1) in[leftChild[i]]++;
        if (rightChild[i] != -1) in[rightChild[i]]++;
    &#125;

    int count0 = 0;
    int countOther = 0;
    for (int temp : in) &#123;
        if (temp == 0) count0++;
        if (temp &gt; 1) countOther++;
    &#125;
    return count0 == 1 &amp;&amp; countOther == 0;
&#125;
</code></pre>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><pre><code>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：
二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。
public class Solution &#123;
    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;
        return construct(nums, 0, nums.length);
    &#125;
    public TreeNode construct(int[] nums, int l, int r) &#123;
        if (l == r)
            return null;
        int max_i = max(nums, l, r);
        TreeNode root = new TreeNode(nums[max_i]);
        root.left = construct(nums, l, max_i);
        root.right = construct(nums, max_i + 1, r);
        return root;
    &#125;
    public int max(int[] nums, int l, int r) &#123;
        int max_i = l;
        for (int i = l; i &lt; r; i++) &#123;
            if (nums[max_i] &lt; nums[i])
                max_i = i;
        &#125;
        return max_i;
    &#125;
&#125;
</code></pre>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><pre><code>给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。
class Solution &#123;
  public boolean helper(TreeNode node, Integer lower, Integer upper) &#123;
    if (node == null) return true;
    int val = node.val;
    if (lower != null &amp;&amp; val &lt;= lower) return false;
    if (upper != null &amp;&amp; val &gt;= upper) return false;

    if (! helper(node.right, val, upper)) return false;
    if (! helper(node.left, lower, val)) return false;
    return true;
&#125;

public boolean isValidBST(TreeNode root) &#123;
    return helper(root, null, null);
  &#125;
&#125;
</code></pre>
<h2 id="单值二叉树"><a href="#单值二叉树" class="headerlink" title="单值二叉树"></a>单值二叉树</h2><pre><code>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
我们先进行一次深度优先搜索，获取这颗树中的所有节点的值。然后，就可以判断所有节点的值是不是都相等了。
class Solution &#123;
    List&lt;Integer&gt; vals;
    public boolean isUnivalTree(TreeNode root) &#123;
        vals = new ArrayList();
        dfs(root);
        for (int v: vals)
            if (v != vals.get(0))
                return false;
        return true;
    &#125;

public void dfs(TreeNode node) &#123;
    if (node != null) &#123;
        vals.add(node.val);
        dfs(node.left);
        dfs(node.right);
    &#125;
&#125;
&#125;
方法二：递归
思路与算法
一颗树是单值的，当且仅当根节点的子节点所在的子树也是单值的，同时根节点的值与子节点的值相同。
class Solution &#123;
    public boolean isUnivalTree(TreeNode root) &#123;
        boolean left_correct = (root.left == null ||
                (root.val == root.left.val &amp;&amp; isUnivalTree(root.left)));
        boolean right_correct = (root.right == null ||
                (root.val == root.right.val &amp;&amp; isUnivalTree(root.right)));
        return left_correct &amp;&amp; right_correct;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><pre><code>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
方法：深度优先搜索
首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。
而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。
class Solution &#123;
    int ans;
    public int diameterOfBinaryTree(TreeNode root) &#123;
        ans = 1;
        depth(root);
        return ans - 1;
    &#125;
    public int depth(TreeNode node) &#123;
        if (node == null) return 0; // 访问到空节点了，返回0
        int L = depth(node.left); // 左儿子为根的子树的深度
        int R = depth(node.right); // 右儿子为根的子树的深度
        ans = Math.max(ans, L+R+1); // 计算d_node即L+R+1 并更新ans
        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的坡度"><a href="#二叉树的坡度" class="headerlink" title="二叉树的坡度"></a>二叉树的坡度</h2><pre><code>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。
整个树的坡度就是其所有节点的坡度之和。
输入：
         1
       /   \
      2     3
输出：1
解释：
结点 2 的坡度: 0
结点 3 的坡度: 0
结点 1 的坡度: |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1
方法：递归
我们需要求出该结点的左子树上所有结点和以及其右子树上全部结点和的差值。
在任何结点调用该函数，都会返回当前结点下面（包括其自身）的结点和。借助于任何结点的左右子结点的这一和值，我们可以直接获得该结点所对应的坡度。
public class Solution &#123;
    int tilt=0;
    public int findTilt(TreeNode root) &#123;
        traverse(root);
        return tilt;
    &#125;
    public int traverse(TreeNode root)
    &#123;
        if(root==null )
            return 0;
        int left=traverse(root.left);
        int right=traverse(root.right);
        tilt+=Math.abs(left-right);
        return left+right+root.val;
    &#125;
&#125;
</code></pre>
<h2 id="恢复一棵-BST"><a href="#恢复一棵-BST" class="headerlink" title="恢复一棵 BST"></a>恢复一棵 BST</h2><pre><code>二叉搜索树中的两个节点被错误地交换。
请在不改变其结构的情况下，恢复这棵树。
方法一：对数组进行排序
我们直到 BST 的中序遍历是升序序列。下面展示了如何计算中序遍历。
这里被交换了两个节点，因此中序遍历是一个几乎排好序的数组，其中有两个元素被交换。识别排序数组中两个交换元素是可以在线性时间内解决的经典问题。
public int[] findTwoSwapped(List&lt;Integer&gt; nums) &#123;
  int n = nums.size();
  int x = -1, y = -1;
  for(int i = 0; i &lt; n - 1; ++i) &#123;
    if (nums.get(i + 1) &lt; nums.get(i)) &#123;
      y = nums.get(i + 1);
      // first swap occurence
      if (x == -1) x = nums.get(i);
      // second swap occurence
      else break;
    &#125;
  &#125;
  return new int[]&#123;x, y&#125;;
&#125;
方法二：递归中序遍历
class Solution &#123;
  TreeNode x = null, y = null, pred = null;

  public void swap(TreeNode a, TreeNode b) &#123;
    int tmp = a.val;
    a.val = b.val;
    b.val = tmp;
  &#125;

  public void findTwoSwapped(TreeNode root) &#123;
    if (root == null) return;
    findTwoSwapped(root.left);
    if (pred != null &amp;&amp; root.val &lt; pred.val) &#123;
      y = root;
      if (x == null) x = pred;
      else return;
    &#125;
    pred = root;
    findTwoSwapped(root.right);
  &#125;

  public void recoverTree(TreeNode root) &#123;
    findTwoSwapped(root);
    swap(x, y);
  &#125;
&#125;
</code></pre>
<h2 id="求二叉树中叶子节点的个数"><a href="#求二叉树中叶子节点的个数" class="headerlink" title="求二叉树中叶子节点的个数"></a>求二叉树中叶子节点的个数</h2><pre><code>class Solution &#123;
    public int getLeafCount(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        if (root.left == null &amp;&amp; root.right == null) &#123;
            // 输出叶子节点
            System.out.println(&quot;leaf nodes:&quot; + root.val);
            return 1;
        &#125;
        return getLeafCount(root.left) + getLeafCount(root.right);
    &#125;
&#125;
</code></pre>
<h2 id="求二叉树第K层的节点个数"><a href="#求二叉树第K层的节点个数" class="headerlink" title="求二叉树第K层的节点个数"></a>求二叉树第K层的节点个数</h2><pre><code>  if (level == k)
    &#123;
        ++num;
        return num;
    &#125;
    _FindKLevel(root-&gt;_left, k, level + 1);
    _FindKLevel(root-&gt;_right, k, level + 1);
</code></pre>
<h2 id="求二叉树中最远的两个节点的距离"><a href="#求二叉树中最远的两个节点的距离" class="headerlink" title="求二叉树中最远的两个节点的距离"></a>求二叉树中最远的两个节点的距离</h2><pre><code>（1）如果具有最远距离的两个节点经过了根节点，那么最远的距离就是左边最深的深度加上右边最深的深度之和。
（2）如果具有最远距离的两个节点之间的路径不经过根节点，那么最远的距离就在根节点的其中一个子树上的两个叶子结点。

 int _Height(Node* root, int&amp; distance)
       &#123;
              if (root == NULL)
              &#123;
                     return 0;
              &#125;
              int leftH = _Height(root-&gt;_left);
              int rightH = _Height(root-&gt;_right);
              if (leftH+rightH &gt; distance)
              &#123;
                     distance = leftH + rightH;
              &#125;
              return leftH &gt; rightH ? leftH+1 : rightH+1;
</code></pre>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><pre><code>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
class Solution &#123;
    private TreeNode pre = null;
    private int[] ret;
    private int retCount = 0;
    private int maxCount = 0;
    private int currCount = 0;

public int[] findMode(TreeNode root) &#123;
    inOrder(root);
    pre = null;
    ret = new int[retCount];
    retCount = 0;
    currCount = 0;
    inOrder(root);
    return ret;
&#125;

private void inOrder(TreeNode root) &#123;
    if (root == null)
        return;
    inOrder(root.left);
    if (pre != null &amp;&amp; pre.val == root.val)
        currCount++;
    else
        currCount = 1;
    if (currCount &gt; maxCount) &#123;
        maxCount = currCount;
        retCount = 1;
    &#125;
    else if (currCount == maxCount) &#123;
        if (ret != null)
            ret[retCount] = root.val;
        retCount++;
    &#125;
    pre = root;
    inOrder(root.right);
&#125;
&#125;
</code></pre>
<h2 id="还原一棵二叉树"><a href="#还原一棵二叉树" class="headerlink" title="还原一棵二叉树"></a>还原一棵二叉树</h2><pre><code>根据前序遍历和中序遍历的结果还原一棵二叉树
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

前序遍历的第一个节点是根节点，只要找到根节点在中序遍历中的位置，在根节点之前被访
问的节点都位于左子树，在根节点之后被访问的节点都位于右子树，由此可知左子树和右子树分别有多少个节点。
不要看这个函数的参数很多，只是为了控制数组索引而已，本质上该算法也就是一个前序遍历。
class Solution &#123;
    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        if (preorder == null || preorder.length == 0) &#123;
            return null;
        &#125;
        Map&lt;Integer, Integer&gt; indexMap = new HashMap&lt;Integer, Integer&gt;(); // 存储位置
        int length = preorder.length;
        for (int i = 0; i &lt; length; i++) &#123;
            indexMap.put(inorder[i], i);
        &#125;
        TreeNode root = buildTree(preorder, 0, length - 1, inorder, 0, length - 1, indexMap);
        return root;
    &#125;

public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd, int[] inorder, int inorderStart, int inorderEnd, Map&lt;Integer, Integer&gt; indexMap) &#123;
    if (preorderStart &gt; preorderEnd) &#123;
        return null;
    &#125;
    int rootVal = preorder[preorderStart];
    TreeNode root = new TreeNode(rootVal);
    if (preorderStart == preorderEnd) &#123;
        return root;
    &#125; else &#123;
        int rootIndex = indexMap.get(rootVal);
        int leftNodes = rootIndex - inorderStart, rightNodes = inorderEnd - rootIndex;
        TreeNode leftSubtree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);
        TreeNode rightSubtree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);
        root.left = leftSubtree;
        root.right = rightSubtree;
        return root;
    &#125;
&#125;
&#125;
</code></pre>
<h2 id="二叉搜索树序列"><a href="#二叉搜索树序列" class="headerlink" title="二叉搜索树序列"></a>二叉搜索树序列</h2><pre><code>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉搜索树，输出所有可能生成此树的数组。
给定如下二叉树

        2
       / \
      1   3
返回：

[
   [2,1,3],
   [2,3,1]
]
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;vector&lt;int&gt;&gt; BSTSequences(TreeNode* root) &#123;
    
    if(root == nullptr) return &#123;&#123;&#125;&#125;;

    // queue 数据结构 并不是一个好的选项 
    // queue&lt;TreeNode*&gt; q;  // q 用于保存 前后顺序不影响最终BST结果的 节点
    deque&lt;TreeNode*&gt; q;
    vector&lt;int&gt; path;
    q.push_back(root);

    dfs(q, path);
    return res;
&#125;

void dfs(deque&lt;TreeNode*&gt;&amp; q, vector&lt;int&gt;&amp; path)&#123;
    // cout &lt;&lt; &quot;size of path:&quot; &lt;&lt; path.size() &lt;&lt;endl;
    if(q.empty()) &#123;
        res.push_back(path);
        return;
    &#125;

    int size = q.size();
    cout &lt;&lt; &quot;***&quot; &lt;&lt; q.size() &lt;&lt; endl;
    for(int i = 0; i &lt; size; i++)&#123;
        auto curr = q.front();
        q.pop_front();

        path.push_back(curr-&gt;val);
        if(curr &amp;&amp; curr-&gt;left) q.push_back(curr-&gt;left);
        if(curr &amp;&amp; curr-&gt;right) q.push_back(curr-&gt;right);
        
        dfs(q, path);

        // 回溯要保证 状态还原
        if(curr &amp;&amp; curr-&gt;left) q.pop_back();
        if(curr &amp;&amp; curr-&gt;right) q.pop_back();
        q.push_back(curr);
        
        path.pop_back();
    &#125;
&#125;
&#125;;
</code></pre>
<h2 id="二叉搜索树总结"><a href="#二叉搜索树总结" class="headerlink" title="二叉搜索树总结"></a>二叉搜索树总结</h2><pre><code>void BST(TreeNode root,int target) &#123;
    if(root.val == target) 
        //找到目标，做点什么
    if(root.val &lt; target) 
        BST(root.right, target);
    if(root.val &gt; target) 
        BST(root.left, target);
&#125;
</code></pre>
<h2 id="在BST中插入一个元素，在BST删除一个元素"><a href="#在BST中插入一个元素，在BST删除一个元素" class="headerlink" title="在BST中插入一个元素，在BST删除一个元素"></a>在BST中插入一个元素，在BST删除一个元素</h2><h2 id="快速计算完全二叉树的节点"><a href="#快速计算完全二叉树的节点" class="headerlink" title="快速计算完全二叉树的节点"></a>快速计算完全二叉树的节点</h2><h2 id="单调栈、单调队列的作用"><a href="#单调栈、单调队列的作用" class="headerlink" title="单调栈、单调队列的作用"></a>单调栈、单调队列的作用</h2><h2 id="双指针的使用技巧"><a href="#双指针的使用技巧" class="headerlink" title="双指针的使用技巧"></a>双指针的使用技巧</h2><pre><code>快慢指针：判断是否有环、环的起始位置、链表的中心点、链表的倒数第k的元素、去除有序数组的重复元素
左右指针：二分查找、翻转数组、
滑动窗口
</code></pre>
<h2 id="位运算相关"><a href="#位运算相关" class="headerlink" title="位运算相关"></a>位运算相关</h2><p>前缀和<br>字符串乘法<br>贪心：跳跃游戏<br>k个一组翻转链表<br>深度优先<br>1、全排列问题<br>2、一个环由个圈组成，把自然数1，2，…，N分别放在每一个圆内，数字的在两个相邻圈之和应该是一个素数。 注意：第一圈数应始终为1。<br>3、油田问题<br>4、棋盘问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift143%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift143%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:21" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:21+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><pre><code>本题的难点在于如何处理数组，一个是开辟另一个数组进行处理，另一个是多次旋转数组实现
方法 1：暴力
最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。
public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        int temp, previous;
        for (int i = 0; i &lt; k; i++) &#123;
            previous = nums[nums.length - 1];
            for (int j = 0; j &lt; nums.length; j++) &#123;
                temp = nums[j];
                nums[j] = previous;
                previous = temp;
            &#125;
        &#125;
    &#125;
&#125;
方法 2：使用额外的数组
public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        int[] a = new int[nums.length];
        for (int i = 0; i &lt; nums.length; i++) &#123;
            a[(i + k) % nums.length] = nums[i];
        &#125;
        for (int i = 0; i &lt; nums.length; i++) &#123;
            nums[i] = a[i];
        &#125;
    &#125;
&#125;
方法 3：使用环状替换
public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        k = k % nums.length;
        int count = 0;
        for (int start = 0; count &lt; nums.length; start++) &#123;
            int current = start;
            int prev = nums[start];
            do &#123;
                int next = (current + k) % nums.length;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
                count++;
            &#125; while (start != current);
        &#125;
    &#125;
&#125;
方法 4：使用反转
原始数组                  : 1 2 3 4 5 6 7
反转所有数字后             : 7 6 5 4 3 2 1
反转前 k 个数字后          : 5 6 7 4 3 2 1
反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果

public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    &#125;
    public void reverse(int[] nums, int start, int end) &#123;
        while (start &lt; end) &#123;
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h2><pre><code>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。
列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。
输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。

public class NestedIterator implements Iterator&lt;Integer&gt; &#123;
Queue&lt;Integer&gt; res = new LinkedList&lt;&gt;();

public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;
    for(NestedInteger temp : nestedList)
        DFS(temp);
&#125;

@Override
public Integer next() &#123;
    return res.poll();
&#125;

@Override
public boolean hasNext() &#123;
    if(res.isEmpty())
        return false;
    return true;
    
&#125;
public void DFS(NestedInteger Node)&#123;
    /* 深度遍历 */
    if(Node.isInteger())
        res.offer(Node.getInteger());
    for(NestedInteger temp :Node.getList())
        DFS(temp);
&#125;
&#125;
</code></pre>
<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><pre><code>本题的难点在入如何交换数据，采用i，j双指针，直到都不为奇偶才交换
public int[] exchange(int[] nums) &#123;
       if(nums.length == 0) return nums;
       int i = 0,j = nums.length-1;
       while(i != j)&#123;
           while(nums[i] %2 != 0 &amp;&amp; i&lt;j )&#123;
               i++;
           &#125;
           while(nums[j] %2 == 0 &amp;&amp; i&lt;j )&#123;
               j--;
           &#125;
           if(i&lt;j)&#123;
               int temp = nums[i];
               nums[i] = nums[j];
               nums[j] = temp;
           &#125;
       &#125;
       return nums;
   &#125;
</code></pre>
<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><pre><code>   哈希表统计法，用 HashMap 统计各数字的数量
   数组排序法：由于众数的数量超过数组长度一半，
   因此 数组中点的元素 一定为众数
   摩尔投票法：核心理念为 “正负抵消” 
   当 n=x ： 抵消的所有数字中，有一半是众数    
   n不等x ： 抵消的所有数字中，少于或等于一半是众数 x
   利用此特性，每轮假设都可以 缩小剩余数组区间 。当遍历完成时，最后一轮假
   设的数字即为众数（由于众数超过一半，最后一轮的票数和必为正数）

   public int majorityElement(int[] nums) &#123;
       int x = 0, votes = 0;
       for(int num : nums)&#123;
           if(votes == 0) x = num;
           votes += num == x ? 1 : -1;
       &#125;
       return x;
   &#125;
</code></pre>
<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><pre><code>    这种最适合动态规划了，慢慢的变化，将前面的结构给到nums[i]
       输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
   class Solution &#123;
       public int maxSubArray(int[] nums) &#123;
           int res = nums[0];
           for(int i = 1; i &lt; nums.length; i++) &#123;
               nums[i] += Math.max(nums[i - 1], 0);
               res = Math.max(res, nums[i]);
           &#125;
           return res;
       &#125;
   &#125;
</code></pre>
<h2 id="1～n整数中1出现的次数"><a href="#1～n整数中1出现的次数" class="headerlink" title="1～n整数中1出现的次数"></a>1～n整数中1出现的次数</h2><pre><code>从个位到最高位的变量递推公式为
# 当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出
# 将 cur 加入 low ，组成下轮 low
# 下轮 cur 是本轮 high 的最低位
# 将本轮 high 最低位删除，得到下轮 high
# 位因子每轮 × 10
   class Solution &#123;
       public int countDigitOne(int n) &#123;
           int digit = 1, res = 0;
           int high = n / 10, cur = n % 10, low = 0;
           while(high != 0 || cur != 0) &#123;
               if(cur == 0) res += high * digit;
               else if(cur == 1) res += high * digit + low + 1;
               else res += (high + 1) * digit;
               low += cur * digit;
               cur = high % 10;
               high /= 10;
               digit *= 10;
           &#125;
           return res;
       &#125;
   &#125;
</code></pre>
<h2 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h2><pre><code>   数字以0123456789101112131415…的格式序列化到一个字符序列中
   迭代 + 求整 / 求余
       count=9×start×digit，num = start + (n - 1)

       class Solution &#123;
       public int findNthDigit(int n) &#123;
           int digit = 1;
           long start = 1;
           long count = 9;
           while (n &gt; count) &#123; // 1.
               n -= count;
               digit += 1;
               start *= 10;
               count = digit * start * 9;
           &#125;
           long num = start + (n - 1) / digit; // 2.
           return Long.toString(num).charAt((n - 1) % digit) - &#39;0&#39;; // 3.
       &#125;
   &#125;
</code></pre>
<h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><pre><code>        双指针法，分别指向数组的两端，如果两个数的和大于target则j--如果小于target则i++，直至相等 
class Solution &#123;
    public int[] twoSum(int[] nums, int target) &#123;
        int i = 0, j = nums.length - 1;
        while(i &lt; j) &#123;
            int s = nums[i] + nums[j];
            if(s &lt; target) i++;
            else if(s &gt; target) j--;
            else return new int[] &#123; nums[i], nums[j] &#125;;
        &#125;
        return new int[0];
    &#125;
&#125;
</code></pre>
<h2 id="给定两个数组，编写一个函数来计算它们的交集。"><a href="#给定两个数组，编写一个函数来计算它们的交集。" class="headerlink" title="给定两个数组，编写一个函数来计算它们的交集。"></a>给定两个数组，编写一个函数来计算它们的交集。</h2><pre><code>方法一：哈希表
首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。
为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。
class Solution &#123;
    public int[] intersect(int[] nums1, int[] nums2) &#123;
        if (nums1.length &gt; nums2.length) &#123;
            return intersect(nums2, nums1);
        &#125;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for (int num : nums1) &#123;
            int count = map.getOrDefault(num, 0) + 1;
            map.put(num, count);
        &#125;
        int[] intersection = new int[nums1.length];
        int index = 0;
        for (int num : nums2) &#123;
            int count = map.getOrDefault(num, 0);
            if (count &gt; 0) &#123;
                intersection[index++] = num;
                count--;
                if (count &gt; 0) &#123;
                    map.put(num, count);
                &#125; else &#123;
                    map.remove(num);
                &#125;
            &#125;
        &#125;
        return Arrays.copyOfRange(intersection, 0, index);
    &#125;
&#125;
方法二：排序
如果两个数组是有序的，则可以便捷地计算两个数组的交集。
class Solution &#123;
    public int[] intersect(int[] nums1, int[] nums2) &#123;
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int length1 = nums1.length, length2 = nums2.length;
        int[] intersection = new int[Math.min(length1, length2)];
        int index1 = 0, index2 = 0, index = 0;
        while (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;
            if (nums1[index1] &lt; nums2[index2]) &#123;
                index1++;
            &#125; else if (nums1[index1] &gt; nums2[index2]) &#123;
                index2++;
            &#125; else &#123;
                intersection[index] = nums1[index1];
                index1++;
                index2++;
                index++;
            &#125;
        &#125;
        return Arrays.copyOfRange(intersection, 0, index);
    &#125;
&#125;
</code></pre>
<h2 id="给定一个未排序的数组，判断这个数组中是否存在长度为-3-的递增子序列。"><a href="#给定一个未排序的数组，判断这个数组中是否存在长度为-3-的递增子序列。" class="headerlink" title="给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。"></a>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</h2><pre><code>class Solution &#123;
public:
    bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;
        int first = INT_MAX, sec = INT_MAX;     
        for(int n : nums)                       //
        &#123;
            if(n &lt;= first)  first = n;          
            else
            &#123;
                if(n &lt;= sec )   sec = n;        
                else   return true;
            &#125;
        &#125;
        return false;

    &#125;
&#125;;
</code></pre>
<h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><pre><code>是一种后缀表达式，所谓后缀就是指算符写在后面。
平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
class Solution &#123;
    //纯数组模拟栈实现(推荐)   3 ms    36 MB
    public static int evalRPN(String[] tokens) &#123;
        int[] numStack = new int[tokens.length / 2 + 1];
        int index = 0;
        for (String s : tokens) &#123;
            switch (s) &#123;
            case &quot;+&quot;:
                numStack[index - 2] += numStack[--index];
                break;
            case &quot;-&quot;:
                numStack[index - 2] -= numStack[--index];
                break;
            case &quot;*&quot;:
                numStack[index - 2] *= numStack[--index];
                break;
            case &quot;/&quot;:
                numStack[index - 2] /= numStack[--index];
                break;
            default:
                // numStack[index++] = Integer.valueOf(s);
                //valueOf改为parseInt，减少自动拆箱装箱操作
                numStack[index++] = Integer.parseInt(s);
                break;
            &#125;
        &#125;
        return numStack[0];
    &#125;
&#125;
class Solution &#123;
    // 栈实现   8 ms    36.7 MB    
    public static int evalRPN(String[] tokens) &#123;
        Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;();
        Integer op1, op2;
        for (String s : tokens) &#123;
            switch (s) &#123;
            case &quot;+&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 + op2);
                break;
            case &quot;-&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 - op2);
                break;
            case &quot;*&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 * op2);
                break;
            case &quot;/&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 / op2);
                break;
            default:
                numStack.push(Integer.valueOf(s));
                break;
            &#125;
        &#125;
        return numStack.pop();
    &#125;
&#125;
</code></pre>
<h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h2><pre><code>输入: [1,2,3,4]
输出: [24,12,8,6]
方法一：左右乘积列表
我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。
class Solution &#123;
    public int[] productExceptSelf(int[] nums) &#123;
        int length = nums.length;

    // L 和 R 分别表示左右两侧的乘积列表
    int[] L = new int[length];
    int[] R = new int[length];

    int[] answer = new int[length];

    // L[i] 为索引 i 左侧所有元素的乘积
    // 对于索引为 &#39;0&#39; 的元素，因为左侧没有元素，所以 L[0] = 1
    L[0] = 1;
    for (int i = 1; i &lt; length; i++) &#123;
        L[i] = nums[i - 1] * L[i - 1];
    &#125;

    // R[i] 为索引 i 右侧所有元素的乘积
    // 对于索引为 &#39;length-1&#39; 的元素，因为右侧没有元素，所以 R[length-1] = 1
    R[length - 1] = 1;
    for (int i = length - 2; i &gt;= 0; i--) &#123;
        R[i] = nums[i + 1] * R[i + 1];
    &#125;

    // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积
    for (int i = 0; i &lt; length; i++) &#123;
        answer[i] = L[i] * R[i];
    &#125;

    return answer;
&#125;
&#125;
方法二：空间复杂度 
第一个循环应该是表示下三角中自上而下对每一行做连乘，而第二个循环是对上三角自下而上的连乘
class Solution &#123;
    public int[] productExceptSelf(int[] nums) &#123;
        int length = nums.length;
        int[] answer = new int[length];

    // answer[i] 表示索引 i 左侧所有元素的乘积
    // 因为索引为 &#39;0&#39; 的元素左侧没有元素， 所以 answer[0] = 1
    answer[0] = 1;
    for (int i = 1; i &lt; length; i++) &#123;
        answer[i] = nums[i - 1] * answer[i - 1];
    &#125;

    // R 为右侧所有元素的乘积
    // 刚开始右边没有元素，所以 R = 1
    int R = 1;
    for (int i = length - 1; i &gt;= 0; i--) &#123;
        // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
        answer[i] = answer[i] * R;
        // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
        R *= nums[i];
    &#125;
    return answer;
&#125;
&#125;
</code></pre>
<h2 id="和为s的连续正数序列-（滑动窗口）"><a href="#和为s的连续正数序列-（滑动窗口）" class="headerlink" title="和为s的连续正数序列  （滑动窗口）"></a>和为s的连续正数序列  （滑动窗口）</h2><pre><code>    窗口的左边界和右边界永远只能向右移动
    当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动
    当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
什么是滑动窗口
滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。
窗口的左边界和右边界永远只能向右移动
第一个问题，窗口何时扩大，何时缩小？
第二个问题，滑动窗口能找到全部的解吗？
当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动
当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动
public int[][] findContinuousSequence(int target) &#123;
    int i = 1; // 滑动窗口的左边界
    int j = 1; // 滑动窗口的右边界
    int sum = 0; // 滑动窗口中数字的和
    List&lt;int[]&gt; res = new ArrayList&lt;&gt;();

while (i &lt;= target / 2) &#123;
    if (sum &lt; target) &#123;
        // 右边界向右移动
        sum += j;
        j++;
    &#125; else if (sum &gt; target) &#123;
        // 左边界向右移动
        sum -= i;
        i++;
    &#125; else &#123;
        // 记录结果
        int[] arr = new int[j-i];
        for (int k = i; k &lt; j; k++) &#123;
            arr[k-i] = k;
        &#125;
        res.add(arr);
        // 左边界向右移动
        sum -= i;
        i++;
    &#125;
&#125;

return res.toArray(new int[res.size()][]);
</code></pre>
<p>}</p>
<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><pre><code>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
单调队列
我们先看什么是单调的双向队列，双向队列大家都知道，既能在头部进行插入、删除操作，也能在尾部进行插入删除操作，而所谓的单调，就是我们人为规定从队列的头部到尾部，所存储的元素是依次递减（或依次递增）的。如下所示：

也就是说，我们维护一个单调的双向队列，窗口在每次滑动的时候，我就从队列头部取当前窗口中的最大值，每次窗口新进来一个元素的时候，我就将它与队列中的元素进行大小比较：

如果刚刚进来的元素比队列的尾部元素大，那么先将队列尾部的元素弹出，然后把刚刚进来的元素添到队列的尾部；
如果刚刚进来的元素比队列的尾部元素小，那么把刚刚进来的元素直接添到队列的尾部即可。

class Solution &#123;
    public int[] maxSlidingWindow(int[] nums, int k) &#123;
        if (nums == null || k &lt; 1 || nums.length &lt; k) &#123;
            return new int[0];
        &#125;

    int index = 0;
    int[] res = new int[nums.length - k + 1];
    LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();

    for (int i = 0; i &lt; nums.length; i++) &#123;
        // 在队列不为空的情况下，如果队列尾部的元素要比当前的元素小，或等于当前的元素
        // 那么为了维持从大到小的原则，我必须让尾部元素弹出
        while (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;= nums[i]) &#123;
            queue.pollLast();
        &#125;
        // 不走 while 的话，说明我们正常在队列尾部添加元素
        queue.addLast(i);
        // 如果滑动窗口已经略过了队列中头部的元素，则将头部元素弹出
        if (queue.peekFirst() == (i - k)) &#123;
            queue.pollFirst();
        &#125;
        // 看看窗口有没有形成，只有形成了大小为 k 的窗口，我才能收集窗口内的最大值
        if (i &gt;= (k - 1)) &#123;
            res[index++] = nums[queue.peekFirst()];
        &#125;
    &#125;
    return res;
&#125;
</code></pre>
<p>}</p>
<h2 id="将数组中所有-0-移动到数组末尾。"><a href="#将数组中所有-0-移动到数组末尾。" class="headerlink" title="将数组中所有 0 移动到数组末尾。"></a>将数组中所有 0 移动到数组末尾。</h2><pre><code>方法一：空间局部优化
class Solution &#123;
    public void moveZeroes(int[] nums) &#123;
        if(nums==null) &#123;
            return;
        &#125;
        //第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]
        int j = 0;
        for(int i=0;i&lt;nums.length;++i) &#123;
            if(nums[i]!=0) &#123;
                nums[j++] = nums[i];
            &#125;
        &#125;
        //非0元素统计完了，剩下的都是0了
        //所以第二次遍历把末尾的元素都赋为0即可
        for(int i=j;i&lt;nums.length;++i) &#123;
            nums[i] = 0;
        &#125;
    &#125;
&#125;    
方法二：空间最优，操作局部优化（双指针）
class Solution &#123;
    public void moveZeroes(int[] nums) &#123;
        if(nums==null) &#123;
            return;
        &#125;
        //两个指针i和j
        int j = 0;
        for(int i=0;i&lt;nums.length;i++) &#123;
            //当前元素!=0，就把其交换到左边，等于0的交换到右边
            if(nums[i]!=0) &#123;
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j++] = tmp;
            &#125;
        &#125;
    &#125;
&#125;    
</code></pre>
<h2 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h2><pre><code>方法一： 暴力 【通过】
暴力算法简单的来说就是把每个数放在一个 ”帽子“ 里面，每次从 ”帽子“ 里面随机摸一个数出来
class Solution &#123;
    private int[] array;
    private int[] original;

private Random rand = new Random();

private List&lt;Integer&gt; getArrayCopy() &#123;
    List&lt;Integer&gt; asList = new ArrayList&lt;Integer&gt;();
    for (int i = 0; i &lt; array.length; i++) &#123;
        asList.add(array[i]);
    &#125;
    return asList;
&#125;

public Solution(int[] nums) &#123;
    array = nums;
    original = nums.clone();
&#125;

public int[] reset() &#123;
    array = original;
    original = original.clone();
    return array;
&#125;

public int[] shuffle() &#123;
    List&lt;Integer&gt; aux = getArrayCopy();

    for (int i = 0; i &lt; array.length; i++) &#123;
        int removeIdx = rand.nextInt(aux.size());
        array[i] = aux.get(removeIdx);
        aux.remove(removeIdx);
    &#125;

    return array;
&#125;
</code></pre>
<p>}<br>    方法二： Fisher-Yates 洗牌算法 【通过】<br>    Fisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换 - 这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。</p>
<pre><code>class Solution &#123;
    private int[] array;
    private int[] original;

Random rand = new Random();

private int randRange(int min, int max) &#123;
    return rand.nextInt(max - min) + min;
&#125;

private void swapAt(int i, int j) &#123;
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
&#125;

public Solution(int[] nums) &#123;
    array = nums;
    original = nums.clone();
&#125;

public int[] reset() &#123;
    array = original;
    original = original.clone();
    return original;
&#125;

public int[] shuffle() &#123;
    for (int i = 0; i &lt; array.length; i++) &#123;
        swapAt(i, randRange(i, array.length));
    &#125;
    return array;
&#125;
&#125;
</code></pre>
<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><pre><code>public class Solution &#123;

public int reversePairs(int[] nums) &#123;
    int len = nums.length;

    if (len &lt; 2) &#123;
        return 0;
    &#125;

    int[] copy = new int[len];
    for (int i = 0; i &lt; len; i++) &#123;
        copy[i] = nums[i];
    &#125;

    int[] temp = new int[len];
    return reversePairs(copy, 0, len - 1, temp);
&#125;

/**
 * nums[left..right] 计算逆序对个数并且排序
 *
 * @param nums
 * @param left
 * @param right
 * @param temp
 * @return
 */
private int reversePairs(int[] nums, int left, int right, int[] temp) &#123;
    if (left == right) &#123;
        return 0;
    &#125;

    int mid = left + (right - left) / 2;
    int leftPairs = reversePairs(nums, left, mid, temp);
    int rightPairs = reversePairs(nums, mid + 1, right, temp);

    if (nums[mid] &lt;= nums[mid + 1]) &#123;
        return leftPairs + rightPairs;
    &#125;

    int crossPairs = mergeAndCount(nums, left, mid, right, temp);
    return leftPairs + rightPairs + crossPairs;
&#125;

/**
 * nums[left..mid] 有序，nums[mid + 1..right] 有序
 *
 * @param nums
 * @param left
 * @param mid
 * @param right
 * @param temp
 * @return
 */
private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) &#123;
    for (int i = left; i &lt;= right; i++) &#123;
        temp[i] = nums[i];
    &#125;

    int i = left;
    int j = mid + 1;

    int count = 0;
    for (int k = left; k &lt;= right; k++) &#123;

        if (i == mid + 1) &#123;
            nums[k] = temp[j];
            j++;
        &#125; else if (j == right + 1) &#123;
            nums[k] = temp[i];
            i++;
        &#125; else if (temp[i] &lt;= temp[j]) &#123;
            nums[k] = temp[i];
            i++;
        &#125; else &#123;
            nums[k] = temp[j];
            j++;
            count += (mid - i + 1);
        &#125;
    &#125;
    return count;
&#125;
&#125;
</code></pre>
<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><pre><code>    用快排最最最高效解决 TopK 问题：
    大根堆(前 K 小) / 小根堆（前 K 大),Java中有现成的 PriorityQueue，实现起来最简单：
    二叉搜索树也可以 解决 TopK 问题哦
    数据范围有限时直接计数排序就行了：
class Solution &#123;
    public int[] getLeastNumbers(int[] arr, int k) &#123;
        if (k == 0 || arr.length == 0) &#123;
            return new int[0];
        &#125;
        // 最后一个参数表示我们要找的是下标为k-1的数
        return quickSearch(arr, 0, arr.length - 1, k - 1);
    &#125;

private int[] quickSearch(int[] nums, int lo, int hi, int k) &#123;
    // 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；
    int j = partition(nums, lo, hi);
    if (j == k) &#123;
        return Arrays.copyOf(nums, j + 1);
    &#125;
    // 否则根据下标j与k的大小关系来决定继续切分左段还是右段。
    return j &gt; k? quickSearch(nums, lo, j - 1, k): quickSearch(nums, j + 1, hi, k);
&#125;

// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。
private int partition(int[] nums, int lo, int hi) &#123;
    int v = nums[lo];
    int i = lo, j = hi + 1;
    while (true) &#123;
        while (++i &lt;= hi &amp;&amp; nums[i] &lt; v);
        while (--j &gt;= lo &amp;&amp; nums[j] &gt; v);
        if (i &gt;= j) &#123;
            break;
        &#125;
        int t = nums[j];
        nums[j] = nums[i];
        nums[i] = t;
    &#125;
    nums[lo] = nums[j];
    nums[j] = v;
    return j;
&#125;
&#125;
我们用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。
// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：
// 1. 若目前堆的大小小于K，将当前数字放入堆中。
// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；
//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。
class Solution &#123;
    public int[] getLeastNumbers(int[] arr, int k) &#123;
        if (k == 0 || arr.length == 0) &#123;
            return new int[0];
        &#125;
        // 默认是小根堆，实现大根堆需要重写一下比较器。
        Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);
        for (int num: arr) &#123;
            if (pq.size() &lt; k) &#123;
                pq.offer(num);
            &#125; else if (num &lt; pq.peek()) &#123;
                pq.poll();
                pq.offer(num);
            &#125;
        &#125;
        
        // 返回堆中的元素
        int[] res = new int[pq.size()];
        int idx = 0;
        for(int num: pq) &#123;
            res[idx++] = num;
        &#125;
        return res;
    &#125;
&#125;
二叉搜索树也可以 O(NlogK)解决 TopK 问题哦
与前两种方法相比，BST 有一个好处是求得的前K大的数字是有序的。
class Solution &#123;
public int[] getLeastNumbers(int[] arr, int k) &#123;
    if (k == 0 || arr.length == 0) &#123;
        return new int[0];
    &#125;
    // TreeMap的key是数字, value是该数字的个数。
    // cnt表示当前map总共存了多少个数字。
    TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();
    int cnt = 0;
    for (int num: arr) &#123;
        // 1. 遍历数组，若当前map中的数字个数小于k，则map中当前数字对应个数+1
        if (cnt &lt; k) &#123;
            map.put(num, map.getOrDefault(num, 0) + 1);
            cnt++;
            continue;
        &#125; 
        // 2. 否则，取出map中最大的Key（即最大的数字), 判断当前数字与map中最大数字的大小关系：
        //    若当前数字比map中最大的数字还大，就直接忽略；
        //    若当前数字比map中最大的数字小，则将当前数字加入map中，并将map中的最大数字的个数-1。
        Map.Entry&lt;Integer, Integer&gt; entry = map.lastEntry();
        if (entry.getKey() &gt; num) &#123;
            map.put(num, map.getOrDefault(num, 0) + 1);
            if (entry.getValue() == 1) &#123;
                map.pollLastEntry();
            &#125; else &#123;
                map.put(entry.getKey(), entry.getValue() - 1);
            &#125;
        &#125;
    
&#125;

    // 最后返回map中的元素
    int[] res = new int[k];
    int idx = 0;
    for (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;
        int freq = entry.getValue();
        while (freq-- &gt; 0) &#123;
            res[idx++] = entry.getKey();
        &#125;
    &#125;
    return res;
&#125;
&#125;
四、数据范围有限时直接计数排序就行了：
class Solution &#123;
    public int[] getLeastNumbers(int[] arr, int k) &#123;
        if (k == 0 || arr.length == 0) &#123;
            return new int[0];
        &#125;
        // 统计每个数字出现的次数
        int[] counter = new int[10001];
        for (int num: arr) &#123;
            counter[num]++;
        &#125;
        // 根据counter数组从头找出k个数作为返回结果
        int[] res = new int[k];
        int idx = 0;
        for (int num = 0; num &lt; counter.length; num++) &#123;
            while (counter[num]-- &gt; 0 &amp;&amp; idx &lt; k) &#123;
                res[idx++] = num;
            &#125;
            if (idx == k) &#123;
                break;
            &#125;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><pre><code>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
    输入: [10,2]
    输出: &quot;102&quot;
    此题求拼接起来的 “最小数字” ，本质上是一个排序问题。
class Solution &#123;
    public String minNumber(int[] nums) &#123;
        String[] strs = new String[nums.length];
        for(int i = 0; i &lt; nums.length; i++)
            strs[i] = String.valueOf(nums[i]);
        fastSort(strs, 0, strs.length - 1);
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    &#125;
    void fastSort(String[] strs, int l, int r) &#123;
        if(l &gt;= r) return;
        int i = l, j = r;
        String tmp = strs[i];
        while(i &lt; j) &#123;
            while((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= 0 &amp;&amp; i &lt; j) j--;
            while((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= 0 &amp;&amp; i &lt; j) i++;
            tmp = strs[i];
            strs[i] = strs[j];
            strs[j] = tmp;
        &#125;
        strs[i] = strs[l];
        strs[l] = tmp;
        fastSort(strs, l, i - 1);
        fastSort(strs, i + 1, r);
    &#125;
&#125;
方法二：内置函数
public String minNumber(int[] nums) &#123;
        String[] strs = new String[nums.length];
        for(int i = 0; i &lt; nums.length; i++) 
            strs[i] = String.valueOf(nums[i]);
        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    &#125;
</code></pre>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><pre><code>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
    由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。

从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能

class Solution &#123;
    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;
            return false;
        &#125;
        int rows = matrix.length, columns = matrix[0].length;
        int row = 0, column = columns - 1;
        while (row &lt; rows &amp;&amp; column &gt;= 0) &#123;
            int num = matrix[row][column];
            if (num == target) &#123;
                return true;
            &#125; else if (num &gt; target) &#123;
                column--;
            &#125; else &#123;
                row++;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><pre><code>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],
[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],
[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]
    算法原理：
    深度优先搜索
class Solution &#123;
    public boolean exist(char[][] board, String word) &#123;
        char[] words = word.toCharArray();
        for(int i = 0; i &lt; board.length; i++) &#123;
            for(int j = 0; j &lt; board[0].length; j++) &#123;
                if(dfs(board, words, i, j, 0)) return true;
            &#125;
        &#125;
        return false;
    &#125;
    boolean dfs(char[][] board, char[] word, int i, int j, int k) &#123;
        if(i &gt;= board.length || i &lt; 0 || j &gt;= board[0].length || j &lt; 0 || board[i][j] != word[k]) return false;
        if(k == word.length - 1) return true;
        char tmp = board[i][j];
        board[i][j] = &#39;/&#39;;
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = tmp;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><pre><code>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
    本文选择使用广度优先搜索的方法来讲解。
    public int movingCount(int m, int n, int k) &#123;
        boolean[][] visited = new boolean[m][n];
        return dfs(0, 0, m, n, k, visited);
    &#125;
    public int dfs(int i, int j, int m, int n, int k, boolean[][] visited) &#123;
        if(i &gt;= m || j &gt;= n || k &lt; getSum(i) + getSum(j) || visited[i][j]) &#123;
            return 0;
        &#125;
        visited[i][j] = true;
        return 1 + dfs(i + 1, j, m, n, k, visited) + dfs(i, j + 1, m, n, k, visited);
    &#125;

private int getSum(int a) &#123;
    int sum = a % 10;
    int tmp = a / 10;
    while(tmp &gt; 0) &#123;
        sum += tmp % 10;
        tmp /= 10;
    &#125;
    return sum;
&#125;
    
</code></pre>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><pre><code>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
可以模拟打印矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，则顺时针旋转，进入下一个方向。
判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素
表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。
如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数
量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。
 public int[] spiralOrder(int[][] matrix) &#123;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;
            return new int[0];
        &#125;
        int rows = matrix.length, columns = matrix[0].length;
        boolean[][] visited = new boolean[rows][columns];
        int total = rows * columns;
        int[] order = new int[total];
        int row = 0, column = 0;
        int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;
        int directionIndex = 0;
        for (int i = 0; i &lt; total; i++) &#123;
            order[i] = matrix[row][column];
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow &lt; 0 || nextRow &gt;= rows || nextColumn &lt; 0 || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123;
                directionIndex = (directionIndex + 1) % 4;
            &#125;
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        &#125;
        return order;
    &#125;
</code></pre>
<h2 id="给定一个-n-x-n-矩阵，其中每行和每列元素均按升序排序，找到矩阵中第-k-小的元素。"><a href="#给定一个-n-x-n-矩阵，其中每行和每列元素均按升序排序，找到矩阵中第-k-小的元素。" class="headerlink" title="给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。"></a>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。</h2><pre><code>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
最直接的做法是将这个二维数组另存为为一维数组，并对该一维数组进行排序。最后这个一维数组中的第 k个数即为答案。
class Solution &#123;
    public int kthSmallest(int[][] matrix, int k) &#123;
        int rows = matrix.length, columns = matrix[0].length;
        int[] sorted = new int[rows * columns];
        int index = 0;
        for (int[] row : matrix) &#123;
            for (int num : row) &#123;
                sorted[index++] = num;
            &#125;
        &#125;
        Arrays.sort(sorted);
        return sorted[k - 1];
    &#125;
&#125;
方法二：归并排序
这个矩阵的每一行均为一个有序数组。问题即转化为从这 n 个有序数组中找第 
k 大的数，可以想到利用归并排序的做法，归并到第 k 个数即可停止。

class Solution &#123;
    public int kthSmallest(int[][] matrix, int k) &#123;
        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;
            public int compare(int[] a, int[] b) &#123;
                return a[0] - b[0];
            &#125;
        &#125;);
        int n = matrix.length;
        for (int i = 0; i &lt; n; i++) &#123;
            pq.offer(new int[]&#123;matrix[i][0], i, 0&#125;);
        &#125;
        for (int i = 0; i &lt; k - 1; i++) &#123;
            int[] now = pq.poll();
            if (now[2] != n - 1) &#123;
                pq.offer(new int[]&#123;matrix[now[1]][now[2] + 1], now[1], now[2] + 1&#125;);
            &#125;
        &#125;
        return pq.poll()[0];
    &#125;
&#125;
方法三：二分查找
那么矩阵中不大于 mid 的数，肯定全部分布在矩阵的左上角。
class Solution &#123;
    public int kthSmallest(int[][] matrix, int k) &#123;
        int n = matrix.length;
        int left = matrix[0][0];
        int right = matrix[n - 1][n - 1];
        while (left &lt; right) &#123;
            int mid = left + ((right - left) &gt;&gt; 1);
            if (check(matrix, mid, k, n)) &#123;
                right = mid;
            &#125; else &#123;
                left = mid + 1;
            &#125;
        &#125;
        return left;
    &#125;

    public boolean check(int[][] matrix, int mid, int k, int n) &#123;
        int i = n - 1;
        int j = 0;
        int num = 0;
        while (i &gt;= 0 &amp;&amp; j &lt; n) &#123;
            if (matrix[i][j] &lt;= mid) &#123;
                num += i + 1;
                j++;
            &#125; else &#123;
                i--;
            &#125;
        &#125;
        return num &gt;= k;
    &#125;
&#125;

可以将矩阵看成若干层，首先打印最外层的元素，其次打印次外层的元素，直到打印最内层的元素。
定义4个顶点的坐标位置left、right、top、bottom
1.从左到右遍历上侧元素， 当到达右顶点时停止
2.从上到下遍历右侧元素，当到达下右顶点时停止
3.从右向左侧遍历
4.从下向上遍历
遍历完毕后，四个顶点位置进行内缩
left和top分别加一
right和bottom分别减一，然后再遍历，直到遍历完所有元素为止。
 public int[] spiralOrder(int[][] matrix) &#123;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;
            return new int[0];
        &#125;
        int rows = matrix.length, columns = matrix[0].length;
        int[] order = new int[rows * columns];
        int index = 0;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;
            for (int column = left; column &lt;= right; column++) &#123;
                order[index++] = matrix[top][column];
            &#125;
            for (int row = top + 1; row &lt;= bottom; row++) &#123;
                order[index++] = matrix[row][right];
            &#125;
            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;
                for (int column = right - 1; column &gt; left; column--) &#123;
                    order[index++] = matrix[bottom][column];
                &#125;
                for (int row = bottom; row &gt; top; row--) &#123;
                    order[index++] = matrix[row][left];
                &#125;
            &#125;
            left++;
            right--;
            top++;
            bottom--;
        &#125;
        return order;
    &#125;
</code></pre>
<h2 id="编写一个高效的算法来搜索-m-x-n-矩阵-matrix-中的一个目标值-target。"><a href="#编写一个高效的算法来搜索-m-x-n-矩阵-matrix-中的一个目标值-target。" class="headerlink" title="编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。"></a>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。</h2><pre><code>该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
方法一：暴力法
方法二：二分法搜索
class Solution &#123;
    private boolean binarySearch(int[][] matrix, int target, int start, boolean vertical) &#123;
        int lo = start;
        int hi = vertical ? matrix[0].length-1 : matrix.length-1;

    while (hi &gt;= lo) &#123;
        int mid = (lo + hi)/2;
        if (vertical) &#123; // searching a column
            if (matrix[start][mid] &lt; target) &#123;
                lo = mid + 1;
            &#125; else if (matrix[start][mid] &gt; target) &#123;
                hi = mid - 1;
            &#125; else &#123;
                return true;
            &#125;
        &#125; else &#123; // searching a row
            if (matrix[mid][start] &lt; target) &#123;
                lo = mid + 1;
            &#125; else if (matrix[mid][start] &gt; target) &#123;
                hi = mid - 1;
            &#125; else &#123;
                return true;
            &#125;
        &#125;
    &#125;

    return false;
&#125;

public boolean searchMatrix(int[][] matrix, int target) &#123;
    // an empty matrix obviously does not contain `target`
    if (matrix == null || matrix.length == 0) &#123;
        return false;
    &#125;

    // iterate over matrix diagonals
    int shorterDim = Math.min(matrix.length, matrix[0].length);
    for (int i = 0; i &lt; shorterDim; i++) &#123;
        boolean verticalFound = binarySearch(matrix, target, i, true);
        boolean horizontalFound = binarySearch(matrix, target, i, false);
        if (verticalFound || horizontalFound) &#123;
            return true;
        &#125;
    &#125;
    
    return false; 
&#125;
&#125;
方法三修剪矩阵
首先，我们初始化一个指向矩阵左下角的 
(row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 
(row，col) 为止，我们执行以下操作：如果当前指向的值大于目标值，则可以 “向上” 移动一行。 否则，如果当前指向的值小于目标值，则可以移动一列。不难理解为什么这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。 因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大。也可以对列进行非常类似的论证，因此这种搜索方式将始终在矩阵中找到目标（如果存在）。
class Solution &#123;
    public boolean searchMatrix(int[][] matrix, int target) &#123;
        // start our &quot;pointer&quot; in the bottom-left
        int row = matrix.length-1;
        int col = 0;

    while (row &gt;= 0 &amp;&amp; col &lt; matrix[0].length) &#123;
        if (matrix[row][col] &gt; target) &#123;
            row--;
        &#125; else if (matrix[row][col] &lt; target) &#123;
            col++;
        &#125; else &#123; // found it
            return true;
        &#125;
    &#125;

    return false;
&#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift127NSObject%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift127NSObject%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">NSObject数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:19" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:19+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="object-class"><a href="#object-class" class="headerlink" title="object_class"></a>object_class</h2><p>继承:objc_object<br>内部：<br>Class superClass; 父类<br>cache_t cache;  缓存<br>class_data_bits_t bits  数据</p>
<p>isa指针关系<br>实例对象其指针指向类对象<br>类对象其指针指向元类对象</p>
<p>cache_t<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/45d409e77806">https://www.jianshu.com/p/45d409e77806</a><br>用散列表(哈希表)来缓存曾经调用过的方法，可以提高方法的查找速度，底层结构如下：<br>用于快速查找方法执行函数<br>是可增量扩展的哈希表结构<br>是局部性原理的最佳应用<br>cache 本质是一个 Hash表。存储bucket_t<br>bucket_t存储<br>cache_key_t _key;//@selector()<br>IMP _imp;//函数地址<br>哈希查找：发现当发生碰撞的时候，索引会+1，查找下一个。<br>槽位如果不够，_mask 会变换，变为原来的2倍，并且扩展槽位的时候，会清空数组里原有的缓存内容<br>子类没有实现方法会调用父类的方法，会将父类方法加入到子类自己的cache 里。<br>为什么要创建新的新的buckets来替换原有的buckets并抹掉原有的buckets的方案，而不是在在原有buckets的基础上进行扩容？<br>减少对方法快速查找流程的影响：调用objc_msgSend时会触发方法快速查找，如果进行扩容需要做一些读写操作，对快速查找影响比较大。<br>对性能要求比较高：开辟新的buckets空间并抹掉原有buckets的消耗比在原有buckets上进行扩展更加高效<br>当扩容后，会把新mask设置为newCapacity长度减一，然后清空缓存。<br>所有散列表(哈希表)的原理都是一样的，都是通过一个函数，这个函数传入一个key，通过这个key算出一个索引，如果索引冲突了就加一或者减一，直至不冲突为止，不同的就是算法不一样。</p>
<p>struct class_rw_t {<br>    uint32_t flags;<br>    uint32_t version;</p>
<pre><code>const class_ro_t *ro;

method_array_t methods;
property_array_t properties; //属性，和变量的区别，属性是名称，变量是值
protocol_array_t protocols;

Class firstSubclass;
Class nextSiblingClass;
</code></pre>
<p>};<br>class_rw_t结构体内有一个指向class_ro_t结构体的指针。</p>
<p>细看两个结构体的成员变量会发现很多相同的地方，他们都存放着当前类的属性、实例变量、方法、协议等等。区别在于：class_ro_t存放的是编译期间就确定的；而class_rw_t是在runtime时才确定，它会先将class_ro_t的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说class_rw_t是class_ro_t的超集，当然实际访问类的方法、属性等也都是访问的class_rw_t中的内容</p>
<p>哈希碰撞<br>开放地址法<br>链地址法</p>
<p>struct method_t {<br>    SEL name; //函数名<br>    const char *types; //编码（返回值类型、参数类型）<br>    IMP imp;//指向函数的指针（函数地址）<br>};</p>
<p>instance对象的isa指向class对象<br>class对象的isa指向meta-class对象<br>meta-class对象的isa指向基类的meta-class对象</p>
<p>发消息的步骤<br>检查target是不是nil    ObjC的特性允许对一个nil对象发消息而不会崩溃<br>通过isa，<br>对象方法查找类对象（类对象及继承链上找方法）<br>方法缓存列表，hashMap的结构，查找速度快<br>方法缓存找不到就查找类对象的方法列表中遍历class_rw_t，从后向前的遍历<br>查找父类的类对象—-同上，直至nsobjcect<br>类方法查找元类对象（元类对象及继承链上找方法）<br>方法缓存列表，hashMap的结构，查找速度快<br>方法缓存找不到就查找元类对象的方法列表中遍历class_rw_t，从后向前的遍历</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift143%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift143%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:16" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:16+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><pre><code>栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。


public int[] reversePrint(ListNode head) &#123;
    Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;();
    ListNode temp = head;
    while (temp != null) &#123;
        stack.push(temp);
        temp = temp.next;
    &#125;
    int size = stack.size();
    int[] print = new int[size];
    for (int i = 0; i &lt; size; i++) &#123;
        print[i] = stack.pop().val;
    &#125;
    return print;
&#125;
</code></pre>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><pre><code>class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* a=nullptr;
        ListNode* b=head;
        while(b!=nullptr)&#123;
            ListNode* temp = b-&gt;next; // 拿到下一个
            b-&gt;next = a; // 将当前反转
            a=b; // 获取上一个指针
            b=temp; // 获取下一个指针
        &#125;
        return a;
    &#125;
&#125;;
递归
public ListNode reverseList(ListNode head) &#123;
    if (head == null || head.next == null) return head;
    ListNode p = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
&#125;
</code></pre>
<h2 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h2><pre><code>class Solution &#123;
    //双指针
    public ListNode deleteNode(ListNode head, int val) &#123;
        if(head.val == val)&#123;
            return head.next;
        &#125;
        ListNode cur = head;
        ListNode se = cur.next ;
        while(se != null)&#123;
            if(se.val == val)&#123;
                cur.next = se.next;
                se = null;
                break;
            &#125;
            cur = se;
            se = se.next; 
        &#125;
        return head;
        &#125;
    //单指针
    public ListNode deleteNode(ListNode head, int val) &#123;
        if(head.val == val)&#123;
            return head.next;
        &#125;
        ListNode cur = head;
        while(cur.next != null)&#123;
            if(cur.next.val == val)&#123;
                cur.next = cur.next.next;
                break;
            &#125;
            cur = cur.next;
        &#125;
        return head;
    &#125;
&#125;
</code></pre>
<h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><pre><code>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
双指针，前面的指针先走k步，然后两个指针一起走，知道走到最后，两个指针之间的位置就是 
     public ListNode getKthFromEnd(ListNode head, int k) &#123;
        ListNode former = head, latter = head;
        for(int i = 0; i &lt; k; i++)
            former = former.next;
        while(former != null) &#123;
            former = former.next;
            latter = latter.next;
        &#125;
        return latter;
    &#125;
</code></pre>
<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><pre><code>双指针遍历两个链表，进行比较，小的放入新的链表中，直到两个链表都遍历完毕
public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;
        ListNode dum = new ListNode(0), cur = dum;
        while(l1 != null &amp;&amp; l2 != null) &#123;
            if(l1.val &lt; l2.val) &#123;
                cur.next = l1;
                l1 = l1.next;
            &#125;
            else &#123;
                cur.next = l2;
                l2 = l2.next;
            &#125;
            cur = cur.next;
        &#125;
        cur.next = l1 != null ? l1 : l2;
        return dum.next;
    &#125;
</code></pre>
<h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><pre><code>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
大家的题解都是双指针双百解法。
我来说一个这题的实际应用：
求两个类最低一层的公共父类，就是两个树节点最低一层的公共祖先节点。
这里的树节点内容不是left和right，而是指向父节点的指针。
两个类都用.getSuperclass()方法生成直到Object的两个链表，
再调用这个题的方法就求出了第一个公共祖先。
我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。
这样，当它们相遇时，所指向的结点就是第一个公共结点。
public class Solution &#123;
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
        if(headA == null || headB == null) return null;
        ListNode a = headA, b = headB;
        int len1 = 0, len2 = 0, sum = 0;
        while(a != null &amp;&amp; ++len1 &gt; 0) a = a.next;
        while(b != null &amp;&amp; ++len2 &gt; 0) b = b.next;
        a = headA;
        b = headB;
        while (a != b)&#123;
            if(a.next == null) a = headB;
            else a = a.next;
            if(b.next == null) b = headA;
            else b = b.next;
            if(sum++ &gt; len1 + len2) return null;
        &#125;
        return a;
    &#125;
&#125;
</code></pre>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><pre><code>class Node &#123;
    int val;
    Node next;
    Node random;

    public Node(int val) &#123;
        this.val = val;
        this.next = null;
        this.random = null;
    &#125;
&#125;
public Node copyRandomList(Node head) &#123;
        HashMap&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); //创建HashMap集合
        Node cur=head;
        //复制结点值
        while(cur!=null)&#123;
            //存储put:&lt;key,value1&gt;
            map.put(cur,new Node(cur.val)); //顺序遍历，存储老结点和新结点(先存储新创建的结点值)
            cur=cur.next;
        &#125;
        //复制结点指向
        cur = head;
        while(cur!=null)&#123;
            //得到get:&lt;key&gt;.value2,3
            map.get(cur).next = map.get(cur.next); //新结点next指向同旧结点的next指向
            map.get(cur).random = map.get(cur.random); //新结点random指向同旧结点的random指向
            cur = cur.next;
        &#125;

        //返回复制的链表
        return map.get(head);


    &#125;
</code></pre>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><pre><code>getIndex
addHead
addLast
addAtIndex
deleteIndex
  public class ListNode &#123;
      int val;
      ListNode next;
      ListNode(int x) &#123; val = x; &#125;
    &#125;

class MyLinkedList &#123;
  int size;
  ListNode head;  // sentinel node as pseudo-head
  public MyLinkedList() &#123;
    size = 0;
    head = new ListNode(0);
  &#125;

  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
  public int get(int index) &#123;
    // if index is invalid
    if (index &lt; 0 || index &gt;= size) return -1;

    ListNode curr = head;
    // index steps needed 
    // to move from sentinel node to wanted index
    for(int i = 0; i &lt; index + 1; ++i) curr = curr.next;
    return curr.val;
  &#125;

  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
  public void addAtHead(int val) &#123;
    addAtIndex(0, val);
  &#125;

  /** Append a node of value val to the last element of the linked list. */
  public void addAtTail(int val) &#123;
    addAtIndex(size, val);
  &#125;

  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
  public void addAtIndex(int index, int val) &#123;
    // If index is greater than the length, 
    // the node will not be inserted.
    if (index &gt; size) return;

    // [so weird] If index is negative, 
    // the node will be inserted at the head of the list.
    if (index &lt; 0) index = 0;

    ++size;
    // find predecessor of the node to be added
    ListNode pred = head;
    for(int i = 0; i &lt; index; ++i) pred = pred.next;

    // node to be added
    ListNode toAdd = new ListNode(val);
    // insertion itself
    toAdd.next = pred.next;
    pred.next = toAdd;
  &#125;

  /** Delete the index-th node in the linked list, if the index is valid. */
  public void deleteAtIndex(int index) &#123;
    // if the index is invalid, do nothing
    if (index &lt; 0 || index &gt;= size) return;

    size--;
    // find predecessor of the node to be deleted
    ListNode pred = head;
    for(int i = 0; i &lt; index; ++i) pred = pred.next;

    // delete pred.next 
    pred.next = pred.next.next;
  &#125;
&#125;
</code></pre>
<h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><pre><code>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。
public class Solution &#123;
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
        ListNode t1 = headA;
        ListNode t2 = headB;
        while(t1 != t2)&#123;
            t1 = t1 != null ? t1.next : headB;
            t2 = t2 != null ? t2.next : headA;
        &#125;
        return t2;
    &#125;
&#125;
</code></pre>
<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><pre><code>方法一：哈希表
public boolean hasCycle(ListNode head) &#123;
    Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();
    while (head != null) &#123;
        if (nodesSeen.contains(head)) &#123;
            return true;
        &#125; else &#123;
            nodesSeen.add(head);
        &#125;
        head = head.next;
    &#125;
    return false;
&#125;
方法二：双指针
通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。
public boolean hasCycle(ListNode head) &#123;
    if (head == null || head.next == null) &#123;
        return false;
    &#125;
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) &#123;
        if (fast == null || fast.next == null) &#123;
            return false;
        &#125;
        slow = slow.next;
        fast = fast.next.next;
    &#125;
    return true;
&#125;
</code></pre>
<h2 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h2><pre><code>输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295
输出：2 -&gt; 1 -&gt; 9，即912
class Solution &#123;
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;
        //初始进位为0
        int pre = 0;
        //操作数
        ListNode mid = new ListNode(0);
        //返回头节点
        ListNode anws = mid ;
        //当l1和l2都不为null时进入while循环
        while(l1!=null&amp;&amp;l2!=null)&#123;
            //操作数赋值
            mid.val = (l1.val+l2.val+pre)%10;
            //更新进位
            pre = (l1.val+l2.val+pre)/10;
            //更新头节点
            l1 = l1.next;
            l2=l2.next;
            //头节点更新后判断是否为空
            if(l1==null)&#123;
                //如果l1头节点为空且进位为0，则操作数的next直接为l2剩下的
                if(pre==0) &#123;
                    mid.next = l2;
                    return anws;
                &#125;else &#123;
                    //如果有进位，则递归调用addTwoNumbers方法
                    mid.next = addTwoNumbers(l2,new ListNode(pre));
                    return anws;
                &#125;
            &#125;
            //同上
            if(l2 == null)&#123;
                if(pre==0) &#123;
                    mid.next = l1;
                    return anws;
                &#125;else &#123;
                    mid.next = addTwoNumbers(l1,new ListNode(pre));
                    return anws;
                &#125;
            &#125;
            //l1 l2更新后都不为null，则设置操作数为0 进入下一次while循环
            mid.next =new ListNode(0);
            mid = mid.next;
        &#125;
        //l1为null，直接不能进入上面while循环的情况下，直接返回l2
        if(l1==null)&#123;
            return l2;
        &#125;//同上
        else if(l2 ==null)&#123;
            return l1;
        &#125;
        return anws;
    &#125;
&#125;
</code></pre>
<h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><pre><code>1，采用快慢两个指针去寻找链表的中间节点；
2，根据链表的中间节点反转后一半的链表；
class Solution &#123;
    public boolean isPalindrome(ListNode head) &#123;
        if(head == null) return true;

    ListNode midNode = findMidNode(head);
    ListNode secondHalfHead = reverseLinked(midNode.next);
    ListNode curr1 = head;
    ListNode curr2 = secondHalfHead;

    boolean palindrome = true;
    while(palindrome &amp;&amp; curr2 != null)&#123;
        if(curr1.val != curr2.val) palindrome = false;
        curr1 = curr1.next;
        curr2 = curr2.next;
    &#125;

    return palindrome;
&#125;

/* 反转链表 */
private ListNode reverseLinked(ListNode head)&#123;
    ListNode cur = head;
    ListNode prev = null;
    while(cur != null)&#123;
        ListNode nextTemp = cur.next;
        cur.next = prev;
        prev = cur;
        cur = nextTemp;
    &#125;
    return prev;
&#125;

/* 快慢指针寻找中间节点 */
private ListNode findMidNode(ListNode head)&#123;
    ListNode fast = head;
    ListNode low = head;
    while(fast.next != null &amp;&amp; fast.next.next != null)&#123;
        fast = fast.next.next;
        low = low.next;
    &#125;
    return low;
&#125;

&#125;
</code></pre>
<h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><pre><code>先将链表闭合成环
找到相应的位置断开这个环，确定新的链表头和链表尾
class Solution &#123;
  public ListNode rotateRight(ListNode head, int k) &#123;
    // base cases
    if (head == null) return null;
    if (head.next == null) return head;

// close the linked list into the ring
ListNode old_tail = head;
int n;
for(n = 1; old_tail.next != null; n++)
  old_tail = old_tail.next;
old_tail.next = head;

// find new tail : (n - k % n - 1)th node
// and new head : (n - k % n)th node
ListNode new_tail = head;
for (int i = 0; i &lt; n - k % n - 1; i++)
  new_tail = new_tail.next;
ListNode new_head = new_tail.next;

// break the ring
new_tail.next = null;

return new_head;
  &#125;
&#125;
</code></pre>
<h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><pre><code>归并排序（递归法）
解答一：归并排序（递归法）
分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；
合并 merge 环节： 将两个排序链表合并，转化为一个排序链表
class Solution &#123;
    public ListNode sortList(ListNode head) &#123;
        if (head == null || head.next == null)
            return head;
        ListNode fast = head.next, slow = head;
        while (fast != null &amp;&amp; fast.next != null) &#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        ListNode tmp = slow.next;
        slow.next = null;
        ListNode left = sortList(head);
        ListNode right = sortList(tmp);
        ListNode h = new ListNode(0);
        ListNode res = h;
        while (left != null &amp;&amp; right != null) &#123;
            if (left.val &lt; right.val) &#123;
                h.next = left;
                left = left.next;
            &#125; else &#123;
                h.next = right;
                right = right.next;
            &#125;
            h = h.next;
        &#125;
        h.next = left != null ? left : right;
        return res.next;
    &#125;
&#125;
</code></pre>
<h2 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h2><pre><code>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起
将奇节点放在一个链表里，偶链表放在另一个链表里。然后把偶链表接在奇链表的尾部。
public class Solution &#123;
    public ListNode oddEvenList(ListNode head) &#123;
        if (head == null) return null;
        ListNode odd = head, even = head.next, evenHead = even;
        while (even != null &amp;&amp; even.next != null) &#123;
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        &#125;
        odd.next = evenHead;
        return head;
    &#125;
&#125;
</code></pre>
<h2 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a>链表的中间结点</h2><pre><code>方法一：数组
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        ListNode[] A = new ListNode[100];
        int t = 0;
        while (head != null) &#123;
            A[t++] = head;
            head = head.next;
        &#125;
        return A[t / 2];
    &#125;
&#125;
方法二：单指针法
我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        int n = 0;
        ListNode cur = head;
        while (cur != null) &#123;
            ++n;
            cur = cur.next;
        &#125;
        int k = 0;
        cur = head;
        while (k &lt; n / 2) &#123;
            ++k;
            cur = cur.next;
        &#125;
        return cur;
    &#125;
&#125;
方法三：快慢指针法
slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        ListNode slow = head, fast = head;
        while (fast != null &amp;&amp; fast.next != null) &#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        return slow;
    &#125;
&#125;
</code></pre>
<h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><pre><code>主要考虑翻转后如何链接
const myReverse = (head, tail) =&gt; &#123;
    let prev = tail.next;
    let p = head;
    while (prev !== tail) &#123;
        const nex = p.next;
        p.next = prev;
        prev = p;
        p = nex;
    &#125;
    return [tail, head];
&#125;
var reverseKGroup = function(head, k) &#123;
    const hair = new ListNode(0);
    hair.next = head;
    let pre = hair;

    while (head) &#123;
        let tail = pre;
        // 查看剩余部分长度是否大于等于 k
        for (let i = 0; i &lt; k; ++i) &#123;
            tail = tail.next;
            if (!tail) &#123;
                return hair.next;
            &#125;
        &#125;
        const nex = tail.next;
        [head, tail] = myReverse(head, tail);
        // 把子链表重新接回原链表
        pre.next = head;
        tail.next = nex;
        pre = tail;
        head = tail.next;
    &#125;
    return hair.next;
&#125;;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift142HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift142HashMap/" class="post-title-link" itemprop="url">HashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:12" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:12+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）"><a href="#HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）" class="headerlink" title="HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）"></a>HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）</h1><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><pre><code>由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的
数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到
的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。
public int findRepeatNumber(int[] nums) &#123;
    Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    int repeat = -1;
    for (int num : nums) &#123;
        if (!set.add(num)) &#123;
            repeat = num;
            break;
        &#125;
    &#125;
    return repeat;
&#125;
</code></pre>
<h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><pre><code>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
本题考察 哈希表 的使用，本文介绍 “哈希表” 和 “有序哈希表” 两种解法。其中
，在字符串很长时， “有序哈希表” 解法理论上效率更高。
public char firstUniqChar(String s) &#123;
    HashMap&lt;Character, Boolean&gt; dic = new HashMap&lt;&gt;();
    char[] sc = s.toCharArray();
    for(char c : sc)
        dic.put(c, !dic.containsKey(c));
    for(char c : sc)
        if(dic.get(c)) return c;
    return &#39; &#39;;
&#125;

在哈希表的基础上，有序哈希表中的键值对是 按照插入顺序排序 的。
基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 1 的字符”。
public char firstUniqChar(String s) &#123;
    Map&lt;Character, Boolean&gt; dic = new LinkedHashMap&lt;&gt;();
    char[] sc = s.toCharArray();
    for(char c : sc)
        dic.put(c, !dic.containsKey(c));
    for(Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())&#123;
       if(d.getValue()) return d.getKey();
    &#125;
    return &#39; &#39;;
&#125;
</code></pre>
<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><pre><code>首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，
然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，
则将该数字添加到答案，并减少哈希表中该数字出现的次数。
为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现
的次数，然后遍历较长的数组得到交集。
public int[] intersect(int[] nums1, int[] nums2) &#123;
    if (nums1.length &gt; nums2.length) &#123;
        return intersect(nums2, nums1);
    &#125;
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
    for (int num : nums1) &#123;
        int count = map.getOrDefault(num, 0) + 1;
        map.put(num, count);
    &#125;
    int[] intersection = new int[nums1.length];
    int index = 0;
    for (int num : nums2) &#123;
        int count = map.getOrDefault(num, 0);
        if (count &gt; 0) &#123;
            intersection[index++] = num;
            count--;
            if (count &gt; 0) &#123;
                map.put(num, count);
            &#125; else &#123;
                map.remove(num);
            &#125;
        &#125;
    &#125;
    return Arrays.copyOfRange(intersection, 0, index);
&#125;
</code></pre>
<h2 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h2><pre><code>class Node &#123;
    public int val;
    public Node next;
    public Node random;

    public Node() &#123;&#125;

    public Node(int _val,Node _next,Node _random) &#123;
        val = _val;
        next = _next;
        random = _random;
    &#125;
&#125;;
public Node copyRandomList(Node head) &#123;
    if(head==null) &#123;
        return null;
    &#125;
    //创建一个哈希表，key是原节点，value是新节点
    Map&lt;Node,Node&gt; map = new HashMap&lt;Node,Node&gt;();
    Node p = head;
    //将原节点和新节点放入哈希表中
    while(p!=null) &#123;
        Node newNode = new Node(p.val);
        map.put(p,newNode);
        p = p.next;
    &#125;
    p = head;
    //遍历原链表，设置新节点的next和random
    while(p!=null) &#123;
        Node newNode = map.get(p);
        //p是原节点，map.get(p)是对应的新节点，p.next是原节点的下一个
        //map.get(p.next)是原节点下一个对应的新节点
        if(p.next!=null) &#123;
            newNode.next = map.get(p.next);
        &#125;
        //p.random是原节点随机指向
        //map.get(p.random)是原节点随机指向  对应的新节点 
        if(p.random!=null) &#123;
            newNode.random = map.get(p.random);
        &#125;
        p = p.next;
    &#125;
    //返回头结点，即原节点对应的value(新节点)
    return map.get(head);
&#125;
</code></pre>
<h2 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h2><pre><code>我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。
public boolean hasCycle(ListNode head) &#123;
    Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();
    while (head != null) &#123;
        if (nodesSeen.contains(head)) &#123;
            return true;
        &#125; else &#123;
            nodesSeen.add(head);
        &#125;
        head = head.next;
    &#125;
    return false;
&#125;
</code></pre>
<h2 id="找树中两个指定节点的最近公共祖先。"><a href="#找树中两个指定节点的最近公共祖先。" class="headerlink" title="找树中两个指定节点的最近公共祖先。"></a>找树中两个指定节点的最近公共祖先。</h2><pre><code>哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点
开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已
经访问过的节点，那么这个节点就是我们要找的最近公共祖先。
class Solution &#123;
Map&lt;Integer, TreeNode&gt; parent = new HashMap&lt;Integer, TreeNode&gt;();
Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;();

public void dfs(TreeNode root) &#123;
    if (root.left != null) &#123;
        parent.put(root.left.val, root);
        dfs(root.left);
    &#125;
    if (root.right != null) &#123;
        parent.put(root.right.val, root);
        dfs(root.right);
    &#125;
&#125;

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
    dfs(root);
    while (p != null) &#123;
        visited.add(p.val);
        p = parent.get(p.val);
    &#125;
    while (q != null) &#123;
        if (visited.contains(q.val)) &#123;
            return q;
        &#125;
        q = parent.get(q.val);
    &#125;
    return null;
&#125;
&#125;
</code></pre>
<h2 id="缺失数字"><a href="#缺失数字" class="headerlink" title="缺失数字"></a>缺失数字</h2><pre><code>给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。
public int missingNumber(int[] nums) &#123;
    Set&lt;Integer&gt; numSet = new HashSet&lt;Integer&gt;();
    for (int num : nums) numSet.add(num);

    int expectedNumCount = nums.length + 1;
    for (int number = 0; number &lt; expectedNumCount; number++) &#123;
        if (!numSet.contains(number)) &#123;
            return number;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<h2 id="找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）"><a href="#找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）" class="headerlink" title="找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）"></a>找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）</h2><pre><code>public int longestConsecutive(int[] nums) &#123;
    Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;();
    for (int num : nums) &#123;
        num_set.add(num);
    &#125;

    int longestStreak = 0;

    for (int num : num_set) &#123;
        if (!num_set.contains(num - 1)) &#123;
            int currentNum = num;
            int currentStreak = 1;

            while (num_set.contains(currentNum + 1)) &#123;
                currentNum += 1;
                currentStreak += 1;
            &#125;

            longestStreak = Math.max(longestStreak, currentStreak);
        &#125;
    &#125;

    return longestStreak;
&#125;
</code></pre>
<h2 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h2><pre><code>遍历五张牌，遇到大小王（即 0直接跳过。
判别重复： 利用 Set 实现遍历判重， Set 
获取最大 / 最小的牌： 借助辅助变量 ma 和 mi ，遍历统计即可。
public boolean isStraight(int[] nums) &#123;
    Set&lt;Integer&gt; repeat = new HashSet&lt;&gt;();
    int max = 0, min = 14;
    for(int num : nums) &#123;
        if(num == 0) continue; // 跳过大小王
        max = Math.max(max, num); // 最大牌
        min = Math.min(min, num); // 最小牌
        if(repeat.contains(num)) return false; // 若有重复，提前返回 false
        repeat.add(num); // 添加此牌至 Set
    &#125;
    return max - min &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子
&#125;
</code></pre>
<h2 id="四数相加（HashMap存一组，另一组和HashMap进行比对）"><a href="#四数相加（HashMap存一组，另一组和HashMap进行比对）" class="headerlink" title="四数相加（HashMap存一组，另一组和HashMap进行比对）"></a>四数相加（HashMap存一组，另一组和HashMap进行比对）</h2><pre><code>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组和为0
采用分为两组，HashMap存一组，另一组和HashMap进行比对。
public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    int res = 0;
    for(int i = 0;i&lt;A.length;i++)&#123;
        for(int j= 0;j&lt;B.length;j++)&#123;
            int sumAB = A[i]+B[j];
            if(map.containsKey(sumAB)) map.put(sumAB,map.get(sumAB)+1);
            else map.put(sumAB,1);
        &#125;
    &#125;

    for(int i = 0;i&lt;C.length;i++)&#123;
        for(int j = 0;j&lt;D.length;j++)&#123;
            int sumCD = -(C[i]+D[j]);
            if(map.containsKey(sumCD)) res += map.get(sumCD);
        &#125;
    &#125;
    return res;
&#125;
</code></pre>
<h2 id="至少有K个重复字符的最长子串"><a href="#至少有K个重复字符的最长子串" class="headerlink" title="至少有K个重复字符的最长子串"></a>至少有K个重复字符的最长子串</h2><pre><code>先用hash表统计s中每个字符出现的次数，显然如果字符c出现的次数小于k
，c必然不在最长子串里面，根据这个特性可以将原始s分割成多个子串递归地求解问
题，我们用一个split数组依次来存放每个分割点的索引，对每个分割区间同样求
解该问题(多路的分治问题)，并取结果的最大值保存在变量ans中，此处有一个小trick
（如果当前求解的子串长度比已存在的ans还要小，则没有必要求解
该区间，这样可以减少不必要的计算），最后递归的结束点就是当前求
解的字符串s符合最长子串的要求。
public:
    int longestSubstring(string s, int k) &#123;
        unordered_map&lt;char, int&gt; umap;
        for (auto c : s) umap[c]++;
        vector&lt;int&gt; split;
        for (int i = 0; i &lt; s.size(); i++) &#123;
            if (umap[s[i]] &lt; k) split.push_back(i);
        &#125;
        if (split.size() == 0) return s.length();
        int ans = 0, left= 0;
        split.push_back(s.length());
        for (int i = 0; i &lt; split.size(); i++) &#123;
            int len = split[i] - left;
            if (len &gt; ans) ans = max(ans, longestSubstring(s.substr(left, len), k));
            left = split[i]+1;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h2 id="给定两个字符串-s-和-t-，编写一个函数来判断-t-是否是-s-的字母异位词。"><a href="#给定两个字符串-s-和-t-，编写一个函数来判断-t-是否是-s-的字母异位词。" class="headerlink" title="给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。"></a>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</h2><pre><code>public boolean isAnagram(String s, String t) &#123;
    if (s.length() != t.length()) &#123;
        return false;
    &#125;
    int[] counter = new int[26];
    for (int i = 0; i &lt; s.length(); i++) &#123;
        counter[s.charAt(i) - &#39;a&#39;]++;
        counter[t.charAt(i) - &#39;a&#39;]--;
    &#125;
    for (int count : counter) &#123;
        if (count != 0) &#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;
</code></pre>
<h2 id="给定一个字符串，找到它的第一个不重复的字符"><a href="#给定一个字符串，找到它的第一个不重复的字符" class="headerlink" title="给定一个字符串，找到它的第一个不重复的字符"></a>给定一个字符串，找到它的第一个不重复的字符</h2><pre><code>public int firstUniqChar(String s) &#123;
    HashMap&lt;Character, Integer&gt; count = new HashMap&lt;Character, Integer&gt;();
    int n = s.length();
    for (int i = 0; i &lt; n; i++) &#123;
        char c = s.charAt(i);
        count.put(c, count.getOrDefault(c, 0) + 1);
    &#125;
    
    for (int i = 0; i &lt; n; i++) &#123;
        if (count.get(s.charAt(i)) == 1) 
            return i;
    &#125;
    return -1;
&#125;
</code></pre>
<h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><pre><code>public int lengthOfLongestSubstring(String s) &#123;
    Map&lt;Character, Integer&gt; dic = new HashMap&lt;&gt;();
    int res = 0, tmp = 0;
    for(int j = 0; j &lt; s.length(); j++) &#123;
        int i = dic.getOrDefault(s.charAt(j), -1); // 获取索引 i
        dic.put(s.charAt(j), j); // 更新哈希表
        tmp = tmp &lt; j - i ? tmp + 1 : j - i; // dp[j - 1] -&gt; dp[j]
        res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
    &#125;
    return res;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift141%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift141%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:08" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:08+08:00">2020-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 10:07:07" itemprop="dateModified" datetime="2022-04-29T10:07:07+08:00">2022-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>数组元素在内存上连续存放，可以通过下表查找元素；插入，删除需要移动大量元素，比较适用于元素很少的情况
优点：
1、按照索引查询元素速度快
2、按照索引遍历数组方便
事物都有两面性，有优点自然就有缺点了
缺点：
1、数组的大小固定后就无法扩容了
2、数组只能存储一种类型的数据
3、添加，删除的操作慢，因为要移动其他的元素。
高级语言中所用数组结构
NSArrayM 用了环形缓冲区 (circular buffer)。环形缓冲区的内容能在到达任意一端时绕向另一端。
NSArrayM 试着去最小化内存的移动，因此会移动最少的一边元素。
</code></pre>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><pre><code>常见的字典结构都是hashmap实现的
扩容：开放定址法的结构通常允许在通列表的数量达到了某个阈值，通常是通列表长度的80%使用量
时，对通列表进行一次扩充grow，然后重新计算数据的keyHash放入新桶中
但是不断扩容的空间就是其弊端，因此开放地址法最好存储的是临时需要，尽快释放的资源
例如字典参数和associated object，拉链法就保证了资源的可控性，像这种@synchronized
锁就可以根据地址拉链出一条对应的使用线程即可，随时使用。
</code></pre>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><pre><code>链表中的元素在内存中不是顺序存储的，查找慢，插入、删除只需要对元素指针重新赋值，效率高
</code></pre>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><pre><code>堆是一种经过排序的树形数据结构，每个节点都有一个值，通常
我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常
可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：
1.堆中某个节点的值总是不大于或不小于其父节点的值；
2.堆总是一棵完全二叉树。
堆常用来实现优先队列
</code></pre>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><pre><code>栈是限定仅在表尾进行插入和删除操作的线性表。我们
把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据
元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删
除位置，它始终只在栈顶进行。
栈的应用—递归
</code></pre>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><pre><code>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表
。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表
，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作
，和栈一样，队列是一种操作受限制的线性表。
</code></pre>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><pre><code>典型应用是用于统计和排序大量的字符串（但不仅限于字符串），
所以经常被搜索引擎系统用于文本词频统计。它的优点是：
最大限度地减少无谓的字符串比较，查询效率比哈希表高。
</code></pre>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><pre><code>线段树，类似区间树，是一个完全二叉树，它在各个节点保存一条线段
（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，
由于二叉结构的特性，它基本能保持每个操作的复杂度为O(lgN)!
性质：父亲的区间是[a,b],(c=(a+b)/2)左儿子的区间是[a,c]，
右儿子的区间是[c+1,b]，线段树需要的空间为数组大小的四倍
</code></pre>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><pre><code>是每个结点最多有两个子树的树结构。通常子树被称作
“左子树”（left subtree）和“右子树”（right subtree）。
</code></pre>
<h3 id="⼆叉搜索树"><a href="#⼆叉搜索树" class="headerlink" title="⼆叉搜索树"></a>⼆叉搜索树</h3><pre><code>假如固定左边子树小于根节点，右边子树大于根节点，
让元素存入的时候就排序好，那么访问速度就加快了，我们称这样的树为二叉搜索树。
1. 若任意节点的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值； 
2. 若任意节点的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值； 
3. 任意节点的左、右⼦树也分别为⼆叉查找树。
</code></pre>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><pre><code>顾名思义，就是用数组来模拟树形结构呗。那么衍生出一个问题，
为什么不直接建树？答案是没必要，因为树状数组能处理的问题就没必要建
树。和Trie树的构造方式有类似之处。
2.树状数组可以解决什么问题
可以解决大部分基于区间上的更新以及求和问题。
3.树状数组和线段树的区别在哪里
树状数组可以解决的问题都可以用线段树解决，这两
者的区别在哪里呢？树状数组的系数要少很多，就比如字符串模
拟大数可以解决大数问题，也可以解决1+1的问题，但没人会
在1+1的问题上用大数模拟。
4.树状数组的优点和缺点
修改和查询的复杂度都是O(logN)，而且相比线段树系数要少很多，比传统数组要快，而且容易写。
缺点是遇到复杂的区间问题还是不能解决，功能还是有限。
</code></pre>
<p>总结算法和自己的模板。</p>
<p>图</p>
<p>优先队列<br>双端队列<br>有向图<br>无向图<br>复杂数据结构</p>
<p>二叉树<br>树状数组<br>优先队列<br>双端队列<br>有向图<br>无向图<br>// 中序遍历<br>void dfs(TreeNode root) {<br>    if(root == null) return;<br>    dfs(root.left); // 左<br>    System.out.println(root.val); // 根<br>    dfs(root.right); // 右<br>}</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>冒泡排序<br>插入排序<br>归并排序<br>快速排序<br>拓扑排序<br>堆排序（大顶堆、小顶堆）<br>桶排序<br>二分搜索<br>广度优先搜索<br>深度优先搜索<br>递归<br>回溯<br>贪婪算法<br>动态规划<br>线性规划<br>区间规划<br>约束规划<br>自底向上<br>自定向下</p>
<p>解体思路</p>
<p>输入一棵二叉树的根结点，求该树的深度？<br>输入一课二叉树的根结点，判断该树是不是平衡二叉树？<br>写个算法，输出2~100的素数<br>写二叉树的先序遍历，然后用非递归写<br>写快排，并分析原理<br>在10亿个数中如何快速找到最大的前100个数？<br>C语言中strlen和sizeof的区别<br>链表反转；<br>字符串查找问题；<br>求k数<br>给一个数组，找出这样一些数，这个数左边的数都比它小，右边的数都比它大<br>算法题：leetcode1 两数之和，给出三种方法<br>剑指offer 62 圆圈中剩下的数字（约瑟夫环问题）<br>leetcode 41 缺失的第一个正数<br>汉洛塔<br>如果为了加快进度增加2根竹子 如何得到最优解<br>智力题：三个人分别点了三家外卖，又一个外卖小哥配送，他有多少种配送方式<br>手撕代码题：<br>两种方法链表翻转<br>最大上升子序列<br>问算法题两道反转列表和二分查找；<br>智力题：赛马题，网上能搜到<br>手撕代码：一棵树，从左边看，输出你能看到的结点（我说用层次遍历、队列、哨兵）<br>问了一题智力题：8个杯子，给5个球，每个杯子放一个球，求三个球连续的概率（排列组合知识遗忘+紧张，没做出来。。）<br>    总共有C（8,5）=56种方法<br>    三个空格相连有123、234、···678共6种<br>    而每种情况是等概率的<br>    所以三个空格相连的概率=6/56=3/28<br>给一个字符串去重；<br>决策树的实现原理<br>上海到北京有很多条公交路线，每条线有不同个数的站点，问：如何找到一条最优路线？<br>hash算法又解决了哪些问题，它的时间复杂度是多少等等；<br>问一个有关花开通知蜜蜂，花关通知蜜蜂的问题；<br>问给出二叉树的前序排序和中序排序结果重建二叉树<br>问 从字典中取数据，为什么比在数组中取数据快，底层原理是什么<br>问到大批量数据库导入如何处理优化；<br>问了些性能优化、重构的问题；<br>问用递归写一个阶乘算法；<br>问：要求想一个时间复杂度为O1的解法，来解决一个2的平方的算法题（答 无限空间换时间的策略）；<br>问二叉树翻转(递归翻转);<br>断开连接是只有客户端断开还是两方都能断开；<br>二叉树非递归遍历二叉树先序、中序、后序；<br>ACID银行家算法；<br>图片的获取与切割；<br>一个不多于5位数的整数，反序处理problem；<br>两个IP端是否有交集problem；<br>给字符串，内含很多整数，按指定要求排序后输出指定位置上的整数；<br>如何返回两个int型变量；<br>如何快速找到一个链表的中间节点；<br>1.给两个int a, b不用temp将数值调换；<br>    如: let a = 1,b=2;<br>    a的二进制: 0001<br>    b的二进制: 0010<br>    利用异或运算的规律：两个操作数的位中，相同返回0，不同相返回1<br>    a = a^b;//now a = 0011<br>    b = b^a;//a: 0011, b:0010, now b:0001<br>    a = a^b;//b:0001, a:0011, now a:0010<br>    达到互换<br>2.银行家算法；<br>3. public private；<br>4.先序遍历树；</p>
<p>两个无限长度链表（也就是可能有环）判断有没有交点<br>10万个数中如何找出前K个数；<br>写一个算法，输出2到100之间的素数（然后不停地问你优化点）；<br>写二叉树的非递归前序遍历；<br>在很多的数据中如何快速找到最大的100个数？<br>二叉树的最大宽度<br>算法：单链表是否存在环；<br>问1秒钟有1000条数据，我只显示10条怎么做；<br>如何判断一个链表是否是无限长的（答判断next指针是否指向NULL）<br>非波拉切数求第n个数的值；<br>写一道二分查找；<br>用中文的数字表示一个十进制数；<br>两个有序数组，找出合并后的中位数。<br> 问了微信红包并发的问题的；<br> 算法：动态规划<br>搜索历史记录的关键字匹配（用的iOS自带的谓词做匹配筛选）<br> 算法：一个数组，有个滑动窗口，求每次窗口中的中位数。<br> 一个较复杂的排序算法:一个多边形分割方法;<br> 一个类似于从篮子里如何取苹果的一个算法;<br> 一个凸多边形，如何求面积。（答把多边形分割成N个三角形，三角形知道三个点的坐标就可以求出面积，全部相加求出总面积。）<br> 你知道矩阵吗？我说知道，他说那你用矩阵变换.<br> 二叉树的镜像；<br> 一组整数求加起来等于0的3个数；<br> 堆排序；<br> 求公共祖先问题<br> 复杂度代码实现；</p>
<p> 复杂度推导。<br> 问：查找登陆次数最多的十个用户<br> 答：（不确定对不对，我的思路是）先用哈希表保存登陆次数和ID，然后用红黑树保存最大的十个数；<br> 问：简述排序算法。<br> 答：快排，partion函数的原理，堆排（不稳定），归并排序，基数排序；<br> 两个字符串，只打印一个字符串中在另一个字符串中出现的共有的字符<br> Vector是怎么实现的？<br>  最小路径算法（楼主说了Dijkstra和floyd算法）<br> 求一个二叉树的最大深度，该二叉树不确定是不是红黑树<br> 两个人掷硬币，先得到正面的人赢，游戏到有人赢结束。问先掷硬币的人赢的概率<br> 算法：两个链表求和<br> 法 求第n大的数。<br> 堆和优先队列有什么区别？什么是堆排序、最大堆、最小堆？<br> 什么是二分搜索树？什么是平衡二分搜索树？常见的平衡二分搜索树有那几种？AVL树、B树、红黑树有什么区别？<br> 什么是稳定排序？时间复杂度的定义是什么？<br> 算法题:如何计算x^n?</p>
<p> Q3:算法题:给定二叉树Root以及任意两个节点p/q,问p,q的最近公共父亲节点是什么?</p>
<p> 有15个瓶子，其中最多有一瓶有毒，现在有四只老鼠，喝了有毒的水之后，第二天就会死。如何在第二天就可以判断出哪个瓶子有毒<br> 答：开始我想到的是常规思路二分法，717，和面试官说了，发现四只老鼠根本不够，面试官友好的提示从老鼠面去想，这时候很快想到了一个老鼠有死和不死，也就0和1两个状态，四只老鼠有16个组合，正好是足够的。但是怎么分配瓶子，还没想好，演算了一会儿，因为面试官这边时间有限，就说思路是正确的。下面有兴趣在看怎么分哈。面试就到此结束了。</p>
<p> 算法思路：二选一</p>
<p> Q1:数学题:给一个棍子，随机砍两刀，组成一个三角形的概率是多少?</p>
<p> Q2:有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生命都会在一星期之后死亡。现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？<br> 如何用Core Graph画圆<br> ，现在我们来做两个算法题，先说一下nlogn的时间复杂度的排序，并调一种实现。</p>
<p> 9，给定两个数组，第一个数组是无序的数长为n，第二个数组每个元素是一对下标[(1,3),(2,4)]，表示第一个数组中下标1-3的和和2-4的和，长度为m，我们要把其相对于第一个数组和求出来，选择一个比较优的算法，并分析其时间复杂度。</p>
<p> 比如1-3和2-4 ，2-3这里出现了重复计算，我们可以用一个额外的数组去保存这些重复运算，这个数组长度为</p>
<p> n，存储的值是，比如下标是1的时候相对于第一个数组下标0的值加下标1的值，下标是2的时候0+1+2，当我们要取数组的(2,5)范围的值，可以用新创建存储重复运算的数组，取其下标5减去其下标2就可以得出3+4+5的值。这题花了15分钟吧，问了三次面试官才知道题目的意思，一开始想用动态规划，后面得出这种用数组存储重复运算，想递归优化那种思路吧，面试官觉得这个答案正确，叫我说一下时间复杂度，最坏是(0,n)即0+1+2…n(这里是第一个数组的下标，这时候已经把所有可以重用的数据求出来了，即后面我们的运算只需要1的复杂度(2,5)-&gt;缓存数组[5]-缓存数组[2]，所以时间复杂度是n+m。这题差点想放弃，大家碰到算法题听不懂的时候不要太快放弃，面试官会很耐心的重复几次。<br>APP的相似照片检测算法<br>人脸识别能做吗？<br>就说了上个项目做类似朋友圈的优化思路，谈到了空间换时间，缓存，渲染相关的技术点。不得不惊叹腾讯的面试官的逻辑条理，很快抓住了问题的本质。</p>
<p>该模块引申到的新话题还涉及到了增量更新，内存缓存，本地缓存。细节上还谈到了富文本绘制，Coretext框架的使用，但由于也好久没用了，最后只能凭借印象大概说了下绘制的流程，其实面试官都是由浅入深的，如果这边回答的不够深入。那么后面也就不会有更深入的探讨了。由于之前我们的产品需求比较简单，没有特别完善。这里我也只能说了大概。</p>
<h1 id="公司性质问题"><a href="#公司性质问题" class="headerlink" title="公司性质问题"></a>公司性质问题</h1><p>自我介绍<br>谈谈自己做过的项目；<br>你还有什么问题问我<br>为什么想来<br>你有什么创新能力<br>聊人生<br>职业规划<br>.会问在之前的项目中担任什么角***r /&gt; 5.再根据你的角色问相关问题。</p>
<p>为什么在快手实习要来抖音面试<br>你认为字节跳动最吸引你的地方或者说好的地方<br>你觉得你比其他人的优点在哪里<br>你觉得未来自己应该做哪些深入研究<br>你对于基础服务和需求featrue 哪个更有兴趣：<br>互联网上广告的形式都有哪几种；<br>产品设计时需要考虑的因素；<br>安卓和ios的区别和优缺点，并让设计一款更好的操作系统；</p>
<p>认识到了自己的不足：<br>怎么改善提高：</p>
<p>大数据中取前100大的数<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyq522376829/article/details/47686867">https://blog.csdn.net/zyq522376829/article/details/47686867</a><br>面试题：输入一个十进制整数，将这个数字转化成对应的十五进制数（在十五进制中，A表示10，B表示11，C表示12，D表示13， E表示14），请写入转换程序。例如：235表示为10A；</p>
<p>地图相关的算法<br>三角剖分</p>
<p>初期:<br>一.基本算法:<br>(1)枚举. (poj1753,poj2965)<br>(2)贪心(poj1328,poj2109,poj2586)<br>(3)递归和分治法.<br>(4)递推.<br>(5)构造法.(poj3295)<br>(6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)<br>二.图算法:<br>(1)图的深度优先遍历和广度优先遍历.<br>(2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)<br>(poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)<br>(3)最小生成树算法(prim,kruskal)<br>(poj1789,poj2485,poj1258,poj3026)<br>(4)拓扑排序 (poj1094)<br>(5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)<br>(6)最大流的增广路算法(KM算法). (poj1459,poj3436)<br>三.数据结构.<br>(1)串 (poj1035,poj3080,poj1936)<br>(2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)<br>(3)简单并查集的应用.<br>(4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)<br>(poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)<br> (5)哈夫曼树(poj3253)<br>(6)堆<br>(7)trie树(静态建树、动态建树) (poj2513)<br>四.简单搜索<br>(1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)<br>(2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)<br>(3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)<br>五.动态规划<br>(1)背包问题. (poj1837,poj1276)<br>(2)型如下表的简单DP(可参考lrj的书 page149):<br>1.E[j]=opt{D+w(i,j)} (poj3267,poj1836,poj1260,poj2533)<br>2.E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)<br>(poj3176,poj1080,poj1159)<br>3.C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)<br>六.数学<br>(1)组合数学:<br>1.加法原理和乘法原理.<br>2.排列组合.<br>3.递推关系.<br>(POJ3252,poj1850,poj1019,poj1942)<br>(2)数论.<br>1.素数与整除问题<br>2.进制位.<br>3.同余模运算.<br>(poj2635, poj3292,poj1845,poj2115)<br>(3)计算方法.<br>1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122)<br>七.计算几何学.<br>(1)几何公式.<br>(2)叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)<br>(3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)<br>(poj1408,poj1584)<br>(4)凸包. (poj2187,poj1113)<br>中级:<br>一.基本算法:<br>(1)C++的标准模版库的应用. (poj3096,poj3007)<br>(2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)<br>二.图算法:<br>(1)差分约束系统的建立和求解. (poj1201,poj2983)<br>(2)最小费用最大流(poj2516,poj2195)<br>(3)双连通分量(poj2942)<br>(4)强连通分支及其缩点.(poj2186)<br>(5)图的割边和割点(poj3352)<br>(6)最小割模型、网络流规约(poj3308, )<br>三.数据结构.<br>(1)线段树. (poj2528,poj2828,poj2777,poj2886,poj2750)<br>(2)静态二叉检索树. (poj2482,poj2352)<br>(3)树状树组(poj1195,poj3321)<br>(4)RMQ. (poj3264,poj3368)<br>(5)并查集的高级应用. (poj1703,2492)<br>(6)KMP算法. (poj1961,poj2406)<br>四.搜索<br>(1)最优化剪枝和可行性剪枝<br>(2)搜索的技巧和优化 (poj3411,poj1724)<br>(3)记忆化搜索(poj3373,poj1691)<br>五.动态规划<br>(1)较为复杂的动态规划(如动态规划解特别的施行商问题等)<br>(poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)<br>(2)记录状态的动态规划. (POJ3254,poj2411,poj1185)<br>(3)树型动态规划(poj2057,poj1947,poj2486,poj3140)<br>六.数学<br>(1)组合数学:<br>1.容斥原理.<br>2.抽屉原理.<br>3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026).<br>4.递推关系和母函数.<br>(2)数学.<br>1.高斯消元法(poj2947,poj1487, poj2065,poj1166,poj1222)<br>2.概率问题. (poj3071,poj3440)<br>3.GCD、扩展的欧几里德(中国剩余定理) (poj3101)<br>(3)计算方法.<br>1.0/1分数规划. (poj2976)<br>2.三分法求解单峰(单谷)的极值.<br>3.矩阵法(poj3150,poj3422,poj3070)<br>4.迭代逼近(poj3301)<br>(4)随机化算法(poj3318,poj2454)<br>(5)杂题.<br>(poj1870,poj3296,poj3286,poj1095)<br>七.计算几何学.<br>(1)坐标离散化.<br>(2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).<br>(poj1765,poj1177,poj1151,poj3277,poj2280,poj3004)<br>(3)多边形的内核(半平面交)(poj3130,poj3335)<br>(4)几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429<br>)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift140%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%861/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift140%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%861/" class="post-title-link" itemprop="url">UI相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:03" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:03+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="drawRect和layouSubviews-的区别"><a href="#drawRect和layouSubviews-的区别" class="headerlink" title="drawRect和layouSubviews 的区别"></a>drawRect和layouSubviews 的区别</h2><p>1   layoutSubviews方便数据计算，<br>2   drawRect方便视图重绘。<br>layoutSubviews在以下情况下会被调用：<br>addSubview、改变view的大小、滚动一个UIScrollView、<br>旋转Screen会触发父UIView上的layoutSubviews，调用setLayoutSubviews。<br>drawRect在以下情况下会被调用：（必须有大小）<br>loadView，viewDidLoad，sizeToFit<br>直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:<br>强制layout刷新,调用setNeedsLayout来代替</p>
<h2 id="setNeedsLayout与layoutIfNeeded的区别"><a href="#setNeedsLayout与layoutIfNeeded的区别" class="headerlink" title="setNeedsLayout与layoutIfNeeded的区别"></a>setNeedsLayout与layoutIfNeeded的区别</h2><p>UIView的setNeedsDisplay和setNeedsLayout两个方法都是异步执行的。<br>而setNeedsDisplay会自动调用drawRect方法，这样可以拿到<br>UIGraphicsGetCurrentContext进行绘制；而setNeedsLayout会默认调用<br>layoutSubViews，给当前的视图做了标记；layoutIfNeeded<br>查找是否有标记，如果有标记及立刻刷新。<br>只有setNeedsLayout和layoutIfNeeded这二者合起来使用，才会起到立刻刷新的效果。</p>
<h2 id="Core-Graphics的更底层的是什么；"><a href="#Core-Graphics的更底层的是什么；" class="headerlink" title="Core Graphics的更底层的是什么；"></a>Core Graphics的更底层的是什么；</h2><p>　1）获取上下文<br>　2）绘制路径<br>　3）添加路径到上下文<br>　4）修改图形状态参数<br>　5）渲染上下文<br>　CGContextRef、CGPathRef、UIBezierPath</p>
<h2 id="iOS-保持界面流畅的技巧"><a href="#iOS-保持界面流畅的技巧" class="headerlink" title="iOS 保持界面流畅的技巧"></a>iOS 保持界面流畅的技巧</h2><p>1.预排版，提前计算<br>在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。<br>尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式<br>2.预渲染，提前绘制<br>例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了<br>避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。<br>3.异步绘制<br>4.全局并发线程<br>5.高效的图片异步加载</p>
<h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h2 id="消息转发的流程"><a href="#消息转发的流程" class="headerlink" title="消息转发的流程"></a>消息转发的流程</h2><p>（动态添加） 首先是征询接收者所属的类,看其是否能动态添加调用的方法,来处理当前这个未知的选择子;<br>-(BOOL)resolveInstanceMethod:(SEL)selector<br>（重定向-备援接收者）寻找是否在其他对象内有该方法实现,并将该消息转发给这个对象</p>
<ul>
<li>(id)forwardingTargetForSelector:(SEL)aSelector<br>生成方法签名，然后系统用这个方法签名生成NSInvocation对象。</li>
<li>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector<br>改变选择子</li>
<li>(void)forwardInvocation:(NSInvocation *)Invocation<br>抛出异常</li>
<li>(void)doesNotRecognizeSelector:(SEL)aSelector方法<h2 id="runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）"><a href="#runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）"></a>runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</h2>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,<br>以及参数类型,其实selector本质就是方法名称,<br>通过这个方法名称就可以在方法列表中找到对应的方法实现.<h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2>在runtime中所有类都存在一个哈希表中，在table的buckets中存储</li>
</ul>
<ol>
<li>加载所有类到类的gdb_objc_realized_classes表中</li>
<li>对所有类做重映射</li>
<li>将所有SEL都注册到namedSelectors表中</li>
<li>修复函数指针遗留</li>
<li>将所有Protocol添加到protocol_map表中</li>
<li>将所有Protocol重映射</li>
<li>初始化所有非懒加载的类，进行rw，ro操作 </li>
<li>便利所有懒加载类，执行初始化</li>
<li>处理所有Category包括Class和MetaClass</li>
<li>初始化所有未初始化类<h2 id="msgSend参数都有哪些；"><a href="#msgSend参数都有哪些；" class="headerlink" title="msgSend参数都有哪些；"></a>msgSend参数都有哪些；</h2><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="NSObject内存分配、ISA指针的内存大小"><a href="#NSObject内存分配、ISA指针的内存大小" class="headerlink" title="NSObject内存分配、ISA指针的内存大小"></a>NSObject内存分配、ISA指针的内存大小</h2>在64位架构下，如果他的第一位是0 。则代表他是一个 isa<br>指针,表示当前对象的类对象的地址，如果是1，则不仅代表一个 isa<br>指针,类对象的地址，里面还存储内存管理相关的内容，第二位代表是否有关联对象，<br>0代表没有，1代表有（has_assoc）,第三位,代表当前对象是否含有C++代码<br>（has_cxx_dtor）,3-15表示当前对象的类对象内存地址,16-31<br>,也是，32-35位也是，也就是说，13+16+4 = 33位<h2 id="子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool"><a href="#子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool" class="headerlink" title="子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool"></a>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool</h2>在子线程你创建了 Pool 的话，产生的 Autorelease 对象就会交给 pool 去管理。<br>如果你没有创建 Pool ，但是产生了 Autorelease 对象，就会调用 autoreleaseNoPage<br>方法。在这个方法中，会自动帮你创建一个 hotpage（hotPage 可以理解为当前正在使用的<br>AutoreleasePoolPage，如果你还是不理解，可以先看看 Autoreleasepool<br>的源代码，再来看这个问题 ），并调用 page-&gt;add(obj)将对象添加到<br>AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！<h2 id="dealloc调用流程"><a href="#dealloc调用流程" class="headerlink" title="dealloc调用流程"></a>dealloc调用流程</h2></li>
<li>直接调用 objc_destructInstance()。</li>
<li>之后调用C的 free() 函数。</li>
<li>objc_destructInstance() 调用流程<br>1&gt;.先判断 hasCxxDtor，是否有析构函数（析构器），<br>要调用 object_cxxDestruct() ，释放（清除成员变量）。<br>2&gt;.再判断hasAssocitatedObjects，如果有的话，<br>要调用object_remove_associations()， 移除当前对象的关联对象。<br>3&gt;.然后调用 clearDeallocating()。 </li>
<li>clearDeallocating() 调用流程<br>0&gt;. 判断isa是否优化过，从arm64架构开始，对isa进行了优化，<br>变成了一个共用体（union）结构，所以结果一般是优化过了。<br>判断是否有弱引用或者引用计数<br>1&gt;.执行 clearDeallocating_slow()。<br>2&gt;.再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。<br>3&gt;.接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。<br>4&gt;.至此为止，Dealloc 的执行流程结束。<h2 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h2>启用Zombie Object进行悬挂指针的检测。<br>应用Product -&gt; Analysis进行内存泄露的初步检测。<br>可以在xcode的build setting中打开implicit retain of ‘self’<br>within blocks，xcode编译器会给出警告，逐个排查警告。<br>应用Leak Instrument进行内存泄露查找。<br>在以上方法不奏效的情况下，通过查看dealloc是否调用查看某个class是否泄露的问题</li>
</ol>
<h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><p>内存泄漏（memory leak）：是指申请的内存空间使用完毕之后未回收。<br>一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，<br>最终导致程序crash。（因此，开发中我们要尽量避免内存泄漏的出现）<br>内存溢出（out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用。<br>通俗理解就是内存不够用了，通常在运行大型应用或游戏时，应用或游戏所需要<br>的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。最终导致机器重启或者程序crash。<br>第一种：静态分析方法（Analyze）<br>第二种：动态分析方法（Instrument工具库里的Leaks）。一般推荐使用第二种。</p>
<h2 id="举例一些I-O操作的例子"><a href="#举例一些I-O操作的例子" class="headerlink" title="举例一些I/O操作的例子"></a>举例一些I/O操作的例子</h2><p>1）阻塞IO<br>2）非阻塞IO<br>3）IO复用（select和poll）<br>4）信号驱动IO（sigio）<br>5）异步IO（aio_）</p>
<h2 id="如何开辟一块内存；"><a href="#如何开辟一块内存；" class="headerlink" title="如何开辟一块内存；"></a>如何开辟一块内存；</h2><p>其实结论就是 实际分配内存是按照16字节对齐的 内存大小都是16 的倍数。</p>
<h2 id="怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手"><a href="#怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手" class="headerlink" title="怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手"></a>怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手</h2><p>复用机制<br>少使用xib<br>不要阻塞线程<br>图片优化<br>合理使用数组字典优化查找速度<br>懒加载<br>缓存<br>一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。可以用单例来处理，避免日期格式转换<br>选择正确的数据格式，json、xml、二进制数据流<br>少使用webView<br>优化tableView<br>选择正确的数据持久化</p>
<h2 id="问堆和栈的区别。"><a href="#问堆和栈的区别。" class="headerlink" title="问堆和栈的区别。"></a>问堆和栈的区别。</h2><p>（答对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。）</p>
<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop概念及数据结构、事件循环机制"><a href="#RunLoop概念及数据结构、事件循环机制" class="headerlink" title="RunLoop概念及数据结构、事件循环机制"></a>RunLoop概念及数据结构、事件循环机制</h2><p>CFRunLoop<br>CFRunLoopMode<br>Source/Timer/Observer<br>source0<br>需要手动唤醒线程<br>source1<br>具备唤醒线程的能力<br>CFRunLoopObserver<br>观测时间点<br>kCFRunLoopEntry<br>kCFRunLoopBeforeTimers<br>CommonMode的特性<br>NSRunLoopCommonModes<br>commonMode不是实际存在的一种mode<br>是同步Source/Timer/Observer到多个Mode中的一种技术方案<br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个<br>Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个<br>Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出<br>Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的<br>Source/Timer/Observer，让其互不影响。</p>
<h2 id="RunLoop和多线程"><a href="#RunLoop和多线程" class="headerlink" title="RunLoop和多线程"></a>RunLoop和多线程</h2><p>在异步线程中下载很多图片,如果失败了,该如何处理?请结合RunLoop来谈谈解决方案<br>在异步线程中启动一个RunLoop重新发送网络请求,下载图片<br>如果程序启动就需要执行一个耗时操作，你会怎么做？<br>开启一个异步的子线程，并启动它的RunLoop来执行该耗时操作</p>
<h2 id="你在开发过程中怎么使用RunLoop？什么应用场景？"><a href="#你在开发过程中怎么使用RunLoop？什么应用场景？" class="headerlink" title="你在开发过程中怎么使用RunLoop？什么应用场景？"></a>你在开发过程中怎么使用RunLoop？什么应用场景？</h2><p>开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来的消息，处理其他事件）<br>在子线程中开启一个定时器<br>在子线程中进行一些长期监控<br>可以控制定时器在特定模式下运行<br>可以让某些事件（行为，任务）在特定模式下执行<br>可以添加observer监听RunLoop的状态，比如监听点击事件的处理（比如在所有点击事件前做一些处理）<br>1）NSTimer<br>2）ImageView显示：控制方法在特定的模式下可用<br>3）PerformSelector<br>4）常驻线程：在子线程中开启一个runloop<br>5）自动释放池</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="GCD、NSOperation、NSThread区别优缺点"><a href="#GCD、NSOperation、NSThread区别优缺点" class="headerlink" title="GCD、NSOperation、NSThread区别优缺点"></a>GCD、NSOperation、NSThread区别优缺点</h2><p>第一种：pthread<br>    a.特点：<br>        1）一套通用的多线程API<br>        2）适用于Unix\Linux\Windows等系统<br>        3）跨平台\可移植<br>        4）使用难度大<br>    b.使用语言：c语言<br>    c.使用频率：几乎不用<br>    d.线程生命周期：由程序员进行管理<br>第二种：NSThread<br>    a.特点：<br>        1）使用更加面向对象<br>        2）简单易用，可直接操作线程对象<br>        b.使用语言：OC语言<br>        c.使用频率：偶尔使用<br>        d.线程生命周期：由程序员进行管理<br>第三种：GCD<br>    a.特点：<br>        1）旨在替代NSThread等线程技术<br>        2）充分利用设备的多核（自动）<br>    b.使用语言：C语言<br>    c.使用频率：经常使用<br>    d.线程生命周期：自动管理<br>第四种：NSOperation<br>    a.特点：<br>        1）基于GCD（底层是GCD）<br>        2）比GCD多了一些更简单实用的功能<br>        3）使用更加面向对象<br>    b.使用语言：OC语言<br>    c.使用频率：经常使用<br>    d.线程生命周期：自动管理</p>
<h2 id="如何让多个网络请求完成后执行下一步"><a href="#如何让多个网络请求完成后执行下一步" class="headerlink" title="如何让多个网络请求完成后执行下一步"></a>如何让多个网络请求完成后执行下一步</h2><p>  dispatch_group_t</p>
<h2 id="多个网络请求顺序执行后执行下一步"><a href="#多个网络请求顺序执行后执行下一步" class="headerlink" title="多个网络请求顺序执行后执行下一步"></a>多个网络请求顺序执行后执行下一步</h2><pre><code>dispatch_semaphore_wait
</code></pre>
<h2 id="异步操作两组数据时-执行完第一组之后-才能执行第二组"><a href="#异步操作两组数据时-执行完第一组之后-才能执行第二组" class="headerlink" title="异步操作两组数据时, 执行完第一组之后, 才能执行第二组"></a>异步操作两组数据时, 执行完第一组之后, 才能执行第二组</h2><pre><code>dispatch_barrier_async
</code></pre>
<h2 id="你知道哪些锁、使用场景"><a href="#你知道哪些锁、使用场景" class="headerlink" title="你知道哪些锁、使用场景"></a>你知道哪些锁、使用场景</h2><p>@synchronized 一个对象层面的锁，锁住了整个对象，底层使用了互斥递归<br>锁来实现<br>pathread_mutex 互斥锁（c语言）和信号量的实现原理类似，也是阻塞线程并进入睡眠<br>，需要进行上下文切换。<br>NSLock 对象锁-简单的互斥锁（内部封装了一个 pthread_mutex）<br>NSCondition （封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件<br>NSCondition和NSLock、@synchronized等是不同的是，<br>NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。<br>这是非常强大。<br>NSConditionLock （借助 NSCondition 来实现，本质是生产者-消费者模型）<br>也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。<br>NSRecursiveLock 递归锁有时候“加锁代码”中存在递归调用，递归开始前加<br>dispatch_semaphore GCD中信号量，也可以解决资源抢占问题,<br>支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；<br>每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，<br>直到信号量大于0开始执行<br>OSSpinLock 自旋锁(不建议使用)<br>自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取<br>锁就需要等待a线程释放锁。在没有获得锁的期间，b线程会一直处于忙等的状<br>态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太<br>划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。</p>
<h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><p>相同点：都能保证同一时间只有一个线程访问共享资源。<br>都能保证线程安全。<br>不同点：<br>互斥锁：如果共享数据已经有其他线程加锁了，线程会进入<br>休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的<br>线程会被唤醒。<br>自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环<br>的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会<br>立即执行。<br>自旋锁的效率高于互斥锁。<br>由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放<br>自旋锁，否则等待该自旋锁的线程会一直在哪里自旋，这就会浪<br>费CPU时间。<br>持有自旋锁的线程在sleep之前应该释放自旋锁以便其他可以获得<br>该自旋锁。内核编程中，如果持有自旋锁的代码sleep了就可能<br>导致整个系统挂起。</p>
<h2 id="runloop与autoreleasepool的关系"><a href="#runloop与autoreleasepool的关系" class="headerlink" title="runloop与autoreleasepool的关系"></a>runloop与autoreleasepool的关系</h2><p>(AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组成)<br>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），<br>除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址<br>iOS里的TaggedPointer不适用autorelesepool<br>AutoreleasePool 在 runloop 在开始时被push，在runloop休眠时(beforewaiting状态)pop</p>
<h2 id="GCD-在Runloop中的使用"><a href="#GCD-在Runloop中的使用" class="headerlink" title="GCD 在Runloop中的使用"></a>GCD 在Runloop中的使用</h2><pre><code>GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。
</code></pre>
<h2 id="GCD-Global队列创建线程进行耗时操作的风险"><a href="#GCD-Global队列创建线程进行耗时操作的风险" class="headerlink" title="GCD Global队列创建线程进行耗时操作的风险"></a>GCD Global队列创建线程进行耗时操作的风险</h2><p>dispatch_async 函数分发到全局队列不一定会新建线程执行任务，全局队列底层有一个的线程池，如果线程池满了，<br> 那么后续的任务会被 block 住，等待前面的任务执行完成，才会继续执行。如果线程池中的线程<br> 长时间不结束，后续堆积的任务会越来越多，此时就会存在 APP crash的风险。<br> 避免使用 GCD Global 队列创建 Runloop 常驻线程</p>
<h2 id="NSOperation数据结构"><a href="#NSOperation数据结构" class="headerlink" title="NSOperation数据结构"></a>NSOperation数据结构</h2><p>ddDependency操作依赖性<br>KVO 兼容属性<br>cancelAllOperations 响应取消命令<br>start;执行操作<br>NSBlockOperation：用于管理一个或多个block的并发执行。<br>NSInvocationOperation：NSInvocationOperation类是NSOperation的一个具体<br>子类，用于开启一个操作，该操作包括在指定对象上调用一个selector。</p>
<h2 id="重写NSOperation需要注意的点"><a href="#重写NSOperation需要注意的点" class="headerlink" title="重写NSOperation需要注意的点"></a>重写NSOperation需要注意的点</h2><p>1、如果需要自定义并发执行的 Operation，必须重写start、main、isExecuting、isFinished、isAsynchronous方法。<br>2、在 operation 的 main 方法里面，必须提供 autorelease pool,因为你的 operation 完成后需要销毁。<br>3、一旦你的 operation 开始了，必须通过 KVO，告诉所有的监听者，现在该operation的执行状态。<br>4、调用时，如果需要并发执行 Operation，必须调用performOperation:方法，当然，也可以改为自定义其他方法或者直接在start方法添加多线程调用。<br>5、对于自定义的 Operation 类，如果不需要并发执行，可以直接调用start</p>
<h2 id="进程中的哪些空间是线程所共有的？"><a href="#进程中的哪些空间是线程所共有的？" class="headerlink" title="进程中的哪些空间是线程所共有的？"></a>进程中的哪些空间是线程所共有的？</h2><p>  一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)</p>
<h2 id="使用GCD需要注意什么；"><a href="#使用GCD需要注意什么；" class="headerlink" title="使用GCD需要注意什么；"></a>使用GCD需要注意什么；</h2><p>dispatch_sync同步死锁（循环等待）<br>重复的获取互斥资源引发的等待（加锁）<br>开启过多线程<br>线程和RunLoop，子线程不会开启runloop</p>
<h2 id="runloop跟runtime有没有关联"><a href="#runloop跟runtime有没有关联" class="headerlink" title="runloop跟runtime有没有关联"></a>runloop跟runtime有没有关联</h2><p>个人想到的是autoreleasepool、其他的不好找<br>runloop中事件源都是由运行时runtime触发</p>
<h2 id="CPU和GPU怎么相互合作的"><a href="#CPU和GPU怎么相互合作的" class="headerlink" title="CPU和GPU怎么相互合作的"></a>CPU和GPU怎么相互合作的</h2><p>命令缓冲区包含了一个命令队列，由CPU向其中添加命令，而由GPU从中读取命令<br>，添加和读取的过程是互相独立的。命令缓冲区使得CPU和GPU可以互相独立工作<br>。当CPU需要渲染一些对象时，它可以向命令缓冲区中添加命令，而当GPU完成了上<br>一次的渲染任务后，它就可以从命令队列中再取出一个命令并执行它。</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTPS-TLS-SSL加密过程"><a href="#HTTPS-TLS-SSL加密过程" class="headerlink" title="HTTPS TLS/SSL加密过程"></a>HTTPS TLS/SSL加密过程</h2><p>1、客户端向服务器端索要并验证公钥。<br>2、双方协商生成”对话密钥”。<br>3、双方采用”对话密钥”进行加密通信。<br>其中，前两个阶段，被称为“握手阶段”。<br>TLS握手过程有单向验证和双向验证之分，简单解释一下，单向验证就是<br>server端将证书发送给客户端，客户端验证server端证书的合法性等，<br>例如百度、新浪、google等普通的https网站，双向验证则是不仅客户端会验<br>证server端的合法性，同时server端也会验证客户端的合法性，例如银行网银登陆<br>，支付宝登陆交易等。<br>1、确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>2、一个服务器生成的随机数（Sever Random），稍后用于生成”对话密钥”。<br>3、确认使用的加密方法，比如RSA公钥加密。<br>4、服务器证书（Certificate）。<br>5、支持的一些SSL/TLS扩展。</p>
<h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><p>①客户端发送报文进行SSL通信。报文中包含客户端支持的SSL的指定版本、<br>加密组件列表（加密算法及密钥长度等）。<br>②服务器应答，并在应答报文中包含SSL版本以及加密组件。<br>服务器的加密组件内容是从接受到的客户端加密组件内筛选出来的。<br>③服务器发送报文，报文中包含公开密钥证书。<br>④服务器发送报文通知客户端，最初阶段SSL握手协商部分结束。<br>⑤SSL第一次握手结束之后，客户端发送一个报文作为回应。<br>报文中包含通信加密中使用的一种被称Pre-master<br>secret的随机密码串。该密码串已经使用服务器的公钥加密。<br>⑥客户端发送报文，并提示服务器，此后的报文通信会采用<br>Pre-master secret密钥加密。<br>⑦客户端发送Finished报文。该报文包含连接至今全部报文的<br>整体校验值。这次握手协商是否能够完成成功，要以服务器是否能够正确解密该报文作为判定标准。<br>⑧服务器同样发送Change Cipher Spec报文。<br>⑨服务器同样发送Finished报文。<br>⑩服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。<br>⑪应用层协议通信，即发送HTTP响应。<br>⑫最后由客户端断开链接。断开链接时，发送close_nofify报文</p>
<h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。<br>  由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>  对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，<br>  再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>  pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，<br>  如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用<br>  pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和<br>  服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机<br>  可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，<br>  随机性增加的可不是一。</p>
<h2 id="TCP特点及与UDP区别"><a href="#TCP特点及与UDP区别" class="headerlink" title="TCP特点及与UDP区别"></a>TCP特点及与UDP区别</h2><p>基于连接（点对点）<br>传输数据前需要建立好连接，然后在传输<br>双工通信<br>TCP连接一旦建立，就可以在连接上进行双向的通信<br>基于字节流而非报文<br>将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制能够保证TCP协议的有序性和完整性，因此TCP能够提供可靠性传输</p>
<p>可靠传输<br>拥塞控制<br>慢启动，拥塞避免，拥塞发生，快速恢复四个算法<br>流量控制能力</p>
<h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><p>DNS服务器一般分三种，根DNS服务器，顶级DNS服务器，权威DNS服务器。<br>1）浏览器缓存　　<br>2）系统缓存　　<br>3）路由器缓存　　　　<br>4） ISP（互联网服务提供商）DNS缓存<br>5）根域名服务器　　　<br>6）顶级域名服务器　　<br>8）保存结果至缓存</p>
<h2 id="HTTP请求头都有哪些内容"><a href="#HTTP请求头都有哪些内容" class="headerlink" title="HTTP请求头都有哪些内容"></a>HTTP请求头都有哪些内容</h2><p>Accept: <em>/</em>(客户端能接收的资源类型)<br>Accept-Language: en-us(客户端接收的语言类型)<br>Connection: Keep-Alive(维护客户端和服务端的连接关系)<br>Host: localhost:8080(连接的目标主机和端口号)<br>Referer: <a target="_blank" rel="noopener" href="http://localhost/links.asp(%E5%91%8A%E8%AF%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%91%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%93%AA%E9%87%8C)">http://localhost/links.asp(告诉服务器我来自于哪里)</a><br>User-Agent: Mozilla/4.0(客户端版本号的名字)<br>Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)<br>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)<br>Cookie(客户端暂存服务端的信息)<br>Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间</p>
<h2 id="哪些加密算法"><a href="#哪些加密算法" class="headerlink" title="哪些加密算法"></a>哪些加密算法</h2><p>MD5加密算法<br>RSA加密算法<br>AES加密算法<br>Base64加密算法</p>
<h2 id="断点续传怎么实现"><a href="#断点续传怎么实现" class="headerlink" title="断点续传怎么实现;"></a>断点续传怎么实现;</h2><p>续传的文件就好说了，只要给一个续传的标识位置，和对应的字节流就可以了，代码如下:<br>filePath:生成的文件,用来续传用<br>content:将要写入的字节<br>position:续传的字节位置</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p> 单一职责原则<br>      CALayer：动画和视图的显示。<br>      UIView：只负责事件传递、事件响应。<br>      生成的数据模型<br>  开闭原则<br>      对修改关闭，对扩展开放。 要考虑到后续的扩展性，而不是在原有的基础上来回修改<br>  接口隔离原则<br>      使用多个专门的协议、而不是一个庞大臃肿的协议，如<br>      UITableviewDelegate + UITableViewDataSource<br>  依赖倒置原则<br>      抽象不应该依赖于具体实现、具体实现可以依赖于抽象。<br>      调用接口感觉不到内部是如何操作的<br>  里氏替换原则<br>      父类可以被子类无缝替换，且原有的功能不受任何影响 如：KVO<br>  迪米特法则<br>      一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合</p>
<h2 id="iOS有哪些常见的设计模式"><a href="#iOS有哪些常见的设计模式" class="headerlink" title="iOS有哪些常见的设计模式?"></a>iOS有哪些常见的设计模式?</h2><p>01代理委托Delegate是协议的一种<br> ,通过@protocol方式实现，常见的有tableView，textField等。<br> 02观察者 通知机制(notification)和KVO机制(Key-value Observing)<br> 03MVC<br> 04单例（Singleton）,UIApplication, NSBundle, NSNotificationCenter,<br> NSFileManager, NSUserDefault, NSURLCache等都是单例.<br> 05策略<br> 06工厂</p>
<h2 id="内存设计、磁盘设计、网络设计原则"><a href="#内存设计、磁盘设计、网络设计原则" class="headerlink" title="内存设计、磁盘设计、网络设计原则"></a>内存设计、磁盘设计、网络设计原则</h2><p>内存设计:存储的Size,淘汰策略 LRU算法<br>磁盘设计:存储方式\大小限制\淘汰策略<br>网络设计:图片请求最大并发\请求超时策略\请求优先级</p>
<h2 id="MVVM模式思想"><a href="#MVVM模式思想" class="headerlink" title="MVVM模式思想"></a>MVVM模式思想</h2><p>MVVM 即模型-视图-视图模型<br>在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，<br>ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel<br>能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，<br>ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的<br>双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。<br>优点 VIew可以独立于Model的变化和修改，一个ViewModel可以绑定到不同的View上，<br> 降低耦合，增加重用<br> 缺点 过于简单的项目不适用、大型的项目视图状态较多时构建和维护成本太大<br> 合理的运用架构模式有利于项目、团队开发工作，但是到底选择哪个设计模式，</p>
<h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><p>Flux是Facebook用来构建用户端的web应用的应用程序体系架构。<br>它通过利用数据的单向流动为React的可复用的视图组件提供了补充。<br>相比于形式化的框架它更像是一个架构思想，不需要太多新的代码你就可以马上<br>使用Flux构建你的应用。<br>一个 Flux 应用主要包含四个部分：<br>dispatcher<br>处理动作分发，维护 Store 之间的依赖关系<br>stores<br>数据和逻辑部分<br>views<br>React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互<br>actions<br>提供给 dispatcher 传递数据给 store<br>视图上添加的所有的视图组成一个视图多叉树；<br>比如某个UI发生变化后，需要反向到根节点，然后由根节点想下遍历查找需<br>要更新的结点；<br>任何一个子节点是没有权利自我更新的，需要把自我变化更<br>新的消息传递给根节点，由根节点进行更新，相当于由主动行为变成被动行为</p>
<h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：<br>   排版，绘制，UI对象操作。<br>   排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>   绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>   UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。<br>   其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主<br>   线程完成，并且有时后面的操作需要依赖前面操作的结果<br>   （例如TextView创建时可能需要提前计算出文本的大小）。ASDK<br>   所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟<br>   (例如视图的创建、属性的调整)。<br>   为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了<br>   UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如<br>   frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只<br>   通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制<br>   放入了后台线程。但是无论怎么操作，<br>   这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>   ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面<br>   更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了<br>   kCFRunLoopBeforeWaiting 和 kCFRunLoopExit<br>   事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<h2 id="AFNetworking-底层原理分析"><a href="#AFNetworking-底层原理分析" class="headerlink" title="AFNetworking 底层原理分析"></a>AFNetworking 底层原理分析</h2><p>AFNetworking是封装的NSURLSession的网络请求，由五个模块组成：<br>分别由NSURLSession,Security,Reachability,Serialization,UIKit五部分组成<br>NSURLSession：网络通信模块（核心模块） 对应 AFNetworking中的<br>AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager<br>,AFHTTPSessionManager是继承于AFURLSessionmanager的<br>Security：网络通讯安全策略模块 对应 AFSecurityPolicy<br>Reachability：网络状态监听模块 对应AFNetworkReachabilityManager<br>Seriaalization：网络通信信息序列化、反序列化模块 对应AFURLResponseSerialization<br>UIKit：对于iOS UIKit的扩展库</p>
<h2 id="SDWebImage加载图片过程，图片缓存设计"><a href="#SDWebImage加载图片过程，图片缓存设计" class="headerlink" title="SDWebImage加载图片过程，图片缓存设计"></a>SDWebImage加载图片过程，图片缓存设计</h2><p>0、首先显示占位图<br>1、在webimagecache中寻找图片对应的缓存，它是以url为数据索引先在内存中<br>查找是否有缓存；<br>2、如果没有缓存，就通过md5处理过的key来在磁盘中查找<br>对应的数据，如果找到就会把磁盘中的数据加到内存中，并显示出来；<br>3、如果内存和磁盘中都没有找到，就会向远程服务器发送请求，开始下载图片；<br>4、下载完的图片加入缓存中，并写入到磁盘中；<br>5、整个获取图片的过程是在子线程中进行，在主线程中显示。</p>
<h2 id="组建化优缺点"><a href="#组建化优缺点" class="headerlink" title="组建化优缺点"></a>组建化优缺点</h2><p>业务分层、解耦，使代码变得可维护；<br>有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；<br>便于各业务功能拆分、抽离，实现真正的功能复用；<br>分工更加明确，提高开发效率<br>复用性更好，能迅速的组成更多的App</p>
<h2 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h2><p>视图层(View&amp;ViewController)<br>业务逻辑处理(ViewModel)<br>数据层(Model&amp;Engine)<br>数据流<br>数据与数据关系<br>MVVM框架思想<br>ReactiveNative的数据流思想<br>系统UIView更新机制的思想<br>FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想</p>
<h2 id="解耦的方式"><a href="#解耦的方式" class="headerlink" title="解耦的方式"></a>解耦的方式</h2><p>1、组件化<br>2、结合MVVM架构和数据驱动UI模式对原有MVC架构进行了兼容性优化<br>3、通过AOP技术对部分业务进行拆分解耦<br>4、优化事件传递方式</p>
<h2 id="项目中用的技术以及实现；"><a href="#项目中用的技术以及实现；" class="headerlink" title="项目中用的技术以及实现；"></a>项目中用的技术以及实现；</h2><p>1.复杂cell提前缓存行高和UI的frame<br>2.网络请求库的封装<br>3.组建化简单实现<br>4.tableView嵌套滑动<br>5.地图对象的单例封装<br>6.用View代替ViewController的实现<br>7.定时器使用</p>
<h2 id="缓存机制是怎么清除数据的？"><a href="#缓存机制是怎么清除数据的？" class="headerlink" title="缓存机制是怎么清除数据的？"></a>缓存机制是怎么清除数据的？</h2><p>沙盒：iOS系统为每一个应用程序创建一个文件目录,是一个的独立,封闭,安全的空间, 一个沙盒就是一个文件目录。沙盒规定了一个程序只能在自身的沙盒中进行操作,不能去访问其他应用程序的沙盒(iOS8已经部分开放访问)<br>沙盒的作用: 用来存放非代码文件(图片, 音频, 视频, 属性列表(plist), sqlite数据库, 文本文件, 其他等等)</p>
<h2 id="如何进行安全测试；"><a href="#如何进行安全测试；" class="headerlink" title="如何进行安全测试；"></a>如何进行安全测试；</h2><p>ipa包加壳（苹果）<br>敏感信息存储位置<br>通讯网络安全<br>代码混淆</p>
<h2 id="说下生产者-消费者模型，其中的同步机制是怎么样的"><a href="#说下生产者-消费者模型，其中的同步机制是怎么样的" class="headerlink" title="说下生产者-消费者模型，其中的同步机制是怎么样的"></a>说下生产者-消费者模型，其中的同步机制是怎么样的</h2><p>产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。<br>在生产者与消费者之间在加个缓冲区，我们形象的称之为仓库，生产<br>者负责往仓库了进商品，而消费者负责从仓库里拿商品，这就构成了生产者消费者模式。<br>dispatch_semaphore_wait<br>dispatch_semaphore_signal</p>
<h1 id="开发日常"><a href="#开发日常" class="headerlink" title="开发日常"></a>开发日常</h1><h2 id="APP启动时间应从哪些方面优化？"><a href="#APP启动时间应从哪些方面优化？" class="headerlink" title="APP启动时间应从哪些方面优化？"></a>APP启动时间应从哪些方面优化？</h2><p>App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit<br>   Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，<br>   优化需以下方面入手<br>   dylib loading time<br>       核心思想是减少dylibs的引用<br>       合并现有的dylibs（最好是6个以内）<br>       使用静态库<br>   rebase/binding time<br>       核心思想是减少DATA块内的指针<br>       减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）<br>       减少c++虚函数<br>       多使用Swift结构体（推荐使用swift）<br>   ObjC setup time<br>       核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时<br>   initializer time<br>       使用initialize替代load方法<br>       减少使用c/c++的attribute((constructor))；推荐使用<br>       dispatch_once() pthread_once() std:once()等方法<br>       推荐使用swift<br>       不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁<br>       ，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁<br>       不要在初始化中创建线程</p>
<h2 id="如何降低APP包的大小"><a href="#如何降低APP包的大小" class="headerlink" title="如何降低APP包的大小"></a>如何降低APP包的大小</h2><p>可执行文件<br>编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden<br>by Default 设置为 YES，去掉异常支持，Enable C++ Exceptions、Enable<br>Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions<br>利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code<br>编写LLVM插件检测出重复代码、未被调用的代码<br>资源（图片、音频、视频 等）<br>优化的方式可以对资源进行无损的压缩<br>去除没有用到的资源： </p>
<h2 id="UILabel图层混合"><a href="#UILabel图层混合" class="headerlink" title="UILabel图层混合"></a>UILabel图层混合</h2><p>UILabel图层混合解决方法： iOS8以后设置背景色为非透明色并且设置label.layer<br>.masksToBounds=YES让label只会渲染她的实际size区域，<br>就能解决UILabel的图层混合问题<br>iOS8 之前只要设置背景色为非透明的就行<br>为什么设置了背景色但是在iOS8上仍然出现了图层混合呢？<br>UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，<br>而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变。在<br>背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，设<br>置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪 图层混合问题解决了</p>
<h2 id="日常如何检查内存泄露？"><a href="#日常如何检查内存泄露？" class="headerlink" title="日常如何检查内存泄露？"></a>日常如何检查内存泄露？</h2><p>目前我知道的方式有以下几种<br>Memory Leaks<br>Alloctions<br>Analyse<br>Debug Memory Graph<br>MLeaksFinder<br>泄露的内存主要有以下两种：<br>Laek Memory 这种是忘记 Release 操作所泄露的内存。<br>Abandon Memory 这种是循环引用，无法释放掉的内存。</p>
<h2 id="LLDB常用的调试命令？"><a href="#LLDB常用的调试命令？" class="headerlink" title="LLDB常用的调试命令？"></a>LLDB常用的调试命令？</h2><p>po：print object的缩写，表示显示对象的文本描述，如果对象不存在则打印nil。<br>p：可以用来打印基本数据类型。<br>call：执行一段代码 如：call NSLog(@”%@”, @“yang”)<br>expr：动态执行指定表达式<br>bt：打印当前线程堆栈信息 （bt all 打印所有线程堆栈信息）<br>image：常用来寻找栈地址对应代码位置 如：image lookup –address 0xxxx</p>
<h2 id="iOS-常见的崩溃类型有哪些？"><a href="#iOS-常见的崩溃类型有哪些？" class="headerlink" title="iOS 常见的崩溃类型有哪些？"></a>iOS 常见的崩溃类型有哪些？</h2><p>unrecognized selector crash<br>KVO crash<br>NSNotification crash<br>NSTimer crash<br>Container crash<br>NSString crash<br>Bad Access crash （野指针）<br>UI not on Main Thread Crash</p>
<h2 id="iOS-App-稳定性指标及监测"><a href="#iOS-App-稳定性指标及监测" class="headerlink" title="iOS App 稳定性指标及监测"></a>iOS App 稳定性指标及监测</h2><p>开发过程中，主要是通过监控内存使用及泄露，CPU使用率，FPS，启动时间等指标，<br>以及常见的UI的主线程监测，NSAssert断言等，最好能在Debug模式下，实时显<br>示在界面上，针对出现的问题及早解决。</p>
<h2 id="iOS的签名机制是怎么样的"><a href="#iOS的签名机制是怎么样的" class="headerlink" title="iOS的签名机制是怎么样的"></a>iOS的签名机制是怎么样的</h2><p>签名机制：<br>先将应用内容通过摘要算法，得到摘要<br>再用私钥对摘要进行加密得到密文<br>将源文本、密文、和私钥对应的公钥一并发布<br>验证流程：<br>查看公钥是否是私钥方的<br>然后用公钥对密文进行解密得到摘要<br>将APP用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常</p>
<h2 id="instruments它为什么能检测内存泄漏"><a href="#instruments它为什么能检测内存泄漏" class="headerlink" title="instruments它为什么能检测内存泄漏"></a>instruments它为什么能检测内存泄漏</h2><h2 id="推送的原理"><a href="#推送的原理" class="headerlink" title="推送的原理"></a>推送的原理</h2><p>1.由App向iOS设备发送一个注册通知，用户需要同意系统发送推送。<br>2.iOS向APNs远程推送服务器发送App的Bundle Id和设备的UDID。<br>3.APNs根据设备的UDID和App的Bundle Id生成deviceToken再发回给App。<br>4.App再将deviceToken发送给远程推送服务器(自己的服务器), 由服务器保存在数据库中。<br>5.当自己的服务器想发送推送时, 在远程推送服务器中输入要发送的消息并选择发给哪些用户的deviceToken，由远程推送服务器发送给APNs。<br>6.APNs根据deviceToken发送给对应的用户。</p>
<h2 id="项目上线被拒原因"><a href="#项目上线被拒原因" class="headerlink" title="项目上线被拒原因"></a>项目上线被拒原因</h2><p>设计类型的问题，图标、UI等<br>app类型设置不准确<br>第三方资源用到广告等资源</p>
<h2 id="有了解过代码如何编译的嘛"><a href="#有了解过代码如何编译的嘛" class="headerlink" title="有了解过代码如何编译的嘛"></a>有了解过代码如何编译的嘛</h2><p>LLVM编译一个源文件的过程：预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt;<br>   AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件</p>
<h2 id="针对线上版本的崩溃处理；"><a href="#针对线上版本的崩溃处理；" class="headerlink" title="针对线上版本的崩溃处理；"></a>针对线上版本的崩溃处理；</h2><p>UIKit不是线程安全的，执行UIKit操作如果不在主线程很可能造成程序Crash<br>KVO<br>避免 Foundation 类Carsh<br>容器越界（NSArray， NSDictionary,…）<br>unrecognized selector crash (这个很多时候是由于class使用错误导致)<br>第三方工具：友盟<br>dSYMTools分析</p>
<h2 id="Xcode构建过程；"><a href="#Xcode构建过程；" class="headerlink" title="Xcode构建过程；"></a>Xcode构建过程；</h2><p>解析项目文件，获取你项目中的所有文件、target 及其依赖关系、build settings，最后把它变成一个树形结构(有向图)。<br>增量构建。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">366</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
