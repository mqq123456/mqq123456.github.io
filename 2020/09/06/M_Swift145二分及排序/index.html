<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="寻找峰值峰值元素是指其值大于左右相邻值的元素方法一: 线性扫描 public int findPeakElement(int[] nums) {        for (int i &#x3D; 0; i &lt; nums.length - 1; i++) {            if (nums[i] &gt; nums[i + 1])                return i;">
<meta property="og:type" content="article">
<meta property="og:title" content="二分查找">
<meta property="og:url" content="http://example.com/2020/09/06/M_Swift145%E4%BA%8C%E5%88%86%E5%8F%8A%E6%8E%92%E5%BA%8F/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="寻找峰值峰值元素是指其值大于左右相邻值的元素方法一: 线性扫描 public int findPeakElement(int[] nums) {        for (int i &#x3D; 0; i &lt; nums.length - 1; i++) {            if (nums[i] &gt; nums[i + 1])                return i;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-06T09:30:29.000Z">
<meta property="article:modified_time" content="2020-09-06T09:30:29.000Z">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/09/06/M_Swift145%E4%BA%8C%E5%88%86%E5%8F%8A%E6%8E%92%E5%BA%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>二分查找 | Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift145%E4%BA%8C%E5%88%86%E5%8F%8A%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          二分查找
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:29" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:29+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h2><p>峰值元素是指其值大于左右相邻值的元素<br>方法一: 线性扫描<br> public int findPeakElement(int[] nums) {<br>        for (int i = 0; i &lt; nums.length - 1; i++) {<br>            if (nums[i] &gt; nums[i + 1])<br>                return i;<br>        }<br>        return nums.length - 1;<br>    }<br>方法二：递归二分查找<br>我们可以将 nums 数组中的任何给定序列视为交替的升序和降序序列。通过利用这一点，以及“可以返回任何一个峰作为结果”的要求，我们可以利用二分查找来找到所需的峰值元素。<br>我们对二分查找进行一点修改。首先从数组 nums 中找到中间的元素 mid若该元素恰好位于降序序列或者一个局部下降坡度中，则说明峰值会在本元素的左边<br>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素<br>public class Solution {<br>    public int findPeakElement(int[] nums) {<br>        return search(nums, 0, nums.length - 1);<br>    }<br>    public int search(int[] nums, int l, int r) {<br>        if (l == r)<br>            return l;<br>        int mid = (l + r) / 2;<br>        if (nums[mid] &gt; nums[mid + 1])<br>            return search(nums, l, mid);<br>        return search(nums, mid + 1, r);<br>    }<br>}</p>
<h2 id="找出这个重复的数"><a href="#找出这个重复的数" class="headerlink" title="找出这个重复的数"></a>找出这个重复的数</h2><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br>方法一：二分查找<br>class Solution {<br>    public int findDuplicate(int[] nums) {<br>        int n = nums.length;<br>        int l = 1, r = n - 1, ans = -1;<br>        while (l &lt;= r) {<br>            int mid = (l + r) &gt;&gt; 1;<br>            int cnt = 0;<br>            for (int i = 0; i &lt; n; ++i) {<br>                if (nums[i] &lt;= mid) {<br>                    cnt++;<br>                }<br>            }<br>            if (cnt &lt;= mid) {<br>                l = mid + 1;<br>            } else {<br>                r = mid - 1;<br>                ans = mid;<br>            }<br>        }<br>        return ans;</p>
<pre><code>&#125;
</code></pre>
<p>}<br>最优<br> int temp;<br>        for(int i=0;i&lt;nums.length;i++){<br>            while (nums[i]!=i){<br>                if(nums[i]==nums[nums[i]]){<br>                    return nums[i];<br>                }<br>                temp=nums[i];<br>                nums[i]=nums[temp];<br>                nums[temp]=temp;<br>            }<br>        }<br>        return -1;</p>
<p>方法二：二进制<br>这个方法我们来将所有数二进制展开按位考虑如何找出重复的数，如果我们能确定重复数每一位是 1 还是 0 就可以按位还原出重复的数是什么。<br>class Solution {<br>    public int findDuplicate(int[] nums) {<br>        int n = nums.length, ans = 0;<br>        int bit_max = 31;<br>        while (((n - 1) &gt;&gt; bit_max) == 0) {<br>            bit_max -= 1;<br>        }<br>        for (int bit = 0; bit &lt;= bit_max; ++bit) {<br>            int x = 0, y = 0;<br>            for (int i = 0; i &lt; n; ++i) {<br>                if ((nums[i] &amp; (1 &lt;&lt; bit)) != 0) {<br>                    x += 1;<br>                }<br>                if (i &gt;= 1 &amp;&amp; ((i &amp; (1 &lt;&lt; bit)) != 0)) {<br>                    y += 1;<br>                }<br>            }<br>            if (x &gt; y) {<br>                ans |= 1 &lt;&lt; bit;<br>            }<br>        }<br>        return ans;<br>    }<br>}<br>方法三：快慢指针<br>我们先设置慢指针<br>slow 和快指针<br>fast ，慢指针每次走一步，快指针每次走两步<br>class Solution {<br>    public int findDuplicate(int[] nums) {<br>        int slow = 0, fast = 0;<br>        do {<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        } while (slow != fast);<br>        slow = 0;<br>        while (slow != fast) {<br>            slow = nums[slow];<br>            fast = nums[fast];<br>        }<br>        return slow;<br>    }<br>}</p>
<h2 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a>0～n-1中缺失的数字</h2><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。<br>二分法<br>class Solution {<br>    public int missingNumber(int[] nums) {<br>        int i = 0, j = nums.length - 1;<br>        while(i &lt;= j) {<br>            int m = (i + j) / 2;<br>            if(nums[m] == m) i = m + 1;<br>            else j = m - 1;<br>        }<br>        return i;<br>    }<br>}</p>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>排序数组的查找问题首先考虑使用 二分法 解决，其可将遍历法的 线性级别 时间复杂度降低至 对数级别<br>public int minArray(int[] numbers) {<br>        int i = 0, j = numbers.length - 1;<br>        while (i &lt; j) {<br>            int m = (i + j) / 2;<br>            if (numbers[m] &gt; numbers[j]) i = m + 1;//m 一定在 左排序数组<br>            else if (numbers[m] &lt; numbers[j]) j = m;//m 一定在 右排序数组 中<br>            else j–;<br>        }<br>        return numbers[i];<br>        }</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：<br>int binary_search(int[] nums, int target) {<br>    int left = 0, right = nums.length - 1;<br>    while(left &lt;= right) {<br>        int mid = left + (right - left) / 2;<br>        if (nums[mid] &lt; target) {<br>            left = mid + 1;<br>        } else if (nums[mid] &gt; target) {<br>            right = mid - 1;<br>        } else if(nums[mid] == target) {<br>            // 直接返回<br>            return mid;<br>        }<br>    }<br>    // 直接返回<br>    return -1;<br>}</p>
<h2 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h2><p>二分查找，找到左右闭合区间即可<br>重点在边界的限制上<br>class Solution {<br>    public int search(int[] nums, int target) {<br>        // 搜索右边界 right<br>        int i = 0, j = nums.length - 1;<br>        while(i &lt;= j) {<br>            int m = (i + j) / 2;<br>            if(nums[m] &lt;= target) i = m + 1;<br>            else j = m - 1;<br>        }<br>        int right = i;<br>        // 若数组中无 target ，则提前返回<br>        if(j &gt;= 0 &amp;&amp; nums[j] != target) return 0;<br>        // 搜索左边界 right<br>        i = 0; j = nums.length - 1;<br>        while(i &lt;= j) {<br>            int m = (i + j) / 2;<br>            if(nums[m] &lt; target) i = m + 1;<br>            else j = m - 1;<br>        }<br>        int left = j;<br>        return right - left - 1;<br>    }<br>}</p>
<h2 id="查找value下标"><a href="#查找value下标" class="headerlink" title="查找value下标"></a>查找value下标</h2><p>给定一个有序的数组，查找value第一次出现的下标，不存在返回-1。</p>
<p>int BinarySearch(int array[], int n, int value)<br>{<br>    int left = 0;<br>    int right = n - 1;</p>
<pre><code>while (left &lt;= right)  
&#123;
    int middle = left + ((right - left) &gt;&gt; 1);
    if (array[middle] &gt;= value)  //因为是找到最小的等值下标，所以等于号放在这里
        right = middle - 1;
    else
        left = middle + 1;
&#125;
return array[right + 1] == value ? right + 1 : -1;
</code></pre>
<p>}<br>如果问题改为查找value最后一次出现的下标呢？只需改动两个位置：<br>1.if (array[middle] &gt;= value)中的等号去掉；<br>2.return中right+1改为left-1。<br>给定一个有序的数组，查找最接近value且大于value的数的下标（如果该数存在多个，返回第一个下标），不存在返回-1。</p>
<p>int BinarySearch(int array[], int n, int value)<br>{<br>    int left = 0;<br>    int right = n - 1;</p>
<pre><code>while (left &lt;= right)  
&#123;
    int middle = left + ((right - left) &gt;&gt; 1);
    if (array[middle] &gt; value)
        right = middle - 1;
    else
        left = middle + 1;
&#125;
return array[right + 1] &gt; value ? right + 1 : -1;
</code></pre>
<p>}<br>如果问题改为查找最接近value且小于value的数的下标（如果该数存在多个，返回最后一个下标）呢？只需改动两个位置：<br>1.if (array[middle] &gt; value)加入一个等号；<br>2.return array[right + 1] &gt; value ? right + 1 : -1;改为return array[left-1] &lt; value ? left - 1 : -1;。</p>
<p>总结</p>
<p>  二分算法所操作的区间，是左闭右开，还是左闭右闭，需要在循环体跳出判断中，以及每次修改left,，right区间值这两个地方保持一致，否则就可能出错。</p>
<p>给一个数组，找出这样一些数，这个数左边的数都比它小，右边的数都比它大</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>    思想：每次遍历，相邻两个比较大小，修改位置
       复杂度：n平方
       function maopao(arr) &#123;
           for (var i = 0; i &lt; arr.length; i++) &#123;
               for (var j = 0; j &lt; arr.length; j++) &#123;
                   if (arr[i] &gt; arr[j]) &#123;
                       var temp = arr[i];
                       arr[i] = arr[j];
                       arr[j] = temp;
                   &#125;
               &#125;
           &#125;
       &#125;
</code></pre>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre><code>    思想：每次往最小数组里插入一个数据，并保证数组是排序的
       (1) 将这个序列的第一个元素R0视为一个有序序列； 
       (2) 依次把 , , … ,  插入到这个有序序列中； 
       (3) 将插入到有序序列中时，前 i-1 个数是有序的，将和 ~ 从后往前进行比较，确定要插入的位置。
        public static int[] insertSOrt(int[] arr) &#123;
              int len = arr.length;
              int preIndex,cur;
              for (int i = 0; i &lt; len; i++) &#123;
                 preIndex = i - 1;
                 cur = arr[i];
                 while (preIndex &gt; 0 &amp;&amp; arr[preIndex] &gt; cur) &#123;
                      arr[preIndex +1] = arr[preIndex];
                      preIndex--;
                 &#125;
                 arr[preIndex+1] = cur;
              &#125;
              return arr;
          &#125;
</code></pre>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code>    作为一种典型的分而治之思想的算法应用
    将一个数组排序，可以先递归的将它分成两半分别排序，然后再将结果归并起来。
    缺点：需要额外的空间
    从下往上的归并排序：将待排序的数列分成若干个长度为1的子数列，然后将这
    些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得
    到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。
    这样就得到了我们想要的排序结果
     public int[] sort(int[] sourceArray) throws Exception &#123;
           // 对 arr 进行拷贝，不改变参数内容
           int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);

           if (arr.length &lt; 2) &#123;
               return arr;
           &#125;
           int middle = (int) Math.floor(arr.length / 2);
           // 分开
           int[] left = Arrays.copyOfRange(arr, 0, middle);
           int[] right = Arrays.copyOfRange(arr, middle, arr.length);
           // 合并
           return merge(sort(left), sort(right));
    &#125;

    protected int[] merge(int[] left, int[] right) &#123;
           int[] result = new int[left.length + right.length];
           int i = 0;
           while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123;
               if (left[0] &lt;= right[0]) &#123;
                   result[i++] = left[0];
                   left = Arrays.copyOfRange(left, 1, left.length);
               &#125; else &#123;
                   result[i++] = right[0];
                   right = Arrays.copyOfRange(right, 1, right.length);
               &#125;
           &#125;

           while (left.length &gt; 0) &#123;
               result[i++] = left[0];
               left = Arrays.copyOfRange(left, 1, left.length);
           &#125;

           while (right.length &gt; 0) &#123;
               result[i++] = right[0];
               right = Arrays.copyOfRange(right, 1, right.length);
           &#125;

           return result;
       &#125;
</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code>    分而治之思想在排序算法。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。
       先是把第一个挖出来，作为基值；然后先是从右向左，对比基值，如果如果小，那么放到坑里；然后在从左往右对比基值，如果大，那么放到坑里；当换完一轮了后，把基值放到坑里；然后在根据基值，分左右两组，递归排序；
       通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比
       另外一部分的所有数据都要小，继续对长度较短的序列进行同样的分割，最后到
       达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故
       减少了比较次数，降低了排序时间。
      private static void quickSort(int[] arr, int low, int high) &#123;

          if (low &lt; high) &#123;
              // 找寻基准数据的正确索引位置
              int index = getIndex(arr, low, high);
              // 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序
              quickSort(arr, low, index - 1); // 左半边排序
              quickSort(arr, index + 1, high); // 右半边排序
          &#125;

      &#125;

      private static int getIndex(int[] arr, int low, int high) &#123;
          // 基准数据
          int tmp = arr[low];
          while (low &lt; high) &#123;
              // 当队尾的元素大于等于基准数据时,向前挪动high指针
              while (low &lt; high &amp;&amp; arr[high] &gt;= tmp) &#123;
                  high--;
              &#125;
              // 如果队尾元素小于tmp了,需要将其赋值给low
              arr[low] = arr[high];
              // 当队首元素小于等于tmp时,向前挪动low指针
              while (low &lt; high &amp;&amp; arr[low] &lt;= tmp) &#123;
                  low++;
              &#125;
              // 当队首元素大于tmp时,需要将其赋值给high
              arr[high] = arr[low];

          &#125;
          // 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置
          // 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low]
          arr[low] = tmp;
          return low; // 返回tmp的正确位置
      &#125;
</code></pre>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><pre><code>    它是对有向图的顶点排成一个线性序列。
</code></pre>
<h2 id="堆排序（大顶堆、小顶堆）"><a href="#堆排序（大顶堆、小顶堆）" class="headerlink" title="堆排序（大顶堆、小顶堆）"></a>堆排序（大顶堆、小顶堆）</h2><pre><code>    堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
     大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列
     小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列
     堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大
     值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将
     剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执
     行，便能得到一个有序序列了
     
     var len;    //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量

     function buildMaxHeap(arr) &#123;   //建立大顶堆
         len = arr.length;
         for (var i = Math.floor(len/2); i &amp;gt;= 0; i--) &#123;
             heapify(arr, i);
         &#125;
     &#125;

     function heapify(arr, i) &#123;     //堆调整
         var left = 2 * i + 1,
             right = 2 * i + 2,
             largest = i;

         if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;
             largest = left;
         &#125;

         if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;
             largest = right;
         &#125;

         if (largest != i) &#123;
             swap(arr, i, largest);
             heapify(arr, largest);
         &#125;
     &#125;

     function swap(arr, i, j) &#123;
         var temp = arr[i];
         arr[i] = arr[j];
         arr[j] = temp;
     &#125;

     function heapSort(arr) &#123;
         buildMaxHeap(arr);

         for (var i = arr.length-1; i &gt; 0; i--) &#123;
             swap(arr, 0, i);
             len--;
             heapify(arr, 0);
         &#125;
         return arr;
     &#125;
</code></pre>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><pre><code>    知道最大最小值，可以生成一个最大最小值的一个桶的map，key是值，value是出现的次数
    for(i=1;i&lt;=n;i++)//循环读入n个数，并进行桶排序
   &#123;
       scanf(&quot;%d&quot;,&amp;t);  //把每一个数读到变量t中
       book[t]++;  //进行计数，对编号为t的桶放一个小旗子
   &#125;
   for(i=1000;i&gt;=0;i--)  //依次判断编号1000~0的桶
       for(j=1;j&lt;=book[i];j++)  //出现了几次就将桶的编号打印几次
            printf(&quot;%d &quot;,i);
   getchar();getchar();
</code></pre>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h2 id="按指定要求排序后输出"><a href="#按指定要求排序后输出" class="headerlink" title="按指定要求排序后输出"></a>按指定要求排序后输出</h2><p>给字符串，内含很多整数，按指定要求排序后输出指定位置上的整数；<br>两个有序数组，找出合并后的中位数<br>获取数组中最值（最大值/最小值）<br> 分治 + 最小堆排序的思想<br>        局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，<br>        与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除<br>        ，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。<br>        原理是最小堆排序<br>        <a target="_blank" rel="noopener" href="https://blog.csdn.net/zyq522376829/article/details/47686867">https://blog.csdn.net/zyq522376829/article/details/47686867</a><br> 求数组中第k大的数<br>        建立一个大小为K的最小堆，堆顶就是第K大的数<br>        例如，假设有10个数，要求求第3大的数，第一步选取任意的3个数，比如说是前3个，<br>        将这3个数建成最小堆，然后从第4个数开始，与堆顶<br>        的数比较，如果比堆顶的数要小，那么这个数就不要，如果比堆顶的数大，<br>        则舍弃当前的堆顶而将这个数作为新的堆顶，并再去维护堆</p>
<h2 id="旋转数组查找；"><a href="#旋转数组查找；" class="headerlink" title="旋转数组查找；"></a>旋转数组查找；</h2><pre><code>public static int minNumberInRotateArray(int[] rotateArray)
   &#123;
       if (rotateArray.Length == 0) return 0;
       else if (rotateArray.Length == 1||rotateArray[0]&lt;rotateArray[rotateArray.Length-1]) return rotateArray[0];
       else
       &#123;
           int low = 0;
           int high = rotateArray.Length - 1;
           while (low&lt;=high)
           &#123;
               int mid = (int)Math.Floor((double)(low + high) / 2);
               if (rotateArray[mid] &gt; rotateArray[0]) low = mid + 1;
               else if (rotateArray[mid] &lt; rotateArray[0]) high = mid - 1;
               else low = low + 1;
           &#125;

           return low == rotateArray.Length ? rotateArray[low - 1] : rotateArray[low];
       &#125;
   &#125;
</code></pre>
<p>##常见算法<br>广度优先搜索<br>深度优先搜索<br>递归<br>回溯<br>贪婪算法<br>动态规划<br>线性规划<br>区间规划<br>约束规划<br>自底向上<br>自定向下</p>
<h2 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h2><p>回溯<br>递归<br>剪枝</p>
<h2 id="基础技巧"><a href="#基础技巧" class="headerlink" title="基础技巧"></a>基础技巧</h2><p>分治<br>倍增<br>二分<br>贪心</p>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><ol start="134">
<li>加油站</li>
<li>LRU缓存机制</li>
<li>快乐数</li>
<li>生命游戏</li>
<li>两整数之和</li>
<li>Fizz Buzz<br>两个人掷硬币，先得到正面的人赢，游戏到有人赢结束。问先掷硬币的人赢的概率</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/06/M_Swift144%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="prev" title="二叉树">
      <i class="fa fa-chevron-left"></i> 二叉树
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/06/M_Swift146%E6%A0%88%E9%98%9F%E5%88%97/" rel="next" title="栈">
      栈 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">1.</span> <span class="nav-text">寻找峰值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">找出这个重复的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">3.</span> <span class="nav-text">0～n-1中缺失的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">4.</span> <span class="nav-text">旋转数组的最小数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">5.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97"><span class="nav-number">6.</span> <span class="nav-text">在排序数组中查找数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BEvalue%E4%B8%8B%E6%A0%87"><span class="nav-number">7.</span> <span class="nav-text">查找value下标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number"></span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88%E5%A4%A7%E9%A1%B6%E5%A0%86%E3%80%81%E5%B0%8F%E9%A1%B6%E5%A0%86%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">堆排序（大顶堆、小顶堆）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">桶排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">8.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E6%8C%87%E5%AE%9A%E8%A6%81%E6%B1%82%E6%8E%92%E5%BA%8F%E5%90%8E%E8%BE%93%E5%87%BA"><span class="nav-number">9.</span> <span class="nav-text">按指定要求排序后输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE%EF%BC%9B"><span class="nav-number">10.</span> <span class="nav-text">旋转数组查找；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7"><span class="nav-number">11.</span> <span class="nav-text">搜索技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%8A%80%E5%B7%A7"><span class="nav-number">12.</span> <span class="nav-text">基础技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F"><span class="nav-number">13.</span> <span class="nav-text">模拟</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">403</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
