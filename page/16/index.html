<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/16/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift138%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift138%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">面试总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:52" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:52+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="58同城"><a href="#58同城" class="headerlink" title="58同城"></a>58同城</h2><h2 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h2><p>我们创建的一般都是静态库，可以制作动态库，不允许上架app store的<br>iOS8，swift以后，出现了阉割版的Extension动态库。这种动态库允许APP和APP Extension共享代码<br>静态库：链接时，静态库会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝<br>系统动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存<br>iOS有没有动态库<br>iOS的动态库（被阉割的动态库）<br>iOS8之前因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，并且iOS是单进程的，也就是某一时刻只有一个进程在运行，那么你写个共享库，给谁共享呢。同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，综上所以上动态库也就没有存在的必要了。<br>但是后来iOS8之后，iOS有了App Extesion特性，而且Swift也诞生了。由于iOS主App需要和Extension共享代码，Swift语言机制也需要动态库，于是苹果后来提出了Embedded Framework，这种动态库允许APP和APP Extension共享代码，但是这份动态库的生命被限定在一个APP进程内。简单点可以理解为被阉割的动态库。<br> App 中（App 和 Extension 的 Bundle 是共享的）所以苹果没有直接把这种Embedded Framework称作动态库而是叫Embedded Framework。<br>前面提到的静态库可以简单理解为一堆目标文件(.o/.obj)的打包体(并非二进制文件)，而动态库可以简单理解为 一个没有main函数的可执行文件。<br>大学再讲编译原理的时候有两个非常重要的过程，编译和链接。编译可以理解为将源代码编译为目标文件，链接可以理解为将各种目标文件上加一些第三方库、并且和系统库链接起来为可执行文件。因为某个目标文件的符号（可以理解为变化、函数）可能来至其他目标文件，链接最为主要的就是决议符号的地址。<br>编译会生成目标文件，目标文件没有经过链接的过程，某些符号还没有调整过，Windows下的.obj文件，Linux下的.o文件，Unix的.out文件。</p>
<p>链接的过程可以简单描述如下：<br>假如主程序main.c 使用了 fun.c 模块的 foo函数，那么main.c在编译的过程，对于调用foo函数的指令，对于指令的目标地址暂时搁置；待到链接的时候，由链接器来填写foo函数的地址。</p>
<h2 id="OC反射"><a href="#OC反射" class="headerlink" title="OC反射"></a>OC反射</h2><p>通过类明获取类，通过方法名获取方法<br>所以说通过上面runtime的方式可以通过指针输出你想要的类当中的的全部属性，当然反过来也是可以实现的（这里对runtime不做过多的讲解，改天更新文章再对runtime进行分享</p>
<h2 id="编译和链接的区别"><a href="#编译和链接的区别" class="headerlink" title="编译和链接的区别"></a>编译和链接的区别</h2><p>将预处理生成的文件，经过词法分析、语法分析、语义分析以及优化后编译成若干个目标模块。可以理解为将高级语言翻译为计算机可以理解的二进制代码，即机器语言。<br>由链接程序将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的载入模型。链接主要解决模块间的相互引用问题。分为地址和空间分配，符号解析和重定位几个步骤。在编译阶段生成目标文件时，会暂时搁置那些外部引用，而这些外部引用就是在链接时进行确定的，链接器在链接时，会根据符号名称去相应模块中寻找对应符号。待符号确定之后，链接器会重写之前那些未确定的符号的地址，这个过程就是重定位。链接一般分为静态链接、载入时动态链接以及运行时动态链接三种。</p>
<h2 id="OC和JS交互方式"><a href="#OC和JS交互方式" class="headerlink" title="OC和JS交互方式"></a>OC和JS交互方式</h2><p>注入 API 和 拦截 URL SCHEME<br>UIWebView 拦截 URL<br>WebViewJavascriptBridge。<br>只要调用<br>window.location.href = “openimagepicker://“<br>就会调用<br>(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</p>
<p>WebViewJavascriptBridge中OC调用JS采用的是WebView提供的JS执行方法；而JS调用OC采用的是URL拦截的方式，OC端通过识别特定的URL来区分是否需要拦截，并做相应的逻辑处理。<br>addScriptMessageHandler<br>evaluateJavaScript<br>JavaScriptCore<br>JSContext上下文，类似全局t对象，html的window对象一样</p>
<p>WKwebView，直接注入了JS方法名，不需要通过JavaScriptCore作为中间件<br>WKWebView 白屏问题： WKWebView 是一个多进程组件，Other Process 的内存占用会增加。WebContent Process 会 crash，从而出现白屏现象<br>缺点：承载当前webView的控制器无法正常释放<br>原因注意：这种方法很可能照成循环引用，所以在适当的时机要移除。</p>
<h2 id="OC和JS是如何交互的"><a href="#OC和JS是如何交互的" class="headerlink" title="OC和JS是如何交互的"></a>OC和JS是如何交互的</h2><p>依赖注入<br>OC先声明一段JS代码，在第一次进入此webView页的时候注入到 webView中，之后webView上下文中就有了这些js函数。<br>注册声明 js 会被 oc 调用的方法存放在 js 环境的字典中；<br>oc 发起调用，生成一个message字典，三个参数（handlerName 方法名，data数据， callbackId 回调方法）<br>把message字典转成json字符串，处理字符串里面的\、\、\r、\n 等特殊字符。生成新的字符串并加上<br>WebViewJavascriptBridge._handleMessageFromObjC(‘messageJSON‘)，形成一段字符串形式的js代码（既通过提前注入js中的函数_handleMessageFromObjC去处理 messageJSON 参数）。</p>
<h2 id="模块化同层的依赖如何实现"><a href="#模块化同层的依赖如何实现" class="headerlink" title="模块化同层的依赖如何实现"></a>模块化同层的依赖如何实现</h2><p>通过引用的方式打出framework，所以需要在项目中同时使用</p>
<p>DNS过程 DNS劫持</p>
<p>编译过程</p>
<p>线程同步方法<br>死锁。如何避免<br>输入url后的事件流程<br>获取mac地址的过程<br>10亿数据查找目标，bitmap<br>浏览器渲染页面过程<br>设计一个StringBuffer<br>设计多线程下载一个1G文件<br>讲一讲hashmap 和hashtable 的区别<br>分享一个最值得分享的经历，觉得最有成就感的？过程中最有收获的点<br>什么是信号量<br>git<br>问这三个http版本有啥区别的区别<br>进程和线程切换的开销<br>    切换虚拟地址空间<br>    切换CPU上下文<br>    切换内核栈<br>进程间通讯的四种方式<br>    共享内存<br>    信号<br>    管道<br>    消息队列<br>动态链接库和共享内存的区别在哪呢？ 区别就在于：多个程序虽然可以共享同一个动态链接库中的相同代码，但每一个进程都为动态链接库使用的全部数据分配了自己的地址空间。而共享内存是代码和数据均被多个程序所共享。动态链接库只是实现了代码的复用，对于数据，各个程序要自己保存。共享内存用于进程间通信，主要用于数据…</p>
<p>DNS查询<br>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift138%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift138%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">UI相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:47" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:47+08:00">2020-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 14:03:52" itemprop="dateModified" datetime="2022-03-03T14:03:52+08:00">2022-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="程序绘制流程"><a href="#程序绘制流程" class="headerlink" title="程序绘制流程"></a>程序绘制流程</h2><h2 id="试图绘制为什么不立即执行"><a href="#试图绘制为什么不立即执行" class="headerlink" title="试图绘制为什么不立即执行"></a>试图绘制为什么不立即执行</h2><h2 id="事件响应流程"><a href="#事件响应流程" class="headerlink" title="事件响应流程"></a>事件响应流程</h2><h2 id="UI卡顿原因"><a href="#UI卡顿原因" class="headerlink" title="UI卡顿原因"></a>UI卡顿原因</h2><h2 id="滑动优化方案"><a href="#滑动优化方案" class="headerlink" title="滑动优化方案"></a>滑动优化方案</h2><h2 id="什么是离屏渲染，触发的条件是什么"><a href="#什么是离屏渲染，触发的条件是什么" class="headerlink" title="什么是离屏渲染，触发的条件是什么"></a>什么是离屏渲染，触发的条件是什么</h2><h2 id="UIView和CALayer关系"><a href="#UIView和CALayer关系" class="headerlink" title="UIView和CALayer关系"></a>UIView和CALayer关系</h2><h2 id="CALayer的mask作用"><a href="#CALayer的mask作用" class="headerlink" title="CALayer的mask作用"></a>CALayer的mask作用</h2><h2 id="如何高性能给UIImageView加圆角"><a href="#如何高性能给UIImageView加圆角" class="headerlink" title="如何高性能给UIImageView加圆角"></a>如何高性能给UIImageView加圆角</h2><h2 id="如何使用核心动画"><a href="#如何使用核心动画" class="headerlink" title="如何使用核心动画"></a>如何使用核心动画</h2><h2 id="如何增加view点击范围"><a href="#如何增加view点击范围" class="headerlink" title="如何增加view点击范围"></a>如何增加view点击范围</h2><h2 id="hitTest：withEvent内部实现"><a href="#hitTest：withEvent内部实现" class="headerlink" title="hitTest：withEvent内部实现"></a>hitTest：withEvent内部实现</h2><h2 id="程序的启动速度优化"><a href="#程序的启动速度优化" class="headerlink" title="程序的启动速度优化"></a>程序的启动速度优化</h2><h2 id="drawRect和layouSubviews-的区别"><a href="#drawRect和layouSubviews-的区别" class="headerlink" title="drawRect和layouSubviews 的区别"></a>drawRect和layouSubviews 的区别</h2><h2 id="setNeedsLayout与layoutIfNeeded的区别"><a href="#setNeedsLayout与layoutIfNeeded的区别" class="headerlink" title="setNeedsLayout与layoutIfNeeded的区别"></a>setNeedsLayout与layoutIfNeeded的区别</h2><h2 id="UIResponder的理解和事件响应分析"><a href="#UIResponder的理解和事件响应分析" class="headerlink" title="UIResponder的理解和事件响应分析"></a>UIResponder的理解和事件响应分析</h2><h2 id="loadView的作用"><a href="#loadView的作用" class="headerlink" title="loadView的作用"></a>loadView的作用</h2><h2 id="UITableView卡顿原因"><a href="#UITableView卡顿原因" class="headerlink" title="UITableView卡顿原因"></a>UITableView卡顿原因</h2><h2 id="UITableView优化"><a href="#UITableView优化" class="headerlink" title="UITableView优化"></a>UITableView优化</h2><h2 id="iOS-保持界面流畅的技巧"><a href="#iOS-保持界面流畅的技巧" class="headerlink" title="iOS 保持界面流畅的技巧"></a>iOS 保持界面流畅的技巧</h2><h2 id="使用-drawRect有什么影响"><a href="#使用-drawRect有什么影响" class="headerlink" title="使用 drawRect有什么影响"></a>使用 drawRect有什么影响</h2><h2 id="tableViewCell的自适应如何实现，如何保证性能"><a href="#tableViewCell的自适应如何实现，如何保证性能" class="headerlink" title="tableViewCell的自适应如何实现，如何保证性能"></a>tableViewCell的自适应如何实现，如何保证性能</h2><h2 id="转场动画相关操作"><a href="#转场动画相关操作" class="headerlink" title="转场动画相关操作"></a>转场动画相关操作</h2><h2 id="绘图相关知识-coreGraphics框架的使用"><a href="#绘图相关知识-coreGraphics框架的使用" class="headerlink" title="绘图相关知识(coreGraphics框架的使用)"></a>绘图相关知识(coreGraphics框架的使用)</h2><h2 id="view的生命周期"><a href="#view的生命周期" class="headerlink" title="view的生命周期"></a>view的生命周期</h2><h2 id="系统UIView更新机制的思想"><a href="#系统UIView更新机制的思想" class="headerlink" title="系统UIView更新机制的思想"></a>系统UIView更新机制的思想</h2><h2 id="drawRect常用作用"><a href="#drawRect常用作用" class="headerlink" title="drawRect常用作用"></a>drawRect常用作用</h2><h2 id="layoutSubView和drawRect的调用时机；"><a href="#layoutSubView和drawRect的调用时机；" class="headerlink" title="layoutSubView和drawRect的调用时机；"></a>layoutSubView和drawRect的调用时机；</h2><h2 id="用UIView实现Scrollview。"><a href="#用UIView实现Scrollview。" class="headerlink" title="用UIView实现Scrollview。"></a>用UIView实现Scrollview。</h2><h2 id="轮播图的实现"><a href="#轮播图的实现" class="headerlink" title="轮播图的实现"></a>轮播图的实现</h2><h2 id="CGSize-intrinsicContentSize-是干什么用的？"><a href="#CGSize-intrinsicContentSize-是干什么用的？" class="headerlink" title="-(CGSize)intrinsicContentSize:是干什么用的？"></a>-(CGSize)intrinsicContentSize:是干什么用的？</h2><h2 id="渲染UI为什么要在主线程？"><a href="#渲染UI为什么要在主线程？" class="headerlink" title="渲染UI为什么要在主线程？"></a>渲染UI为什么要在主线程？</h2><h2 id="如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？"><a href="#如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？" class="headerlink" title="如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？"></a>如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？</h2><h2 id="scrollview与消息响应链冲突？"><a href="#scrollview与消息响应链冲突？" class="headerlink" title="scrollview与消息响应链冲突？"></a>scrollview与消息响应链冲突？</h2><h2 id="Core-Graphics的更底层的是什么；"><a href="#Core-Graphics的更底层的是什么；" class="headerlink" title="Core Graphics的更底层的是什么；"></a>Core Graphics的更底层的是什么；</h2><h1 id="OC相关"><a href="#OC相关" class="headerlink" title="OC相关"></a>OC相关</h1><h2 id="分类可以添加哪些内容，为什么不能添加属性"><a href="#分类可以添加哪些内容，为什么不能添加属性" class="headerlink" title="分类可以添加哪些内容，为什么不能添加属性"></a>分类可以添加哪些内容，为什么不能添加属性</h2><h2 id="类扩展和分类的区别"><a href="#类扩展和分类的区别" class="headerlink" title="类扩展和分类的区别"></a>类扩展和分类的区别</h2><h2 id="分类是如何实现的"><a href="#分类是如何实现的" class="headerlink" title="分类是如何实现的"></a>分类是如何实现的</h2><h2 id="分类重写了原类中同名方法会怎么样，为什么"><a href="#分类重写了原类中同名方法会怎么样，为什么" class="headerlink" title="分类重写了原类中同名方法会怎么样，为什么"></a>分类重写了原类中同名方法会怎么样，为什么</h2><h2 id="如何给分类添加属性（关联对象）"><a href="#如何给分类添加属性（关联对象）" class="headerlink" title="如何给分类添加属性（关联对象）"></a>如何给分类添加属性（关联对象）</h2><h2 id="什么是代理，和通知-BLOCK区别"><a href="#什么是代理，和通知-BLOCK区别" class="headerlink" title="什么是代理，和通知/BLOCK区别"></a>什么是代理，和通知/BLOCK区别</h2><h2 id="什么是通知"><a href="#什么是通知" class="headerlink" title="什么是通知"></a>什么是通知</h2><h2 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h2><h2 id="KVC的实现原理"><a href="#KVC的实现原理" class="headerlink" title="KVC的实现原理"></a>KVC的实现原理</h2><h2 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h2><h2 id="include与-import的区别、-import-与-class-的区别"><a href="#include与-import的区别、-import-与-class-的区别" class="headerlink" title="include与#import的区别、#import 与@class 的区别"></a>include与#import的区别、#import 与@class 的区别</h2><h2 id="解释-const-static-inline-关键字"><a href="#解释-const-static-inline-关键字" class="headerlink" title="解释 const, static, inline 关键字"></a>解释 const, static, inline 关键字</h2><h2 id="OC-里怎么实现多继承"><a href="#OC-里怎么实现多继承" class="headerlink" title="OC 里怎么实现多继承"></a>OC 里怎么实现多继承</h2><h2 id="load方法实现原理与initialize区别"><a href="#load方法实现原理与initialize区别" class="headerlink" title="load方法实现原理与initialize区别"></a>load方法实现原理与initialize区别</h2><h2 id="懒加载的使用"><a href="#懒加载的使用" class="headerlink" title="懒加载的使用"></a>懒加载的使用</h2><h2 id="写一个单例"><a href="#写一个单例" class="headerlink" title="写一个单例"></a>写一个单例</h2><h2 id="nil-NIL-NSNULL区别，id-和-instanceType-区别，self和super的区别，struct和class的区别"><a href="#nil-NIL-NSNULL区别，id-和-instanceType-区别，self和super的区别，struct和class的区别" class="headerlink" title="nil NIL NSNULL区别，id 和 instanceType 区别，self和super的区别，struct和class的区别"></a>nil NIL NSNULL区别，id 和 instanceType 区别，self和super的区别，struct和class的区别</h2><h2 id="如何实现一个线程安全的-NSMutableArray"><a href="#如何实现一个线程安全的-NSMutableArray" class="headerlink" title="如何实现一个线程安全的 NSMutableArray?"></a>如何实现一个线程安全的 NSMutableArray?</h2><h2 id="JS-和-OC-互相调用的几种方式"><a href="#JS-和-OC-互相调用的几种方式" class="headerlink" title="JS 和 OC 互相调用的几种方式"></a>JS 和 OC 互相调用的几种方式</h2><h2 id="数据持久性有哪几种"><a href="#数据持久性有哪几种" class="headerlink" title="数据持久性有哪几种"></a>数据持久性有哪几种</h2><h2 id="blcok，NSNotification，delegate，Observer比较"><a href="#blcok，NSNotification，delegate，Observer比较" class="headerlink" title="blcok，NSNotification，delegate，Observer比较"></a>blcok，NSNotification，delegate，Observer比较</h2><h2 id="const-extern-static-用法区别"><a href="#const-extern-static-用法区别" class="headerlink" title="const extern static 用法区别"></a>const extern static 用法区别</h2><h2 id="写一个宏定义函数，实现返回三个数中最大的"><a href="#写一个宏定义函数，实现返回三个数中最大的" class="headerlink" title="写一个宏定义函数，实现返回三个数中最大的"></a>写一个宏定义函数，实现返回三个数中最大的</h2><h2 id="static和extern的访问范围，用extern的情况下什么时候程序会报错"><a href="#static和extern的访问范围，用extern的情况下什么时候程序会报错" class="headerlink" title="static和extern的访问范围，用extern的情况下什么时候程序会报错"></a>static和extern的访问范围，用extern的情况下什么时候程序会报错</h2><h2 id="inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？"><a href="#inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？" class="headerlink" title="inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？"></a>inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？</h2><h2 id="OC里的基本数据类型如数组字典等的数据结构是怎样的；"><a href="#OC里的基本数据类型如数组字典等的数据结构是怎样的；" class="headerlink" title="OC里的基本数据类型如数组字典等的数据结构是怎样的；"></a>OC里的基本数据类型如数组字典等的数据结构是怎样的；</h2><h2 id="sychronized实现原理"><a href="#sychronized实现原理" class="headerlink" title="sychronized实现原理"></a>sychronized实现原理</h2><h2 id="问NSTimer的底层实现原理"><a href="#问NSTimer的底层实现原理" class="headerlink" title="问NSTimer的底层实现原理"></a>问NSTimer的底层实现原理</h2><h2 id="block中为什么要用Strong类型的引用来保持self；"><a href="#block中为什么要用Strong类型的引用来保持self；" class="headerlink" title="block中为什么要用Strong类型的引用来保持self；"></a>block中为什么要用Strong类型的引用来保持self；</h2><h2 id="问-ifdef-cplusplus-extern-“C-“"><a href="#问-ifdef-cplusplus-extern-“C-“" class="headerlink" title="问#ifdef __cplusplus extern “C “"></a>问#ifdef __cplusplus extern “C “</h2><h2 id="说下ASCII和unicode的区别utf-8的优势"><a href="#说下ASCII和unicode的区别utf-8的优势" class="headerlink" title="说下ASCII和unicode的区别utf-8的优势"></a>说下ASCII和unicode的区别utf-8的优势</h2><h2 id="iOS-launchwith-options-返回no有什么作用；"><a href="#iOS-launchwith-options-返回no有什么作用；" class="headerlink" title="iOS launchwith options 返回no有什么作用；"></a>iOS launchwith options 返回no有什么作用；</h2><h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h2 id="NSObject的数据结构"><a href="#NSObject的数据结构" class="headerlink" title="NSObject的数据结构"></a>NSObject的数据结构</h2><h2 id="类对象和实例对象的isa指针的指向"><a href="#类对象和实例对象的isa指针的指向" class="headerlink" title="类对象和实例对象的isa指针的指向"></a>类对象和实例对象的isa指针的指向</h2><h2 id="为什么id类型可以指向OC中任意对象"><a href="#为什么id类型可以指向OC中任意对象" class="headerlink" title="为什么id类型可以指向OC中任意对象"></a>为什么id类型可以指向OC中任意对象</h2><h2 id="为什么不能用isa判断一个类的继承关系"><a href="#为什么不能用isa判断一个类的继承关系" class="headerlink" title="为什么不能用isa判断一个类的继承关系"></a>为什么不能用isa判断一个类的继承关系</h2><h2 id="cache-t的数据结构、实现原理及扩容"><a href="#cache-t的数据结构、实现原理及扩容" class="headerlink" title="cache_t的数据结构、实现原理及扩容"></a>cache_t的数据结构、实现原理及扩容</h2><h2 id="cache-t-扩容"><a href="#cache-t-扩容" class="headerlink" title="cache_t 扩容"></a>cache_t 扩容</h2><h2 id="class-rw-t的数据结构，实现原理"><a href="#class-rw-t的数据结构，实现原理" class="headerlink" title="class_rw_t的数据结构，实现原理"></a>class_rw_t的数据结构，实现原理</h2><h2 id="哈希碰撞的解决方法"><a href="#哈希碰撞的解决方法" class="headerlink" title="哈希碰撞的解决方法"></a>哈希碰撞的解决方法</h2><h2 id="方法查找的过程"><a href="#方法查找的过程" class="headerlink" title="方法查找的过程"></a>方法查找的过程</h2><h2 id="消息转发的流程"><a href="#消息转发的流程" class="headerlink" title="消息转发的流程"></a>消息转发的流程</h2><h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><h2 id="系统如何解决新增实例冲突"><a href="#系统如何解决新增实例冲突" class="headerlink" title="系统如何解决新增实例冲突"></a>系统如何解决新增实例冲突</h2><h2 id="常用的runtime方法有哪些"><a href="#常用的runtime方法有哪些" class="headerlink" title="常用的runtime方法有哪些"></a>常用的runtime方法有哪些</h2><h2 id="runtime的具体应用有哪些，你在什么地方用到了"><a href="#runtime的具体应用有哪些，你在什么地方用到了" class="headerlink" title="runtime的具体应用有哪些，你在什么地方用到了"></a>runtime的具体应用有哪些，你在什么地方用到了</h2><h2 id="runtime-怎么添加属性，方法等"><a href="#runtime-怎么添加属性，方法等" class="headerlink" title="runtime 怎么添加属性，方法等"></a>runtime 怎么添加属性，方法等</h2><h2 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="runtime 如何实现 weak 属性"></a>runtime 如何实现 weak 属性</h2><h2 id="runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）"><a href="#runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）"></a>runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</h2><h2 id="runtime如何实现weak变量的自动置nil"><a href="#runtime如何实现weak变量的自动置nil" class="headerlink" title="runtime如何实现weak变量的自动置nil"></a>runtime如何实现weak变量的自动置nil</h2><h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2><h2 id="共用体方法查找"><a href="#共用体方法查找" class="headerlink" title="共用体方法查找"></a>共用体方法查找</h2><h2 id="msgSend如何查找"><a href="#msgSend如何查找" class="headerlink" title="msgSend如何查找"></a>msgSend如何查找</h2><h2 id="msgSend参数都有哪些；"><a href="#msgSend参数都有哪些；" class="headerlink" title="msgSend参数都有哪些；"></a>msgSend参数都有哪些；</h2><h2 id="class方法相关"><a href="#class方法相关" class="headerlink" title="class方法相关"></a>class方法相关</h2><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存中的5大区都是什么？"><a href="#内存中的5大区都是什么？" class="headerlink" title="内存中的5大区都是什么？"></a>内存中的5大区都是什么？</h2><h2 id="C-内存如何分布、堆和栈的区别"><a href="#C-内存如何分布、堆和栈的区别" class="headerlink" title="C++内存如何分布、堆和栈的区别"></a>C++内存如何分布、堆和栈的区别</h2><h2 id="ARC实现机制，遵循哪些原则"><a href="#ARC实现机制，遵循哪些原则" class="headerlink" title="ARC实现机制，遵循哪些原则"></a>ARC实现机制，遵循哪些原则</h2><h2 id="NSObject内存分配、ISA指针的内存大小"><a href="#NSObject内存分配、ISA指针的内存大小" class="headerlink" title="NSObject内存分配、ISA指针的内存大小"></a>NSObject内存分配、ISA指针的内存大小</h2><h2 id="Tagged-Pointer、NONPOINTER-ISA实现机制和作用"><a href="#Tagged-Pointer、NONPOINTER-ISA实现机制和作用" class="headerlink" title="Tagged Pointer、NONPOINTER_ISA实现机制和作用"></a>Tagged Pointer、NONPOINTER_ISA实现机制和作用</h2><h2 id="异步多线程访问导致的内存问题分析及解决办法。（代码题）"><a href="#异步多线程访问导致的内存问题分析及解决办法。（代码题）" class="headerlink" title="异步多线程访问导致的内存问题分析及解决办法。（代码题）"></a>异步多线程访问导致的内存问题分析及解决办法。（代码题）</h2><h2 id="SideTables数据结构及实现原理，为什么用多个SideTables"><a href="#SideTables数据结构及实现原理，为什么用多个SideTables" class="headerlink" title="SideTables数据结构及实现原理，为什么用多个SideTables"></a>SideTables数据结构及实现原理，为什么用多个SideTables</h2><pre><code>                       
</code></pre>
<h2 id="Autoreleasepool的数据结构及实现原理，什么时候释放"><a href="#Autoreleasepool的数据结构及实现原理，什么时候释放" class="headerlink" title="Autoreleasepool的数据结构及实现原理，什么时候释放"></a>Autoreleasepool的数据结构及实现原理，什么时候释放</h2><h2 id="AutoreleasePool-为何可以嵌套使用"><a href="#AutoreleasePool-为何可以嵌套使用" class="headerlink" title="AutoreleasePool 为何可以嵌套使用"></a>AutoreleasePool 为何可以嵌套使用</h2><h2 id="子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool"><a href="#子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool" class="headerlink" title="子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool"></a>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool</h2><h2 id="dealloc调用流程"><a href="#dealloc调用流程" class="headerlink" title="dealloc调用流程"></a>dealloc调用流程</h2><h2 id="常见的循环引用，如何破除循环引用"><a href="#常见的循环引用，如何破除循环引用" class="headerlink" title="常见的循环引用，如何破除循环引用"></a>常见的循环引用，如何破除循环引用</h2><h2 id="weak-修饰的变量在地址被释放后，为何被置为-nil？"><a href="#weak-修饰的变量在地址被释放后，为何被置为-nil？" class="headerlink" title="__weak 修饰的变量在地址被释放后，为何被置为 nil？"></a>__weak 修饰的变量在地址被释放后，为何被置为 nil？</h2><h2 id="深拷贝和浅拷贝区别"><a href="#深拷贝和浅拷贝区别" class="headerlink" title="深拷贝和浅拷贝区别"></a>深拷贝和浅拷贝区别</h2><h2 id="atomic是安全的吗"><a href="#atomic是安全的吗" class="headerlink" title="atomic是安全的吗"></a>atomic是安全的吗</h2><h2 id="assign-vs-weak，-block-vs-weak-区别"><a href="#assign-vs-weak，-block-vs-weak-区别" class="headerlink" title="assign vs weak，_block vs _weak 区别"></a>assign vs weak，_block vs _weak 区别</h2><h2 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h2><h2 id="图片加载占用内存对比"><a href="#图片加载占用内存对比" class="headerlink" title="图片加载占用内存对比"></a>图片加载占用内存对比</h2><h2 id="block一般用那个关键字修饰，为什么"><a href="#block一般用那个关键字修饰，为什么" class="headerlink" title="block一般用那个关键字修饰，为什么"></a>block一般用那个关键字修饰，为什么</h2><h2 id="写一个MRC的set方法"><a href="#写一个MRC的set方法" class="headerlink" title="写一个MRC的set方法"></a>写一个MRC的set方法</h2><h2 id="如何解决定时器循环引用"><a href="#如何解决定时器循环引用" class="headerlink" title="如何解决定时器循环引用"></a>如何解决定时器循环引用</h2><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><h2 id="什么是虚拟内存、共享内存、物理内存"><a href="#什么是虚拟内存、共享内存、物理内存" class="headerlink" title="什么是虚拟内存、共享内存、物理内存"></a>什么是虚拟内存、共享内存、物理内存</h2><h2 id="举例一些I-O操作的例子"><a href="#举例一些I-O操作的例子" class="headerlink" title="举例一些I/O操作的例子"></a>举例一些I/O操作的例子</h2><h2 id="如何开辟一块内存；"><a href="#如何开辟一块内存；" class="headerlink" title="如何开辟一块内存；"></a>如何开辟一块内存；</h2><h2 id="什么时候深复制，什么时候浅复制；"><a href="#什么时候深复制，什么时候浅复制；" class="headerlink" title="什么时候深复制，什么时候浅复制；"></a>什么时候深复制，什么时候浅复制；</h2><h2 id="怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手"><a href="#怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手" class="headerlink" title="怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手"></a>怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手</h2><h2 id="问堆和栈的区别。"><a href="#问堆和栈的区别。" class="headerlink" title="问堆和栈的区别。"></a>问堆和栈的区别。</h2><h2 id="Block的创建，何时被释放。"><a href="#Block的创建，何时被释放。" class="headerlink" title="Block的创建，何时被释放。"></a>Block的创建，何时被释放。</h2><h2 id="dynamic的应用场景？"><a href="#dynamic的应用场景？" class="headerlink" title="@dynamic的应用场景？"></a>@dynamic的应用场景？</h2><h2 id="问题：-property-copy-NSMutableArray-array"><a href="#问题：-property-copy-NSMutableArray-array" class="headerlink" title="问题：@property (copy) NSMutableArray *array;"></a>问题：@property (copy) NSMutableArray *array;</h2><h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><h2 id="Block为什么用copy"><a href="#Block为什么用copy" class="headerlink" title="Block为什么用copy"></a>Block为什么用copy</h2><h2 id="Block如何截获不同变量，代码分析"><a href="#Block如何截获不同变量，代码分析" class="headerlink" title="Block如何截获不同变量，代码分析"></a>Block如何截获不同变量，代码分析</h2><h2 id="Block本质数据结构"><a href="#Block本质数据结构" class="headerlink" title="Block本质数据结构"></a>Block本质数据结构</h2><h2 id="栈上的Block经过copy操作后发生哪些变化"><a href="#栈上的Block经过copy操作后发生哪些变化" class="headerlink" title="栈上的Block经过copy操作后发生哪些变化"></a>栈上的Block经过copy操作后发生哪些变化</h2><h2 id="block循环引用"><a href="#block循环引用" class="headerlink" title="block循环引用"></a>block循环引用</h2><h2 id="block原理"><a href="#block原理" class="headerlink" title="__block原理"></a>__block原理</h2><h2 id="strong原理"><a href="#strong原理" class="headerlink" title="__strong原理"></a>__strong原理</h2><h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop概念及数据结构、事件循环机制"><a href="#RunLoop概念及数据结构、事件循环机制" class="headerlink" title="RunLoop概念及数据结构、事件循环机制"></a>RunLoop概念及数据结构、事件循环机制</h2><h2 id="CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用"><a href="#CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用" class="headerlink" title="CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用"></a>CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用</h2><h2 id="RunLoop和NStimer"><a href="#RunLoop和NStimer" class="headerlink" title="RunLoop和NStimer"></a>RunLoop和NStimer</h2><h2 id="RunLoop和多线程"><a href="#RunLoop和多线程" class="headerlink" title="RunLoop和多线程"></a>RunLoop和多线程</h2><h2 id="如何实现一个常驻线程"><a href="#如何实现一个常驻线程" class="headerlink" title="如何实现一个常驻线程"></a>如何实现一个常驻线程</h2><h2 id="利用-runloop-解释一下页面的渲染的过程"><a href="#利用-runloop-解释一下页面的渲染的过程" class="headerlink" title="利用 runloop 解释一下页面的渲染的过程"></a>利用 runloop 解释一下页面的渲染的过程</h2><h2 id="你在开发过程中怎么使用RunLoop？什么应用场景？"><a href="#你在开发过程中怎么使用RunLoop？什么应用场景？" class="headerlink" title="你在开发过程中怎么使用RunLoop？什么应用场景？"></a>你在开发过程中怎么使用RunLoop？什么应用场景？</h2><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程与线程、并行-和-并发-区别"><a href="#进程与线程、并行-和-并发-区别" class="headerlink" title="进程与线程、并行 和 并发 区别"></a>进程与线程、并行 和 并发 区别</h2><h2 id="GCD、NSOperation、NSThread区别优缺点"><a href="#GCD、NSOperation、NSThread区别优缺点" class="headerlink" title="GCD、NSOperation、NSThread区别优缺点"></a>GCD、NSOperation、NSThread区别优缺点</h2><h2 id="performSelector-withObject-afterDelay-为什么在子线程无效"><a href="#performSelector-withObject-afterDelay-为什么在子线程无效" class="headerlink" title="performSelector:withObject:afterDelay:为什么在子线程无效"></a>performSelector:withObject:afterDelay:为什么在子线程无效</h2><h2 id="如何让多个网络请求完成后执行下一步"><a href="#如何让多个网络请求完成后执行下一步" class="headerlink" title="如何让多个网络请求完成后执行下一步"></a>如何让多个网络请求完成后执行下一步</h2><h2 id="多个网络请求顺序执行后执行下一步"><a href="#多个网络请求顺序执行后执行下一步" class="headerlink" title="多个网络请求顺序执行后执行下一步"></a>多个网络请求顺序执行后执行下一步</h2><h2 id="异步操作两组数据时-执行完第一组之后-才能执行第二组"><a href="#异步操作两组数据时-执行完第一组之后-才能执行第二组" class="headerlink" title="异步操作两组数据时, 执行完第一组之后, 才能执行第二组"></a>异步操作两组数据时, 执行完第一组之后, 才能执行第二组</h2><h2 id="你知道哪些锁、使用场景"><a href="#你知道哪些锁、使用场景" class="headerlink" title="你知道哪些锁、使用场景"></a>你知道哪些锁、使用场景</h2><h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><h2 id="CommonMode的特性"><a href="#CommonMode的特性" class="headerlink" title="CommonMode的特性"></a>CommonMode的特性</h2><h2 id="runloop与autoreleasepool的关系"><a href="#runloop与autoreleasepool的关系" class="headerlink" title="runloop与autoreleasepool的关系"></a>runloop与autoreleasepool的关系</h2><h2 id="GCD-在Runloop中的使用"><a href="#GCD-在Runloop中的使用" class="headerlink" title="GCD 在Runloop中的使用"></a>GCD 在Runloop中的使用</h2><h2 id="GCD-Global队列创建线程进行耗时操作的风险"><a href="#GCD-Global队列创建线程进行耗时操作的风险" class="headerlink" title="GCD Global队列创建线程进行耗时操作的风险"></a>GCD Global队列创建线程进行耗时操作的风险</h2><h2 id="CADispalyTimer和Timer哪个更精确"><a href="#CADispalyTimer和Timer哪个更精确" class="headerlink" title="CADispalyTimer和Timer哪个更精确"></a>CADispalyTimer和Timer哪个更精确</h2><h2 id="怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"><a href="#怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作" class="headerlink" title="怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"></a>怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作</h2><h2 id="分析线程同步串行、同步并行、异步串行、异步并行问题"><a href="#分析线程同步串行、同步并行、异步串行、异步并行问题" class="headerlink" title="分析线程同步串行、同步并行、异步串行、异步并行问题"></a>分析线程同步串行、同步并行、异步串行、异步并行问题</h2><h2 id="GCD执行原理、问题分析"><a href="#GCD执行原理、问题分析" class="headerlink" title="GCD执行原理、问题分析"></a>GCD执行原理、问题分析</h2><h2 id="dispatch-once如何实现一次性代码"><a href="#dispatch-once如何实现一次性代码" class="headerlink" title="dispatch_once如何实现一次性代码"></a>dispatch_once如何实现一次性代码</h2><h2 id="NSOperation数据结构"><a href="#NSOperation数据结构" class="headerlink" title="NSOperation数据结构"></a>NSOperation数据结构</h2><h2 id="重写NSOperation需要注意的点"><a href="#重写NSOperation需要注意的点" class="headerlink" title="重写NSOperation需要注意的点"></a>重写NSOperation需要注意的点</h2><h2 id="进程中的哪些空间是线程所共有的？"><a href="#进程中的哪些空间是线程所共有的？" class="headerlink" title="进程中的哪些空间是线程所共有的？"></a>进程中的哪些空间是线程所共有的？</h2><h2 id="使用GCD需要注意什么；"><a href="#使用GCD需要注意什么；" class="headerlink" title="使用GCD需要注意什么；"></a>使用GCD需要注意什么；</h2><h2 id="runloop跟runtime有没有关联"><a href="#runloop跟runtime有没有关联" class="headerlink" title="runloop跟runtime有没有关联"></a>runloop跟runtime有没有关联</h2><h2 id="CPU和GPU怎么相互合作的"><a href="#CPU和GPU怎么相互合作的" class="headerlink" title="CPU和GPU怎么相互合作的"></a>CPU和GPU怎么相互合作的</h2><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP请求方式有哪些"><a href="#HTTP请求方式有哪些" class="headerlink" title="HTTP请求方式有哪些"></a>HTTP请求方式有哪些</h2><h2 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h2><h2 id="HTTP三次握手，为什么需要三次"><a href="#HTTP三次握手，为什么需要三次" class="headerlink" title="HTTP三次握手，为什么需要三次"></a>HTTP三次握手，为什么需要三次</h2><h2 id="HTTP四次挥手，为什么需要四次"><a href="#HTTP四次挥手，为什么需要四次" class="headerlink" title="HTTP四次挥手，为什么需要四次"></a>HTTP四次挥手，为什么需要四次</h2><h2 id="为什么“握手”是三次，“挥手”却要四次？"><a href="#为什么“握手”是三次，“挥手”却要四次？" class="headerlink" title="为什么“握手”是三次，“挥手”却要四次？"></a>为什么“握手”是三次，“挥手”却要四次？</h2><h2 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL"></a>为什么客户端在TIME-WAIT阶段要等2MSL</h2><h2 id="HTTPS-TLS-SSL加密过程"><a href="#HTTPS-TLS-SSL加密过程" class="headerlink" title="HTTPS TLS/SSL加密过程"></a>HTTPS TLS/SSL加密过程</h2><h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><h2 id="中间人攻击（charles抓包原理）"><a href="#中间人攻击（charles抓包原理）" class="headerlink" title="中间人攻击（charles抓包原理）"></a>中间人攻击（charles抓包原理）</h2><h2 id="UDP协议及特点、"><a href="#UDP协议及特点、" class="headerlink" title="UDP协议及特点、"></a>UDP协议及特点、</h2><h2 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h2><h2 id="TCP特点及与UDP区别"><a href="#TCP特点及与UDP区别" class="headerlink" title="TCP特点及与UDP区别"></a>TCP特点及与UDP区别</h2><h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><h2 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h2><h2 id="Cookie机制及作用"><a href="#Cookie机制及作用" class="headerlink" title="Cookie机制及作用"></a>Cookie机制及作用</h2><h2 id="Session机制及作用"><a href="#Session机制及作用" class="headerlink" title="Session机制及作用"></a>Session机制及作用</h2><h2 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h2><h2 id="如何保证cookie的安全"><a href="#如何保证cookie的安全" class="headerlink" title="如何保证cookie的安全"></a>如何保证cookie的安全</h2><h2 id="HTTP请求头都有哪些内容"><a href="#HTTP请求头都有哪些内容" class="headerlink" title="HTTP请求头都有哪些内容"></a>HTTP请求头都有哪些内容</h2><h2 id="哪些加密算法"><a href="#哪些加密算法" class="headerlink" title="哪些加密算法"></a>哪些加密算法</h2><h2 id="TCP和UDP各自使用场景"><a href="#TCP和UDP各自使用场景" class="headerlink" title="TCP和UDP各自使用场景"></a>TCP和UDP各自使用场景</h2><h2 id="http为什么底层是tcp不是udp"><a href="#http为什么底层是tcp不是udp" class="headerlink" title="http为什么底层是tcp不是udp ?"></a>http为什么底层是tcp不是udp ?</h2><h2 id="socket异常断开时，设计一个合理的重连机制。"><a href="#socket异常断开时，设计一个合理的重连机制。" class="headerlink" title="socket异常断开时，设计一个合理的重连机制。"></a>socket异常断开时，设计一个合理的重连机制。</h2><h2 id="有了mac地址为什么要有ip地址"><a href="#有了mac地址为什么要有ip地址" class="headerlink" title="有了mac地址为什么要有ip地址"></a>有了mac地址为什么要有ip地址</h2><h2 id="断点续传怎么实现"><a href="#断点续传怎么实现" class="headerlink" title="断点续传怎么实现;"></a>断点续传怎么实现;</h2><h2 id="大型文件怎么下载并保存到本地；"><a href="#大型文件怎么下载并保存到本地；" class="headerlink" title="大型文件怎么下载并保存到本地；"></a>大型文件怎么下载并保存到本地；</h2><h2 id="xml和json的区别"><a href="#xml和json的区别" class="headerlink" title="xml和json的区别"></a>xml和json的区别</h2><h2 id="加密解密的技术讲解。"><a href="#加密解密的技术讲解。" class="headerlink" title="加密解密的技术讲解。"></a>加密解密的技术讲解。</h2><h2 id="reachability如何检测到网络状态变化？"><a href="#reachability如何检测到网络状态变化？" class="headerlink" title="reachability如何检测到网络状态变化？"></a>reachability如何检测到网络状态变化？</h2><h2 id="IP-地址用-int-保存和读取转化"><a href="#IP-地址用-int-保存和读取转化" class="headerlink" title="IP 地址用 int 保存和读取转化"></a>IP 地址用 int 保存和读取转化</h2><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h2 id="iOS有哪些常见的设计模式"><a href="#iOS有哪些常见的设计模式" class="headerlink" title="iOS有哪些常见的设计模式?"></a>iOS有哪些常见的设计模式?</h2><h2 id="单例优缺点"><a href="#单例优缺点" class="headerlink" title="单例优缺点"></a>单例优缺点</h2><h2 id="内存设计、磁盘设计、网络设计原则"><a href="#内存设计、磁盘设计、网络设计原则" class="headerlink" title="内存设计、磁盘设计、网络设计原则"></a>内存设计、磁盘设计、网络设计原则</h2><h2 id="MVP、MVVM模式思想"><a href="#MVP、MVVM模式思想" class="headerlink" title="MVP、MVVM模式思想"></a>MVP、MVVM模式思想</h2><h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><h2 id="AFNetworking-底层原理分析"><a href="#AFNetworking-底层原理分析" class="headerlink" title="AFNetworking 底层原理分析"></a>AFNetworking 底层原理分析</h2><h2 id="SDWebImage加载图片过程，图片缓存设计"><a href="#SDWebImage加载图片过程，图片缓存设计" class="headerlink" title="SDWebImage加载图片过程，图片缓存设计"></a>SDWebImage加载图片过程，图片缓存设计</h2><h2 id="YYKit"><a href="#YYKit" class="headerlink" title="YYKit"></a>YYKit</h2><h2 id="组建化优缺点"><a href="#组建化优缺点" class="headerlink" title="组建化优缺点"></a>组建化优缺点</h2><h2 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h2><h2 id="为什么要做组件化"><a href="#为什么要做组件化" class="headerlink" title="为什么要做组件化"></a>为什么要做组件化</h2><h2 id="你认为组件化的一些收益"><a href="#你认为组件化的一些收益" class="headerlink" title="你认为组件化的一些收益"></a>你认为组件化的一些收益</h2><h2 id="redux-单向数据流是怎么产生的-描述下"><a href="#redux-单向数据流是怎么产生的-描述下" class="headerlink" title="redux 单向数据流是怎么产生的 描述下"></a>redux 单向数据流是怎么产生的 描述下</h2><h2 id="Charts框架底层实现；"><a href="#Charts框架底层实现；" class="headerlink" title="Charts框架底层实现；"></a>Charts框架底层实现；</h2><h2 id="画出项目的结构图。"><a href="#画出项目的结构图。" class="headerlink" title="画出项目的结构图。"></a>画出项目的结构图。</h2><h2 id="yyModel的逻辑"><a href="#yyModel的逻辑" class="headerlink" title="yyModel的逻辑"></a>yyModel的逻辑</h2><h2 id="解耦的方式"><a href="#解耦的方式" class="headerlink" title="解耦的方式"></a>解耦的方式</h2><h2 id="项目中用的技术以及实现；"><a href="#项目中用的技术以及实现；" class="headerlink" title="项目中用的技术以及实现；"></a>项目中用的技术以及实现；</h2><h2 id="就是项目中遇到的问题以及解决方式；"><a href="#就是项目中遇到的问题以及解决方式；" class="headerlink" title="就是项目中遇到的问题以及解决方式；"></a>就是项目中遇到的问题以及解决方式；</h2><h2 id="缓存机制是怎么清除数据的？"><a href="#缓存机制是怎么清除数据的？" class="headerlink" title="缓存机制是怎么清除数据的？"></a>缓存机制是怎么清除数据的？</h2><h2 id="如何进行安全测试；"><a href="#如何进行安全测试；" class="headerlink" title="如何进行安全测试；"></a>如何进行安全测试；</h2><h2 id="涂鸦怎么实现；"><a href="#涂鸦怎么实现；" class="headerlink" title="涂鸦怎么实现；"></a>涂鸦怎么实现；</h2><h2 id="实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；"><a href="#实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；" class="headerlink" title="实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；"></a>实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；</h2><h2 id="说下生产者-消费者模型，其中的同步机制是怎么样的"><a href="#说下生产者-消费者模型，其中的同步机制是怎么样的" class="headerlink" title="说下生产者-消费者模型，其中的同步机制是怎么样的"></a>说下生产者-消费者模型，其中的同步机制是怎么样的</h2><h1 id="开发日常"><a href="#开发日常" class="headerlink" title="开发日常"></a>开发日常</h1><h2 id="APP启动时间应从哪些方面优化？"><a href="#APP启动时间应从哪些方面优化？" class="headerlink" title="APP启动时间应从哪些方面优化？"></a>APP启动时间应从哪些方面优化？</h2><h2 id="如何降低APP包的大小"><a href="#如何降低APP包的大小" class="headerlink" title="如何降低APP包的大小"></a>如何降低APP包的大小</h2><h2 id="如何检测离屏渲染与优化"><a href="#如何检测离屏渲染与优化" class="headerlink" title="如何检测离屏渲染与优化"></a>如何检测离屏渲染与优化</h2><h2 id="怎么检测图层混合"><a href="#怎么检测图层混合" class="headerlink" title="怎么检测图层混合"></a>怎么检测图层混合</h2><h2 id="UILabel图层混合"><a href="#UILabel图层混合" class="headerlink" title="UILabel图层混合"></a>UILabel图层混合</h2><h2 id="日常如何检查内存泄露？"><a href="#日常如何检查内存泄露？" class="headerlink" title="日常如何检查内存泄露？"></a>日常如何检查内存泄露？</h2><h2 id="LLDB常用的调试命令？"><a href="#LLDB常用的调试命令？" class="headerlink" title="LLDB常用的调试命令？"></a>LLDB常用的调试命令？</h2><h2 id="iOS-常见的崩溃类型有哪些？"><a href="#iOS-常见的崩溃类型有哪些？" class="headerlink" title="iOS 常见的崩溃类型有哪些？"></a>iOS 常见的崩溃类型有哪些？</h2><h2 id="iOS-App-稳定性指标及监测"><a href="#iOS-App-稳定性指标及监测" class="headerlink" title="iOS App 稳定性指标及监测"></a>iOS App 稳定性指标及监测</h2><h2 id="cocoapods-常见问题"><a href="#cocoapods-常见问题" class="headerlink" title="cocoapods 常见问题"></a>cocoapods 常见问题</h2><h2 id="iOS的签名机制是怎么样的"><a href="#iOS的签名机制是怎么样的" class="headerlink" title="iOS的签名机制是怎么样的"></a>iOS的签名机制是怎么样的</h2><h2 id="instruments它为什么能检测内存泄漏"><a href="#instruments它为什么能检测内存泄漏" class="headerlink" title="instruments它为什么能检测内存泄漏"></a>instruments它为什么能检测内存泄漏</h2><h2 id="推送的原理"><a href="#推送的原理" class="headerlink" title="推送的原理"></a>推送的原理</h2><h2 id="项目上线被拒原因"><a href="#项目上线被拒原因" class="headerlink" title="项目上线被拒原因"></a>项目上线被拒原因</h2><h2 id="项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线"><a href="#项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线" class="headerlink" title="项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线"></a>项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线</h2><h2 id="iPhone自带的AssistiveTouch你如何实现"><a href="#iPhone自带的AssistiveTouch你如何实现" class="headerlink" title="iPhone自带的AssistiveTouch你如何实现"></a>iPhone自带的AssistiveTouch你如何实现</h2><h2 id="有了解过代码如何编译的嘛"><a href="#有了解过代码如何编译的嘛" class="headerlink" title="有了解过代码如何编译的嘛"></a>有了解过代码如何编译的嘛</h2><h2 id="编译好的目标文件有data-和text段他们两者有啥区别"><a href="#编译好的目标文件有data-和text段他们两者有啥区别" class="headerlink" title="编译好的目标文件有data 和text段他们两者有啥区别"></a>编译好的目标文件有data 和text段他们两者有啥区别</h2><h2 id="appstore上架流程"><a href="#appstore上架流程" class="headerlink" title="appstore上架流程"></a>appstore上架流程</h2><h2 id="一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ"><a href="#一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ" class="headerlink" title="一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ;"></a>一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ;</h2><h2 id="针对线上版本的崩溃处理；"><a href="#针对线上版本的崩溃处理；" class="headerlink" title="针对线上版本的崩溃处理；"></a>针对线上版本的崩溃处理；</h2><h2 id="Xcode构建过程；"><a href="#Xcode构建过程；" class="headerlink" title="Xcode构建过程；"></a>Xcode构建过程；</h2><h2 id="js和Oc交互以及区别；"><a href="#js和Oc交互以及区别；" class="headerlink" title="js和Oc交互以及区别；"></a>js和Oc交互以及区别；</h2><h2 id="pod-install和pod-update有什么区别？"><a href="#pod-install和pod-update有什么区别？" class="headerlink" title="pod install和pod update有什么区别？"></a>pod install和pod update有什么区别？</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift137%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift137%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">其他问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:42" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:42+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36747738/article/details/106537874">https://blog.csdn.net/qq_36747738/article/details/106537874</a></p>
<h2 id="共用体方法查找"><a href="#共用体方法查找" class="headerlink" title="共用体方法查找"></a>共用体方法查找</h2><pre><code>公用体
位运算，|，&amp;
encding :编码
方法缓存（散列表）
key IMP
seleter &amp;  _mask 就是数据在索引中位置   或者求%
如果找到相同的key不同，就是i - 1或者+1
</code></pre>
<h2 id="msgSend如何查找"><a href="#msgSend如何查找" class="headerlink" title="msgSend如何查找"></a>msgSend如何查找</h2><pre><code>SEL  key;       //方法名称
IMP imp;       //方法的实现，imp是一个函数指针类型
msgSend
// objc_msgSend(person, sel_registerName(&quot;test&quot;));
search_method_list // 排序的（二分查找），线性的、填充缓存
lookUpImpOrForward
cache_getImp
getMethodNoSuper_nolock
cache_fill
</code></pre>
<h2 id="msgSend参数都有哪些；"><a href="#msgSend参数都有哪些；" class="headerlink" title="msgSend参数都有哪些；"></a>msgSend参数都有哪些；</h2><pre><code>第一个参数：消息接受的对象实例
第二个参数：执行的方法
</code></pre>
<h2 id="class方法相关"><a href="#class方法相关" class="headerlink" title="class方法相关"></a>class方法相关</h2><pre><code>class在nsobject中实现，谁调用返回的就是谁
isKaidof[NSObect class] 无论谁调用都分会yes
print能调用成功是应为通过对象找到的就是 isa
</code></pre>
<h1 id="UI相关"><a href="#UI相关" class="headerlink" title="UI相关"></a>UI相关</h1><h2 id="tableViewCell的自适应如何实现，如何保证性能"><a href="#tableViewCell的自适应如何实现，如何保证性能" class="headerlink" title="tableViewCell的自适应如何实现，如何保证性能"></a>tableViewCell的自适应如何实现，如何保证性能</h2><pre><code>提前计算好每个cell的高度，保存在一个frameModel中，每次从frameModel中取
</code></pre>
<h2 id="转场动画相关操作"><a href="#转场动画相关操作" class="headerlink" title="转场动画相关操作"></a>转场动画相关操作</h2><pre><code>前面提到转场的本质是下一个场景的视图替换当前场景的视图，从当前场景过渡下一个场景。下面称即将消失的
场景的视图为 fromView，对应的视图控制器为 fromVC，即将出现的视图为 toView，对应的视图控制器称之为 toVC。
交互控制器(Interaction Controller)
转场环境(Transition Context)
转场协调器(Transition Coordinator)
</code></pre>
<h2 id="绘图相关知识-coreGraphics框架的使用"><a href="#绘图相关知识-coreGraphics框架的使用" class="headerlink" title="绘图相关知识(coreGraphics框架的使用)"></a>绘图相关知识(coreGraphics框架的使用)</h2><pre><code>绘图周期
iOS在运行循环中会整合所有的绘图请求，并一次将它们绘制出来
不能在子线程中绘制，也不能进行复杂的操作，否则会造成主线程卡顿
视图绘制
调用UIView的drawRect:方法进行绘制。如果调用一个视图的setNeedsDisplay方法
，那么该视图就被标记为重新绘制，并且会在下一次绘制周期中重新绘制，自动调用drawRect:方法。
视图布局
调用UIView的layoutSubviews方法。如果调用一个视图的setNeedsLayout方法，
那么该视图就被标记为需要重新布局，UIKit会自动调用layoutSubviews
方法及其子视图的layoutSubviews方法。
在绘图时，我们应该尽量多使用布局，少使用绘制，是因为布局使用的是GPU，而
绘制使用的是CPU。GPU对于图形处理有优势，而CPU要处理的事情较多，且不擅长
处理图形，所以尽量使用GPU来处理图形。

绘图原理
context：imageContext：图片上下文，
CGPathRef / UIBezierPath图形的绘制需要绘制一个路径
</code></pre>
<h2 id="view的生命周期"><a href="#view的生命周期" class="headerlink" title="view的生命周期"></a>view的生命周期</h2><pre><code>1).initWithCoder
2).awakeFromNib: 此时frameh还没有完成。
2.手写代码：
1.initWithCoder
initWithFrame
view采用懒加载的方式，只有用到view时才会被创建，即才会被调用
loadView-&gt;viewDidLoad这一系列函数，控制器的View
是延迟加载的: 创建控制器并不一定会创建控制器的view,等用到时再加载。
</code></pre>
<h2 id="系统UIView更新机制的思想"><a href="#系统UIView更新机制的思想" class="headerlink" title="系统UIView更新机制的思想"></a>系统UIView更新机制的思想</h2><pre><code>UIView提供了layoutSubViews方法来处理。
需要注意的时layoutSubViews方法由系统来调用，不能程序员来调用。
可以调用setNeedsLayout方法进行标记,以保证在UI下个刷屏系统中会调用layoutSubviews。
或者layoutIfNedded直接请求系统调用layoutIfNeeded直接请求系统调用layoutSubviews。
layoutSubViews的被调用时机:
1.addSubView会触发layoutSubviews,比如ivewA add ViewB，
第一次添加A和B的layoutSubviews都会被调用，而第二次( viewA 已经有了viewB)只调用viewB的。
2.view的frame改变会触发layoutSubViews。
3.滚动一个UIScrollView会触发layoutSubviews。
4.旋转Screen会触发UIView的layoutSubviews。
5.改变transform属性时，当然frame也会变。
6.处于key window的UIView才会被调用( 程序同一时间只有一个window为keyWindow，
可以简单理解为显示在最前面的window的keywindow)
</code></pre>
<h2 id="drawRect常用作用"><a href="#drawRect常用作用" class="headerlink" title="drawRect常用作用"></a>drawRect常用作用</h2><pre><code>实际需求：1、在当前画板上画图像，曲线、虚线、几何图形、写字等等。

2、UITextView添加自定义placeholder的需求中，将holder的label添加在写drawRect内，设置holder字符串时调用setNeedsDisplay重绘UITextView。
</code></pre>
<h2 id="layoutSubView和drawRect的调用时机；"><a href="#layoutSubView和drawRect的调用时机；" class="headerlink" title="layoutSubView和drawRect的调用时机；"></a>layoutSubView和drawRect的调用时机；</h2><h2 id="用UIView实现Scrollview。"><a href="#用UIView实现Scrollview。" class="headerlink" title="用UIView实现Scrollview。"></a>用UIView实现Scrollview。</h2><pre><code>而子视图的frame正是基于父视图的坐标系，当我们更改父视图bounds中origin的
时候子视图的位置就发生了变化，这就是实现scrollView的关键点！！！
通过contentSize限制scrollView的内部空间，实现代码如下
</code></pre>
<h2 id="轮播图的实现"><a href="#轮播图的实现" class="headerlink" title="轮播图的实现"></a>轮播图的实现</h2><pre><code>基于collectionView进行的封装（推荐）
基于scrollView的无限轮播（首尾各多创建一个展示图片的ImageView）
同样是基于scrollView的无限轮播（总共就创建三个ImageView）
（答定时器，标志位判断，代理方法）
</code></pre>
<h2 id="CGSize-intrinsicContentSize-是干什么用的？"><a href="#CGSize-intrinsicContentSize-是干什么用的？" class="headerlink" title="-(CGSize)intrinsicContentSize:是干什么用的？"></a>-(CGSize)intrinsicContentSize:是干什么用的？</h2><pre><code>属性来获取内置大小
答：固有大小。顾名思义，在AutoLayout中，它作为UIView的属性（不是语法上的属性），
意思就是说我知道自己的大小，如果你没有为我指定大小，我就按照这个大小来。
</code></pre>
<h2 id="渲染UI为什么要在主线程？"><a href="#渲染UI为什么要在主线程？" class="headerlink" title="渲染UI为什么要在主线程？"></a>渲染UI为什么要在主线程？</h2><pre><code>因为UIKit框架不是线程安全的，所以涉及多个线程同时对UI进行操作会造成什么影响、
问题、错误，这里就不再赘述。那么，就有人会问为什么不把UIKit框架设置为线程安全呢？
因为线程安全需要加锁，我们都知道加锁就会消耗性能，影响处理速度，影响渲染速度，
我们通常自己在写@property时都会写nonatomic来追求高性能高效率。
而UI又是最追求速度流畅，体验无顿挫感的，给UI加锁是不可能的，这辈子都不可能的，
想要UI极度流畅，但线程安全又得不到保障，怎么办呢？
</code></pre>
<h2 id="如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？"><a href="#如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？" class="headerlink" title="如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？"></a>如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？</h2><pre><code>（答一般block里面回调的话，数据还是会回来的。但是，如果控制器销毁了的话，self置为nil，对nil的操作一般也是安全的，就是浪费了流量。）；
</code></pre>
<h2 id="scrollview与消息响应链冲突？"><a href="#scrollview与消息响应链冲突？" class="headerlink" title="scrollview与消息响应链冲突？"></a>scrollview与消息响应链冲突？</h2><pre><code>1、设置是否延时传递给内部组件
self.delaysContentTouches = NO;
设置返回值为YES
-(BOOL)touchesShouldCancelInContentView:(UIView *)view
&#123;
    [super touchesShouldCancelInContentView:view];
    return YES;
&#125;
同时识别多个手势
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
自定义手势
</code></pre>
<h2 id="Core-Graphics的更底层的是什么；"><a href="#Core-Graphics的更底层的是什么；" class="headerlink" title="Core Graphics的更底层的是什么；"></a>Core Graphics的更底层的是什么；</h2><pre><code>　1）获取上下文
　2）绘制路径
　3）添加路径到上下文
　4）修改图形状态参数
　5）渲染上下文
　CGContextRef、CGPathRef、UIBezierPath
</code></pre>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><pre><code>指针指对象的地址，引用是对象的引用计数
指针调用和函数调用
原因：调用函数的时候，由于runtime机制，通过方法objc_msgSend() 把函数的调用对象和方法名发送出去
根据对象名找到对象类存储的函数函数列表MethordList,再根据方法名找到MethordList 中的函数指针method_imp，再根据函数指针调用响应函数
</code></pre>
<h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><pre><code>内存泄漏（memory leak）：是指申请的内存空间使用完毕之后未回收。
一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，
最终导致程序crash。（因此，开发中我们要尽量避免内存泄漏的出现）
内存溢出（out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用。
通俗理解就是内存不够用了，通常在运行大型应用或游戏时，应用或游戏所需要
的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。最终导致机器重启或者程序crash。
第一种：静态分析方法（Analyze）
第二种：动态分析方法（Instrument工具库里的Leaks）。一般推荐使用第二种。
</code></pre>
<h2 id="什么是虚拟内存、共享内存、物理内存"><a href="#什么是虚拟内存、共享内存、物理内存" class="headerlink" title="什么是虚拟内存、共享内存、物理内存"></a>什么是虚拟内存、共享内存、物理内存</h2><pre><code>物理内存就是实打实的存放数据的硬件，
虚拟内存是在物理内存上的一层与具体硬件无关的抽象
共享内存：进程在运行过程中，会加载许多操作系统的动态库，比如 libc.so、libld.so等。
这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。
</code></pre>
<h2 id="举例一些I-O操作的例子"><a href="#举例一些I-O操作的例子" class="headerlink" title="举例一些I/O操作的例子"></a>举例一些I/O操作的例子</h2><pre><code>1）阻塞IO
2）非阻塞IO
3）IO复用（select和poll）
4）信号驱动IO（sigio）
5）异步IO（aio_）
</code></pre>
<h2 id="如何开辟一块内存；"><a href="#如何开辟一块内存；" class="headerlink" title="如何开辟一块内存；"></a>如何开辟一块内存；</h2><pre><code>其实结论就是 实际分配内存是按照16字节对齐的 内存大小都是16 的倍数。
</code></pre>
<h2 id="什么时候深复制，什么时候浅复制；"><a href="#什么时候深复制，什么时候浅复制；" class="headerlink" title="什么时候深复制，什么时候浅复制；"></a>什么时候深复制，什么时候浅复制；</h2><pre><code>string 是拷贝的（指针）
copy是内容的复制。
不可变对象用浅复制。
可变对象用深复制
自定义对象的copy我们要实现NSCoding协议
</code></pre>
<h2 id="怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手"><a href="#怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手" class="headerlink" title="怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手"></a>怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手</h2><pre><code>（答 检查是否有野指针,检查是否有循环引用,优化数组存取等）；
复用机制
少使用xib
不要阻塞线程
图片优化
合理使用数组字典优化查找速度
懒加载
缓存
一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。可以用单例来处理，避免日期格式转换
选择正确的数据格式，json、xml、二进制数据流
少使用webView
优化tableView
选择正确的数据持久化
</code></pre>
<h2 id="问堆和栈的区别。"><a href="#问堆和栈的区别。" class="headerlink" title="问堆和栈的区别。"></a>问堆和栈的区别。</h2><pre><code>（答对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。）
</code></pre>
<h2 id="Block的创建，何时被释放。"><a href="#Block的创建，何时被释放。" class="headerlink" title="Block的创建，何时被释放。"></a>Block的创建，何时被释放。</h2><pre><code>（答Block在栈区创建，用copy从栈区拷贝到堆区保证安全，由系统回收，何时回收）；
如果没有其他对象强引用，block执行完毕就会被释
</code></pre>
<h2 id="dynamic的应用场景？"><a href="#dynamic的应用场景？" class="headerlink" title="@dynamic的应用场景？"></a>@dynamic的应用场景？</h2><pre><code>@dynamic 就是要来告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会
在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译。其主要的作用就是
用在NSManageObject对象的属性声明上，由于此类对象的属性一般是从Core Data
的属性中生成的，Core Data框架会在程序运行的时候为此类属性生成getter和Setter方法。
</code></pre>
<h2 id="问题：-property-copy-NSMutableArray-array"><a href="#问题：-property-copy-NSMutableArray-array" class="headerlink" title="问题：@property (copy) NSMutableArray *array;"></a>问题：@property (copy) NSMutableArray *array;</h2><pre><code>答1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩
溃.因为copy就是复制一个不可变NSArray的对象；
2、使用了atomic属性会影响性能。
</code></pre>
<h1 id="OC语言相关"><a href="#OC语言相关" class="headerlink" title="OC语言相关"></a>OC语言相关</h1><h2 id="blcok，NSNotification，delegate，Observer比较"><a href="#blcok，NSNotification，delegate，Observer比较" class="headerlink" title="blcok，NSNotification，delegate，Observer比较"></a>blcok，NSNotification，delegate，Observer比较</h2><pre><code>代理是一种回调机制，且是一对一的关系，通知是一对多的关系，一个对向所有的观察者提供变更通知；
效率：Delegate比NSNOtification高；
Delegate和Block一般是一对一的通信；
Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信；
Block：Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate；
</code></pre>
<h2 id="const-extern-static-用法区别"><a href="#const-extern-static-用法区别" class="headerlink" title="const extern static 用法区别"></a>const extern static 用法区别</h2><pre><code>只要使用static修改局部变量之后, 当执行到定义局部变量的代码就会
分配存储空间, 但是只有程序结束才会释放该存储空间
extern：此变量/函数是在别处定义的，要在此处引用
</code></pre>
<h2 id="写一个宏定义函数，实现返回三个数中最大的"><a href="#写一个宏定义函数，实现返回三个数中最大的" class="headerlink" title="写一个宏定义函数，实现返回三个数中最大的"></a>写一个宏定义函数，实现返回三个数中最大的</h2><pre><code>#define MAX(a,b,c) (a&gt;b?(a&gt;c?a:c):(b&gt;c?b:c))
</code></pre>
<h2 id="static和extern的访问范围，用extern的情况下什么时候程序会报错"><a href="#static和extern的访问范围，用extern的情况下什么时候程序会报错" class="headerlink" title="static和extern的访问范围，用extern的情况下什么时候程序会报错"></a>static和extern的访问范围，用extern的情况下什么时候程序会报错</h2><pre><code>静态变量用static修饰，其目的是声明一个变量只能被此文件里的函数享有。因而它的主要工作就是防止变量被外部函数使用
extern存储类型的目的却是允许几个源文件可以共享同一个变量
编译器当然不会答应他俩修饰同一个变量。
</code></pre>
<h2 id="inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？"><a href="#inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？" class="headerlink" title="inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？"></a>inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？</h2><pre><code>避免了频繁调用函数对栈内存重复开辟所带来的消耗
inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，
它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。
</code></pre>
<h2 id="OC里的基本数据类型如数组字典等的数据结构是怎样的；"><a href="#OC里的基本数据类型如数组字典等的数据结构是怎样的；" class="headerlink" title="OC里的基本数据类型如数组字典等的数据结构是怎样的；"></a>OC里的基本数据类型如数组字典等的数据结构是怎样的；</h2><pre><code>数组字典都是使用工厂方法创建的，根据不同数据，生成类不同
字典本质上是一个hash表，根据字典的key进行哈希取位置
开放定址法的结构通常允许在通列表的数量达到了某个阈值，通常是通列表长度的80%使用量
时，对通列表进行一次扩充grow，然后重新计算数据的keyHash放入新桶中
但是不断扩容的空间就是其弊端，因此开放地址法最好存储的是临时需要，尽快释放的资源
例如字典参数和associated object，拉链法就保证了资源的可控性，像这种@synchronized
锁就可以根据地址拉链出一条对应的使用线程即可，随时使用。
正如你会猜测的，__NSArrayM 用了环形缓冲区 (circular buffer)。这个数据结构相当简单，
只是比常规数组或缓冲区复杂点。环形缓冲区的内容能在到达任意一端时绕向另一端。
环形缓冲区有一些非常酷的属性。尤其是，除非缓冲区满了，否则在任意一端插入
或删除均不会要求移动任何内存。我们来分析这个类如何充分利用环形缓冲区来使得自身比 C
数组强大得多。在任意一端插入或者删除，只是修改offset参数，不需要移动内存，我们访问的时
候只是不和普通的数组一样index多少就是多少，这里会计算加上offset之后处理的值取数据，而不
是插入头和尾巴的时候，环形结构会根据最少移动内存指针的方式插入，例如要在A和B之间插入，按照
C的数组，我们需要把B到E的元素移动内存，但是环形缓冲区的设计，我们只要把A的值向前移动一
个单位内存，即可，同时修改offset偏移量，就能保证最小的移动单元来完成中间插入
可以看到插入头尾只是修改offset指针而已，如果插入数据到达阀值，一样需要扩容。
往中部插入对象有非常相似的结果。合理的解释就是，__NSArrayM 试着去最
小化内存的移动，因此会移动最少的一边元素。
</code></pre>
<h2 id="sychronized实现原理"><a href="#sychronized实现原理" class="headerlink" title="sychronized实现原理"></a>sychronized实现原理</h2><pre><code>你调用 sychronized 的每个对象，Objective-C runtime 都会为其分配一个递归锁并存储在哈希表中。
如果在 sychronized 内部对象被释放或被设为 nil 看起来都 OK。不过这没在文档中说明，所以我不会再生产代码中依赖这条。
注意不要向你的 sychronized block 传入 nil！这将会从代码中移走线程安全。
你可以通过在 objc_sync_nil 上加断点来查看是否发生了这样的事情。
</code></pre>
<h2 id="问NSTimer的底层实现原理"><a href="#问NSTimer的底层实现原理" class="headerlink" title="问NSTimer的底层实现原理"></a>问NSTimer的底层实现原理</h2><pre><code>NSTimer可以选择是否重复执行，为了保证NSTimer调用的方法中传递的
对象生命周期，NSTimer会对外界传递的对象进行一次retain。
进行invalidate，NSTimer才会消失，这时Object对象也就会释放了
NSTimer会默认为我们添加到Runloop的NSDefaultRunLoopMode中，而
且由于是在主线程中，所以Runloop是开启的，不需要我们手动打开
</code></pre>
<h2 id="block中为什么要用Strong类型的引用来保持self；"><a href="#block中为什么要用Strong类型的引用来保持self；" class="headerlink" title="block中为什么要用Strong类型的引用来保持self；"></a>block中为什么要用Strong类型的引用来保持self；</h2><pre><code>确保strongSelf在block中不会被释放。
</code></pre>
<h2 id="问-ifdef-cplusplus-extern-“C-“"><a href="#问-ifdef-cplusplus-extern-“C-“" class="headerlink" title="问#ifdef __cplusplus extern “C “"></a>问#ifdef __cplusplus extern “C “</h2><pre><code>&#123; #endif………… …………#ifdef __cplusplus &#125; #endif这段代码为什么总是会出现
答：编译器判断是否支持c++，涉及到c++命名问题，如果是c++编译器，要加上extern &quot;C&quot;
</code></pre>
<h2 id="说下ASCII和unicode的区别utf-8的优势"><a href="#说下ASCII和unicode的区别utf-8的优势" class="headerlink" title="说下ASCII和unicode的区别utf-8的优势"></a>说下ASCII和unicode的区别utf-8的优势</h2><pre><code>ASCII 码一共规定了128个字符的编码
Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号
UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节
表示一个符号，根据不同的符号而变化字节长度。
</code></pre>
<h2 id="iOS-launchwith-options-返回no有什么作用；"><a href="#iOS-launchwith-options-返回no有什么作用；" class="headerlink" title="iOS launchwith options 返回no有什么作用；"></a>iOS launchwith options 返回no有什么作用；</h2><pre><code> application:openURL:options: 方法是否执行
 当 return YES 时执行，return NO 时不执行
</code></pre>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="CommonMode的特性"><a href="#CommonMode的特性" class="headerlink" title="CommonMode的特性"></a>CommonMode的特性</h2><pre><code>1. 首先runloop对象到自己的common modes里面拿出被标记的运行模式commonModes.
2. 匹配commonModes和modes-&gt;model-&gt;name.
3. 匹配成功的模式，将timer加入到对应model-&gt;timers里面.
4. source, observer同timer.
</code></pre>
<h2 id="runloop与autoreleasepool的关系"><a href="#runloop与autoreleasepool的关系" class="headerlink" title="runloop与autoreleasepool的关系"></a>runloop与autoreleasepool的关系</h2><pre><code>(AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组成)
AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），
除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址
iOS里的TaggedPointer不适用autorelesepool
AutoreleasePool 在 runloop 在开始时被push，在runloop休眠时(beforewaiting状态)pop
</code></pre>
<h2 id="GCD-在Runloop中的使用"><a href="#GCD-在Runloop中的使用" class="headerlink" title="GCD 在Runloop中的使用"></a>GCD 在Runloop中的使用</h2><pre><code>GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。
</code></pre>
<h2 id="GCD-Global队列创建线程进行耗时操作的风险"><a href="#GCD-Global队列创建线程进行耗时操作的风险" class="headerlink" title="GCD Global队列创建线程进行耗时操作的风险"></a>GCD Global队列创建线程进行耗时操作的风险</h2><pre><code>dispatch_async 函数分发到全局队列不一定会新建线程执行任务，全局队列底层有一个的线程池，如果线程池满了，
那么后续的任务会被 block 住，等待前面的任务执行完成，才会继续执行。如果线程池中的线程
长时间不结束，后续堆积的任务会越来越多，此时就会存在 APP crash的风险。
避免使用 GCD Global 队列创建 Runloop 常驻线程
</code></pre>
<h2 id="CADispalyTimer和Timer哪个更精确"><a href="#CADispalyTimer和Timer哪个更精确" class="headerlink" title="CADispalyTimer和Timer哪个更精确"></a>CADispalyTimer和Timer哪个更精确</h2><pre><code>CADisplayLink 更精确
iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。
CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视
频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可
以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的
好处就是我们不需要在格外关心屏幕的刷新
频率了，因为它本身就是跟屏幕刷新同步的。
</code></pre>
<h2 id="怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"><a href="#怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作" class="headerlink" title="怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"></a>怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作</h2><pre><code>我们就可以将更新UI事件放在主线程的NSDefaultRunLoopMode上执行即可，这样
就会等用户不再滑动页面，主线程RunLoop由UITrackingRunLoopMode切
换到NSDefaultRunLoopMode时再去更新UI
</code></pre>
<h2 id="分析线程同步串行、同步并行、异步串行、异步并行问题"><a href="#分析线程同步串行、同步并行、异步串行、异步并行问题" class="headerlink" title="分析线程同步串行、同步并行、异步串行、异步并行问题"></a>分析线程同步串行、同步并行、异步串行、异步并行问题</h2><h2 id="GCD执行原理、问题分析"><a href="#GCD执行原理、问题分析" class="headerlink" title="GCD执行原理、问题分析"></a>GCD执行原理、问题分析</h2><pre><code>GCD底层有一个线程池，这个线程池存放的是一个个的线程，这个线程池中
的线程可以重用，当一段时间这个线程没有被调用就会被销毁，
开辟多少线程不是由同步异步决定的而是底层线程池决定的，线程池是系统维护，
</code></pre>
<h2 id="dispatch-once如何实现一次性代码"><a href="#dispatch-once如何实现一次性代码" class="headerlink" title="dispatch_once如何实现一次性代码"></a>dispatch_once如何实现一次性代码</h2><pre><code>定义一个dispatch_once_t(其实也就是整型)静态变量，
意义：作为标识下面dispatch_once的block是否已执行过。
 static修饰会默认将其初始化为0，当值为0时才会执行block。
 当block执行完成，底层会将onceToken设置为1，这也就是为什
 么要传onceToken的地址（static修饰的变量可以通过地址修改
 onceToken的值），同时底层会加锁来保证这个方法是线程安全的
</code></pre>
<h2 id="NSOperation数据结构"><a href="#NSOperation数据结构" class="headerlink" title="NSOperation数据结构"></a>NSOperation数据结构</h2><pre><code>addDependency操作依赖性
KVO 兼容属性
cancelAllOperations 响应取消命令
start;执行操作
NSBlockOperation：用于管理一个或多个block的并发执行。
NSInvocationOperation：NSInvocationOperation类是NSOperation的一个具体
子类，用于开启一个操作，该操作包括在指定对象上调用一个selector。
</code></pre>
<h2 id="重写NSOperation需要注意的点"><a href="#重写NSOperation需要注意的点" class="headerlink" title="重写NSOperation需要注意的点"></a>重写NSOperation需要注意的点</h2><pre><code>1、如果需要自定义并发执行的 Operation，必须重写start、main、isExecuting、isFinished、isAsynchronous方法。
2、在 operation 的 main 方法里面，必须提供 autorelease pool,因为你的 operation 完成后需要销毁。
3、一旦你的 operation 开始了，必须通过 KVO，告诉所有的监听者，现在该operation的执行状态。
4、调用时，如果需要并发执行 Operation，必须调用performOperation:方法，当然，也可以改为自定义其他方法或者直接在start方法添加多线程调用。
5、对于自定义的 Operation 类，如果不需要并发执行，可以直接调用start
</code></pre>
<h2 id="进程中的哪些空间是线程所共有的？"><a href="#进程中的哪些空间是线程所共有的？" class="headerlink" title="进程中的哪些空间是线程所共有的？"></a>进程中的哪些空间是线程所共有的？</h2><pre><code>一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)
</code></pre>
<h2 id="使用GCD需要注意什么；"><a href="#使用GCD需要注意什么；" class="headerlink" title="使用GCD需要注意什么；"></a>使用GCD需要注意什么；</h2><pre><code>dispatch_sync同步死锁（循环等待）
重复的获取互斥资源引发的等待（加锁）
开启过多线程
线程和RunLoop，子线程不会开启runloop
</code></pre>
<h2 id="runloop跟runtime有没有关联"><a href="#runloop跟runtime有没有关联" class="headerlink" title="runloop跟runtime有没有关联"></a>runloop跟runtime有没有关联</h2><pre><code>个人想到的是autoreleasepool、其他的不好找
runloop中事件源都是由运行时runtime触发
</code></pre>
<h2 id="CPU和GPU怎么相互合作的"><a href="#CPU和GPU怎么相互合作的" class="headerlink" title="CPU和GPU怎么相互合作的"></a>CPU和GPU怎么相互合作的</h2><pre><code>命令缓冲区包含了一个命令队列，由CPU向其中添加命令，而由GPU从中读取命令
，添加和读取的过程是互相独立的。命令缓冲区使得CPU和GPU可以互相独立工作
。当CPU需要渲染一些对象时，它可以向命令缓冲区中添加命令，而当GPU完成了上
一次的渲染任务后，它就可以从命令队列中再取出一个命令并执行它。
</code></pre>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP请求头都有哪些内容"><a href="#HTTP请求头都有哪些内容" class="headerlink" title="HTTP请求头都有哪些内容"></a>HTTP请求头都有哪些内容</h2><pre><code>Accept: */*(客户端能接收的资源类型) 
Accept-Language: en-us(客户端接收的语言类型) 
Connection: Keep-Alive(维护客户端和服务端的连接关系) 
Host: localhost:8080(连接的目标主机和端口号) 
Referer: http://localhost/links.asp(告诉服务器我来自于哪里) 
User-Agent: Mozilla/4.0(客户端版本号的名字) 
Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) 
If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  
Cookie(客户端暂存服务端的信息) 
Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间
响应(服务端-&gt;客户端[response])
HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)
Location: http://www.baidu.com(服务端需要客户端访问的页面路径) 
Server:apache tomcat(服务端的Web服务端名)
Content-Encoding: gzip(服务端能够发送压缩编码类型) 
Content-Length: 80(服务端发送的压缩数据的长度) 
Content-Language: zh-cn(服务端发送的语言类型) 
Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)
Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)
Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)
Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)
Transfer-Encoding: chunked(分块传递数据到客户端）  
Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)
Expires: -1//3种(服务端禁止客户端缓存页面数据)
Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  
Pragma: no-cache(服务端禁止客户端缓存页面数据)   
Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  
Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)
</code></pre>
<h2 id="哪些加密算法"><a href="#哪些加密算法" class="headerlink" title="哪些加密算法"></a>哪些加密算法</h2><pre><code>MD5加密算法
RSA加密算法
AES加密算法
Base64加密算法
</code></pre>
<h2 id="TCP和UDP各自使用场景"><a href="#TCP和UDP各自使用场景" class="headerlink" title="TCP和UDP各自使用场景"></a>TCP和UDP各自使用场景</h2><pre><code>TCP应用场景：
效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认
、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输
（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。
UDP应用场景：
效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、
在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题
，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。
</code></pre>
<h2 id="http为什么底层是tcp不是udp"><a href="#http为什么底层是tcp不是udp" class="headerlink" title="http为什么底层是tcp不是udp ?"></a>http为什么底层是tcp不是udp ?</h2><pre><code>tcp协议比udp更安全（结合tcp的特点讲）
</code></pre>
<h2 id="socket异常断开时，设计一个合理的重连机制。"><a href="#socket异常断开时，设计一个合理的重连机制。" class="headerlink" title="socket异常断开时，设计一个合理的重连机制。"></a>socket异常断开时，设计一个合理的重连机制。</h2><pre><code>当与服务器断开连接或网络出错时，先不要处理当前正在连接的socket，可能回应下当前UI的数据显示问题；
可以另起一个socket服务，与服务器尝试连接，当连接成功时，通知当前Socket进行重新连接
每六秒连接一次如果30秒仍未连接上则通知UI掉线，之后仍然继续连接，知道连接上为止
</code></pre>
<h2 id="有了mac地址为什么要有ip地址"><a href="#有了mac地址为什么要有ip地址" class="headerlink" title="有了mac地址为什么要有ip地址"></a>有了mac地址为什么要有ip地址</h2><pre><code>mac地址与我们的设备进行绑定，就能确定我们身份。其实MAC地址，并不能算是地址，更应该算是一个身份证，用来表明身份。
只拥有MAC地址的话，只有在同一网络区域内，才能进行数据传输，不能跨网络区域。
如果想跨网络区域进行数据传递，最现实的方法就是借助ISP提供的网络区域。
ISP能提供全球互联的网络——因特网，借助因特网可以传输数据给连接因特网上的机器。
</code></pre>
<h2 id="断点续传怎么实现"><a href="#断点续传怎么实现" class="headerlink" title="断点续传怎么实现;"></a>断点续传怎么实现;</h2><pre><code>续传的文件就好说了，只要给一个续传的标识位置，和对应的字节流就可以了，代码如下:
filePath:生成的文件,用来续传用
content:将要写入的字节
position:续传的字节位置
</code></pre>
<h2 id="大型文件怎么下载并保存到本地；"><a href="#大型文件怎么下载并保存到本地；" class="headerlink" title="大型文件怎么下载并保存到本地；"></a>大型文件怎么下载并保存到本地；</h2><pre><code>大型文件压缩、分割成小份文件
</code></pre>
<h2 id="xml和json的区别"><a href="#xml和json的区别" class="headerlink" title="xml和json的区别"></a>xml和json的区别</h2><pre><code>1，xml是重量级的，json是轻量级的。
2，xml在传输过程中比较占带宽，json占带宽少，易于压缩。
3，xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。
4，json可用jackson，gson等方法解析，xml可用dom，sax，demo4j等方式解析。
</code></pre>
<h2 id="加密解密的技术讲解。"><a href="#加密解密的技术讲解。" class="headerlink" title="加密解密的技术讲解。"></a>加密解密的技术讲解。</h2><pre><code>（密解密就是是base64加密、POST加密、MD5加密、时间戳密码等等）
</code></pre>
<h2 id="reachability如何检测到网络状态变化？"><a href="#reachability如何检测到网络状态变化？" class="headerlink" title="reachability如何检测到网络状态变化？"></a>reachability如何检测到网络状态变化？</h2><pre><code>Reachability 是苹果官方提供的示例源码，它是对 SystemConfiguration.framework 
模块中的 SCNetworkReachability.h 头文件里提供的一系列网络连接状态相关的 C 函数进行简单封装
Reachability 中提供了三个快速初始化方法，分别为
reachabilityWithHostName:、reachabilityWithAddress: 和 reachabilityForInternetConnection。
通过上述初始化方法获得一个 Reachability 对象后，可调用 startNotifier 方法开始进行网络状态变化的监听
</code></pre>
<h2 id="IP-地址用-int-保存和读取转化"><a href="#IP-地址用-int-保存和读取转化" class="headerlink" title="IP 地址用 int 保存和读取转化"></a>IP 地址用 int 保存和读取转化</h2><pre><code>/**
     * 根据位运算把 byte[] -&gt; int
     * @param bytes
     * @return int
     */
    public static int bytesToInt(byte[] bytes) &#123;
        int addr = bytes[3] &amp; 0xFF;
        addr |= ((bytes[2] &lt;&lt; 8) &amp; 0xFF00);
        addr |= ((bytes[1] &lt;&lt; 16) &amp; 0xFF0000);
        addr |= ((bytes[0] &lt;&lt; 24) &amp; 0xFF000000);
        return addr;
    &#125;
</code></pre>
<h1 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h1><h2 id="instruments它为什么能检测内存泄漏"><a href="#instruments它为什么能检测内存泄漏" class="headerlink" title="instruments它为什么能检测内存泄漏"></a>instruments它为什么能检测内存泄漏</h2><pre><code>Activity Monitor（活动监视器）：监控进程的CPU,内存,磁盘，网络使用情况 是程序在手机运行真正占用的内存大小
Cocoa Layout 观察NSLayoutConstraint对象的改变，帮助我们判断什么时间什么地点的constraint是否合理
Energy Log  耗电量监控
Leaks（泄漏）：一般的措施内存使用情况，检查泄漏的内存，并提供了所有活动的分
配和泄漏模块的类对象分配统计信息以及内存地址历史记录；
Core Animation（图形性能）这个模块显示程序显卡性能以及CPU使用情况
Network 用链接工具分析你的程序如何使用TCP/IP和UDP/IP链接
</code></pre>
<h2 id="推送的原理"><a href="#推送的原理" class="headerlink" title="推送的原理"></a>推送的原理</h2><pre><code>1.由App向iOS设备发送一个注册通知，用户需要同意系统发送推送。
2.iOS向APNs远程推送服务器发送App的Bundle Id和设备的UDID。
3.APNs根据设备的UDID和App的Bundle Id生成deviceToken再发回给App。
4.App再将deviceToken发送给远程推送服务器(自己的服务器), 由服务器保存在数据库中。
5.当自己的服务器想发送推送时, 在远程推送服务器中输入要发送的消息并选择发给哪些用户的deviceToken，由远程推送服务器发送给APNs。
6.APNs根据deviceToken发送给对应的用户。
</code></pre>
<h2 id="项目上线被拒原因"><a href="#项目上线被拒原因" class="headerlink" title="项目上线被拒原因"></a>项目上线被拒原因</h2><pre><code>设计类型的问题，图标、UI等
app类型设置不准确
第三方资源用到广告等资源
</code></pre>
<h2 id="项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线"><a href="#项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线" class="headerlink" title="项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线"></a>项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线</h2><pre><code>加载大图，内存崩溃
时间戳问题
复杂页面的设计
页面之间交互
</code></pre>
<h2 id="iPhone自带的AssistiveTouch你如何实现"><a href="#iPhone自带的AssistiveTouch你如何实现" class="headerlink" title="iPhone自带的AssistiveTouch你如何实现"></a>iPhone自带的AssistiveTouch你如何实现</h2><pre><code>UIWindow进行实现；
层级UIWindowLevelAlert + 1
</code></pre>
<h2 id="有了解过代码如何编译的嘛"><a href="#有了解过代码如何编译的嘛" class="headerlink" title="有了解过代码如何编译的嘛"></a>有了解过代码如何编译的嘛</h2><pre><code>LLVM编译一个源文件的过程：预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt; 
AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件
</code></pre>
<h2 id="编译好的目标文件有data-和text段他们两者有啥区别"><a href="#编译好的目标文件有data-和text段他们两者有啥区别" class="headerlink" title="编译好的目标文件有data 和text段他们两者有啥区别"></a>编译好的目标文件有data 和text段他们两者有啥区别</h2><pre><code>text段: 用于存放程序代码的区域， 编译时确定， 只读。
data段 :用于存放在编译阶段(而非运行时)就能确定的数据，可读可写。也是通常
所说的静态存储区，赋了初值的全局变量、常量和静态变量都存放在这个域。
</code></pre>
<h2 id="appstore上架流程"><a href="#appstore上架流程" class="headerlink" title="appstore上架流程"></a>appstore上架流程</h2><pre><code>1.申请开发者账号
2.创建开发者证书
3.创建项目app id
4.添加测试设备
5.生成描述文件
6.itnues connect创建项目
7.上传app
8.提交以供审核
</code></pre>
<h2 id="一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ"><a href="#一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ" class="headerlink" title="一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ;"></a>一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ;</h2><pre><code>微信自己添加应用白名单，自己app通过k能否打开微信定义的url来判断用户是否安装
</code></pre>
<h2 id="针对线上版本的崩溃处理；"><a href="#针对线上版本的崩溃处理；" class="headerlink" title="针对线上版本的崩溃处理；"></a>针对线上版本的崩溃处理；</h2><pre><code>UIKit不是线程安全的，执行UIKit操作如果不在主线程很可能造成程序Crash
KVO
避免 Foundation 类Carsh
容器越界（NSArray， NSDictionary,...）
unrecognized selector crash (这个很多时候是由于class使用错误导致)
第三方工具：友盟
dSYMTools分析
</code></pre>
<h2 id="Xcode构建过程；"><a href="#Xcode构建过程；" class="headerlink" title="Xcode构建过程；"></a>Xcode构建过程；</h2><pre><code>解析项目文件，获取你项目中的所有文件、target 及其依赖关系、build settings，最后把它变成一个树形结构(有向图)。
增量构建。
</code></pre>
<h2 id="js和Oc交互以及区别；"><a href="#js和Oc交互以及区别；" class="headerlink" title="js和Oc交互以及区别；"></a>js和Oc交互以及区别；</h2><pre><code>js调用oc、oc调用js、通过javaSpritCore实现，JavascriptBridge
</code></pre>
<h2 id="pod-install和pod-update有什么区别？"><a href="#pod-install和pod-update有什么区别？" class="headerlink" title="pod install和pod update有什么区别？"></a>pod install和pod update有什么区别？</h2><pre><code>pod install:执行该命令时，如果Podfile.lock文件存在, 则
直接从此文件中读取框架信息并且它会只下载Podfile.lock
文件中指定的版本安装。对于不在Podfile.lock文件中的pod库，pod
install命令会搜索这个pod库在Podfile文件中指定的版本来安装
pod update:只有当你想要更新pod库的版本时才使用pod update；它
不管Podfile.lock是否存在, 都会读取Podfile文件的的框架信息去下载安装
，下载好之后, 再根据下载好的框架信息, 生成Podfile.lock文件
</code></pre>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="为什么要做组件化"><a href="#为什么要做组件化" class="headerlink" title="为什么要做组件化"></a>为什么要做组件化</h2><pre><code>随着app业务发展过程中体积越来越大，堆叠大量的业务逻辑，不同业务之间相互调用，相互嵌套
代码之间的耦合性越来越高，不方便维护
</code></pre>
<h2 id="你认为组件化的一些收益"><a href="#你认为组件化的一些收益" class="headerlink" title="你认为组件化的一些收益"></a>你认为组件化的一些收益</h2><pre><code>解耦合
分工更加明确，提高开发效率
复用性更好，能迅速的组成更多的App
</code></pre>
<h2 id="redux-单向数据流是怎么产生的-描述下"><a href="#redux-单向数据流是怎么产生的-描述下" class="headerlink" title="redux 单向数据流是怎么产生的 描述下"></a>redux 单向数据流是怎么产生的 描述下</h2><h2 id="Charts框架底层实现；"><a href="#Charts框架底层实现；" class="headerlink" title="Charts框架底层实现；"></a>Charts框架底层实现；</h2><pre><code>通过CoreGraphics绘制的，数据模型。不如js方便美观
</code></pre>
<h2 id="画出项目的结构图。"><a href="#画出项目的结构图。" class="headerlink" title="画出项目的结构图。"></a>画出项目的结构图。</h2><pre><code>Fundation 基础资源（配置信息、基础分类、宏、工具集合）
Map 地图资源（地图单例对象）
Navi 导航资源 （导航页面控制器相关全部）
Net 网络资源 （业务层对应的网络、测试网、线网、版本）
Lib 图片、第三方资源 
App 业务层 （主页、我的、poi、路线规划）
</code></pre>
<h2 id="yyModel的逻辑"><a href="#yyModel的逻辑" class="headerlink" title="yyModel的逻辑"></a>yyModel的逻辑</h2><pre><code>（YYModel的核心是通过runtime获取结构体中得Ivars的值，
将此值定义为key,然后给key赋value值，所以我们需要自己遍历容器
（NSArray，NSSet，NSDictionary），获取每一个值，然后KVC进行处理）。
</code></pre>
<h2 id="解耦的方式"><a href="#解耦的方式" class="headerlink" title="解耦的方式"></a>解耦的方式</h2><pre><code>1、组件化
2、结合MVVM架构和数据驱动UI模式对原有MVC架构进行了兼容性优化
3、通过AOP技术对部分业务进行拆分解耦
4、优化事件传递方式
</code></pre>
<h2 id="项目中用的技术以及实现；"><a href="#项目中用的技术以及实现；" class="headerlink" title="项目中用的技术以及实现；"></a>项目中用的技术以及实现；</h2><pre><code>1.复杂cell提前缓存行高和UI的frame
2.网络请求库的封装
3.组建化简单实现
4.tableView嵌套滑动
5.地图对象的单例封装
6.用View代替ViewController的实现
7.定时器使用
</code></pre>
<h2 id="就是项目中遇到的问题以及解决方式；"><a href="#就是项目中遇到的问题以及解决方式；" class="headerlink" title="就是项目中遇到的问题以及解决方式；"></a>就是项目中遇到的问题以及解决方式；</h2><h2 id="缓存机制是怎么清除数据的？"><a href="#缓存机制是怎么清除数据的？" class="headerlink" title="缓存机制是怎么清除数据的？"></a>缓存机制是怎么清除数据的？</h2><pre><code>沙盒：iOS系统为每一个应用程序创建一个文件目录,是一个的独立,封闭,安全的空间, 一个沙盒就是一个文件目录。沙盒规定了一个程序只能在自身的沙盒中进行操作,不能去访问其他应用程序的沙盒(iOS8已经部分开放访问)
沙盒的作用: 用来存放非代码文件(图片, 音频, 视频, 属性列表(plist), sqlite数据库, 文本文件, 其他等等)
</code></pre>
<h2 id="如何进行安全测试；"><a href="#如何进行安全测试；" class="headerlink" title="如何进行安全测试；"></a>如何进行安全测试；</h2><pre><code>ipa包加壳（苹果）
敏感信息存储位置
通讯网络安全
代码混淆
</code></pre>
<h2 id="涂鸦怎么实现；"><a href="#涂鸦怎么实现；" class="headerlink" title="涂鸦怎么实现；"></a>涂鸦怎么实现；</h2><pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
最终我们决定放弃 drawRect 而选用图层 CAShapeLayer。CAShapeLayer 不仅在功能上满足了我们的需求，对比之下 CAShapeLayer 在性能方面表现也非常出色。
</code></pre>
<h2 id="实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；"><a href="#实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；" class="headerlink" title="实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；"></a>实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；</h2><h2 id="说下生产者-消费者模型，其中的同步机制是怎么样的"><a href="#说下生产者-消费者模型，其中的同步机制是怎么样的" class="headerlink" title="说下生产者-消费者模型，其中的同步机制是怎么样的"></a>说下生产者-消费者模型，其中的同步机制是怎么样的</h2><pre><code>产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。
在生产者与消费者之间在加个缓冲区，我们形象的称之为仓库，生产
者负责往仓库了进商品，而消费者负责从仓库里拿商品，这就构成了生产者消费者模式。
//生产者消费者
   dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
   self.array = [[NSMutableArray alloc] init];
   dispatch_queue_t queue = dispatch_queue_create(&quot;cn.chutong.www&quot;, DISPATCH_QUEUE_CONCURRENT);
  //生产
   dispatch_async(queue, ^&#123;
       while (YES) &#123;
           int count = random()%10;
           sleep(1);
           dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
           [self.array addObject:[NSString stringWithFormat:@&quot;%d&quot;,count]];
           dispatch_semaphore_signal(semaphore);
           NSLog(@&quot;生产了%d&quot;,count);
       &#125;
   &#125;);
   //消费
   dispatch_async(queue, ^&#123;
       while (YES) &#123;
       if (self.array.count&gt;0) &#123;
           NSLog(@&quot;消费了%@&quot;,self.array.lastObject);
           dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
           [self.array removeLastObject];
           dispatch_semaphore_signal(semaphore);
       &#125;
           
       &#125;
   &#125;);
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift136%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift136%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:38" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:38+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.jishudog.com/8744/html">https://www.jishudog.com/8744/html</a><br>Tagged Pointer<br>所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。<br>所有类都继承自NSObject，因此每个对象都有一个isa指针指向它所属的类。在《ARM64 and You》文章中指出：在32位环境下，对象的引用计数都保存在一个外部的表中，<br>而对引用计数的增减操作都要先锁定这个表，操作完成后才解锁。这个效率是非常慢的。<br>而在64位环境下，isa也是64位，实际作为指针部分只用到的其中33位,剩余的部分会运用到Tagged Pointer的概念，其中19位将保存对象的引用计数，这样对引用计数的操作只需要原子的修改这个指针即可，<br>如果引用计数超出19位，才会将引用计数保存到外部表，而这种情况往往是很少的，因此效率将会大大提高。</p>
<p>1.Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate<br>2.Tagged Pointer指针的值不再是地址了，而是真正的值。<br>    实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。<br>    它的内存并不存储在堆中，也不需要malloc和free。<br>3.在内存读取上有着3倍的效率，创建时比以前快106倍。<br>4.它不单单是一个指针，还包括了其值+类型</p>
<p>dispatch_queue_t queue = dispatch_queue_create(“queue”, DISPATCH_QUEUE_CONCURRENT);<br>   for (int i = 0; i &lt; 1000; i ++) {<br>       dispatch_async(queue, ^{<br>           self.name = [NSString stringWithFormat:@”abcdefghijklmn”];<br>       });<br>   }<br>运行结果：崩溃（坏内存访问）<br>因为setter方法中，对strong修饰的属性会有一个retain和release的操作。在并发多线程的赋值操作中，都是对_name指针进行的操作，可能在_name刚刚被release后进行赋值操作，这个时候_name指向的内存地址是已经被释放了，所以造成了坏内存访问崩溃<br>解决办法：<br>1.异步改同步<br>2.将属性改成原子性<br>3.加锁</p>
<p>dispatch_queue_t queue = dispatch_queue_create(“queue”, DISPATCH_QUEUE_CONCURRENT);<br>for (int i = 0; i &lt; 1000; i ++) {<br>    dispatch_async(queue, ^{<br>        self.name = [NSString stringWithFormat:@”a”];<br>    });<br>}<br>为什么不崩溃了？因为没有用到引用计数的内存管理方法，使用的是TaggedPointer<br>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象存储</p>
<p>NONPOINTER_ISA<br> NONPOINTER_ISA在64位机上，对象的isa区域不再只是一个指向另一块存储空间的指针。还包含了更多信息，比如引用计数，析构状态，被其他weak 变量引用情况等。如果引用计数超过了当前指针所能表示的范围，Runtime 会使用一张散列表来管理用计数。<br>(union)，利用联合体可以用相同的存储空间存储不同型别的数据类型，从而节省内存空间<br> ARC：由LLVM和Runtime共同协作来进行自动引用计数的。<br>   uintptr_t nonpointer : 1;</p>
<p>         uintptr_t has_assoc : 1; // </p>
<p>         uintptr_t has_cxx_dtor : 1;</p>
<p>         uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000</p>
<p>         uintptr_t magic : 6;</p>
<p>         uintptr_t weakly_referenced : 1;</p>
<p>         uintptr_t deallocating : 1;</p>
<p>         uintptr_t has_sidetable_rc : 1;</p>
<p>         uintptr_t extra_rc : 19;</p>
<p> SideTables包括了多个SideTable，在不同系统架构中SideTable的个数是不同的；SideTables是哈希表，可以通过一个对象的指针来找到具体的引用计数表或弱引用表在哪一个具体的SideTable中。</p>
<p> 为什么用多个SideTable？ 如果只有一个table，意味着内存中分配的所有对象都要在一个表中操作，因为多个线程可能同时操作这个表，所以就要对这个表加锁，如果并发操作这个表的线程有成千上万个，就会产生效率问题。所以系统引入了分离锁这样一个技术方案，把大表拆成多个小表来进行操作，分别对小表加锁，从而提升效率。</p>
<p> 自旋锁：<br>                       自旋锁：是“忙等”的锁。由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放自旋锁，否则其他等待该自旋锁的线程会一直自旋，从而浪费CPU时间。</p>
<p>                        自旋锁适用于那些仅需要阻塞很短时间的场景。</p>
<p>dealloc -&gt; weak_clear_no_lock(从弱引用表中取出所有该对象的weak_entry_t对象，weak_entry_t里存放了weak_referrer_t数组，就是所有的弱引用，全部设为nil，然后再移除weak_entry_t对象)</p>
<p>Autoreleasepool的实现原理:</p>
<p>以栈为结点，由双向链表的形式合成的数据结构。<br>与线程一一对应。</p>
<p>Main函数自动添加了@autoreleasepool{}; 很多次循环的内部最好自己添加@autoreleasepool{},以及时释放其内部的临时对象。<br> 在当次runloop将要结束的时候调用AutoreleasePoolPage::pop()。<br>autoreleasePoolPage 数据结构<br>可在源码中查看<br>    id *next;<br>    pthread_t const thread;<br>    AutoreleasePoolPage * const parent;<br>    AutoreleasePoolPage *child;<br>    uint32_t const depth;</p>
<p>                        多层嵌套就是多次插入哨兵对象。</p>
<p>                        在for循环中alloc图片数据等内存消耗较大的场景手动插入autoreleasePool。<br>AutoreleasePool 为何可以嵌套使用</p>
<p>多层嵌套就是多次插入哨兵对象<br>,每次创建一个AutoreleasePool，@AutoreleasePool，其实系统就是为我们创建了一个哨兵对象,其实就是创建page，若果当前page没有满，其实就是创建一个哨兵，所以可以嵌套使用<br>中间用nil作为分割</p>
<p>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理？不手动处理会内存泄漏吗？<br>在子线程你创建了 Pool 的话，产生的 Autorelease 对象就会交给 pool 去管理。如果你没有创建 Pool ，但是产生了 Autorelease 对象，就会调用 autoreleaseNoPage 方法。在这个方法中，会自动帮你创建一个 hotpage（hotPage 可以理解为当前正在使用的 AutoreleasePoolPage，如果你还是不理解，可以先看看 Autoreleasepool 的源代码，再来看这个问题 ），并调用 page-&gt;add(obj)将对象添加到 AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！</p>
<p>将对象放入自动释放池不会引起引用计数+1</p>
<p>在for循环大量使用imageNamed:之类的方法生成UIImage对象可能是个更要命的事情，内存随时可能因为占用过多被系统杀掉。<br>这种情况下利用Autoreleasepool可以大幅度降低程序的内存占用。</p>
<p>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成（分别对应结构中的parent指针和child指针）<br>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）<br>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址<br>上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置<br>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</p>
<p>1.根据传入的哨兵对象地址找到哨兵对象所处的page<br>2.在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置<br>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page</p>
<p>黑魔法之Thread Local Storage</p>
<p>Thread Local Storage（TLS）线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以key-value的形式进行读写，比如在非arm架构下，使用pthread提供的方法实现：</p>
<p>一 、dealloc 调用流程</p>
<p>1.首先调用 _objc_rootDealloc()</p>
<p>2.接下来调用 rootDealloc() </p>
<p>3. isTaggedPointer   是否是标记指针 是直接 return ;</p>
<p>  接下来会判断是否可以被直接快速释放，判断的依据主要有 5 个，判断是否有以下五种情况</p>
<p>nonpointer              是否优化过isa指针</p>
<p> weakly_reference  是否存在弱引用指向</p>
<p> has_assoc              是否设置过关联对象</p>
<p> has_cxx_dtor         是否有cpp的析构函数（.cxx_destruct）</p>
<p> has_sidetable_rc   引用计数器是否过大无法存储在isa中</p>
<p>二、object_dispose() 调用流程。</p>
<p>1.直接调用 objc_destructInstance()。</p>
<p>2.之后调用C的 free() 函数。</p>
<p>3.objc_destructInstance() 调用流程</p>
<p>1&gt;.先判断 hasCxxDtor，是否有析构函数（析构器），要调用 object_cxxDestruct() ，释放（清除成员变量）。</p>
<p>2&gt;.再判断hasAssocitatedObjects，如果有的话，要调用object_remove_associations()， 移除当前对象的关联对象。</p>
<p>3&gt;.然后调用 clearDeallocating()。 </p>
<p>4&gt;.执行完毕。</p>
<p>4.clearDeallocating() 调用流程<br>0&gt;. 判断isa是否优化过，从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，所以结果一般是优化过了。</p>
<p>判断是否有弱引用或者引用计数</p>
<p>1&gt;.执行 clearDeallocating_slow()。</p>
<p>2&gt;.再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。</p>
<p>3&gt;.接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。</p>
<p>4&gt;.至此为止，Dealloc 的执行流程结束。</p>
<p>如何破除循环引用</p>
<p>方式1:－－打断引用链条         方式2:－－使用__weak<br>NSTimer破除循环引用<br>weak指针：<br>既然是强引用导致循环引用，那么用__weak修饰self就好了，想法是对的，但是做法是无效的。<br>中间类，block<br>及时销毁<br>创建一个继承NSProxy的子类WeakProxy，并实现消息转发的相关方法<br>多次调用对象的autorelease方法会导致什么问题?<br>答：多次将地址存到自动释放池中,导致野指针异常<br>图片加载占用内存对比</p>
<p>使用 imageName: 加载图片：<br>加载到内存当中后，占据内存空间较大<br>相同的图片，图片不会重复加载<br>加载内存当中之后，会一直停留在内存当中，不会随着对象销毁而销毁<br>加载进去图片之后，占用的内存归系统管理，我们无法管理<br>使用 imageWithContentsOfFile: 加载图片<br>加载到内存当中后,占据内存空间较小<br>相同的图片会被重复加载内存当中<br>对象销毁的时候,加载到内存中图片会随着一起销毁<br>结论:<br>图片较小，并且使用频繁，使用 imageName: 来加载(按钮图标/主页里面图片)<br>图片较大，并且使用较少，使用 imageWithContentsOfFile: 来加载(版本新特性/相册)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift135%E6%88%AA%E5%9B%BE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift135%E6%88%AA%E5%9B%BE%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">截图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:33" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:33+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>class = objc_class -&gt;继承 objc_object<br>objc_class 内部：superClass ; cache; clss_data_bits_t bits</p>
<p>class_rw_t<br>    class_ro_t<br>    protocols  —&gt; lsit_array_tt 二维数组类型<br>    properties<br>    methods</p>
<p>method_t<br>    名称 SEL<br>    返回值、参数体 const char *types;<br>    函数体 IMP<br>const char *types; type encoding<br>返回值 参数1.参数2，参数3</p>
<p>isa指向<br>class -》 subclass -〉subclass meta<br>继承关系<br>class-&gt;superclass-&gt;nsobject<br>subclass meta -&gt; root  class meta - &gt;nsobject</p>
<p>消息传递<br>开始-缓存是否有-当前类方法列表中是否有 - 逐级父类方法列表<br>消息转发<br>动态添加-转发类给别的类-生成方法签名-处理方法-抛出异常</p>
<p>@dynamic<br>    动态运行时语言将函数决议推迟到运行时<br>    编译时语言在编译期进行函数决议</p>
<p>hash查找<br>给定值时对象内存地址，目标值是数组索引<br>f(ptr) = (untntptr_t) ptr % array.count;</p>
<p>retain实现<br>获取sidetable。<br>获取对象的引用计数<br>引用计数加一</p>
<p>retainCount实现 （默认是1的原理）<br>获取sideTable，默认count =1；<br>获取引用计数，与上SIDE_TABLE_RC_SHIFT</p>
<p>delloc<br>开始-》objc_root_dealloc-&gt;root_dealloc<br>判断是否能够释放<br>    是否isa优化-〉是否有弱引用-是否有关联对象-是否有c++晰构器-是否有引用计数表<br>清除c++ object_cXXDestruct<br>清除关联对象 bobject_remove_assocations()</p>
<p>清除引用计数<br>    清除弱引用 weak_clear_no_lock<br>    清除引用计数 table.refcnts.erase<br>添加weak<br>    objc_initWeak-storeWeak-weak_register_no_lock</p>
<p>CFRunLoop<br>    pthread<br>    currentMode<br>    modes<br>    commonModes - &gt;集合<br>    cmomonModeItems<br>CFRunLoopMode<br>    name<br>    sources0 需要手动唤醒<br>    sources1 具备自动唤醒能力<br>    observers<br>    timers</p>
<p>runLoop - n个 model - n个 sources、timer、observer<br>三次握手<br>1.syn——–》<br>2.《——–syn，ack<br>3.ack———》<br>四次挥手<br>1.fin———〉<br>2.〈——–ack<br>3.《——–fin、ack<br>4.———ack<br>https<br>tls版本号，加密算法随机数 ——-》<br>《——商定加密算法、随机数、证书<br>客户端：验证证书<br>客户端：组装会话密钥<br>通过公钥对预主密钥进行加密—-》<br>服务端：通过私钥得到预主密钥<br>服务端：组装会话密钥<br>加密的握手消息————–〉<br>〈—————-加密的握手消息<br>UDP解析<br>12字节伪首部<br>8字节UDp首部<br>7字节数据<br>UDP复用分用<br>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，<br>1.源端口： 源端口号，需要对方回信时选用，不需要时全部置0.<br>2.目的端口：目的端口号，在终点交付报文的时候需要用到。<br>3.长度：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）<br>4.校验和：检测UDP数据报在传输中是否有错，有错则丢弃。<br>TCP<br>无差错、不丢失、不重复、安序到达<br>超时重传、确认迟到、确认丢失<br>面向字节流<br>滑动窗口<br>发送窗口：发送缓存（最后被确认的字节-最后发送的字节）<br>接受窗口：接收缓存（下一个期望收到的字节）<br>拥塞窗口<br>慢开始-拥塞避免-拥塞堵塞（乘法减少）-慢开始—-<br>解决DNS劫持<br>httpDNS  server<br>    使用DNS协议向DNS服务器的53端口进行请求<br>    使用HTTP协议向DNS服务器的80端口进行请求<br>长连接<br>    client -长连接通道 - 长连接server — API server</p>
<p>session<br>发送信息 ———-》 记录用户状态，生成sessionid<br>《——————返回cookie 中携带sessid<br>发送信息，携带cookie，内容是sessid—》通过识别sessid<br>图片缓存框架<br>manager<br>    内存、磁盘、网络<br>    图片解码、图片压缩、解压缩<br>淘汰策略：以队列形式，先进先出的方式淘汰<br>如果缓存文件超过 maxCacheAge 中指定的时长，就会被删除掉。<br> maxCacheSize 控制 SDImageCache 所允许的最大缓存空间<br>RN数据流思想：多叉树<br>    自顶向下遍历更新<br>    自底向上反馈<br>    包含dispatcher、stores、views、actions<br>依赖注入<br>中间层（业务A、业务B。。。。<br>AsyncDisplayKit<br>    Layout：文本计算，试图布局计算<br>    Rendering：文本渲染、图片解码、图形绘制<br>    UIKit Object：对象创建、对象调整、对象销毁</p>
<p>AsyncDisplayKit原理<br>ASNode<br>    view<br>    node</p>
<p>block的copy<br>在arc环境下，编译器会根据情况自动将栈上的block复制到堆上<br>如果block copy到堆上，会调用_Block_objcet_assign<br>如果block移除内部会调用dispose函数，内部会调用_Block_objcet_disponse<br>设计模式<br>创建型模式：单例、 工厂方法<br>结构模式：代理、适配器、组合、装饰<br>行为模式：命令模式、观察者模式、责任链模式<br>通知：Notification_Map<br>key:notificationName value:observer<br>浅拷贝就是内存地址的copy，让目标对象指针和源对象指向同一片内存<br>可变对象的copy和mutablecopy都是深拷贝<br>不可变对象的copy是浅c拷贝，nutableCopy是浅拷贝<br>copy方法返回的s都是不可变对象</p>
<p>试图绘制<br>setNeedsDisplay<br>display<br>displayLayer<br>other works<br>    CGBitmapContext<br>    CoreGraphic API<br>    CGBitmapContext<br>setContents</p>
<p>layer has delegate<br> yes：drawRect<br> no：drawInContext<br> calayer uploads backing store to GPU</p>
<p> source0<br>    触摸事件<br>    performSelector onThread<br>source1<br>    基于port的线程间通信<br>    系统事件捕捉<br>timers<br>    nstimer<br>    performselector withObject anterDelay<br>Observers<br>    用于监听RunLoop的状态<br>    UI刷新（beforeWaiting）</p>
<p>耗电量优化<br>    尽量减少CPU、GPU功耗<br>    少用定时器<br>    优化IO操作<br>    网络优化<br>    减少压缩网络数据</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift134%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift134%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:28" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:28+08:00">2020-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 13:42:43" itemprop="dateModified" datetime="2022-03-25T13:42:43+08:00">2022-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><pre><code>单一职责原则
开闭原则
接口隔离原则
依赖倒置原则
里氏替换原则
迪米特法则
</code></pre>
<h2 id="内存设计"><a href="#内存设计" class="headerlink" title="内存设计"></a>内存设计</h2><pre><code>存储的Size
淘汰策略 LRU算法
</code></pre>
<h2 id="磁盘设计"><a href="#磁盘设计" class="headerlink" title="磁盘设计"></a>磁盘设计</h2><pre><code>存储方式
大小限制
淘汰策略
</code></pre>
<h2 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h2><pre><code>图片请求最大并发
请求超时策略
请求优先级
</code></pre>
<h2 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h2><pre><code>对于不同格式的图片，解码采用什么方式
应用策略模式对不同图片格式进行解码
在那个阶段做图片解码处理
</code></pre>
<h2 id="记录上传器"><a href="#记录上传器" class="headerlink" title="记录上传器"></a>记录上传器</h2><pre><code>关于延时上传具体场景有哪些
前后台切换
从无网络到有网络的变化
通用轻量接口少捎带
</code></pre>
<h2 id="MVVM框架思想"><a href="#MVVM框架思想" class="headerlink" title="MVVM框架思想"></a>MVVM框架思想</h2><pre><code>即模型-视图-视图模型
在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。
</code></pre>
<h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><p>Flux是Facebook用来构建用户端的web应用的应用程序体系架构。它通过利用数据的单向流动为React的可复用的视图组件提供了补充。相比于形式化的框架它更像是一个架构思想，不需要太多新的代码你就可以马上使用Flux构建你的应用。<br>一个 Flux 应用主要包含四个部分：<br>dispatcher<br>处理动作分发，维护 Store 之间的依赖关系</p>
<p>stores<br>数据和逻辑部分</p>
<p>views<br>React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互</p>
<p>actions<br>提供给 dispatcher 传递数据给 store</p>
<h2 id="系统UIView更新机制的思想"><a href="#系统UIView更新机制的思想" class="headerlink" title="系统UIView更新机制的思想"></a>系统UIView更新机制的思想</h2><h2 id="FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想"><a href="#FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想" class="headerlink" title="FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想"></a>FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36747738/article/details/106537874">https://blog.csdn.net/qq_36747738/article/details/106537874</a><br>AsyncDisplayKit</p>
<p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift133%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift133%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:23" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:23+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="同步串行"><a href="#同步串行" class="headerlink" title="同步串行"></a>同步串行</h2><pre><code> // 队列引起的循环等待
//    dispatch_sync(dispatch_get_main_queue(), ^&#123;
//        [self print];
//    &#125;);
</code></pre>
<h2 id="同步并行"><a href="#同步并行" class="headerlink" title="同步并行"></a>同步并行</h2><pre><code>// 同步并行
//    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;
//        NSLog(@&quot;1&quot;);
//        dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;
//            NSLog(@&quot;2&quot;);
//        &#125;);
//        NSLog(@&quot;3&quot;);
//    &#125;);
//
</code></pre>
<h2 id="异步串行"><a href="#异步串行" class="headerlink" title="异步串行"></a>异步串行</h2><pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;
       NSLog(@&quot;1&quot;);
       
       [self performSelector:@selector(print) withObject:nil afterDelay:2];
       [[NSRunLoop currentRunLoop] run];
   &#125;);
   NSLog(@&quot;3&quot;);
    // 在gcd中开启的线程没有runloop，我们提交任务到runloop中是会失效的
     //而performSelector:withObject:afterDelay:其实就是在内部创建了一个NSTimer，
       //然后会添加到当前线程的Runloop中。所以当该方法添加到子线程中时，需要格外的注意两个地方
       // 因为子线程中的runloop默认是没有启动的状态。使用run方法开启当前线程的runloop，但是一定要注意run方法和执行该延迟方法的顺序。
       //而performSelector:withObject:afterDelay:其实就是在内部创建了一个NSTimer
       //所以在子线程中两者的顺序必须是先执行performSelector延迟方法之后再执行run方法。
   //因为run方法只是尝试想要开启当前线程中的runloop，但是如果该线程中并没有任何事件(source、timer、observer)的话，并不会成功的开启。
</code></pre>
<h2 id="异步并行"><a href="#异步并行" class="headerlink" title="异步并行"></a>异步并行</h2><p>NSOperation<br>需要和NSOperationQueue配合使用来实现多线程方案（如果直接start的话，是在主线程执行）<br>添加任务依赖<br>任务执行状态控制<br>最大并发量</p>
<p>NSOperation 实现多线程的使用步骤分为三步：</p>
<p>创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。<br>创建队列：创建 NSOperationQueue 对象。<br>将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。<br>凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行，感谢指正）<br>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。</p>
<p>系统是怎么移除一个isFinished=YES的NSOperation<br>通过KVO的方式</p>
<p>常用属性方法<br>判断操作状态方法</p>
<ul>
<li>(void)cancel; 可取消操作，实质是标记 isCancelled 状态。</li>
<li>(BOOL)isFinished; 判断操作是否已经结束。</li>
<li>(BOOL)isCancelled; 判断操作是否已经标记为取消。</li>
<li>(BOOL)isExecuting; 判断操作是否正在在运行。</li>
<li>(BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。</li>
</ul>
<p>操作同步</p>
<ul>
<li>(void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。</li>
<li>(void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。</li>
<li>(void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li>(void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。<br>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。<br>NSOperationQueue 常用属性和方法</li>
</ul>
<p>取消/暂停/恢复操作</p>
<ul>
<li>(void)cancelAllOperations; 可以取消队列的所有操作。</li>
<li>(BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。</li>
<li>(void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。<br>操作同步</li>
<li>(void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。<br>添加/获取操作</li>
<li>(void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。</li>
<li>(void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束</li>
<li>(NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。</li>
<li>(NSUInteger)operationCount; 当前队列中的操作数。<br>获取队列</li>
</ul>
<ul>
<li>(id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。</li>
<li>(id)mainQueue; 获取主队列。</li>
</ul>
<p>NSThread启动流程<br>start-》创建pthread-〉main函数-》执行-〉结束</p>
<p>iOS常见的锁<br>@synchronized 一般创建单例对象的时候使用<br>atomic<br>修饰属性的关键字<br>对被修饰对象进行院子性操作（不负责使用）<br>atomic作用：多线程下将属性设置为atomic可以保证读取数据的一致性。因为他将保证数据只能被一个线程占用，也就是说一个线程对属性进行写操作时，会使用自旋锁锁住该属性。不允许其他的线程对其进行读取操作了。<br>简而言之，atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。<br>atomic修饰的实际上是这个指针，也就是占8个字节内存的指针，因此就不可能随意使用多线程来操作这块内存的。因为这块内存是原子性的。是线程安全的。<br>真正不安全的是指针指向的那块内存区域，他是非原子性的，当多个线程去操作这块内存的时候，就会出现不安全的情况。<br>OSSpinLock循环等待询问，不释放资源，用于轻量级数据访问，简单的int值+ 1 -1操作<br>NSLock 互斥锁<br>//主线程中<br>NSLock *lock = [[NSLock alloc] init];</p>
<p>//线程1<br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    [lock lock];<br>    NSLog(@”线程1”);<br>    sleep(2);<br>    [lock unlock];<br>    NSLog(@”线程1解锁成功”);<br>});</p>
<p>//线程2<br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{<br>    sleep(1);//以保证让线程2的代码后执行<br>    [lock lock];<br>    NSLog(@”线程2”);<br>    [lock unlock];<br>});<br>2016-08-19 14:23:09.659 ThreadLockControlDemo[1754:129663] 线程1<br>2016-08-19 14:23:11.663 ThreadLockControlDemo[1754:129663] 线程1解锁成功<br>2016-08-19 14:23:11.665 ThreadLockControlDemo[1754:129659] 线程2<br>NSLock 对象是在应用中用于协调多个线程操作<br>你不应该把这个类实现递归锁。如果在同一个线程上调用两次lock方法，将会对这个线程永久上锁。使用NSRecursiveLock类来才可以实现递归锁。<br>解锁一个没有被锁定的锁是一个程序错误，这个地方需要注意。<br>某个线程A调用lock方法。这样，NSLock将被上锁。可以执行“关键部分”，完成后，调用unlock方法。<br>如果，在线程A 调用unlock方法之前，另一个线程B调用了同一锁对象的lock方法。那么，线程B只有等待。直到线程A调用了unlock。<br>同一个线程不能连续两次调用加锁</p>
<p>NSRecursiveLock  递归锁<br>它允许同一线程多次加锁，而不会造成死锁。</p>
<p>发挥CPU多核（多线程）的优势</p>
<p>dispatch_semaphore_t 唤醒一个被动行为</p>
<p>GCD的常见作用<br>延迟执行dispatch_time<br>一次执行dispatch_once<br>dispatch_group_async的使用，调度，当所有任务执行完成之后再执行dispatch_group_notify<br>dispatch_barrier_async等待一些任务完成之后才能继续执行，使用barrier来等待之前任务完成，避免数据竞争等问题。<br>dispatch_semaphore信号量</p>
<p>多线程使用场景<br>类似聊天页的小视频和本地视频列表这样的tableView在显示视频的缩略图时，需要使用多线程来解决tableView的卡顿问题。因为对视频进行切图的操作是耗时的，如果在主线程进行，则会卡住tableView的滑动。<br>异步加载网络数据及解析<br>批量下载图片、图片压缩等处理，之后再刷新ui，<br>延迟执行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift132%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift132%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:17" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:17+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><pre><code>方法 URL 协议版本号 首部字段 实体
</code></pre>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><pre><code>版本 状态码 短语 首部字段 实体
</code></pre>
<h2 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h2><pre><code>GET、POST、HEAD、PUT、DELETE、OPTIONS
</code></pre>
<h2 id="HTTP三次握手"><a href="#HTTP三次握手" class="headerlink" title="HTTP三次握手"></a>HTTP三次握手</h2><pre><code>客户端发送SYN请求连接
服务端接受SYN，返回SYN和ACK
客户端接受SYN和ACK，返回服务端ACK
“第三次握手”是客户端向服务器端发送数据，这个数据就是要告诉服务器，客户端有没有收到服务器“第二次握手”时传过去的数据。若发送的这个数据是“收到了”的信息，接收后服务器就正常建立TCP连接，否则建立TCP连接失败，服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。
</code></pre>
<h2 id="HTTP四次挥手"><a href="#HTTP四次挥手" class="headerlink" title="HTTP四次挥手"></a>HTTP四次挥手</h2><pre><code>客户端发送FIN请求释放连接  FIN-WAIT-1阶段
服务端返回ACK，服务端处于准备断开状态  CLOSE-WAIT阶段（半关闭状态），客户端收到，进入FIN-WAIT-2阶段
服务端做好释放准备，再次向客户端发送FIN和ACK，LAST-ACK阶段
客户端收到FIN和ACK，发送ACK断开连接，TIME-WAIT阶段
随后客户端开始在TIME-WAIT阶段等待2MSL
服务端收到客户端LAST-ACK，进入CLOSED阶段。
与“三次挥手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续&quot;挥手&quot;，以此确保了&quot;四次挥手&quot;的顺利完成。
</code></pre>
<h2 id="为什么“握手”是三次，“挥手”却要四次？"><a href="#为什么“握手”是三次，“挥手”却要四次？" class="headerlink" title="为什么“握手”是三次，“挥手”却要四次？"></a>为什么“握手”是三次，“挥手”却要四次？</h2><pre><code>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。
释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。
</code></pre>
<h2 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL?"></a>为什么客户端在TIME-WAIT阶段要等2MSL?</h2><pre><code>为的是确认服务器端是否收到客户端发出的ACK确认报文
当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。

（1）序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
（2）确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
（3）标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：
URG：紧急指针（urgent pointer）有效。
ACK：确认序号有效。
PSH：接收方应该尽快将这个报文交给应用层。
RST：重置连接。
SYN：发起一个新连接。
FIN：释放一个连接。
</code></pre>
<h2 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h2><pre><code>无连接：HTTP的持久性
是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接
无状态：Cookie/Session
无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。
</code></pre>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><pre><code>即HTTP下加入SSL层
SSL/TLS协议提供的服务主要有：
1、认证用户和服务器，确保数据发送到正确的客户机和服务器；
2、加密数据以防止数据中途被窃取；
3、维护数据的完整性，确保数据在传输过程中不被改变。
SSL安全机制

1、身份验证机制
基于证书利用数字签名方法对服务器和客户端进行身份验证，其中客户端的身份验证是可选的。
2、数据传输的机密性
利用对称密钥算法对传输的数据进行加密。
3、消息完整性验证
消息传输过程中使用MAC算法来检验消息的完整性。
</code></pre>
<h2 id="TLS的主要增强内容"><a href="#TLS的主要增强内容" class="headerlink" title="TLS的主要增强内容"></a>TLS的主要增强内容</h2><pre><code>TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS 在SSL v3.0 的基础上，提供了以下增强内容：

1、更安全的MAC算法
2、更严密的警报
3、“灰色区域”规范的更明确的定义
</code></pre>
<h2 id="TLS对于安全性的改进"><a href="#TLS对于安全性的改进" class="headerlink" title="TLS对于安全性的改进"></a>TLS对于安全性的改进</h2><pre><code>1、对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。
2、增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。
3、改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。
4、一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。
5、特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。
</code></pre>
<h2 id="基本运行过程"><a href="#基本运行过程" class="headerlink" title="基本运行过程"></a>基本运行过程</h2><pre><code>1、客户端向服务器端索要并验证公钥。
2、双方协商生成&quot;对话密钥&quot;。
3、双方采用&quot;对话密钥&quot;进行加密通信。
其中，前两个阶段，被称为“握手阶段”。

TLS握手过程有单向验证和双向验证之分，简单解释一下，单向验证就是server端将证书发送给客户端，客户端验证server端证书的合法性等，例如百度、新浪、google等普通的https网站，双向验证则是不仅客户端会验证server端的合法性，同时server端也会验证客户端的合法性，例如银行网银登陆，支付宝登陆交易等。
1、确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
2、一个服务器生成的随机数（Sever Random），稍后用于生成&quot;对话密钥&quot;。
3、确认使用的加密方法，比如RSA公钥加密。
4、服务器证书（Certificate）。
5、支持的一些SSL/TLS扩展。

客户端需要对服务端的证书进行检查，如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥。然后，向服务器发送下面三项信息：

1、一个随机数（Pre Master Secret）。该随机数用服务器公钥加密，防止被窃听。
2、编码改变通知（Change Chiper Spec），表示随后的信息都将用双方商定的加密方法和密钥发送。
3、客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
</code></pre>
<h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><pre><code>&quot;不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。
</code></pre>
<h2 id="HTTPS通信的步骤"><a href="#HTTPS通信的步骤" class="headerlink" title="HTTPS通信的步骤"></a>HTTPS通信的步骤</h2><pre><code>①客户端发送报文进行SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件列表（加密算法及密钥长度等）。
②服务器应答，并在应答报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接受到的客户端加密组件内筛选出来的。
③服务器发送报文，报文中包含公开密钥证书。
④服务器发送报文通知客户端，最初阶段SSL握手协商部分结束。
⑤SSL第一次握手结束之后，客户端发送一个报文作为回应。报文中包含通信加密中使用的一种被称Pre-master secret的随机密码串。该密码串已经使用服务器的公钥加密。
⑥客户端发送报文，并提示服务器，此后的报文通信会采用Pre-master secret密钥加密。
⑦客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够完成成功，要以服务器是否能够正确解密该报文作为判定标准。
⑧服务器同样发送Change Cipher Spec报文。
⑨服务器同样发送Finished报文。
⑩服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。
⑪应用层协议通信，即发送HTTP响应。
⑫最后由客户端断开链接。断开链接时，发送close_nofify报文
</code></pre>
<h2 id="中间人攻击（charles抓包原理）"><a href="#中间人攻击（charles抓包原理）" class="headerlink" title="中间人攻击（charles抓包原理）"></a>中间人攻击（charles抓包原理）</h2><pre><code>流程如下：
1、截获客户端与服务器通信的通道
2、然后在 SSL 建立连接的时候，进行中间人攻击
3、将自己伪装成客户端，获取到服务器真实有效的 CA 证书（非对称加密的公钥）
4、将自己伪装成服务器，获取到客服端的之后通信的密钥（对称加密的密钥）
5、有了证书和密钥就可以监听之后通信的内容了
抓取https包的时候,青花瓷会要求使用者 对抓包的设备(手机或其他设备)
,安装一个证书,安装这个证书的时候,其实是安装了一个根证书(允许颁发CA的一个证书机构的根证书),当你安装了该根证书之后,该证书机构颁发的其他证书,默认都会被你的系统所信任,这个就是青花瓷完成https抓包的一个重要前提!!
</code></pre>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><pre><code>UDP协议：

无连接协议，也称透明协议，也位于传输层。
UDP通讯协议的特点：

将数据封装为数据包。面向无连接。
每个数据包大小限制在64K。
因为无连接，所以不可靠。
因为不需要建立连接，所以速度快。
UDP通讯是不分服务端和客服端的，只分发送端和接收端。

两者区别：

1） TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。
2） TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。
3） TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。
4） TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。
</code></pre>
<h2 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h2><pre><code>    基于连接（点对点）
    传输数据前需要建立好连接，然后在传输
    双工通信
    TCP连接一旦建立，就可以在连接上进行双向的通信
    基于字节流而非报文
    将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制能够保证TCP协议的有序性和完整性，因此TCP能够提供可靠性传输

    可靠传输
    拥塞控制
    慢启动，拥塞避免，拥塞发生，快速恢复四个算法
    流量控制能力
通过滑动窗口控制数据的发送速率，滑动窗口的本质是动态缓冲区，接收区根据自己的能力在TCP的header中动态调整窗口大小，通过ACK应答包通知给发送端，发送端根据窗口大小调控发送速率
</code></pre>
<h2 id="TCP传输是可靠的原因"><a href="#TCP传输是可靠的原因" class="headerlink" title="TCP传输是可靠的原因"></a>TCP传输是可靠的原因</h2><pre><code>（1）TCP协议采用发送应答机制，即发送端发送的每个
TCP报文段都必须得到接收方的应答，才能认为这个TCP报文段传输成功。
（2）TCP协议采用超时重传机制，发送端在发送出一个TCP报文
段之后启动定时器，如果在定时时间内未收到应答，它将重新发送该报文段。
（3）由于TCP报文段最终是以IP数据报发送的，而IP数
据报到达接收端可能乱序、重复、所以TCP协议还会将接收到的TCP报文段重排、整理、再交付给应用层。
TCP使用滑动窗口机制来进行流量控制。
建立连接时，各端分配一个缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给
另一端。接收方发送的确认消息中包含了自己剩余的缓冲区尺寸。剩余缓冲区空间的数
量叫做窗口。其实就是建立连接的双虎互相知道彼此剩余的缓冲区大小。
 （5）、拥塞控制
 拥塞控制：防止过多的数据注入到网路中，这样可以使网络中的路由器
 或链路不至于阻塞。拥塞控制是一个全局性的过程，和流量控制不同，流量控制是点对点的控制。
 2.拥塞避免：
 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的
 拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按照线性规律缓慢增长。
</code></pre>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><pre><code>DNS服务器一般分三种，根DNS服务器，顶级DNS服务器，权威DNS服务器。
1）浏览器缓存　　
2）系统缓存　　
3）路由器缓存　　　　
4） ISP（互联网服务提供商）DNS缓存
5）根域名服务器　　　
6）顶级域名服务器　　
8）保存结果至缓存
</code></pre>
<h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><pre><code>一般而言，用户上网的DNS服务器都是运营商分配的，所以，在这个节点上，运营商可以为所欲为。
例如，访问http://jiankang.qq.com/index.html，
正常DNS应该返回腾讯的ip，而DNS劫持后，会返回一个运营商的中间服务器ip。
访问该服务器会一致性的返回302，让用户浏览器跳转到预处理好的带广告的网页，
在该网页中再通过iframe打开用户原来访问的地址。
</code></pre>
<h2 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h2><pre><code>在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而
且是html类型请求，则拦截处理。后续做法往往分为2种，1种是类
似DNS劫持返回302让用户浏览器跳转到另外的地址，还有1种是在服务器返
回的HTML数据中插入js或dom节点（广告）。
</code></pre>
<p>Cookie<br>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。<br>服务器在向客户端回传相应的超文本的同时也会发回这些个人信息存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置<br>自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。<br>Cookie的maxAge决定着Cookie的有效期，单位为秒（Second）。Cookie中通过getMaxAge()方法与setMaxAge(int maxAge)方法来读写maxAge属性。 如果maxAge属性为正数，则表示该Cookie会在maxAge秒之后自动失效。<br>Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。读者可以通过上例的程序进行验证，设置不同的属性。</p>
<p>Session机制</p>
<p>除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。<br>Session技术则是服务端的解决方案，它是通过服务器来保持状态的。<br>URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。HttpServletResponse类提供了encodeURL(Stringurl)实现URL地址重写，例如：</p>
<p>Cookie与Session的区别</p>
<p>cookie数据存放在客户的浏览器上，session数据放在服务器上；<br>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；<br>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；<br>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；<br>Cookie和Session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，上面我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用（注意：有些资料说ASP解决这个问题，当浏览器的cookie被禁掉，服务端的session任然可以正常使用，ASP我没试验过，但是对于网络上很多用php和jsp编写的网站，我发现禁掉cookie，网站的session都无法正常的访问）。</p>
<p>如何保证cookie的安全<br>对cookie进行加密处理<br>只在https上携带cookie<br>设置cookie为httpOnly，防止跨站脚本攻击</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift131RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift131RunLoop/" class="post-title-link" itemprop="url">RunLoop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:11" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:11+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>概念<br>数据结构<br>事件循环机制<br>RunLoop和NStimer<br>RunLoop和多线程<br>RunLoop是通过内部维护的事件循环来对事件/消息进行管理的一个对象<br>没有消息需要处理时，休眠以避免资源占用<br>用户态-》核心态<br>有消息处理时，立即被唤醒<br>核心态-〉用户态</p>
<p>CFRunLoop<br>CFRunLoopMode<br>Source/Timer/Observer</p>
<p>source0<br>需要手动唤醒线程<br>source1<br>具备唤醒线程的能力</p>
<p>CFRunLoopObserver<br>观测时间点<br>kCFRunLoopEntry<br>kCFRunLoopBeforeTimers</p>
<p>CommonMode的特性<br>NSRunLoopCommonModes<br>commonMode不是实际存在的一种mode<br>是同步Source/Timer/Observer到多个Mode中的一种技术方案</p>
<p>如何实现一个常驻线程<br>给子线程添加RunLoop<br> @autoreleasepool {<br>    // 子线程对应的runloop需要自己创建并开启<br>    // 创建子线程对应的runloop,使子线程一直存在<br>    NSRunLoop *currentRunloop = [NSRunLoop currentRunLoop];<br>    // 给runloop添加一个基于port的事件(系统事件),让runloop的运行模式不为空,保证runloop不退出<br>    [currentRunloop addPort:[NSPort port] forMode:NSDefaultRunLoopMode];<br>    // 开启运行循环<br>    [currentRunloop run];<br>    }<br>利用 runloop 解释一下页面的渲染的过程？</p>
<p>当我们调用 [UIView setNeedsDisplay] 时，这时会调用当前 View.layer 的 [view.layer setNeedsDisplay]方法。</p>
<p>这等于给当前的 layer 打上了一个脏标记，而此时并没有直接进行绘制工作。而是会到当前的 Runloop 即将休眠，也就是 beforeWaiting 时才会进行绘制工作。</p>
<p>紧接着会调用 [CALayer display]，进入到真正绘制的工作。CALayer 层会判断自己的 delegate 有没有实现异步绘制的代理方法 displayer:，这个代理方法是异步绘制的入口，如果没有实现这个方法，那么会继续进行系统绘制的流程，然后绘制结束。</p>
<p>CALayer 内部会创建一个 Backing Store，用来获取图形上下文。接下来会判断这个 layer 是否有 delegate。</p>
<p>如果有的话，会调用 [layer.delegate drawLayer:inContext:]，并且会返回给我们 [UIView DrawRect:] 的回调，让我们在系统绘制的基础之上再做一些事情。</p>
<p>如果没有 delegate，那么会调用 [CALayer drawInContext:]。</p>
<p>以上两个分支，最终 CALayer 都会将位图提交到 Backing Store，最后提交给 GPU。</p>
<p>至此绘制的过程结束。</p>
<p>二 你在开发过程中怎么使用RunLoop？什么应用场景？</p>
<p>开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来的消息，处理其他事件）</p>
<p>在子线程中开启一个定时器</p>
<p>在子线程中进行一些长期监控</p>
<p>可以控制定时器在特定模式下运行</p>
<p>可以让某些事件（行为，任务）在特定模式下执行</p>
<p>可以添加observer监听RunLoop的状态，比如监听点击事件的处理（比如在所有点击事件前做一些处理）<br>   1）NSTimer</p>
<p>   2）ImageView显示：控制方法在特定的模式下可用</p>
<p>   3）PerformSelector</p>
<p>   4）常驻线程：在子线程中开启一个runloop</p>
<p>   5）自动释放池</p>
<pre><code>   第一次创建：进入runloop的时候

   最后一次释放：runloop退出的时候

   其它创建和释放：当runloop即将休眠的时候会把之前的自动释放池释放，然后重新创建一个新的释放池
</code></pre>
<p>// 高性能定时器<br>__block int timeout=300; //倒计时时间<br>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);<br>dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行<br>dispatch_source_set_event_handler(_timer, ^{<br>    if(timeout&lt;=0){ //倒计时结束，关闭<br>        dispatch_source_cancel(_timer);<br>        dispatch_async(dispatch_get_main_queue(), ^{<br>            //设置界面的按钮显示 根据自己需求设置<br>            NSLog(@”=====”)<br>        });</p>
<pre><code>&#125;else&#123;
    int minutes = timeout / 60;
    int seconds = timeout % 60;
    NSString *strTime = [NSString stringWithFormat:@&quot;%d分%.2d秒后重新获取验证码&quot;,minutes, seconds];
    dispatch_async(dispatch_get_main_queue(), ^&#123;
        NSLog(@&quot;*******&quot;);
    &#125;); 
    timeout--; 
&#125; 
</code></pre>
<p>});<br>dispatch_resume(_timer); </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift130Block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift130Block/" class="post-title-link" itemprop="url">Block</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:06" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:06+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Block是将函数及其执行上下文封装起来的对象。</p>
<p>Block截获变量<br>对于基本数据类型的局部变量截获的是其值<br>对于对象类型的局部变量连同所有权修饰符一起截获（强引用）<br>以指针形式结果局部静态变量<br>不截获全局变量、全局静态变量</p>
<p>Block本质上是一个结构体，也有自己的isa<br>__block将修饰的变量变成了一个对象<br>a = 20 -&gt;  (a.__forwarding-&gt;a) = 20</p>
<p>本质<br>栈上的block<br>堆上的block（经过copy处理）<br>都有.__forwarding指针<br>栈上的__forwarding指向自己（变量）<br>经过copy后，栈上的.__forwarding指针指向了堆上的__block变量<br>.__forwarding存在的意义<br>不论任何内存位置都可以顺利访问统一个__block变量<br>Block不允许修改外部变量的值,这里所说的外部变量的值,指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有,就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</p>
<p>block类型：全局类型、栈类型、堆类型</p>
<p>栈上的block进行copy在MRC上会不会存在内存泄漏</p>
<p>block循环引用<br>__weak所有权修饰变量，是联通属性关键字拷贝的<br>__block 修改变量<br>__block自动变量的值，被copy进了Block，不带__block的自动变量只能在里面被访问<br>在MRC环境下，__block根本不会对指针所指向的对象执行copy操作，而只是把指针进行的复制。<br>而在ARC环境下，对于声明为__block的外部对象，在block内部会进行retain，以至于在block环境内能安全的引用外部对象。<br>__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。<br>为什么会产生循环引用</p>
<p>怎么理解block截获变量的特性</p>
<p>ARC环境下，一旦Block赋值就会触发copy，__block就会copy到堆上，Block也是__NSMallocBlock。ARC环境下也是存在__NSStackBlock的时候，这种情况下，__block就在栈上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">365</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
