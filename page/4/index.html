<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/02/M_Swift157OpenGL%E7%BB%98%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/02/M_Swift157OpenGL%E7%BB%98%E5%88%B6/" class="post-title-link" itemprop="url">OpenGL 渲染</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-02 11:56:09" itemprop="dateCreated datePublished" datetime="2020-12-02T11:56:09+08:00">2020-12-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="创建render-buffer-（渲染缓冲区）"><a href="#创建render-buffer-（渲染缓冲区）" class="headerlink" title="创建render buffer （渲染缓冲区）"></a>创建render buffer （渲染缓冲区）</h2><p> Render buffer 是OpenGL的一个对象，用于存放渲染过的图像。</p>
<ul>
<li>(void)setupRenderBuffer {<br>  glGenRenderbuffers(1, &amp;_colorRenderBuffer);<br>  glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderBuffer);<br>  [_context renderbufferStorage:GL_RENDERBUFFER fromDrawable:_eaglLayer];<br>}</li>
</ul>
<h2 id="创建一个-frame-buffer（帧缓冲区）"><a href="#创建一个-frame-buffer（帧缓冲区）" class="headerlink" title="创建一个 frame buffer（帧缓冲区）"></a>创建一个 frame buffer（帧缓冲区）</h2><ul>
<li>(void)setupFrameBuffer {<br>  GLuint framebuffer;<br>  glGenFramebuffers(1, &amp;framebuffer);<br>  glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<br>  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderBuffer);  // 深度测试<br>  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, _depthRenderBuffer);<br>}<h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2></li>
<li>(void)setupDepthBuffer {<br>  glGenRenderbuffers(1, &amp;_depthRenderBuffer);<br>  glBindRenderbuffer(GL_RENDERBUFFER, _depthRenderBuffer);<br>  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, self.frame.size.width, self.frame.size.height);<br>}</li>
</ul>
<h2 id="加载着色器"><a href="#加载着色器" class="headerlink" title="加载着色器"></a>加载着色器</h2><ul>
<li>(void)compileShaders {<br>  // 1<br>  GLuint vertexShader = [self compileShader:@”SimpleVertex5” withType:GL_VERTEX_SHADER];<br>  GLuint fragmentShader = [self compileShader:@”SimpleFragment5” withType:GL_FRAGMENT_SHADER];  // 2<br>  GLuint programHandle = glCreateProgram();<br>  glAttachShader(programHandle, vertexShader);<br>  glAttachShader(programHandle, fragmentShader);<br>  glLinkProgram(programHandle);  // 3 检查link状态<br>  GLint linkSuccess;<br>  glGetProgramiv(programHandle, GL_LINK_STATUS, &amp;linkSuccess);<br>  if (linkSuccess == GL_FALSE) {<pre><code>  GLchar messages[256];
  glGetProgramInfoLog(programHandle, sizeof(messages), 0, &amp;messages[0]);
  NSString *messageString = [NSString stringWithUTF8String:messages];
  NSLog(@&quot;link no Success-------------%@&quot;, messageString);
  exit(1);
</code></pre>
  }  // 4 让OpenGL执行glProgram<br>  glUseProgram(programHandle);  // 5<br>  _positionSlot = glGetAttribLocation(programHandle, “Position”);<br>  _colorSlot = glGetAttribLocation(programHandle, “SourceColor”);<br>  glEnableVertexAttribArray(_positionSlot);<br>  glEnableVertexAttribArray(_colorSlot);  // 投影<br>  _projectionUniform = glGetUniformLocation(programHandle, “Projection”);<br>  // 移动<br>  _modelViewUniform = glGetUniformLocation(programHandle, “Modelview”);<br>}</li>
</ul>
<h2 id="编译着色代码"><a href="#编译着色代码" class="headerlink" title="编译着色代码"></a>编译着色代码</h2><ul>
<li>(GLuint)compileShader:(NSString *)shaderName withType:(GLenum)shaderType {<br>  // 1 查找shader文件<br>  NSString *shaderPath = [[NSBundle mainBundle] pathForResource:shaderName ofType:@”glsl”];<br>  NSFileManager *mg = [NSFileManager defaultManager];  if ([mg fileExistsAtPath:shaderPath]) {<pre><code>  NSLog(@&quot;ok&quot;);
</code></pre>
  }else{<pre><code>  NSLog(@&quot;no&quot;);
</code></pre>
  }  NSError *error;<br>  NSString *shaderString = [NSString stringWithContentsOfFile:shaderPath encoding:NSUTF8StringEncoding error:&amp;error];  if (!shaderString) {<pre><code>  NSLog(@&quot;-----------Error loading shader: %@&quot;, error.localizedDescription);
  exit(1);
</code></pre>
  }  // 2 创建一个代表shader的OpenGL对象, 指定vertex或fragment shader<br>  GLuint shaderHandle = glCreateShader(shaderType);  // 3获取shader的source<br>  const char *shaderStringUTF8 = [shaderString UTF8String];<br>  int shaderStringLength = (int)[shaderString length];<br>  glShaderSource(shaderHandle, 1, &amp;shaderStringUTF8, &amp;shaderStringLength);  // 4 编译shader<br>  glCompileShader(shaderHandle);  // 5查询shader对象的信息<br>  GLint compileSuccess;<br>  glGetShaderiv(shaderHandle, GL_COMPILE_STATUS, &amp;compileSuccess);  if (compileSuccess == GL_FALSE) {<pre><code>  GLchar messages[256];
  glGetShaderInfoLog(shaderHandle, sizeof(messages), 0, &amp;messages[0]);
  NSString *messageString = [NSString stringWithUTF8String:messages];
  NSLog(@&quot;compile no Success-----------%@&quot;, messageString);
  exit(1);
</code></pre>
  }  return shaderHandle;<br>}<h2 id="清理屏幕"><a href="#清理屏幕" class="headerlink" title="清理屏幕"></a>清理屏幕</h2></li>
<li>(void)render {<br>  glClearColor(0, 104.0/255.0, 55.0/255.0, 1.0);<br>  glClear(GL_COLOR_BUFFER_BIT);<br>  [_context presentRenderbuffer:GL_RENDERBUFFER];<br>}<h2 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h2>  /**<ol>
<li>GL_ARRAY_BUFFER用于顶点数组</li>
<li>绑定vertexBuffer到GL_ARRAY_BUFFER</li>
<li>给VBO传递数据</li>
<li>取出地址</li>
<li>取出颜色</li>
<li>glVertexAttribPointer的最后一个参数是要获取的参数在GL_ARRAY_BUFFER（每一个Vertex）的偏移量</li>
</ol>
  */</li>
<li>(void)setupVBOs{  GLuint verticesBuffer;<br>  glGenBuffers(1, &amp;verticesBuffer);<br>  glBindBuffer(GL_ARRAY_BUFFER, verticesBuffer);<br>  glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);<br>  glEnableVertexAttribArray(GLKVertexAttribPosition);<br>  glEnableVertexAttribArray(GLKVertexAttribColor);<br>  glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 0);<br>  glVertexAttribPointer(GLKVertexAttribColor, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 6, (GLfloat *)NULL + 3);<br>}</li>
</ul>
<p>b.流程代码化</p>
<p>  一、配置渲染环境<br>    1) 配置渲染窗口 [ 继承自 UIView ]<br>    2) 配置渲染上下文<br>    3) 配置帧渲染<br>    4) 配置渲染缓存<br>    5) 帧缓存装载渲染缓存的内容<br>    6) 渲染上下文绑定渲染窗口（图层）<br>二、修改背景色</p>
<p>  三、 初始化数据</p>
<p>  四、 配置 OpenGL ES Shader</p>
<pre><code>1) 编写 Vertex Shader Code 文件
2) 编写 Fragment Shader Code 文件
3) 配置 Vertex Shader
4) 配置 Fragment Shader
5) 创建 Shader Program
6) 装载 Vertex Shader 和 Fragment Shader
7) 链接 Shader Program
</code></pre>
<p>  五、渲染绘制</p>
<pre><code>1) 清空旧渲染缓存
2) 设置渲染窗口
3) 使用 Shder Program
4) **关联数据**
5) 绘制图形
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift163iOS%E5%9C%B0%E5%9B%BESDK%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift163iOS%E5%9C%B0%E5%9B%BESDK%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">地图SDK开发设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:11:56" itemprop="dateCreated datePublished" datetime="2020-12-01T14:11:56+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 15:38:42" itemprop="dateModified" datetime="2021-04-12T15:38:42+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="设计方向"><a href="#设计方向" class="headerlink" title="设计方向"></a>设计方向</h2><pre><code>1.距离计算
2.坐标转换
3.覆盖物的设计理念
4.弧线坐标获取逻辑
5.webgl截屏
6.地图手势
7.地图覆盖物管理
8.比例尺计算
9.定位计算
10.坐标转换
11.宏定义
12.覆盖物定义逻辑
13.poi点击
</code></pre>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><pre><code>1.mark问题
目前采用了直接地图绘制marker的方式，后续考虑添加接口实现点击效果
2.地图样式问题
添加地图样式接口，目前配置文件没有其它样式数据
3.地图绘制文本

4.地图导航图标绘制
没有绘制成功，

5.地图定位图标的绘制

6.未完成接口
1.Annomation 接口
2.

1.判断折线是否被点击
    原理：点到线的距离是否大与线的宽度
2.判断是否在弧形上
    原理：点到圆心的距离相同。2点在弧形的三角形内
2.判断是否在圆内
    原理：点到圆心的距离小于半径
3.判断是否在面内
    原理：
5.图形的点击
    判断点是否在rect内

7.覆盖物的选中和非选中状态

6.覆盖物的拖拽：
    原理是修改覆盖物的位置

覆盖物的内容
1.点 MAMarker
2.线 MAPolyline
3.面 MAPolygon
4.圆 MACircle
5.弧 MAArc
6.3d图 MAGroundOverlay

问题：
比例尺不同 ：咱们这个好行0是最大
倾斜角度不同 ：咱们是 0 - 90 度

今天终点是定位，显示定位点，用marker实现，不用annimation

定位点的显示逻辑
1.是否定位
2.是否显示定位点
3.是否自定义定位点
4.是否显示精度圈
5.是否自定义精度圈



初始完成
默认定位是打开的，所以设置完代理时，启动定位
默认显示用户位置，所以启动完定位，添加用户位置

添加定位的逻辑


Annimation使用
由annimation转为view，在地图上添加view、可拖拽的view

点击
选中
取消选中
拖拽


地图Annimation 的重用机制原理
1.添加Annimation 
2.当annimation 位置处在地图以外时，在地图上再添加annimation时，使用屏幕外的annimation 就可以了
3.当annimation位置在、


未实现覆盖物
2.大地曲线
4.路段纹理绘制
5.车标绘制

问题：
1.贴图丢失
2.转角问题
3.大地曲线
4.图片贴图显示问题


https://www.cnblogs.com/csu-lmw/category/1555941.html


未实现接口

图标问题
分段纹理

室内地图
点平滑移动
绘制海量点
获取地址


1.内存问题，map对象不消失，一致占用较大内存
2.室内地图缩放等级不对
3.室内地图绘制poi
4.室内地图事件回调
5.

重用机制
：就是删除数据时候不将数据放到备用池中
室内地图配色
室内地图poi绘制
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift161iOS%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift161iOS%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">iOS常用框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:11:50" itemprop="dateCreated datePublished" datetime="2020-12-01T14:11:50+08:00">2020-12-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>界面图形框架 – UIKit<br>核心动画框架 – Core Animation<br>苹果封装的图形框架 – Core Graphics &amp; Quartz 2D<br>传统跨平台图形框架 – OpenGL ES<br>苹果最新力推的图形框架 – Metal<br>适合图片的苹果滤镜框架 – Core Image<br>适合视频的第三方滤镜方案 – GPUImage<br>游戏引擎 – Scene Kit (3D) 和 Sprite Kit (2D)<br>计算机视觉在iOS的应用 – OpenCV for iOS<br>UIKit与Core Graphics的关系</p>
<h2 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h2><p>在UIKit中，UIView类本身在绘制时自动创建一个图形环境，即Core Graphics层的CGContext类型，作为当前的图形绘制环境。在绘制时可以调用 UIGraphicsGetCurrentContext 函数获得当前的图形环境，例如：</p>
<ul>
<li>(void)drawRect:(CGRect)rect {<br>  // Drawing code<br>  NSLog(@”%s”,<strong>func</strong>);<br>  //1.获取上下文<br>  CGContextRef contextRef = UIGraphicsGetCurrentContext();<br>  //2.描述路径<br>  UIBezierPath * path = [UIBezierPath bezierPath];<br>  //起点<br>  [path moveToPoint:CGPointMake(10, 10)];<br>  //终点<br>  [path addLineToPoint:CGPointMake(100, 100)];<br>  //设置颜色<br>  [[UIColor whiteColor]setStroke];<br>  //3.添加路径<br>  CGContextAddPath(contextRef, path.CGPath);<br>  //显示路径<br>  CGContextStrokePath(contextRef);</li>
</ul>
<p>}</p>
<h2 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h2><p>Core Animation 是一套Objective-C API，实现了一个高性能的复合引擎，并提供一个简单易用的编程接口，给用户UI添加平滑运动和动态反馈能力。</p>
<p>Core Animation 是 UIKit 实现动画和变换的基础，也负责视图的复合功能。使用Core Animation可以实现定制动画和细粒度的动画控制，创建复杂的、支持动画和变换的layered 2D视图。</p>
<p>Core Animation 不属于绘制系统，但它是以硬件复合和操作显示内容的基础设施。这个基础设施的核心是layer对象，用来管理和操作显示内容。在 iOS 中 每一个视图都对应Core Animation的一个层对象，与视图一样，层之间也组织为层关系树。一个层捕获视图内容为一个被图像硬件容易操作的位图。在多数应用中层作为管理视图的方式使用，但也可以创建独立的层到一个层关系树中来显示视图不够支持的显示内容。</p>
<p>OpenGL ES的内容也可以与Core Animation内容进行集成。</p>
<p>为了使用Core Animation实现动画，可以修改 层的属性值 来触发一个action对象的执行，不同的action对象实现不同的动画。</p>
<h2 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h2><p>Core Graphics是一套C-based API， 支持向量图形，线、形状、图案、路径、剃度、位图图像和pdf 内容的绘制。</p>
<h2 id="Quartz-2D"><a href="#Quartz-2D" class="headerlink" title="Quartz 2D"></a>Quartz 2D</h2><p>Quartz 2D是Core Graphics中的2D 绘制呈现引擎。Quartz是资源和设备无关的,提供路径绘制，anti-aliased呈现，剃度填充图案，图像，透明绘制和透明层、遮蔽和阴影、颜色管理，坐标转换，字体、offscreen呈现、pdf文档创建、显示和分析等功能。</p>
<p>Quartz 2D能够与所有的图形和动画技术（如Core Animation, OpenGL ES, 和 UIKit 等）一起使用。</p>
<p>Quartz 2D采用paint模式进行绘制。<br>Quartz 2D提供的主要类包括：</p>
<p>CGContext：表示一个图形环境；<br>CGPath：使用向量图形来创建路径，并能够填充和stroke；<br>CGImage：用来表示位图；<br>CGLayer：用来表示一个能够用于重复绘制和offscreen绘制的绘制层；<br>CGPattern：用来表示Pattern，用于重复绘制；<br>CGShading和 CGGradient：用于绘制剃度；<br>CGColor 和 CGColorSpace；用来进行颜色和颜色空间管理；<br>CGFont, 用于绘制文本；<br>CGPDFContentStream、CGPDFScanner、CGPDFPage、CGPDFObject,CGPDFStream, CGPDFString等用来进行pdf文件的创建、解析和显示。</p>
<p>在调用任何OpenGL ES 功能之前必须首先初始化一个EAGLContext 对象。每一个IOS应用的每一个线程都有一个当前context，在调用OpenGL ES函数时，使用或改变此context中的状态。</p>
<p>EAGLContext 的类方法setCurrentContext: 用来设置当前线程的当前context。EAGLContext 的类方法currentContext 返回当前线程的当前context。在切换相同线程的两个上下文之前，必须调用glFlush函数来确保先前已提交的命令被提交到图形硬件中。<br>为了创建全屏幕的视图或使OpenGL ES内容与UIKit视图集成，可以使用GLKit。在使用GLKit时，GLKit提供的类GLKView类本身实现呈现目标及创建和维护一个framebuffer。<br>1） GLKView 和GLKViewController类提供一个标准的OpenGL ES视图和相关联的呈现循环。GLKView可以作为OpenGL ES内容的呈现目标，GLKViewController提供内容呈现的控制和动画。视图管理和维护一个framebuffer，应用只需在framebuffer进行绘画即可。</p>
<p>2）GLKTextureLoader 为应用提供从IOS支持的各种图像格式的源自动加载纹理图像到OpenGL ES 图像环境的方式，并能够进行适当的转换，并支持同步和异步加载方式。</p>
<p>3）数学运算库，提供向量、矩阵、四元数的实现和矩阵堆栈操作等OpenGL ES 1.1功能。</p>
<p>4）Effect效果类提供标准的公共着色效果的实现。能够配置效果和相关的顶点数据，然后创建和加载适当的着色器。GLKit 包括三个可配置着色效果类：GLKBaseEffect实现OpenGL ES 1.1规范中的关键的灯光和材料模式, GLKSkyboxEffect提供一个skybox效果的实现, GLKReflectionMapEffect 在GLKBaseEffect基础上包括反射映射支持。</p>
<p>如果想要一个 iOS 上高性能的并行计算库，答案非常简单。Metal 是唯一的选择。OpenGL 在 iOS 上是私有框架，而 Core Image (使用了 OpenGL) 对这样的任务来说既不够强大又不够灵活。</p>
<h2 id="Core-Image"><a href="#Core-Image" class="headerlink" title="Core Image"></a>Core Image</h2><p>Core Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 滤镜链 将各种效果的 Filter叠加 起来形成强大的自定义效果</p>
<p>Core Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。</p>
<p>// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)<br>context = [CIContext contextWithOptions: [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextUseSoftwareRenderer]];</p>
<p>// 创建基于 GPU 的 CIContext 对象<br>context = [CIContext contextWithOptions: nil];</p>
<p>// 创建基于 GPU 的 CIContext 对象<br>EAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];<br>context = [CIContext contextWithEAGLContext:eaglctx];<br>GPUImage 在视频处理上有更好的表现。<br>GPUImage 的代码完成公开，实现透明。<br>可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift164%E5%AD%97%E8%8A%82%E5%BA%8F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift164%E5%AD%97%E8%8A%82%E5%BA%8F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">字节序问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:08:08" itemprop="dateCreated datePublished" datetime="2020-12-01T14:08:08+08:00">2020-12-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>Little endian<br>    简写：LE<br>    常见翻译：小端序，低端序<br>    解释：将低序字节存储在起始地址。就是高位值放在存储（可以认为是内存）的高位，低位值放在存储的低位，<br>        即：顺序写入到内存中。最符合人的思维，低位高位对应内存地址的高位低位。</p>
<p>Big endian<br>    简写：BE<br>    常见翻译：大端序，高端序<br>    解释：将高序字节存储在起始地址。地址低位存储值的高位，地址高位存储值的低位。<br>        即：一个二进制数，那么从高位到低位顺序写到内存中(内存是从低位到高位的，我们写数字的时候是从高位到低位)。<br>        所以这种方式是最直观的。</p>
<p>iOS中一般是Little endian</p>
<p>比如int数据bit大端许写法如下<br>void BufferPutInt(MapBuffer *pBuffer, int val) {<br>    if (pBuffer-&gt;m_pPtr &gt;= pBuffer-&gt;m_pEnd)<br>        return;<br>    pBuffer-&gt;m_pPtr[0] =  (val &gt;&gt; 24);<br>    pBuffer-&gt;m_pPtr[1] =  (val &gt;&gt; 16);<br>    pBuffer-&gt;m_pPtr[2] =  (val &gt;&gt; 8);<br>    pBuffer-&gt;m_pPtr[3] =  (val);<br>    pBuffer-&gt;m_pPtr += 4;<br>//    MEMCPY(pBuffer-&gt;m_pPtr, &amp;val, sizeof(int));<br>//    pBuffer-&gt;m_pPtr += sizeof(int);<br>}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/M_Swift165%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/M_Swift165%E5%9C%B0%E5%9B%BE%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD/" class="post-title-link" itemprop="url">地图开发技能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 14:08:08" itemprop="dateCreated datePublished" datetime="2020-12-01T14:08:08+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 15:40:55" itemprop="dateModified" datetime="2021-04-12T15:40:55+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="瓦片地图"><a href="#瓦片地图" class="headerlink" title="瓦片地图"></a>瓦片地图</h2><p>瓦片的切分方式。具体参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/8006049?fr=aladdin">https://baike.baidu.com/item/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/8006049?fr=aladdin</a></p>
<h2 id="webgl教程"><a href="#webgl教程" class="headerlink" title="webgl教程"></a>webgl教程</h2><p>参考网站：<a target="_blank" rel="noopener" href="https://www.yiibai.com/webgl/webgl_graphics_basics.html">https://www.yiibai.com/webgl/webgl_graphics_basics.html</a></p>
<h2 id="墨卡托投影"><a href="#墨卡托投影" class="headerlink" title="墨卡托投影"></a>墨卡托投影</h2><p>参考：<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A2%A8%E5%8D%A1%E6%89%98%E6%8A%95%E5%BD%B1/5477927?fr=aladdin">https://baike.baidu.com/item/%E5%A2%A8%E5%8D%A1%E6%89%98%E6%8A%95%E5%BD%B1/5477927?fr=aladdin</a></p>
<h2 id="相机："><a href="#相机：" class="headerlink" title="相机："></a>相机：</h2><p>透视投影：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/stl112514/article/details/83927643">https://blog.csdn.net/stl112514/article/details/83927643</a></p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>webgl使用矩阵实现平移，缩放。参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1005103">https://cloud.tencent.com/developer/article/1005103</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/M_Swift153GLSL%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/M_Swift153GLSL%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">GLES语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-24 14:25:04" itemprop="dateCreated datePublished" datetime="2020-11-24T14:25:04+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 16:09:15" itemprop="dateModified" datetime="2021-04-12T16:09:15+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GLSL-着色器编程语言"><a href="#GLSL-着色器编程语言" class="headerlink" title="GLSL(着色器编程语言)"></a>GLSL(着色器编程语言)</h1><p>1、介绍<br>是一个和C语言语法比较类似的着色器变成语言<br>2、注释<br>和C语言一样<br>// this is a comment<br>/*</p>
<ul>
<li>  this is muti comment</li>
<li>/<br>备注：GLSL语言必须由ASCII码字符组成，如果包括非ascii码编译会出错<br>3、变量命名<br>GLSL的变量名必须以字母或者下划线开头，由英文字母，数字，_组成，且不能是gl_或__开头(都是系统预留的)，也不能是系统关键字<br>4、预处理指令<br>预处理指令以#开头，#号之前不能有除了空白字符之外的任何字符。每一个指令独占一行。内置的预处理指令如下：<br>#define<br>#undef<br>#if<br>#ifdef<br>#ifndef<br>#else<br>#elif<br>#endif<br>#error<br>#pragma<br>#extension<br>#version<br>#line</li>
</ul>
<p>#pragma<br>编译指示。用来控制编译器的一些行为，开发和调试时可以设置为off，默认设为on。</p>
<p>#pragma optimize(on)<br>#pragma optimize(off)</p>
<p>开发和调试时可以打开debug选项，以便获取更多的调试信息。默认设为off。<br>#pragma debug(on)<br>#pragma debug(off)</p>
<p>#extension<br>如果想使用GLGL默认不支持的操作，则必须启用对应的扩展，启用一个扩展可以使用下面的命令：</p>
<p>#extension : behavior<br>#extension all : behavior<br>其中，extension_name是扩展的名称，all是指所有的编译器支持的扩展。<br>behavior是指对该扩展的具体操作。比如启用、禁用等等。详情如下：<br>behavior                                    作用<br>require                         启用该扩展。如果不支持，则报错。<br>enable                          启用该扩展。如果不支持，则会警告。extension_name是all的时候会报错。<br>warn                            启用该扩展。但是会检测到所有使用该扩展的地方，提出警告。<br>disable                         禁用该扩展。如果该扩展不被支持，则提出警告。</p>
<p>5、预定义的变量<br>除此之外，还预定义了一些变量：<br><strong>LINE</strong> ：int类型，当前的行号，也就是在Source String中是第一行<br><strong>FILE</strong> ：int类型，当前Source String的唯一ID标识<br><strong>VERSION</strong> ：int类型，GLGL的版本<br>GL_ES ：对于嵌入式系统（Embed System，简称 ES），它的值为1，否则为0</p>
<p>6、运算符及其优先级<br>| 1 |()<br>| 从右往左 |<br>| 3 | 乘除法 | * / % | 从左往右 |<br>| 4 | 加减法 | + - | 从左往右 |<br>| 5 | 位运算 移位 | &lt;&lt; &gt;&gt; | 从左往右 |<br>| 6 | 大小关系 | &lt; &gt; &lt;= &gt;= | 从左往右 |<br>| 7 | 相等性判断 | == != | 从左往右 |<br>| 8 | 位运算 与 | &amp; | 从左往右 |<br>| 9 | 位或算 非 | ^ | 从左往右 |<br>| 10 | 位或算 或 | | | 从左往右 |<br>| 11 | 逻辑与 | &amp;&amp; | 从左往右 |<br>| 12 | 逻辑或 | || | 从左往右 |</p>
<p>7、关键词<br>列举一下GLSL中的关键词，这些全部是系统保留的，不可私自篡改。</p>
<p>attribute const uniform varying<br>break continue do for while<br>if else<br>in out inout<br>float int void bool true false<br>lowp mediump highp precision invariant<br>discard return<br>mat2 mat3 mat4<br>vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4<br>sampler2D samplerCube<br>struct</p>
<p>asm<br>class union enum typedef template this packed<br>goto switch default<br>inline noinline volatile public static extern external interface flat<br>long short double half fixed unsigned superp<br>input output<br>hvec2 hvec3 hvec4 dvec2 dvec3 dvec4 fvec2 fvec3 fvec4<br>sampler1D sampler3D<br>sampler1DShadow sampler2DShadow<br>sampler2DRect sampler3DRect sampler2DRectShadow<br>sizeof cast<br>namespace using</p>
<p>除此之外，所有的以”__”开头的变量全部是预留的，自定义的变量不能以“__”开头。</p>
<h1 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hankern/article/details/85316476">https://blog.csdn.net/hankern/article/details/85316476</a><br>1.1 Vertex Shader<br>对于发送给GPU的每一个Vertex(顶点)，都要执行一次Vertex Shader。其功能是把每个顶点在虚拟空间中的三维坐标变换为可以在屏幕上显示的二维坐标，并带有用于z-buffer的深度信息。Vertex Shader可以操作的属性有：位置、颜色、纹理坐标，但是不能创建新的顶点。</p>
<p>vertex shader主要完成以下工作：1).基于点操作的矩阵乘法位置变换；2).根据光照公式计算每点的color值；3).生成或者转换纹理坐标。<br>Vertex Shader输入数据如下：<br>1).Attributes：由 vertext array 提供的顶点数据，如空间位置，法向量，纹理坐标以及顶点颜色，它是针对每一个顶点的数据。属性只在顶点着色器中才有，片元着色器中没有属性。属性可以理解为针对每一个顶点的输入数据。OpenGL ES 2.0 规定了所有实现应该支持的最大属性个数不能少于 8 个。<br>注：Vertex Attributes 是每点的属性数据。与一个index序号绑定。外部程序可通过 glBindAttribLocation将一个attribute 名与一个index绑定起来。当然，OPENGL ES 内部会自动绑定所有attributes.外部程序只需通过 glGetAttribLocation获取指定attribute名的index。 给Attribute传值可以通过 glVertexAttribPointer函数或者glVertexAttrib4fv</p>
<p>2).Uniforms：uniforms保存由应用程序传递给着色器的只读常量数据。在顶点着色器中，这些数据通常是变换矩阵，光照参数，颜色等。由 uniform 修饰符修饰的变量属于全局变量，该全局性对顶点着色器与片元着色器均可见，也就是说，这两个着色器如果被连接到同一 个program Object，则它们共享同一份 uniform 全局变量集。因此如果在这两个着色器中都声明了同名的 uniform 变量，要保证这对同名变量完全相同：同名+同类型，因为它们实际是同一个变量。此外，uniform 变量存储在常量存储区，因此限制了 uniform 变量的个数，OpenGL ES 2.0 也规定了所有实现应该支持的最大顶点着色器 uniform 变量个数不能少于 128 个，最大的片元着色器 uniform 变量个数不能少于 16 个。</p>
<p>3).Samplers：一种特殊的 uniform，在vertex shader中是可选的，用于呈现纹理。sampler 可用于顶点着色器和片元着色器。</p>
<p>4).Shader program：由 main 声明的一段程序源码，描述在顶点上执行的操作：如坐标变换，计算光照公式来产生 per-vertex 颜色或计算纹理坐标。</p>
<p>1.2 Fragment Shader<br>Pixel Shader(像素着色器)就是众所周知的Fragment Shader(片元着色器)，它计算每个像素的颜色和其它属性。它通过应用光照值、凹凸贴图，阴影，镜面高光，半透明等处理来计算像素的颜色并输出。它也可改变像素的深度(z-buffering)或在多个渲染目标被激活的状态下输出多种颜色。一个Pixel Shader不能产生复杂的效果，因为它只在一个像素上进行操作，而不知道场景的几何形状。</p>
<p>Fragment Shader输入数据如下：<br>1).Varyings：这个在前面已经讲过了，顶点着色器阶段输出的 varying 变量在光栅化阶段被线性插值计算之后输出到片元着色器中作为它的输入，即上图中的 gl_FragCoord，gl_FrontFacing 和 gl_PointCoord。OpenGL ES 2.0 也规定了所有实现应该支持的最大 varying 变量个数不能少于 8 个。<br>2).Uniforms：前面也已经讲过，这里是用于片元着色器的常量，如雾化参数，纹理参数等；OpenGL ES 2.0 也规定了所有实现应该支持的最大的片元着色器 uniform 变量个数不能少于 16 个。<br>3).Samples：一种特殊的 uniform，用于呈现纹理。<br>4).Shader program：由 main 申明的一段程序源码，描述在片元上执行的操作。<br>FragmentShader输出为：<br>在顶点着色器阶段只有唯一的 varying 输出变量-即内建变量：gl_FragColor</p>
<h1 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jxw167/article/details/55098260">https://blog.csdn.net/jxw167/article/details/55098260</a><br> 在游戏中模型的渲染显示，当模型被加载后，在引擎底层需要DX库或者OpenGL库提供数据缓冲从而将数据传输到GPU中渲染绘制，模型都是由数据组成的，这些数据需要OpenGL图形库渲染它们时开辟一块缓冲内存进行存放，OpenGL为我们开发者提供了很多函数接口供我们使用，作为开发者熟悉这些关于缓冲数据操作的接口对于学习Shader编程也非常有帮助，市面上的Unity引擎和UE4虚幻引擎也是基于这些函数开发的，本片博客主要是为读者揭秘OpenGL中的数据缓冲原理。<br> 在OpenGL中缓冲只是一块儿内存区域的对象，当把缓冲绑定到一个特定缓冲对象时，我们就给缓冲赋予了一个特殊的意义。当我们绑定到GL_ARRAY_BUFFER的时候，这个缓冲就是一个顶点数组缓冲，我们也可以简单地绑定到GL_ELEMENT_ARRAY_BUFFER。OpenGL内部为每个目标（target）储存一个缓冲，并基于目标来处理不同的缓冲。<br> 我们使用glBufferData函数填充缓冲对象管理的内存，这个函数分配了一块内存空间，然后把数据存入其中。如果我们向它的data这个参数传递的是NULL，那么OpenGL只会帮我们分配内存，而不会填充它。如果我们先打算开辟一些内存，稍后回到这个缓冲一点一点的填充数据，有些时候会很有用。</p>
<p> 我们还可以调用glBufferSubData函数填充特定区域的缓冲，而不是一次填充整个缓冲。这个函数需要一个缓冲目标（target），一个偏移量（offset），数据的大小以及数据本身作为参数。这个函数新的功能是我们可以给它一个偏移量（offset）来指定我们打算填充缓冲的位置与起始位置之间的偏移量。这样我们就可以插入/更新指定区域的缓冲内存空间了。一定要确保修改的缓冲要有足够的内存分配，所以在调用glBufferSubData之前，调用glBufferData是必须的。注意，glBufferData函数接口在Shader编程中使用的非常广泛。它的函数接口如下所示：</p>
<p> float data[] = {<br>   0.5f, 1.0f, -0.35f<br>   …<br> };</p>
<p> glBindBuffer(GL_ARRAY_BUFFER, buffer);<br> // 获取当前绑定缓存buffer的内存地址<br> void* ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);<br> // 向缓冲中写入数据<br> memcpy(ptr, data, sizeof(data));<br> // 完成够别忘了告诉OpenGL我们不再需要它了<br> glUnmapBuffer(GL_ARRAY_BUFFER);</p>
<p>调用glUnmapBuffer函数可以告诉OpenGL我们已经用完指针了，OpenGL会知道你已经做完了。通过解映射（unmapping），指针会不再可用，如果OpenGL可以把你的数据映射到缓冲上，就会返回GL_TRUE。</p>
<p>把数据直接映射到缓冲上使用glMapBuffer很有用，因为不用把它储存在临时内存里。你可以从文件读取数据然后直接复制到缓冲的内存里。</p>
<p>使用glVertexAttribPointer函数可以指定缓冲内容的顶点数组的属性的布局(Layout)。我们已经知道，通过使用顶点属性指针我们可以交叉(Interleave)属性，也就是说我们可以把每个顶点的位置、法线、纹理坐标放在彼此挨着的地方。现在我们了解了更多的缓冲的内容，可以采取另一种方式了。我们可以做的是把每种类型的属性的所有向量数据批量保存在一个布局，而不是交叉布局。</p>
<p>当从文件加载顶点数据时你通常获取一个位置数组，一个法线数组和一个纹理坐标数组。需要花点力气才能把它们结合为交叉数据。使用 glBufferSubData 可以简单的实现分批处理方式：<br>缓冲满足的条件：</p>
<p>建构一个完整的帧缓冲必须满足以下条件：</p>
<p>我们必须往里面加入至少一个附件（颜色、深度、模板缓冲）。<br>其中至少有一个是颜色附件。<br>所有的附件都应该是已经完全做好的（已经存储在内存之中）。<br>每个缓冲都应该有同样数目的样本。</p>
<h1 id="投影相机"><a href="#投影相机" class="headerlink" title="投影相机"></a>投影相机</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/24/M_Swift156OpenGLES%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/M_Swift156OpenGLES%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">OpenGL常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-24 10:32:44" itemprop="dateCreated datePublished" datetime="2020-11-24T10:32:44+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 16:09:51" itemprop="dateModified" datetime="2021-04-12T16:09:51+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创建buffers"><a href="#创建buffers" class="headerlink" title="创建buffers"></a>创建buffers</h1><p>1、void glGenFramebuffers(GLsizei n,GLuint * framebuffers);<br>创建frame buffers<br>2、void glDeleteFramebuffers(GLsizei n,const GLuint * framebuffers);<br>删除frame buffers<br>n表示buffers数量,framebuffers 表示buffer的数组<br>3、void glGenRenderbuffers(GLsizei n,GLuint * renderbuffers);<br>创建render buffers<br>4、void glDeleteRenderbuffers(GLsizei n,const GLuint * renderbuffers);<br>删除 render buffers<br>5、void glFramebufferRenderbuffer(GLenum target,GLenum attachment,GLenum renderbuffertarget,GLuint renderbuffer);<br>将render buffer关联到GL_FRAMEBUFFER常量上面<br>target:取值必须为GL_FRAMEBUFFER<br>attachment:取值为GL_COLOR_ATTACHMENT0, GL_DEPTH_ATTACHMENT, or GL_STENCIL_ATTACHMENT。一般视频渲染取GL_COLOR_ATTACHMENT0<br>renderbuffertarget:取值必须为GL_RENDERBUFFER<br>renderbuffer:要关联的render buffer的id(由glGenRenderbuffers()函数生成)<br>6、GLenum glCheckFramebufferStatus(GLenum target);<br>检查frame buffer相关是否成功，再glFramebufferRenderbuffer()之后调用去检查<br>tagert:GL_FRAMEBUFFER;<br>7.glEnableVertexAttribArray()或 者glDisableVertexAttribArray()<br>//— 告 诉 OpenGL ES 在接下来的渲染中是否使用缓存中的数据<br>glEnableVertexAttribArray(GLKVertexAttribPosition);</p>
<h1 id="着色器相关函数"><a href="#着色器相关函数" class="headerlink" title="着色器相关函数"></a>着色器相关函数</h1><p>1、GLuint glCreateShader(GLenum shaderType);<br>创建着色器程序的句柄；成功返回非0整数<br>shaderType:着色器类型，顶点和片元；取值GL_VERTEX_SHADER和GL_FRAGMENT_SHADER<br>2、void glShaderSource(GLuint shader,GLsizei count,const GLchar * const *string,const GLint *length);<br>为着色器句柄添加GLSL源代码<br>shader:前面创建的着色器句柄<br>count:源代码个数<br>string:源代码字符串<br>lenght:源代码字符串长度<br>3、void glCompileShader(GLuint shader);<br>编译着色器GLSL源码<br>4、void glGetShaderiv(GLuint shader,GLenum pname,GLint *params);<br>获取着色器编译过程中的日志和检测是否编译成功<br>// 检查编译中日志,logLenght&gt;0则说明有日志<br>glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;logLenght);<br>// 检查编译是否成功,成功status==GLTRUE<br>glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;status);<br>5、GLuint glCreateProgram(void);<br>创建用于生成顶点着色器和片元着色器最终程序的句柄<br>6、void glAttachShader(GLuint program,GLuint shader);<br>添加顶点着色器和片元着色器<br>program:第五步创建的program<br>shader:为前面编译成功的着色器句柄<br>7、void glLinkProgram(GLuint program);<br>连接程序,就像C语言的连接一样，这里将顶点着色器和片元着色器连接起来<br>8、void glGetProgramiv(GLuint program,GLenum pname,GLint *params);<br>输出连接过程中的日志和检查连接是否成功<br>// 检查编译中日志,logLenght&gt;0则说明有日志<br>glGetProgramiv(filterProgram, GL_INFO_LOG_LENGTH, &amp;logLength);<br>// 检查编译是否成功,成功status==GLTRUE<br>glGetProgramiv(filterProgram, GL_LINK_STATUS, &amp;status);<br>9、void glUseProgram(GLuint program);<br>调用此函数后着色器程序才能正常使用，就相当于生成可执行程序后还得点击一下让其运行起来一样；之后才能使用第10个之后的函数<br>10、GLint glGetAttribLocation(GLuint program,const GLchar *name);<br>获取顶点着色器中的attribute修饰的变量的句柄，后面就可以通过该句柄从应用端向GLSL对应的变量传值了<br>program:对应的GLSL程序，该函数必须在GLSL程序运行后才能使用(即调用了glUseProgram()函数)<br>name:GLSL中attribute修饰的变量名<br>11、GLint glGetUniformLocation(GLuint program,const GLchar *name);<br>获取片元着色器中uniform sampler2D修饰的变量的句柄，后面就可以将该句柄和对应的纹理单元关联起来<br>program:对应的GLSL程序，该函数必须在GLSL程序运行后才能使用(即调用了glUseProgram()函数)<br>name:GLSL中uniform sampler2D修饰的变量名</p>
<h1 id="视窗有关函数"><a href="#视窗有关函数" class="headerlink" title="视窗有关函数"></a>视窗有关函数</h1><p>1、void glClearColor(GLclampf red,GLclampf green,GLclampf blue,GLclampf alpha);<br>设置清屏的颜色,四个参数的范围都是0-1的浮点数，表示RGBA的组合<br>2、void glClear(GLbitfield mask);<br>用前面glClearColor(),glClearDepthf(),and glClearStencil()设置的颜色清除buffers;<br>mask在这个函数中的取值要与上面三个函数一一对应，可取值如下：<br>GL_COLOR_BUFFER_BIT:color buffer，前面如果调用了glClearColor()，则设置包含该值<br>GL_DEPTH_BUFFER_BIT：depth buffer，前面如果调用了glClearDepthf()，则设置包含该值<br>GL_STENCIL_BUFFER_BIT：stencil buffer，前面如果调用了glClearStencil()，则设置包含该值<br>mask可以是上面几个值的组合,比如GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT,但前提是前面分别调用了glClearColor()和glClearDepthf()设置颜色</p>
<p>3、void glViewport(GLint x,GLint y,GLsizei width,GLsizei height);<br>以当前视图的大小为基础(当前视图的左下角为坐标原点)在开辟一个(x,y,width,height)的渲染区域，该区域将作为后面顶点坐标等的参考坐标系。</p>
<h1 id="纹理操作相关函数-应用端和opengl-es传值相关函数"><a href="#纹理操作相关函数-应用端和opengl-es传值相关函数" class="headerlink" title="纹理操作相关函数,应用端和opengl es传值相关函数"></a>纹理操作相关函数,应用端和opengl es传值相关函数</h1><p>4、void glPixelStorei(GLenum pname,GLint param);<br>设置像素的对齐方式；<br>pname:为GL_PACK_ALIGNMENT,会影响glReadPixels()函数从opengl es缓存中读取像素数据到app中的字节对齐方式<br>pname:为GL_UNPACK_ALIGNMENT，会影响glTexImage2D() 和 glTexSubImage2D()函数从app发送像素数据到opengl es的字节对齐方式<br>param:表示每次读取或者发送的像素数据是param的整数倍;举个例子，比如param为4，想要通过glTexImage2D()传输5x5像素的一张图片(25不是4的整数倍，所以需要手<br>动添加padding即添加3个字节到这个图片buf中,这样读取时才不会出错，如果param为1就没有这样的烦恼，但是可能性能会低，值越大吞吐量就越大，效率也越高。<br>那么上面两种方式的取值含义都是一样的,<br>默认值为4；取值如下：<br>1 (byte-alignment),<br>2 (rows aligned to even-numbered bytes),<br>4 (word-alignment),<br>8 (rows start on double-word boundaries).</p>
<p>5、void glDrawArrays(GLenum mode,GLint first,GLsizei count);<br>确定要绘制的几何形状；通过mode指定，可取值如下：<br>GL_POINTS:绘制点，那么顶点着色器还需要有gl_PointSize内建变量指定顶点的大小<br>GL_LINES:绘制线<br>GL_TRIANGLE_STRIP:绘制三角形，比如绘制纹理图片就是这种类型<br>它处于渲染管线的第一阶段</p>
<p>6、void glVertexAttribPointer(GLuint index,GLint size,GLenum type,GLboolean normalized,GLsizei stride,const GLvoid * pointer);<br>用一个数组的方式给GLSL中attribute修饰的属性变量赋值;<br>index:前面获取的GLSL变量的句柄<br>size:表示每几个元素表示一个attribute修饰的变量;比如对于attribute vec4 position;修饰的顶点,就表示四个数据(x,y,z,w)才能表示一个顶点坐标，如果这里size为<br>2，那么x,y有值，z，w将默认为0,依次类推。<br>type:每个元素的数据类型，取值为GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_FIXED, or GL_FLOAT<br>normalized:是否要对pointer中的数据进行归一化处理成(-1.0,1.0)范围的浮点型类型,如果已经是浮点型，这里传GL_FALSE即可。<br>stride:获取每一个元素是否需要跳字节，如果前面的type类型pointer中元素类型一致，这里传0<br>pointer:几何形状的各个顶点组成的数组;对于矩形来说，数组中顶点顺序为(左下角，右下角，左上角，右上角)<br>该赋值得用glEnableVertexAttribArray()函数启用后才会生效</p>
<p>7、void glUniform1i(GLint location,GLint v0);<br>给片段着色器中的uniform sampler2D 修饰的纹理变量赋值，只有该函数调用后,片元着色器中的texture2D()函数才能正确工作<br>location:为片元着色器中uniform sampler2D 修饰的变量句柄<br>v0的取值为纹理单元的索引；比如想让激活的GL_TEXTURE2和上面的变量关联，则v0取值为2，那么片元着色器中的texture2D()函数将从该纹理单元对应的纹理里面查找像素</p>
<p>8、void glEnableVertexAttribArray(GLuint index);<br>   void glDisableVertexAttribArray(GLuint index);<br>启用和禁用给attribute变量的赋值</p>
<p>9、void glGetIntegerv(GLenum pname,GLint * params);<br>获取指定类型的值<br>GL_ACTIVE_TEXTURE:获取设备支持的纹理单元数目<br>GL_MAX_TEXTURE_SIZE:获取设备支持的纹理能渲染的最大的长或宽大小，超过此大小则必须先压缩再传给opengl es，否则opengl es无法渲染</p>
<p>10、void glGenTextures(GLsizei n,GLuint * textures);<br>    void glDeleteTextures(GLsizei n,const GLuint * textures);<br>创建纹理Id和删除纹理Id<br>调用删除纹理Id函数会解除它与纹理类型对象的绑定</p>
<p>11、void glActiveTexture(GLenum texture);<br>选择指定的纹理单元，texture取值范围GL_TEXTUREi(i取值为0-GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1)，其中GL_TEXTURE0默认激活的<br>方式一、glActioveTexture(GL_TEXTUREi);只能到GL_TEXTURE31<br>方式二、glActioveTexture(GL_TEXTURE0+i);i可以取值到GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1</p>
<p>12、void glBindTexture(GLenum target,GLuint texture);<br>绑定纹理，当绑定完后，如果用其它texture再次与target绑定，则先前的绑定失效。或者调用glDeleteTextures()函数后，该绑定也将失效<br>target:纹理类型，可取值：GL_TEXTURE_2D、GL_TEXTURE_CUBE_MAP<br>texture:纹理id，由glGenTextures()函数生成<br>函数10和11的工作流程用伪代码表示如下：<br>GLenum curentTexutre;<br>GLESObj globalObj;<br>glActiveTexture(GLenum texture)<br>{<br>curentTexutre = texture;<br>}<br>glBindTexture(GLenum target,GLuint texture)<br>{<br>TextureUnit *texUnit = globalObj[curentTexutre];<br>switch(target)<br>{<br>case GL_TEXTURE_1D: texUnit-&gt;targetTexture1D = textureObject; break;<br>case GL_TEXTURE_2D: texUnit-&gt;targetTexture2D = textureObject; break;<br>case GL_TEXTURE_3D: texUnit-&gt;targetTexture3D = textureObject; break;<br>case GL_TEXTURE_CUBEMAP: texUnit-&gt;targetTextureCube = textureObject; break;<br>}<br>glTexImage2D(….)<br>{<br>    TextureUnit *texUnit = globalObj[curentTexutre];<br>    texUnit-&gt;targetTexture2D-&gt;TexImage2D(…);<br>    ……<br>}<br>所以如果调用glActiveTexture()之后不调用glBindTexture()函数，其实后面的glxxx()系列函数设置的参数只是对curentTexutre有效，会造成值被覆盖</p>
<p>13、void glTexParameteri(GLenum target,GLenum pname,GLint param);<br>给指定的纹理类型对象设定参数<br>warping<br>纹理坐标的范围是(0,1)当给定的纹理坐标超过这个范围时，将通过如下方式对超过的纹理坐标进行采样<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_WARP_S,GL_REPEAT) S轴方向<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_WARP_T,GL_REPEAT) T轴方向<br>GL_REPEAT,GL_MIRRODED_REPEAT    (经过试验，此这两种方式视乎无效，GL_REPEAT默认)<br>GL_CLAMP_TO_EDGE 超出的部分坐标被设置成0或者1，行程边缘色<br>filter<br>实际纹理的分辨率大小与要显示的屏幕区域的分辨率大小往往不相等，也就是要根据屏幕的实际大小对纹理进行放大和缩小，这里就需要用到filter，取值如下：<br>GL_NEAREST:最邻近插值，取最近的纹素像素<br>GL_LINEAR:线性插值，取最近的点的线性平均值 (性能消耗较大)<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR)<br>glTexParameter(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR)<br>mipmaps<br>它也是一种纹理过滤算法，按我的理解它是以空间换时间的一种技巧，具体原理就是事先根据纹理生成长和宽逐渐除以2的小纹理，比如原始纹理大小128x128，<br>采用此方法后，会生成64x64 32x32 16x16 8x8 4x4 2x2 1x1的一系列纹理，如果需要20x18的纹理，则取最近的32x32 16x16进行平均<br>该方法很好的解决了如下问题：<br>1、当纹理很大，但是屏幕区域很小，渲染出现的闪烁问题，因为根据最邻近插值和线性插值都无法很快计算出合理的像素<br>它可以取的值如下：<br>GL_NEAREST_MIPMAP_NEAREST 选择最近的mipmap层，然后再用最邻近过滤插值<br>GL_LINEAR_MIPMAP_NEAREST    选择最近mipmap层，然后再用线性插值<br>GL_NEAREST_MIPMAP_LINEAR    选择最近的2层mipmap用最邻近过滤插值<br>GL_LINEAR_MIPMAP_LINEAR       选择最邻近的2层mipmap用线性插值<br>使用如下函数生成mipmaps<br>glGenerateMipmap(GLenum target);</p>
<p>14、void glTexImage2D(GLenum target,    // 纹理对象类型，取值GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z或者<br>GLint level,    // 纹理压缩等级，0代表不压缩，默认0<br>GLint internalformat,// 内部每个像素的构成格式,取值GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_RGBA.<br>GLsizei width,  // 纹理的宽，单位像素<br>GLsizei height, // 纹理的高，单位像素<br>GLint border,   // 设置为0 即可<br>GLenum format,  // data中每个像素的构成格式，必须与internalformat保持一直，取值为GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.<br>GLenum type,    // data中像素数据的组织方式,取值 GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, and GL_UNSIGNED_SHORT_5_5_5_1.<br>const GLvoid * data // 代表一张图片的像素数据<br>);<br>GL_ALPHA<br>表示data中每个像素只有一个透明通道，当它传递给opengl es时，自动将RGB填充为0。<br>GL_RGB<br>表示data中每个像素只由RGB三个数组成，当它传递给opengl es时，自动将Alpha填充为1。<br>GL_RGBA<br>表示data中每个像素只由RGBA四个数组成，传递给Opengl es时，原封不动的传递<br>GL_LUMINANCE<br>表示data中每个像素只有一个值组成，当它传递给opengl es时，自动将RGB填充为该值，alpha填充为1<br>GL_LUMINANCE_ALPHA<br>表示data中每个像素只有一个值组成，当它传递给opengl es时，自动将RGB填充为该值，alpha原封不动<br>GL_UNSIGNED_BYTE<br>表示组成每个像素的通道占用8位该值可以与前面任何格式搭配使用<br>GL_UNSIGNED_SHORT_5_6_5<br>表示RGB分别占用6 6 5位,一个像素两个字节，该值只能与前面GL_RGB搭配<br>GL_UNSIGNED_SHORT_4_4_4_4，<br>表示RGBA 分别占用4位，一个像素两个字节，该值只能与前面GL_RGB搭配GL_RGBA<br>GL_UNSIGNED_SHORT_5_5_5_1，<br>表示RGBA 分别占用 5551位，一个像素两个字节，该值只能与前面GL_RGB搭配GL_RGBA</p>
<p>15、void glTexSubImage2D(    GLenum target,<br>GLint level,<br>GLint xoffset,<br>GLint yoffset,<br>GLsizei width,<br>GLsizei height,<br>GLenum format,<br>GLenum type,<br>const GLvoid * data);<br>用法和第15个函数一样，只不过可以选取data中的部分数据传递，更加灵活</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/02/M_Swift162iOS%E5%9C%B0%E5%9B%BE%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/M_Swift162iOS%E5%9C%B0%E5%9B%BE%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">地图计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-02 09:38:22" itemprop="dateCreated datePublished" datetime="2020-11-02T09:38:22+08:00">2020-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算经纬度之间的距离"><a href="#计算经纬度之间的距离" class="headerlink" title="计算经纬度之间的距离"></a>计算经纬度之间的距离</h2><p>  /*!<br>     @brief 计算经纬度之间的距离<br>     @param a a点<br>     @param b b点<br>     @return 距离，单位：米<br>     */<br>    CLLocationDistance MAMetersBetweenMapPoints(CLLocationCoordinate2D a, CLLocationCoordinate2D b)<br>    {<br>        CLLocation *curLocation = [[CLLocation alloc] initWithLatitude:a.latitude longitude:a.longitude];<br>        CLLocation *otherLocation = [[CLLocation alloc] initWithLatitude:b.latitude longitude:b.longitude];<br>        return [curLocation distanceFromLocation:otherLocation];<br>    }</p>
<p>static const double a = 6378245.0;<br>static const double ee = 0.00669342162296594323;<br>static const double pi = M_PI;<br>static const double xPi = M_PI  * 3000.0 / 180.0;</p>
<h2 id="GPS转高德"><a href="#GPS转高德" class="headerlink" title="GPS转高德"></a>GPS转高德</h2><ul>
<li>(CLLocationCoordinate2D)transformFromWGSToGCJ:(CLLocationCoordinate2D)wgsLoc {<br>  CLLocationCoordinate2D adjustLoc;<br>  if([self isLocationOutOfChina:wgsLoc]) {<pre><code>  adjustLoc = wgsLoc;
</code></pre>
  }<br>  else {<pre><code>  double adjustLat = [self transformLatWithX:wgsLoc.longitude - 105.0 withY:wgsLoc.latitude - 35.0];
  double adjustLon = [self transformLonWithX:wgsLoc.longitude - 105.0 withY:wgsLoc.latitude - 35.0];
  long double radLat = wgsLoc.latitude / 180.0 * pi;
  long double magic = sin(radLat);
  magic = 1 - ee * magic * magic;
  long double sqrtMagic = sqrt(magic);
  adjustLat = (adjustLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);
  adjustLon = (adjustLon * 180.0) / (a / sqrtMagic * cos(radLat) * pi);
  adjustLoc.latitude = wgsLoc.latitude + adjustLat;
  adjustLoc.longitude = wgsLoc.longitude + adjustLon;
</code></pre>
  }<br>  return adjustLoc;<br>}<h2 id="GPS转百度"><a href="#GPS转百度" class="headerlink" title="GPS转百度"></a>GPS转百度</h2></li>
<li>(CLLocationCoordinate2D)transformFromWGSToBaidu:(CLLocationCoordinate2D)p {<br>  CLLocationCoordinate2D coo =[NSValue transformFromWGSToGCJ:p];<br>  return [NSValue transformFromGCJToBaidu:coo];<br>}<h2 id="百度转GPS"><a href="#百度转GPS" class="headerlink" title="百度转GPS"></a>百度转GPS</h2></li>
<li>(CLLocationCoordinate2D)transformFromBaiduToWGS:(CLLocationCoordinate2D)p {<br>   CLLocationCoordinate2D start_coor = [NSValue transformFromBaiduToGCJ:p];<br>   return [NSValue transformFromGCJToWGS:start_coor];<br>}<h2 id="百度转高德"><a href="#百度转高德" class="headerlink" title="百度转高德"></a>百度转高德</h2></li>
<li>(CLLocationCoordinate2D)transformFromBaiduToGCJ:(CLLocationCoordinate2D)p {<br>  double x = p.longitude - 0.0065, y = p.latitude - 0.006;<br>  double z = sqrt(x * x + y * y) - 0.00002 * sin(y * xPi);<br>  double theta = atan2(y, x) - 0.000003 * cos(x * xPi);<br>  CLLocationCoordinate2D geoPoint;<br>  geoPoint.latitude  = z * sin(theta);<br>  geoPoint.longitude = z * cos(theta);<br>  return geoPoint;<br>}<h2 id="高德转百度"><a href="#高德转百度" class="headerlink" title="高德转百度"></a>高德转百度</h2></li>
<li>(CLLocationCoordinate2D)transformFromGCJToBaidu:(CLLocationCoordinate2D)p {<br>  long double z = sqrt(p.longitude * p.longitude + p.latitude * p.latitude) + 0.00002 * sqrt(p.latitude * pi);<br>  long double theta = atan2(p.latitude, p.longitude) + 0.000003 * cos(p.longitude * pi);<br>  CLLocationCoordinate2D geoPoint;<br>  geoPoint.latitude  = (z * sin(theta) + 0.006);<br>  geoPoint.longitude = (z * cos(theta) + 0.0065);<br>  return geoPoint;<br>}<h2 id="高德转GPS"><a href="#高德转GPS" class="headerlink" title="高德转GPS"></a>高德转GPS</h2></li>
<li>(CLLocationCoordinate2D)transformFromGCJToWGS:(CLLocationCoordinate2D)p {<br>  double threshold = 0.00001;  // The boundary<br>  double minLat = p.latitude - 0.5;<br>  double maxLat = p.latitude + 0.5;<br>  double minLng = p.longitude - 0.5;<br>  double maxLng = p.longitude + 0.5;  double delta = 1;<br>  int maxIteration = 30;<br>  // Binary search<br>  while(true) {<pre><code>  CLLocationCoordinate2D leftBottom  = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = minLat,.longitude = minLng&#125;];
  CLLocationCoordinate2D rightBottom = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = minLat,.longitude = maxLng&#125;];
  CLLocationCoordinate2D leftUp      = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = maxLat,.longitude = minLng&#125;];
  CLLocationCoordinate2D midPoint    = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = ((minLat + maxLat) / 2),.longitude = ((minLng + maxLng) / 2)&#125;];
  delta = fabs(midPoint.latitude - p.latitude) + fabs(midPoint.longitude - p.longitude);
  
  if(maxIteration-- &lt;= 0 || delta &lt;= threshold) &#123;
      return (CLLocationCoordinate2D)&#123;.latitude = ((minLat + maxLat) / 2),.longitude = ((minLng + maxLng) / 2)&#125;;
  &#125;
  
  if(isContains(p, leftBottom, midPoint)) &#123;
      maxLat = (minLat + maxLat) / 2;
      maxLng = (minLng + maxLng) / 2;
  &#125; else if(isContains(p, rightBottom, midPoint)) &#123;
      maxLat = (minLat + maxLat) / 2;
      minLng = (minLng + maxLng) / 2;
  &#125; else if(isContains(p, leftUp, midPoint)) &#123;
      minLat = (minLat + maxLat) / 2;
      maxLng = (minLng + maxLng) / 2;
  &#125; else &#123;
      minLat = (minLat + maxLat) / 2;
      minLng = (minLng + maxLng) / 2;
  &#125;
</code></pre>
  }</li>
</ul>
<p>}</p>
<ul>
<li>(double)transformLatWithX:(double)x withY:(double)y {<br>  double lat = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt(fabs(x));<br>  lat += (20.0 * sin(6.0 * x * pi) + 20.0 *sin(2.0 * x * pi)) * 2.0 / 3.0;<br>  lat += (20.0 * sin(y * pi) + 40.0 * sin(y / 3.0 * pi)) * 2.0 / 3.0;<br>  lat += (160.0 * sin(y / 12.0 * pi) + 320 * sin(y * pi / 30.0)) * 2.0 / 3.0;<br>  return lat;<br>}</li>
<li>(double)transformLonWithX:(double)x withY:(double)y {<br>  double lon = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt(fabs(x));<br>  lon += (20.0 * sin(6.0 * x * pi) + 20.0 * sin(2.0 * x * pi)) * 2.0 / 3.0;<br>  lon += (20.0 * sin(x * pi) + 40.0 * sin(x / 3.0 * pi)) * 2.0 / 3.0;<br>  lon += (150.0 * sin(x / 12.0 * pi) + 300.0 * sin(x / 30.0 * pi)) * 2.0 / 3.0;<br>  return lon;<br>}<h2 id="判断某个点point是否在p1和p2之间"><a href="#判断某个点point是否在p1和p2之间" class="headerlink" title="判断某个点point是否在p1和p2之间"></a>判断某个点point是否在p1和p2之间</h2>static bool isContains(CLLocationCoordinate2D point, CLLocationCoordinate2D p1, CLLocationCoordinate2D p2) {<br>  return (point.latitude &gt;= MIN(p1.latitude, p2.latitude) &amp;&amp; point.latitude &lt;= MAX(p1.latitude, p2.latitude)) &amp;&amp; (point.longitude &gt;= MIN(p1.longitude,p2.longitude) &amp;&amp; point.longitude &lt;= MAX(p1.longitude, p2.longitude));<br>}</li>
</ul>
<h2 id="粗略判断是不是在中国"><a href="#粗略判断是不是在中国" class="headerlink" title="粗略判断是不是在中国"></a>粗略判断是不是在中国</h2><ul>
<li>(BOOL)isLocationOutOfChina:(CLLocationCoordinate2D)location {<br>  if (location.longitude &lt; 72.004 || location.longitude &gt; 137.8347 || location.latitude &lt; 0.8293 || location.latitude &gt; 55.8271)<pre><code>  return YES;
</code></pre>
  return NO;<br>}<h2 id="弧线计算"><a href="#弧线计算" class="headerlink" title="弧线计算"></a>弧线计算</h2>double x1 = pArc.startCoordinate.longitude;<br>double y1 = pArc.startCoordinate.latitude;<br>double x2 = pArc.passedCoordinate.longitude;<br>double y2 = pArc.passedCoordinate.latitude;<br>double x3 = pArc.endCoordinate.longitude;<br>double y3 = pArc.endCoordinate.latitude;<br>double a = 2 * (x2 - x1);<br>double b = 2 * (y2 - y1);<br>double c = x2 * x2 + y2 * y2 - x1 * x1 - y1 * y1;<br>double d = 2 * (x3 - x2);<br>double e = 2 * (y3 - y2);<br>double f = x3 * x3 + y3 * y3 - x2 * x2 - y2 * y2;<br>double x = (b * f - e * c) / (b * d - e * a);<br>double y = (d * c - a * f) / (b * d - e * a);<br>double r = sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));<br>double angle1 = acos((x1 - x) / r);<br>if (y1 - y &lt; 0)<br>  angle1 = -angle1;<br>double angle2 = acos((x2 - x) / r);<br>if (y2 - y &lt; 0)<br>  angle2 = -angle2;<br>double angle3 = acos((x3 - x) / r);<br>if (y3 - y &lt; 0)<br>  angle3 = -angle3;<br>double deltaAngle1 = angle1 - angle2;</li>
</ul>
<p>while (deltaAngle1 &gt; M_PI)<br>    deltaAngle1 -= M_PI * 2;<br>while (deltaAngle1 &lt;= -M_PI)<br>    deltaAngle1 += M_PI * 2;<br>int numPoints1 = (int) (128 * fabs(deltaAngle1) / M_PI);<br>double phase1 = deltaAngle1 / numPoints1;<br>double deltaAngle2 = angle2 - angle3;<br>while (deltaAngle2 &gt; M_PI)<br>    deltaAngle2 -= M_PI * 2;<br>while (deltaAngle2 &lt;= -M_PI)<br>    deltaAngle2 += M_PI * 2;<br>int numPoints2 = (int) (128 * fabs(deltaAngle2) / M_PI);<br>double phase2 = deltaAngle2 / numPoints2;<br>int pointCnt = numPoints1 + numPoints2 + 1;<br>CLLocationCoordinate2D coos[pointCnt];<br>pointCnt = 0;<br>coos[pointCnt] = CLLocationCoordinate2DMake(y1, x1);<br>pointCnt++;<br>for (int i = 1; i &lt; numPoints1; i++) {<br>    coos[pointCnt] = CLLocationCoordinate2DMake((y + r * sin(angle1 - phase1 * i)),(x + r * cos(angle1 - phase1 * i)));<br>    pointCnt++;<br>}<br>coos[pointCnt] = CLLocationCoordinate2DMake(y2, x2);<br>pointCnt++;<br>for (int i = 1; i &lt; numPoints2; i++) {<br>    coos[pointCnt] = CLLocationCoordinate2DMake((y + r * sin(angle2 - phase2 * i)),(x + r * cos(angle2 - phase2 * i)));<br>    pointCnt++;<br>}<br>coos[pointCnt] = CLLocationCoordinate2DMake(y3, x3);<br>pointCnt++;</p>
<h2 id="图片截图"><a href="#图片截图" class="headerlink" title="图片截图"></a>图片截图</h2><ul>
<li>(UIImage *)takeSnapshotInRect:(CGRect)rect {<br>  UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, [UIScreen mainScreen].scale);<br>  [self drawViewHierarchyInRect:self.bounds afterScreenUpdates:YES];<br>  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();<br>  UIGraphicsEndImageContext();<br>  if (CGRectEqualToRect(rect, self.bounds)) {<pre><code>  return image;
</code></pre>
  }<br>  CGFloat scale = image.scale;<br>  CGRect scaledRect = CGRectMake(rect.origin.x * scale, rect.origin.y * scale, rect.size.width * scale, rect.size.height * scale);<br>  CGImageRef rectImage = CGImageCreateWithImageInRect(image.CGImage,scaledRect);<br>  return [UIImage imageWithCGImage:rectImage];<br>}<h2 id="地图手势"><a href="#地图手势" class="headerlink" title="地图手势"></a>地图手势</h2>// 单击<br>UITapGestureRecognizer * singletapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onSingleTap:)];<br>  [singletapGesture setNumberOfTapsRequired:1];<br>  [singletapGesture setNumberOfTouchesRequired:1];<br>  [self addGestureRecognizer:singletapGesture];<br>双击<br>  UITapGestureRecognizer * doubletapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onDoubleTap:)];<br>  [doubletapGesture setNumberOfTapsRequired: 2];<br>  [doubletapGesture setNumberOfTouchesRequired: 1];<br>  [self addGestureRecognizer:doubletapGesture];<br>  [singletapGesture requireGestureRecognizerToFail:doubletapGesture];<br>长按<br>  UILongPressGestureRecognizer* longPressGr = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)];<br>  [self addGestureRecognizer:longPressGr];<br>缩放<br>  UITapGestureRecognizer *m_pZoomoutGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onZoomOut:)];<br>  [m_pZoomoutGesture setNumberOfTapsRequired:1];<br>  [m_pZoomoutGesture setNumberOfTouchesRequired:2];<br>  [self addGestureRecognizer:m_pZoomoutGesture];<br>拖拽<br>  m_pSinglePanGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(onScroll:)];<br>  [m_pSinglePanGesture setMaximumNumberOfTouches:1];<br>  [self addGestureRecognizer:m_pSinglePanGesture];<br>旋转<br>  UIPanGestureRecognizer * doublePanGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(onOverlook:)];<br>  [doublePanGesture setMinimumNumberOfTouches:2];<br>  [self addGestureRecognizer:doublePanGesture];<br>  m_pPinchGesture = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(onPinch:)];<br>  m_pPinchGesture.delegate = self;<br>  [self addGestureRecognizer:m_pPinchGesture];<br>缩放<br>  m_pRotateGesture = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(onRotate:)];<br>  m_pRotateGesture.delegate = self;<br>  [self addGestureRecognizer:m_pRotateGesture];</li>
</ul>
<h2 id="比例尺绘制"><a href="#比例尺绘制" class="headerlink" title="比例尺绘制"></a>比例尺绘制</h2><ul>
<li><p>(void)drawRect:(CGRect)rect {</p>
<p>  CGContextRef context = UIGraphicsGetCurrentContext();</p>
<p>  CGContextSetRGBStrokeColor(context, 0.0f, 0.0f, 0.0f, 1.0f); //画笔颜色<br>  CGContextSetLineWidth(context, 1.0); //线宽</p>
<p>  CGFloat scale = [UIScreen mainScreen].scale;<br>  int zoomLevel = self.zoomLevel;</p>
<p>  int iLength = (MASCALE_DISTANCES[zoomLevel] /([self.mapView metersPerPointForZoomLevel:zoomLevel] * scale));<br>  if (iLength &gt;200) {</p>
<pre><code>  iLength = 200;
</code></pre>
<p>  }<br>  int iStartX = rect.origin.x;<br>  int iStartY = rect.size.height - 12;<br>  int iEndY = rect.size.height - 9;<br>  NSString *name = MASCALE_DISTANCESNAME[zoomLevel];<br>  [name drawInRect:CGRectMake(iStartX + SCALE_NAME_STARTX, iStartY - 13, rect.size.width, rect.size.height) withFont:[UIFont systemFontOfSize:10.0]];</p>
<p>  CGPoint points[2];//坐标点<br>  points[0] = CGPointMake(iStartX, iEndY);//坐标1<br>  points[1] = CGPointMake(iStartX + iLength, iEndY);//坐标2<br>  CGContextAddLines(context, points, 2);//添加线<br>  CGContextDrawPath(context, kCGPathStroke);</p>
<p>  points[0] = CGPointMake(iStartX, iStartY); //坐标1<br>  points[1] = CGPointMake(iStartX, iEndY); //坐标2<br>  CGContextAddLines(context, points, 2); //添加线<br>  CGContextDrawPath(context, kCGPathStroke);</p>
<p>  points[0] = CGPointMake(iStartX + iLength, iStartY);//坐标1<br>  points[1] = CGPointMake(iStartX + iLength, iEndY);//坐标2<br>  CGContextAddLines(context, points, 2);//添加线<br>  CGContextDrawPath(context, kCGPathStroke);<br>}</p>
</li>
</ul>
<h2 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h2><ul>
<li>(CGFloat)lineDistance:(CGPoint)point linePoint1:(CGPoint)line1 linePoint2:(CGPoint)line2<br>{<br>  CGFloat se =  (line1.x-line2.x)<em>(line1.x-line2.x)+(line1.y-line2.y)</em>(line1.y-line2.y);//线段两点距离平方<br>  CGFloat p = ((point.x-line1.x)<em>(line2.x-line1.x)+(point.y-line1.y)</em>(line2.y-line1.y)); //向量点乘=|a|<em>|b|<em>cosA<br>  CGFloat r = p / se; //r即点到线段的投影长度与线段长度比<br>  CGFloat outx = line1.x + r * (line2.x-line1.x);<br>  CGFloat outy = line1.y+r</em>(line2.y-line1.y);<br>  CGFloat des =(point.x-outx)</em>(point.x-outx)+(point.y-outy)*(point.y-outy);<br>  return sqrt(des);<br>}</li>
</ul>
<h2 id="检查某点是否包含在多边形的范围内-判断多边形是否被点击"><a href="#检查某点是否包含在多边形的范围内-判断多边形是否被点击" class="headerlink" title="检查某点是否包含在多边形的范围内(判断多边形是否被点击"></a>检查某点是否包含在多边形的范围内(判断多边形是否被点击</h2><ul>
<li>(BOOL)PointInPoly:(CGPoint *)poly count:(int)count point:(CGPoint)pt {<br>  BOOL c = false;<br>  int i = -1, l = count;<br>  for (int j = l - 1; ++i &lt; l; j = i){<pre><code>  ((poly[i].y &lt;= pt.y &amp;&amp; pt.y &lt; poly[j].y) || (poly[j].y &lt;= pt.y &amp;&amp; pt.y &lt; poly[i].y)) &amp;&amp; (pt.x &lt; (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) &amp;&amp; (c = !c);
</code></pre>
  }<br>  return c;<br>}<h2 id="判断折线是否被点击"><a href="#判断折线是否被点击" class="headerlink" title="判断折线是否被点击"></a>判断折线是否被点击</h2>  原理：点到线的距离是否大与线的宽度<br>  MAPolylineRenderer *line = (MAPolylineRenderer *)ovlay;<br>  CLLocationCoordinate2D *coo = line.polyline.points;<br>  long count = line.polyline.pointCount;<br>  for (int i = 0; i &lt; count - 1; i++) {<pre><code>  CLLocationCoordinate2D item = coo[i];
  CLLocationCoordinate2D item1 = coo[i + 1];
  CGPoint point1 = [m_pSkMap lonlat2Pixel:item];
  CGPoint point2 = [m_pSkMap lonlat2Pixel:item1];
  CGFloat dis = [self lineDistance:point linePoint1:point1 linePoint2:point2];
  if (dis &lt; line.lineWidth * 3) &#123; // 为了防止点不上，给进行了加大处理
      return line.polyline;
  &#125;
</code></pre>
  }<h2 id="判断是否在弧形上"><a href="#判断是否在弧形上" class="headerlink" title="判断是否在弧形上"></a>判断是否在弧形上</h2>  原理：同线的点击<br>  MAArcRenderer *arcRenderer = (MAArcRenderer *)ovlay;<br>  MAArc *arc = arcRenderer.arc;<br>  int count = arc.pointCount;<br>  CLLocationCoordinate2D *coo = arc.points;<br>  for (int i = 0; i &lt; count - 1; i++) {<pre><code>  CLLocationCoordinate2D item = coo[i];
  CLLocationCoordinate2D pointCoo = [m_pSkMap pixel2LonLat:point];
  CLLocationDistance dis = MAMetersBetweenMapPoints(item,pointCoo);
  CGFloat zoom = [m_pSkMap getZoom];
 if (dis &lt; arcRenderer.lineWidth * 500 / zoom) &#123; // 为了防止点不上，给进行了加大处理
     return arc;
 &#125;
</code></pre>
 }<h2 id="判断是否在圆内"><a href="#判断是否在圆内" class="headerlink" title="判断是否在圆内"></a>判断是否在圆内</h2>  原理：点到圆心的距离小于半径<br>  MACircleRenderer *circle = (MACircleRenderer *)ovlay;<br>  CLLocationCoordinate2D coo = circle.circle.coordinate;<br>  CLLocationCoordinate2D sele = [m_pSkMap pixel2LonLat:point];<br>  double dis = MAMetersBetweenMapPoints(coo,sele);<br>  if (dis &lt; circle.circle.radius) {<pre><code>  return circle.circle;
</code></pre>
  }<h2 id="判断矩形画图标是否被点击"><a href="#判断矩形画图标是否被点击" class="headerlink" title="判断矩形画图标是否被点击"></a>判断矩形画图标是否被点击</h2>  判断点击是否在矩形图标rect内<br>  MAMarkerRenderer *mark = (MAMarkerRenderer *)ovlay;<br>  CGPoint markPoint = [m_pSkMap lonlat2Pixel:mark.marker.coordinate];<br>  CGSize imageSize = mark.imageSize;<br>  CGFloat scale = 1;<br>  if (mark.image) { // 不规则图形处理<pre><code>  scale = mark.imageSize.height / mark.imageSize.width;
  if (scale &gt; 1) &#123;
      imageSize.width = mark.imageSize.width / scale;
      imageSize.height = mark.imageSize.height / scale;
      markPoint.x = markPoint.x + imageSize.width / scale;
  &#125;else&#123;
      imageSize.width = mark.imageSize.width * scale;
      imageSize.height = mark.imageSize.height * scale;
  &#125;
</code></pre>
  }<br>  CGRect rect = CGRectMake(markPoint.x, markPoint.y, imageSize.width,imageSize.height);<br>  if (CGRectContainsPoint(rect,point)) {<pre><code>  return mark.marker;
</code></pre>
  }</li>
</ul>
<h2 id="覆盖物的拖拽："><a href="#覆盖物的拖拽：" class="headerlink" title="覆盖物的拖拽："></a>覆盖物的拖拽：</h2><pre><code>1.通过长按手势触发拖拽
2.通过判断是否点击了多边形，判断是否在拖拽覆盖物
3.计算移动的坐标数量，获取覆盖物新的坐标位置
4.修改覆盖物坐标位置
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/02/M_Swift154OpenGL%E6%9C%AF%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/M_Swift154OpenGL%E6%9C%AF%E8%AF%AD/" class="post-title-link" itemprop="url">OpenGL术语</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-02 09:26:55" itemprop="dateCreated datePublished" datetime="2020-11-02T09:26:55+08:00">2020-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>2D+透视 = 3D</p>
<h2 id="3D术语"><a href="#3D术语" class="headerlink" title="3D术语"></a>3D术语</h2><p>光栅化：实际绘制或填充每个顶点之间的像素形成过程</p>
<p>着色：沿着顶点之间改变颜色值，能够轻松创建光照照射到一个立方体的效果</p>
<p>纹理贴图：将纹理图片附着到你绘图的图像上</p>
<p>混合：颜色混合效果</p>
<p>渲染：表示计算机从模型创建最终图像的过程</p>
<p>顶点处理：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在现有的GPU中，这些工作由硬件实现的Vertex Shader（顶点着色器）完成。</p>
<p>光栅化计算：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。</p>
<p>纹理帖图：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture mapping）工作完成对多变形表面的帖图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成“真实”的图形。TMU（Texture mapping unit）即是用来完成此项工作。</p>
<p>像素处理：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel Shader（像素着色器）完成。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context是一个非常抽象的概念，我们姑且把它理解成一个包含了所有OpenGL状态的对象。如果我们把一个Context销毁了，那么OpenGL也不复存在。</p>
<h2 id="OpenGL对象"><a href="#OpenGL对象" class="headerlink" title="OpenGL对象"></a>OpenGL对象</h2><p>我们可以把OpenGL对象理解成一个状态的集合，它负责管理它下属的所有状态。当然，除了状态，OpenGL对象还会存储其他数据。注意。这些状态和上述context中的状态并不重合，只有在把一个OpenGL对象绑定到context上时，OpenGL对象的各种状态才会映射到context的状态。因此，这时如果我们改变了context的状态，那么也会影响这个对象，而相反地，依赖这些context状态的函数也会使用存储在这个对象上的数据。</p>
<p>OpenGL对象包含了下面一些类型：Buffer Objects，Vertex Array Objects，Textures，Framebuffer Objects等等。我们下面会讲到Vertex Array Objects这个对象。</p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>渲染（Rendering）：计算机从模型到创建一张图像的过程。OpenGL仅仅是其中一个渲染系统。它是一个基于光栅化的系统，其他的系统还有光线追踪（但有时也会用到OpenGL）等。</p>
<p>模型（Models）或者对象（Objects）：这里两者的含义是一样的。指从几何图元——点、线、三角形中创建的东西，由顶点指定。</p>
<p>Shaders：这是一类特殊的函数，是在图形硬件上执行的。我们可以理解成，Shader是一些为图形处理单元（GPU）编译的小程序。OpenGL包含了编译工具来把我们编写的Shader源代码编译成可以在GPU上运行的代码。在OpenGL中，我们可以使用四种shader阶段。最常见的就是vertex shaders——它们可以处理顶点数据；以及fragment shaders，它们处理光栅化后生成的fragments。vertex shaders和fragment shaders是每个OpenGL程序必不可少的部分。</p>
<p>像素（pixel）：像素是我们显示器上的最小可见元素。我们系统中的像素被存储在一个帧缓存（framebuffer）中。帧缓存是一块由图形硬件管理的内存空间，用于供给给我们的显示设备。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/29/M_Swift158iOS%20OpenGL%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/29/M_Swift158iOS%20OpenGL%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">ios OpenGL 加载图片流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-29 10:20:12" itemprop="dateCreated datePublished" datetime="2020-09-29T10:20:12+08:00">2020-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 15:54:14" itemprop="dateModified" datetime="2021-04-12T15:54:14+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-采用C的FILE方式读取图片"><a href="#1-采用C的FILE方式读取图片" class="headerlink" title="1.采用C的FILE方式读取图片"></a>1.采用C的FILE方式读取图片</h2><pre><code>FILE *fp = fopen(texfile, &quot;rb&quot;);
if(NULL == fp)&#123;
    LOGE(&quot;png can&#39;t openfile:%s\n&quot;, texfile);
    return 0;
&#125;
fseek(fp, 0, SEEK_END);
length = (int)ftell(fp);
fseek(fp, 0, SEEK_SET);
//LOGD(&quot;png file length:%s %d\n&quot;, texfile, length);
pngRawData = (unsigned char*)malloc(length);
fread(pngRawData, 1, length, fp);
fclose(fp);
</code></pre>
<h2 id="2-采用OC-CGImageRef-处理图片"><a href="#2-采用OC-CGImageRef-处理图片" class="headerlink" title="2.采用OC CGImageRef 处理图片"></a>2.采用OC CGImageRef 处理图片</h2><pre><code>CGImageRef cgImageRef = [UIImage imageWithData:[NSData dataWithBytes:data length:length]].CGImage;
GLuint width = (GLuint)CGImageGetWidth(cgImageRef);
GLuint height = (GLuint)CGImageGetHeight(cgImageRef);
CGRect rect = CGRectMake(0, 0, width, height);

CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
void *imageData = malloc(width * height * 4);
CGContextRef context = CGBitmapContextCreate(imageData, width, height, 8, width * 4, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);
//    出现反转的问题
//    CGContextTranslateCTM(context, 0, height);
//    CGContextScaleCTM(context, 1.0f, -1.0f);
CGColorSpaceRelease(colorSpace);
CGContextClearRect(context, rect);
CGContextDrawImage(context, rect, cgImageRef);
UIGraphicsBeginImageContext(CGSizeMake(width, height));
</code></pre>
<h2 id="3-采用opengl绑定图片，获取图片id"><a href="#3-采用opengl绑定图片，获取图片id" class="headerlink" title="3.采用opengl绑定图片，获取图片id"></a>3.采用opengl绑定图片，获取图片id</h2><pre><code>GLuint textureID;
glGenTextures(1, &amp;textureID);
glBindTexture(GL_TEXTURE_2D, textureID);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imageData);

glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

glBindTexture(GL_TEXTURE_2D, 0);

CGContextRelease(context);
free(imageData);

return textureID;
</code></pre>
<h2 id="4在使用图片是时候调用gl方法渲染图片"><a href="#4在使用图片是时候调用gl方法渲染图片" class="headerlink" title="4在使用图片是时候调用gl方法渲染图片"></a>4在使用图片是时候调用gl方法渲染图片</h2><pre><code>glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
glEnable(GL_TEXTURE_2D);
glEnableClientState(GL_TEXTURE_COORD_ARRAY);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
glBindTexture(GL_TEXTURE_2D, pLC-&gt;m_IconTex);
glVertexPointer(2, GL_FLOAT, sizeof(IconPoint), (char*)pLC-&gt;m_pIconPoints);
glTexCoordPointer(2, GL_FLOAT, sizeof(IconPoint), (char*)pLC-&gt;m_pIconPoints + 8);
glDrawArrays(GL_TRIANGLES, 0, pLC-&gt;m_iIconPointCnt);

glDisableClientState(GL_TEXTURE_COORD_ARRAY);
glDisable(GL_TEXTURE_2D);
glDisable(GL_BLEND);
</code></pre>
<h2 id="5-使用GLKView搭配OpenGL方式"><a href="#5-使用GLKView搭配OpenGL方式" class="headerlink" title="5.使用GLKView搭配OpenGL方式"></a>5.使用GLKView搭配OpenGL方式</h2><pre><code>创建一个继承于GLKView的试图
添加context
self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES1];
[EAGLContext setCurrentContext:self.context];
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">269</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
