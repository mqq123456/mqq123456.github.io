<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Men的博客">
<meta property="og:url" content="http://example.com/page/19/index.html">
<meta property="og:site_name" content="Men的博客">
<meta property="og:description" content="博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="门乾强">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Men的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Men的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎光临！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift144%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift144%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">二叉树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:26" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:26+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h2><pre><code>void traverse(TreeNode root) &#123;
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
&#125;
非递归前序遍历
void preorder(TreeNode *root, vector&lt;int&gt;&amp; res)
&#123;
    stack&lt; pair&lt;TreeNode*, bool&gt; &gt; s;
    s.push(make_pair(root, false));
    bool visited;
    while(!s.empty()) &#123;
        root = s.top().first;
        visited = s.top().second;
        s.pop();
        if(root == NULL) &#123;
            continue;
        &#125;
        if(visited) &#123;
            res.push_back(root-&gt;val);
        &#125; else &#123;
            // 后序遍历
            s.push(make_pair(root-&gt;right, false));
            // 中序遍历
            s.push(make_pair(root-&gt;left, false));
            // 前序遍历
            s.push(make_pair(root, true));
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的广度优先搜索-（从上到下打印二叉树）"><a href="#二叉树的广度优先搜索-（从上到下打印二叉树）" class="headerlink" title="二叉树的广度优先搜索 （从上到下打印二叉树）"></a>二叉树的广度优先搜索 （从上到下打印二叉树）</h2><pre><code>本质上是前序遍历，用一个队列存储二叉树的（先入先出）
public int[] levelOrder(TreeNode root) &#123;
    if(root == null) return new int[0];
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;
    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
    while(!queue.isEmpty()) &#123;
        TreeNode node = queue.poll();
        ans.add(node.val);
        if(node.left != null) queue.add(node.left);
        if(node.right != null) queue.add(node.right);
    &#125;
    int[] res = new int[ans.size()];
    for(int i = 0; i &lt; ans.size(); i++)
        res[i] = ans.get(i);
    return res;
&#125;
</code></pre>
<h2 id="二叉树的深度优先搜索"><a href="#二叉树的深度优先搜索" class="headerlink" title="二叉树的深度优先搜索"></a>二叉树的深度优先搜索</h2><pre><code>本质上是二叉树的后续遍历，用栈存储（先入后出）
public class Solution &#123;
public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;
    ArrayList&lt;Integer&gt; lists=new ArrayList&lt;Integer&gt;();
    if(root==null)
        return lists;
    Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;();
    stack.push(root);
    while(!stack.isEmpty())&#123;
        TreeNode tree=stack.pop();
　　　 //先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。
            if(tree.right!=null)
                stack.push(tree.right);
            if(tree.left!=null)
                stack.push(tree.left);
            lists.add(tree.val);
        &#125;
        return lists;
    &#125;
&#125;
</code></pre>
<h2 id="树的子结构-（判断B是不是A的子结构。）"><a href="#树的子结构-（判断B是不是A的子结构。）" class="headerlink" title="树的子结构 （判断B是不是A的子结构。）"></a>树的子结构 （判断B是不是A的子结构。）</h2><pre><code>本质是二叉树的递归遍历（递归判断左右子树是不是相同）
代码步骤：A和B不能是Null，A和B相同、A的左边和B相同、A的右边和B相同
public boolean isSubStructure(TreeNode A, TreeNode B) &#123;
      return (A != null &amp;&amp; B != null) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    &#125;
    boolean recur(TreeNode A, TreeNode B) &#123;
        if(B == null) return true;
        if(A == null || A.val != B.val) return false;
        return recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);
    &#125;
</code></pre>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><pre><code>本质是二叉树的递归遍历 （交换left和right）
代码步骤：判断是否是空、交换左右的遍历结果
public TreeNode mirrorTree(TreeNode root) &#123;
        if(root == null) return null;
        TreeNode tmp = root.left;
        root.left = mirrorTree(root.right);
        root.right = mirrorTree(tmp);
        return root;
    &#125;
方法二：辅助栈（或队列）
利用栈（或队列）遍历树的所有节点 node ，并交换每个 node 的左 / 右子节点。
 public TreeNode mirrorTree(TreeNode root) &#123;
        if(root == null) return null;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
        while(!stack.isEmpty()) &#123;
            TreeNode node = stack.pop();
            if(node.left != null) stack.add(node.left);
            if(node.right != null) stack.add(node.right);
            TreeNode tmp = node.left;
            node.left = node.right;
            node.right = tmp;
        &#125;
        return root;
    &#125;
</code></pre>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><pre><code>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树
二叉树的先序遍历
// 判断左右两个数的左边和右边是不是一样，递归调用前序遍历
public boolean isSymmetric(TreeNode root) &#123;
        //方法调用
        return isSymmetric(root,root);
    &#125;

public boolean isSymmetric(TreeNode root1,TreeNode root2)&#123;
    if(root1 == null &amp;&amp; root2 == null)&#123;
        return true;
    &#125;

    //某结点只有一个子结点，故不对称，所以返回false
    if(root1 == null || root2 == null)&#123;
        return false;
    &#125;

    //对称结点存在，但是值不相同
    if(root1.val != root2.val)&#123;
        return false;
    &#125;

    //递归调用左子节点和右子节点
    return isSymmetric(root1.left, root2.right) &amp;&amp; isSymmetric(root1.right,root2.left);
&#125;
</code></pre>
<h2 id="从上到下打印二叉树-同一层的节点按从左到右的顺序打印"><a href="#从上到下打印二叉树-同一层的节点按从左到右的顺序打印" class="headerlink" title="从上到下打印二叉树 同一层的节点按从左到右的顺序打印"></a>从上到下打印二叉树 同一层的节点按从左到右的顺序打印</h2><pre><code>前序遍历，用队列存储每一层的值
将每一层数据存放到队列中
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) &#123;
            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();
            for(int i = queue.size(); i &gt; 0; i--) &#123;
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            &#125;
            res.add(tmp);
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="从上到下打印二叉树-之字形顺序打印二叉树"><a href="#从上到下打印二叉树-之字形顺序打印二叉树" class="headerlink" title="从上到下打印二叉树 之字形顺序打印二叉树"></a>从上到下打印二叉树 之字形顺序打印二叉树</h2><pre><code>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
方法一：层序遍历 + 双端队列
利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列），奇数层 则添加至 尾部，偶数层添加至头部
 public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) &#123;
            LinkedList&lt;Integer&gt; tmp = new LinkedList&lt;&gt;();
            for(int i = queue.size(); i &gt; 0; i--) &#123;
                TreeNode node = queue.poll();
                if(res.size() % 2 == 0) tmp.addLast(node.val); // 偶数层 -&gt; 队列头部
                else tmp.addFirst(node.val); // 奇数层 -&gt; 队列尾部
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            &#125;
            res.add(tmp);
        &#125;
        return res;
    &#125;
</code></pre>
<h2 id="二叉搜索树的后序"><a href="#二叉搜索树的后序" class="headerlink" title="二叉搜索树的后序"></a>二叉搜索树的后序</h2><pre><code>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。
每一层判断左右子树和根节点的大小关系，如果满足则继续向下判断；否则直接返回失败
递归分治 / 单调栈， 遍历顺序为 “左、右、根” 
    二叉搜索树定义： 左子树中所有节点的值 &lt; 根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。
    public boolean verifyPostorder(int[] postorder) &#123;
        return recur(postorder, 0, postorder.length - 1);
    &#125;
    boolean recur(int[] postorder, int i, int j) &#123;
        if(i &gt;= j) return true;
        int p = i;
        while(postorder[p] &lt; postorder[j]) p++;
        int m = p;
        while(postorder[p] &gt; postorder[j]) p++;
        return p == j &amp;&amp; recur(postorder, i, m - 1) &amp;&amp; recur(postorder, m, j - 1);
    &#125;
</code></pre>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><pre><code>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。
前序遍历：从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
 LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();
    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); 
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;
        recur(root, sum);
        return res;
    &#125;
    void recur(TreeNode root, int tar) &#123;
        if(root == null) return;
        path.add(root.val);
        tar -= root.val;
        if(tar == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)
            res.add(new LinkedList(path));
        recur(root.left, tar);
        recur(root.right, tar);
        path.removeLast();
    &#125;
</code></pre>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><pre><code>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
本文解法基于性质：二叉搜索树的中序遍历为 递增序列 。排序链表，双向链表。循环链表\
并在访问每个节点时构建 
cur 和前驱节点   pre 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可
中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 
head 和  pre 的双向节点引用即可。
Node pre, head;
    public Node treeToDoublyList(Node root) &#123;
        if(root == null) return null;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    &#125;
    void dfs(Node cur) &#123;
        if(cur == null) return;
        dfs(cur.left);
        if(pre != null) pre.right = cur;
        else head = cur;
        cur.left = pre;
        pre = cur;
        dfs(cur.right);
    &#125;
</code></pre>
<h2 id="序列化二叉树-层序遍历-BFS"><a href="#序列化二叉树-层序遍历-BFS" class="headerlink" title="序列化二叉树  层序遍历 BFS"></a>序列化二叉树  层序遍历 BFS</h2><pre><code>定义 StringBuilder 前序遍历拼接，删除最后一个逗号
 public String serialize(TreeNode root) &#123;
        if(root == null) return &quot;[]&quot;;
        StringBuilder res = new StringBuilder(&quot;[&quot;);
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
        while(!queue.isEmpty()) &#123;
            TreeNode node = queue.poll();
            if(node != null) &#123;
                res.append(node.val + &quot;,&quot;);
                queue.add(node.left);
                queue.add(node.right);
            &#125;
            else res.append(&quot;null,&quot;);
        &#125;
        res.deleteCharAt(res.length() - 1);
        res.append(&quot;]&quot;);
        return res.toString();
    &#125;

public TreeNode deserialize(String data) &#123;
    if(data.equals(&quot;[]&quot;)) return null;
    String[] vals = data.substring(1, data.length() - 1).split(&quot;,&quot;);
    TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;
    int i = 1;
    while(!queue.isEmpty()) &#123;
        TreeNode node = queue.poll();
        if(!vals[i].equals(&quot;null&quot;)) &#123;
            node.left = new TreeNode(Integer.parseInt(vals[i]));
            queue.add(node.left);
        &#125;
        i++;
        if(!vals[i].equals(&quot;null&quot;)) &#123;
            node.right = new TreeNode(Integer.parseInt(vals[i]));
            queue.add(node.right);
        &#125;
        i++;
    &#125;
    return root;
&#125;
</code></pre>
<h2 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h2><pre><code>第k小的话，我觉得可以反过来遍历
class Solution &#123;
    int res, k;
    public int kthLargest(TreeNode root, int k) &#123;
        this.k = k;
        dfs(root);
        return res;
    &#125;
    void dfs(TreeNode root) &#123;
        if(root == null) return;
        dfs(root.right);
        if(k == 0) return;
        if(--k == 0) res = root.val;
        dfs(root.left);
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h2><pre><code>BST 的特性：BST 的中序遍历是升序序列。
通过构造 BST 的中序遍历序列，则第 k-1 个元素就是第 k 小的元素
方法一：递归
class Solution &#123;
  public ArrayList&lt;Integer&gt; inorder(TreeNode root, ArrayList&lt;Integer&gt; arr) &#123;
    if (root == null) return arr;
    inorder(root.left, arr);
    arr.add(root.val);
    inorder(root.right, arr);
    return arr;
  &#125;

  public int kthSmallest(TreeNode root, int k) &#123;
    ArrayList&lt;Integer&gt; nums = inorder(root, new ArrayList&lt;Integer&gt;());
    return nums.get(k - 1);
  &#125;
&#125;
</code></pre>
<h2 id="二叉树的深度（后序遍历）"><a href="#二叉树的深度（后序遍历）" class="headerlink" title="二叉树的深度（后序遍历）"></a>二叉树的深度（后序遍历）</h2><pre><code>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
方法一：后序遍历（DFS）
  public int maxDepth(TreeNode root) &#123;
        if(root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    &#125;

方法二：层序遍历（BFS）
class Solution &#123;
    public int maxDepth(TreeNode root) &#123;
        if(root == null) return 0;
        List&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;
        int res = 0;
        while(!queue.isEmpty()) &#123;
            tmp = new LinkedList&lt;&gt;();
            for(TreeNode node : queue) &#123;
                if(node.left != null) tmp.add(node.left);
                if(node.right != null) tmp.add(node.right);
            &#125;
            queue = tmp;
            res++;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><pre><code>递归，0.1，
class Solution &#123;
  public int minDepth(TreeNode root) &#123;
    if (root == null) &#123;
      return 0;
    &#125;

    if ((root.left == null) &amp;&amp; (root.right == null)) &#123;
      return 1;
    &#125;

    int min_depth = Integer.MAX_VALUE;
    if (root.left != null) &#123;
      min_depth = Math.min(minDepth(root.left), min_depth);
    &#125;
    if (root.right != null) &#123;
      min_depth = Math.min(minDepth(root.right), min_depth);
    &#125;

    return min_depth + 1;
  &#125;
&#125;
方法2:广度优先搜索迭代
class Solution &#123;
  public int minDepth(TreeNode root) &#123;
    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = new LinkedList&lt;&gt;();
    if (root == null) &#123;
      return 0;
    &#125;
    else &#123;
      stack.add(new Pair(root, 1));
    &#125;

    int current_depth = 0;
    while (!stack.isEmpty()) &#123;
      Pair&lt;TreeNode, Integer&gt; current = stack.poll();
      root = current.getKey();
      current_depth = current.getValue();
      if ((root.left == null) &amp;&amp; (root.right == null)) &#123;
        break;
      &#125;
      if (root.left != null) &#123;
        stack.add(new Pair(root.left, current_depth + 1));
      &#125;
      if (root.right != null) &#123;
        stack.add(new Pair(root.right, current_depth + 1));
      &#125;
    &#125;
    return current_depth;
  &#125;
&#125;
</code></pre>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><pre><code>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
方法一：后序遍历 + 剪枝 （从底至顶）
class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        return recur(root) != -1;
    &#125;

private int recur(TreeNode root) &#123;
    if (root == null) return 0;
    int left = recur(root.left);
    if(left == -1) return -1;
    int right = recur(root.right);
    if(right == -1) return -1;
    return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1;
&#125;
&#125;
方法二：先序遍历 + 判断深度 （从顶至底）
class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);
    &#125;

    private int depth(TreeNode root) &#123;
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><pre><code>用集合遍历根树，保存Hashmap
用set保存一个二叉树在集合中的结果
遍历另一个二叉树，看set中是否有，有则为最近公共祖先
方法一：迭代
class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        if(p.val &gt; q.val) &#123; // 保证 p.val &lt; q.val
            TreeNode tmp = p;
            p = q;
            q = tmp;
        &#125;
        while(root != null) &#123;
            if(root.val &lt; p.val) // p,q 都在 root 的右子树中
                root = root.right; // 遍历至右子节点
            else if(root.val &gt; q.val) // p,q 都在 root 的左子树中
                root = root.left; // 遍历至左子节点
            else break;
        &#125;
        return root;
    &#125;
&#125;
方法二：递归
class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)
            return lowestCommonAncestor(root.right, p, q);
        if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)
            return lowestCommonAncestor(root.left, p, q);
        return root;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h2><h2 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a>最小高度树</h2><pre><code>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。
二分，拿到中间元素，然后递归创建左右子树
class Solution &#123;
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        int n = nums.size();
        return createTree(nums, 0, n - 1);
    &#125;
    TreeNode* createTree(vector&lt;int&gt;&amp; nums, int start, int end) &#123;
        if (start &gt; end) return nullptr;
        int mid = (start + end) &gt;&gt; 1;
        TreeNode* root = new TreeNode(nums[mid]);
        root-&gt;left = createTree(nums, start, mid - 1);
        root-&gt;right = createTree(nums, mid + 1, end);
        return root;
    &#125;
&#125;;
</code></pre>
<h2 id="合法二叉搜索树"><a href="#合法二叉搜索树" class="headerlink" title="合法二叉搜索树"></a>合法二叉搜索树</h2><pre><code>实现一个函数，检查一棵二叉树是否为二叉搜索树。
双百，递归遍历树，分别检查左右根节点的大小
    public boolean isValidBST(TreeNode root) &#123;
        if(root==null) return true;
        return isValidBSThelp(root.left,Long.MIN_VALUE,root.val)&amp;&amp;isValidBSThelp(root.right,root.val,Long.MAX_VALUE);
    &#125;
    private boolean isValidBSThelp(TreeNode root,long min,long max)&#123;
        if(root==null) return true;
        if(root.val&lt;=min||root.val&gt;=max) return false;
        boolean left = isValidBSThelp(root.left,min,root.val);
        boolean right = isValidBSThelp(root.right,root.val,max);
        return left &amp;&amp; right;
    &#125;
</code></pre>
<h2 id="二叉树中最大路径和"><a href="#二叉树中最大路径和" class="headerlink" title="二叉树中最大路径和"></a>二叉树中最大路径和</h2><pre><code>给定一个非空二叉树，返回其最大路径和。
递归计算，更新max，（递归中返回较大的）
class Solution &#123;
    int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) &#123;
    maxGain(root);
    return maxSum;
&#125;

public int maxGain(TreeNode node) &#123;
    if (node == null) &#123;
        return 0;
    &#125;
    
    // 递归计算左右子节点的最大贡献值
    // 只有在最大贡献值大于 0 时，才会选取对应子节点
    int leftGain = Math.max(maxGain(node.left), 0);
    int rightGain = Math.max(maxGain(node.right), 0);

    // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
    int priceNewpath = node.val + leftGain + rightGain;

    // 更新答案
    maxSum = Math.max(maxSum, priceNewpath);

    // 返回节点的最大贡献值
    return node.val + Math.max(leftGain, rightGain);
&#125;
&#125;
</code></pre>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><pre><code>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
输入: 
    Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
         3
        / \
       4   5
      / \   \ 
     5   4   7
public class Solution &#123;
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;
        if (t1 == null)
            return t2;
        if (t2 == null)
            return t1;
        t1.val += t2.val;
        t1.left = mergeTrees(t1.left, t2.left);
        t1.right = mergeTrees(t1.right, t2.right);
        return t1;
    &#125;
&#125;
</code></pre>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><pre><code>public TreeNode invertTree(TreeNode root) &#123;
    if (root == null) &#123;
        return null;
    &#125;
    TreeNode right = invertTree(root.right);
    TreeNode left = invertTree(root.left);
    root.left = right;
    root.right = left;
    return root;
&#125;
</code></pre>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><pre><code>给定一个二叉树，我们在树的节点上安装摄像头。
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
计算监控树的所有节点所需的最小摄像头数量。
根据每个节点的左右子节点来判断当前节点的状态，因此左右根后续遍历
class Solution &#123;
public:
    //记录需要放置摄像头的数量
    int res = 0;
    int minCameraCover(TreeNode* root) 
    &#123;
        //后序遍历，从下自上遍历。
        //若遍历至最上面，root标志为0，则多加一个摄像头
        if(dfs(root) == 0)
        &#123;
            res++;  
        &#125;
        return res;
    &#125;
    int dfs(TreeNode* root)
    &#123;

    //0：未被覆盖(当前节点未被照到)
    //1：已被覆盖(摄像头已经照到这个节点)
    //2：需放置摄像头

    //到根节点，
    if(root == NULL) return 1;
    //遍历左节点
    int left = dfs(root-&gt;left);
    //遍历右节点
    int right = dfs(root-&gt;right);
    //一个节点左右确定后，判断左右节点情况
    //所有情况00,01,02,11,12,22
    //左右孩子中有一个未被覆盖，则当前节点需要放置摄像头，当前节点标志为2
    if(left ==0 || right==0)
    &#123;
        res++;
        return 2;
    &#125;
    //左右孩子均为已覆盖状态,则当前节点未被覆盖，标志为0
    if(left == 1 &amp;&amp; right == 1)
    &#123;
        return 0;
    &#125;
    //若左右孩子为一个覆盖一个放置了摄像头，则当前节点为已被覆盖，标志为1
    if(left+right &gt;= 3)
    &#123;
        return 1;
    &#125;
    //此时已经组合完了根节点所有情况，随便返回一个整数即可
    return 0;
&#125;
&#125;;
</code></pre>
<h2 id="验证二叉树"><a href="#验证二叉树" class="headerlink" title="验证二叉树"></a>验证二叉树</h2><pre><code>如果一棵树是一个二叉树的话 必定除了根节点 每个非空节点的入度都为1
样例还给了某一个节点被两个&quot;父节点&quot;引用的例子 那这个节点的入度就为2了 也就不能构成二叉树

public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) &#123;
    int[] in = new int[n];
    for (int i = 0; i &lt; n; i++) &#123;
        if (leftChild[i] != -1) in[leftChild[i]]++;
        if (rightChild[i] != -1) in[rightChild[i]]++;
    &#125;

    int count0 = 0;
    int countOther = 0;
    for (int temp : in) &#123;
        if (temp == 0) count0++;
        if (temp &gt; 1) countOther++;
    &#125;
    return count0 == 1 &amp;&amp; countOther == 0;
&#125;
</code></pre>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><pre><code>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：
二叉树的根是数组中的最大元素。
左子树是通过数组中最大值左边部分构造出的最大二叉树。
右子树是通过数组中最大值右边部分构造出的最大二叉树。
public class Solution &#123;
    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;
        return construct(nums, 0, nums.length);
    &#125;
    public TreeNode construct(int[] nums, int l, int r) &#123;
        if (l == r)
            return null;
        int max_i = max(nums, l, r);
        TreeNode root = new TreeNode(nums[max_i]);
        root.left = construct(nums, l, max_i);
        root.right = construct(nums, max_i + 1, r);
        return root;
    &#125;
    public int max(int[] nums, int l, int r) &#123;
        int max_i = l;
        for (int i = l; i &lt; r; i++) &#123;
            if (nums[max_i] &lt; nums[i])
                max_i = i;
        &#125;
        return max_i;
    &#125;
&#125;
</code></pre>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><pre><code>给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。
class Solution &#123;
  public boolean helper(TreeNode node, Integer lower, Integer upper) &#123;
    if (node == null) return true;
    int val = node.val;
    if (lower != null &amp;&amp; val &lt;= lower) return false;
    if (upper != null &amp;&amp; val &gt;= upper) return false;

    if (! helper(node.right, val, upper)) return false;
    if (! helper(node.left, lower, val)) return false;
    return true;
&#125;

public boolean isValidBST(TreeNode root) &#123;
    return helper(root, null, null);
  &#125;
&#125;
</code></pre>
<h2 id="单值二叉树"><a href="#单值二叉树" class="headerlink" title="单值二叉树"></a>单值二叉树</h2><pre><code>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
我们先进行一次深度优先搜索，获取这颗树中的所有节点的值。然后，就可以判断所有节点的值是不是都相等了。
class Solution &#123;
    List&lt;Integer&gt; vals;
    public boolean isUnivalTree(TreeNode root) &#123;
        vals = new ArrayList();
        dfs(root);
        for (int v: vals)
            if (v != vals.get(0))
                return false;
        return true;
    &#125;

public void dfs(TreeNode node) &#123;
    if (node != null) &#123;
        vals.add(node.val);
        dfs(node.left);
        dfs(node.right);
    &#125;
&#125;
&#125;
方法二：递归
思路与算法
一颗树是单值的，当且仅当根节点的子节点所在的子树也是单值的，同时根节点的值与子节点的值相同。
class Solution &#123;
    public boolean isUnivalTree(TreeNode root) &#123;
        boolean left_correct = (root.left == null ||
                (root.val == root.left.val &amp;&amp; isUnivalTree(root.left)));
        boolean right_correct = (root.right == null ||
                (root.val == root.right.val &amp;&amp; isUnivalTree(root.right)));
        return left_correct &amp;&amp; right_correct;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><pre><code>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
方法：深度优先搜索
首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。
而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。
class Solution &#123;
    int ans;
    public int diameterOfBinaryTree(TreeNode root) &#123;
        ans = 1;
        depth(root);
        return ans - 1;
    &#125;
    public int depth(TreeNode node) &#123;
        if (node == null) return 0; // 访问到空节点了，返回0
        int L = depth(node.left); // 左儿子为根的子树的深度
        int R = depth(node.right); // 右儿子为根的子树的深度
        ans = Math.max(ans, L+R+1); // 计算d_node即L+R+1 并更新ans
        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的坡度"><a href="#二叉树的坡度" class="headerlink" title="二叉树的坡度"></a>二叉树的坡度</h2><pre><code>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。
整个树的坡度就是其所有节点的坡度之和。
输入：
         1
       /   \
      2     3
输出：1
解释：
结点 2 的坡度: 0
结点 3 的坡度: 0
结点 1 的坡度: |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1
方法：递归
我们需要求出该结点的左子树上所有结点和以及其右子树上全部结点和的差值。
在任何结点调用该函数，都会返回当前结点下面（包括其自身）的结点和。借助于任何结点的左右子结点的这一和值，我们可以直接获得该结点所对应的坡度。
public class Solution &#123;
    int tilt=0;
    public int findTilt(TreeNode root) &#123;
        traverse(root);
        return tilt;
    &#125;
    public int traverse(TreeNode root)
    &#123;
        if(root==null )
            return 0;
        int left=traverse(root.left);
        int right=traverse(root.right);
        tilt+=Math.abs(left-right);
        return left+right+root.val;
    &#125;
&#125;
</code></pre>
<h2 id="恢复一棵-BST"><a href="#恢复一棵-BST" class="headerlink" title="恢复一棵 BST"></a>恢复一棵 BST</h2><pre><code>二叉搜索树中的两个节点被错误地交换。
请在不改变其结构的情况下，恢复这棵树。
方法一：对数组进行排序
我们直到 BST 的中序遍历是升序序列。下面展示了如何计算中序遍历。
这里被交换了两个节点，因此中序遍历是一个几乎排好序的数组，其中有两个元素被交换。识别排序数组中两个交换元素是可以在线性时间内解决的经典问题。
public int[] findTwoSwapped(List&lt;Integer&gt; nums) &#123;
  int n = nums.size();
  int x = -1, y = -1;
  for(int i = 0; i &lt; n - 1; ++i) &#123;
    if (nums.get(i + 1) &lt; nums.get(i)) &#123;
      y = nums.get(i + 1);
      // first swap occurence
      if (x == -1) x = nums.get(i);
      // second swap occurence
      else break;
    &#125;
  &#125;
  return new int[]&#123;x, y&#125;;
&#125;
方法二：递归中序遍历
class Solution &#123;
  TreeNode x = null, y = null, pred = null;

  public void swap(TreeNode a, TreeNode b) &#123;
    int tmp = a.val;
    a.val = b.val;
    b.val = tmp;
  &#125;

  public void findTwoSwapped(TreeNode root) &#123;
    if (root == null) return;
    findTwoSwapped(root.left);
    if (pred != null &amp;&amp; root.val &lt; pred.val) &#123;
      y = root;
      if (x == null) x = pred;
      else return;
    &#125;
    pred = root;
    findTwoSwapped(root.right);
  &#125;

  public void recoverTree(TreeNode root) &#123;
    findTwoSwapped(root);
    swap(x, y);
  &#125;
&#125;
</code></pre>
<h2 id="求二叉树中叶子节点的个数"><a href="#求二叉树中叶子节点的个数" class="headerlink" title="求二叉树中叶子节点的个数"></a>求二叉树中叶子节点的个数</h2><pre><code>class Solution &#123;
    public int getLeafCount(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        if (root.left == null &amp;&amp; root.right == null) &#123;
            // 输出叶子节点
            System.out.println(&quot;leaf nodes:&quot; + root.val);
            return 1;
        &#125;
        return getLeafCount(root.left) + getLeafCount(root.right);
    &#125;
&#125;
</code></pre>
<h2 id="求二叉树第K层的节点个数"><a href="#求二叉树第K层的节点个数" class="headerlink" title="求二叉树第K层的节点个数"></a>求二叉树第K层的节点个数</h2><pre><code>  if (level == k)
    &#123;
        ++num;
        return num;
    &#125;
    _FindKLevel(root-&gt;_left, k, level + 1);
    _FindKLevel(root-&gt;_right, k, level + 1);
</code></pre>
<h2 id="求二叉树中最远的两个节点的距离"><a href="#求二叉树中最远的两个节点的距离" class="headerlink" title="求二叉树中最远的两个节点的距离"></a>求二叉树中最远的两个节点的距离</h2><pre><code>（1）如果具有最远距离的两个节点经过了根节点，那么最远的距离就是左边最深的深度加上右边最深的深度之和。
（2）如果具有最远距离的两个节点之间的路径不经过根节点，那么最远的距离就在根节点的其中一个子树上的两个叶子结点。

 int _Height(Node* root, int&amp; distance)
       &#123;
              if (root == NULL)
              &#123;
                     return 0;
              &#125;
              int leftH = _Height(root-&gt;_left);
              int rightH = _Height(root-&gt;_right);
              if (leftH+rightH &gt; distance)
              &#123;
                     distance = leftH + rightH;
              &#125;
              return leftH &gt; rightH ? leftH+1 : rightH+1;
</code></pre>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><pre><code>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
class Solution &#123;
    private TreeNode pre = null;
    private int[] ret;
    private int retCount = 0;
    private int maxCount = 0;
    private int currCount = 0;

public int[] findMode(TreeNode root) &#123;
    inOrder(root);
    pre = null;
    ret = new int[retCount];
    retCount = 0;
    currCount = 0;
    inOrder(root);
    return ret;
&#125;

private void inOrder(TreeNode root) &#123;
    if (root == null)
        return;
    inOrder(root.left);
    if (pre != null &amp;&amp; pre.val == root.val)
        currCount++;
    else
        currCount = 1;
    if (currCount &gt; maxCount) &#123;
        maxCount = currCount;
        retCount = 1;
    &#125;
    else if (currCount == maxCount) &#123;
        if (ret != null)
            ret[retCount] = root.val;
        retCount++;
    &#125;
    pre = root;
    inOrder(root.right);
&#125;
&#125;
</code></pre>
<h2 id="还原一棵二叉树"><a href="#还原一棵二叉树" class="headerlink" title="还原一棵二叉树"></a>还原一棵二叉树</h2><pre><code>根据前序遍历和中序遍历的结果还原一棵二叉树
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

前序遍历的第一个节点是根节点，只要找到根节点在中序遍历中的位置，在根节点之前被访
问的节点都位于左子树，在根节点之后被访问的节点都位于右子树，由此可知左子树和右子树分别有多少个节点。
不要看这个函数的参数很多，只是为了控制数组索引而已，本质上该算法也就是一个前序遍历。
class Solution &#123;
    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        if (preorder == null || preorder.length == 0) &#123;
            return null;
        &#125;
        Map&lt;Integer, Integer&gt; indexMap = new HashMap&lt;Integer, Integer&gt;(); // 存储位置
        int length = preorder.length;
        for (int i = 0; i &lt; length; i++) &#123;
            indexMap.put(inorder[i], i);
        &#125;
        TreeNode root = buildTree(preorder, 0, length - 1, inorder, 0, length - 1, indexMap);
        return root;
    &#125;

public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd, int[] inorder, int inorderStart, int inorderEnd, Map&lt;Integer, Integer&gt; indexMap) &#123;
    if (preorderStart &gt; preorderEnd) &#123;
        return null;
    &#125;
    int rootVal = preorder[preorderStart];
    TreeNode root = new TreeNode(rootVal);
    if (preorderStart == preorderEnd) &#123;
        return root;
    &#125; else &#123;
        int rootIndex = indexMap.get(rootVal);
        int leftNodes = rootIndex - inorderStart, rightNodes = inorderEnd - rootIndex;
        TreeNode leftSubtree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);
        TreeNode rightSubtree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);
        root.left = leftSubtree;
        root.right = rightSubtree;
        return root;
    &#125;
&#125;
&#125;
</code></pre>
<h2 id="二叉搜索树序列"><a href="#二叉搜索树序列" class="headerlink" title="二叉搜索树序列"></a>二叉搜索树序列</h2><pre><code>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉搜索树，输出所有可能生成此树的数组。
给定如下二叉树

        2
       / \
      1   3
返回：

[
   [2,1,3],
   [2,3,1]
]
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;vector&lt;int&gt;&gt; BSTSequences(TreeNode* root) &#123;
    
    if(root == nullptr) return &#123;&#123;&#125;&#125;;

    // queue 数据结构 并不是一个好的选项 
    // queue&lt;TreeNode*&gt; q;  // q 用于保存 前后顺序不影响最终BST结果的 节点
    deque&lt;TreeNode*&gt; q;
    vector&lt;int&gt; path;
    q.push_back(root);

    dfs(q, path);
    return res;
&#125;

void dfs(deque&lt;TreeNode*&gt;&amp; q, vector&lt;int&gt;&amp; path)&#123;
    // cout &lt;&lt; &quot;size of path:&quot; &lt;&lt; path.size() &lt;&lt;endl;
    if(q.empty()) &#123;
        res.push_back(path);
        return;
    &#125;

    int size = q.size();
    cout &lt;&lt; &quot;***&quot; &lt;&lt; q.size() &lt;&lt; endl;
    for(int i = 0; i &lt; size; i++)&#123;
        auto curr = q.front();
        q.pop_front();

        path.push_back(curr-&gt;val);
        if(curr &amp;&amp; curr-&gt;left) q.push_back(curr-&gt;left);
        if(curr &amp;&amp; curr-&gt;right) q.push_back(curr-&gt;right);
        
        dfs(q, path);

        // 回溯要保证 状态还原
        if(curr &amp;&amp; curr-&gt;left) q.pop_back();
        if(curr &amp;&amp; curr-&gt;right) q.pop_back();
        q.push_back(curr);
        
        path.pop_back();
    &#125;
&#125;
&#125;;
</code></pre>
<h2 id="二叉搜索树总结"><a href="#二叉搜索树总结" class="headerlink" title="二叉搜索树总结"></a>二叉搜索树总结</h2><pre><code>void BST(TreeNode root,int target) &#123;
    if(root.val == target) 
        //找到目标，做点什么
    if(root.val &lt; target) 
        BST(root.right, target);
    if(root.val &gt; target) 
        BST(root.left, target);
&#125;
</code></pre>
<h2 id="在BST中插入一个元素，在BST删除一个元素"><a href="#在BST中插入一个元素，在BST删除一个元素" class="headerlink" title="在BST中插入一个元素，在BST删除一个元素"></a>在BST中插入一个元素，在BST删除一个元素</h2><h2 id="快速计算完全二叉树的节点"><a href="#快速计算完全二叉树的节点" class="headerlink" title="快速计算完全二叉树的节点"></a>快速计算完全二叉树的节点</h2><h2 id="单调栈、单调队列的作用"><a href="#单调栈、单调队列的作用" class="headerlink" title="单调栈、单调队列的作用"></a>单调栈、单调队列的作用</h2><h2 id="双指针的使用技巧"><a href="#双指针的使用技巧" class="headerlink" title="双指针的使用技巧"></a>双指针的使用技巧</h2><pre><code>快慢指针：判断是否有环、环的起始位置、链表的中心点、链表的倒数第k的元素、去除有序数组的重复元素
左右指针：二分查找、翻转数组、
滑动窗口
</code></pre>
<h2 id="位运算相关"><a href="#位运算相关" class="headerlink" title="位运算相关"></a>位运算相关</h2><p>前缀和<br>字符串乘法<br>贪心：跳跃游戏<br>k个一组翻转链表<br>深度优先<br>1、全排列问题<br>2、一个环由个圈组成，把自然数1，2，…，N分别放在每一个圆内，数字的在两个相邻圈之和应该是一个素数。 注意：第一圈数应始终为1。<br>3、油田问题<br>4、棋盘问题</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift143%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift143%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:21" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:21+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><pre><code>本题的难点在于如何处理数组，一个是开辟另一个数组进行处理，另一个是多次旋转数组实现
方法 1：暴力
最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。
public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        int temp, previous;
        for (int i = 0; i &lt; k; i++) &#123;
            previous = nums[nums.length - 1];
            for (int j = 0; j &lt; nums.length; j++) &#123;
                temp = nums[j];
                nums[j] = previous;
                previous = temp;
            &#125;
        &#125;
    &#125;
&#125;
方法 2：使用额外的数组
public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        int[] a = new int[nums.length];
        for (int i = 0; i &lt; nums.length; i++) &#123;
            a[(i + k) % nums.length] = nums[i];
        &#125;
        for (int i = 0; i &lt; nums.length; i++) &#123;
            nums[i] = a[i];
        &#125;
    &#125;
&#125;
方法 3：使用环状替换
public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        k = k % nums.length;
        int count = 0;
        for (int start = 0; count &lt; nums.length; start++) &#123;
            int current = start;
            int prev = nums[start];
            do &#123;
                int next = (current + k) % nums.length;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
                count++;
            &#125; while (start != current);
        &#125;
    &#125;
&#125;
方法 4：使用反转
原始数组                  : 1 2 3 4 5 6 7
反转所有数字后             : 7 6 5 4 3 2 1
反转前 k 个数字后          : 5 6 7 4 3 2 1
反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果

public class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    &#125;
    public void reverse(int[] nums, int start, int end) &#123;
        while (start &lt; end) &#123;
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h2><pre><code>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。
列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。
输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。

public class NestedIterator implements Iterator&lt;Integer&gt; &#123;
Queue&lt;Integer&gt; res = new LinkedList&lt;&gt;();

public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;
    for(NestedInteger temp : nestedList)
        DFS(temp);
&#125;

@Override
public Integer next() &#123;
    return res.poll();
&#125;

@Override
public boolean hasNext() &#123;
    if(res.isEmpty())
        return false;
    return true;
    
&#125;
public void DFS(NestedInteger Node)&#123;
    /* 深度遍历 */
    if(Node.isInteger())
        res.offer(Node.getInteger());
    for(NestedInteger temp :Node.getList())
        DFS(temp);
&#125;
&#125;
</code></pre>
<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><pre><code>本题的难点在入如何交换数据，采用i，j双指针，直到都不为奇偶才交换
public int[] exchange(int[] nums) &#123;
       if(nums.length == 0) return nums;
       int i = 0,j = nums.length-1;
       while(i != j)&#123;
           while(nums[i] %2 != 0 &amp;&amp; i&lt;j )&#123;
               i++;
           &#125;
           while(nums[j] %2 == 0 &amp;&amp; i&lt;j )&#123;
               j--;
           &#125;
           if(i&lt;j)&#123;
               int temp = nums[i];
               nums[i] = nums[j];
               nums[j] = temp;
           &#125;
       &#125;
       return nums;
   &#125;
</code></pre>
<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><pre><code>   哈希表统计法，用 HashMap 统计各数字的数量
   数组排序法：由于众数的数量超过数组长度一半，
   因此 数组中点的元素 一定为众数
   摩尔投票法：核心理念为 “正负抵消” 
   当 n=x ： 抵消的所有数字中，有一半是众数    
   n不等x ： 抵消的所有数字中，少于或等于一半是众数 x
   利用此特性，每轮假设都可以 缩小剩余数组区间 。当遍历完成时，最后一轮假
   设的数字即为众数（由于众数超过一半，最后一轮的票数和必为正数）

   public int majorityElement(int[] nums) &#123;
       int x = 0, votes = 0;
       for(int num : nums)&#123;
           if(votes == 0) x = num;
           votes += num == x ? 1 : -1;
       &#125;
       return x;
   &#125;
</code></pre>
<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><pre><code>    这种最适合动态规划了，慢慢的变化，将前面的结构给到nums[i]
       输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
   class Solution &#123;
       public int maxSubArray(int[] nums) &#123;
           int res = nums[0];
           for(int i = 1; i &lt; nums.length; i++) &#123;
               nums[i] += Math.max(nums[i - 1], 0);
               res = Math.max(res, nums[i]);
           &#125;
           return res;
       &#125;
   &#125;
</code></pre>
<h2 id="1～n整数中1出现的次数"><a href="#1～n整数中1出现的次数" class="headerlink" title="1～n整数中1出现的次数"></a>1～n整数中1出现的次数</h2><pre><code>从个位到最高位的变量递推公式为
# 当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出
# 将 cur 加入 low ，组成下轮 low
# 下轮 cur 是本轮 high 的最低位
# 将本轮 high 最低位删除，得到下轮 high
# 位因子每轮 × 10
   class Solution &#123;
       public int countDigitOne(int n) &#123;
           int digit = 1, res = 0;
           int high = n / 10, cur = n % 10, low = 0;
           while(high != 0 || cur != 0) &#123;
               if(cur == 0) res += high * digit;
               else if(cur == 1) res += high * digit + low + 1;
               else res += (high + 1) * digit;
               low += cur * digit;
               cur = high % 10;
               high /= 10;
               digit *= 10;
           &#125;
           return res;
       &#125;
   &#125;
</code></pre>
<h2 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h2><pre><code>   数字以0123456789101112131415…的格式序列化到一个字符序列中
   迭代 + 求整 / 求余
       count=9×start×digit，num = start + (n - 1)

       class Solution &#123;
       public int findNthDigit(int n) &#123;
           int digit = 1;
           long start = 1;
           long count = 9;
           while (n &gt; count) &#123; // 1.
               n -= count;
               digit += 1;
               start *= 10;
               count = digit * start * 9;
           &#125;
           long num = start + (n - 1) / digit; // 2.
           return Long.toString(num).charAt((n - 1) % digit) - &#39;0&#39;; // 3.
       &#125;
   &#125;
</code></pre>
<h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><pre><code>        双指针法，分别指向数组的两端，如果两个数的和大于target则j--如果小于target则i++，直至相等 
class Solution &#123;
    public int[] twoSum(int[] nums, int target) &#123;
        int i = 0, j = nums.length - 1;
        while(i &lt; j) &#123;
            int s = nums[i] + nums[j];
            if(s &lt; target) i++;
            else if(s &gt; target) j--;
            else return new int[] &#123; nums[i], nums[j] &#125;;
        &#125;
        return new int[0];
    &#125;
&#125;
</code></pre>
<h2 id="给定两个数组，编写一个函数来计算它们的交集。"><a href="#给定两个数组，编写一个函数来计算它们的交集。" class="headerlink" title="给定两个数组，编写一个函数来计算它们的交集。"></a>给定两个数组，编写一个函数来计算它们的交集。</h2><pre><code>方法一：哈希表
首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。
为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。
class Solution &#123;
    public int[] intersect(int[] nums1, int[] nums2) &#123;
        if (nums1.length &gt; nums2.length) &#123;
            return intersect(nums2, nums1);
        &#125;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for (int num : nums1) &#123;
            int count = map.getOrDefault(num, 0) + 1;
            map.put(num, count);
        &#125;
        int[] intersection = new int[nums1.length];
        int index = 0;
        for (int num : nums2) &#123;
            int count = map.getOrDefault(num, 0);
            if (count &gt; 0) &#123;
                intersection[index++] = num;
                count--;
                if (count &gt; 0) &#123;
                    map.put(num, count);
                &#125; else &#123;
                    map.remove(num);
                &#125;
            &#125;
        &#125;
        return Arrays.copyOfRange(intersection, 0, index);
    &#125;
&#125;
方法二：排序
如果两个数组是有序的，则可以便捷地计算两个数组的交集。
class Solution &#123;
    public int[] intersect(int[] nums1, int[] nums2) &#123;
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int length1 = nums1.length, length2 = nums2.length;
        int[] intersection = new int[Math.min(length1, length2)];
        int index1 = 0, index2 = 0, index = 0;
        while (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;
            if (nums1[index1] &lt; nums2[index2]) &#123;
                index1++;
            &#125; else if (nums1[index1] &gt; nums2[index2]) &#123;
                index2++;
            &#125; else &#123;
                intersection[index] = nums1[index1];
                index1++;
                index2++;
                index++;
            &#125;
        &#125;
        return Arrays.copyOfRange(intersection, 0, index);
    &#125;
&#125;
</code></pre>
<h2 id="给定一个未排序的数组，判断这个数组中是否存在长度为-3-的递增子序列。"><a href="#给定一个未排序的数组，判断这个数组中是否存在长度为-3-的递增子序列。" class="headerlink" title="给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。"></a>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。</h2><pre><code>class Solution &#123;
public:
    bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;
        int first = INT_MAX, sec = INT_MAX;     
        for(int n : nums)                       //
        &#123;
            if(n &lt;= first)  first = n;          
            else
            &#123;
                if(n &lt;= sec )   sec = n;        
                else   return true;
            &#125;
        &#125;
        return false;

    &#125;
&#125;;
</code></pre>
<h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><pre><code>是一种后缀表达式，所谓后缀就是指算符写在后面。
平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
class Solution &#123;
    //纯数组模拟栈实现(推荐)   3 ms    36 MB
    public static int evalRPN(String[] tokens) &#123;
        int[] numStack = new int[tokens.length / 2 + 1];
        int index = 0;
        for (String s : tokens) &#123;
            switch (s) &#123;
            case &quot;+&quot;:
                numStack[index - 2] += numStack[--index];
                break;
            case &quot;-&quot;:
                numStack[index - 2] -= numStack[--index];
                break;
            case &quot;*&quot;:
                numStack[index - 2] *= numStack[--index];
                break;
            case &quot;/&quot;:
                numStack[index - 2] /= numStack[--index];
                break;
            default:
                // numStack[index++] = Integer.valueOf(s);
                //valueOf改为parseInt，减少自动拆箱装箱操作
                numStack[index++] = Integer.parseInt(s);
                break;
            &#125;
        &#125;
        return numStack[0];
    &#125;
&#125;
class Solution &#123;
    // 栈实现   8 ms    36.7 MB    
    public static int evalRPN(String[] tokens) &#123;
        Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;();
        Integer op1, op2;
        for (String s : tokens) &#123;
            switch (s) &#123;
            case &quot;+&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 + op2);
                break;
            case &quot;-&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 - op2);
                break;
            case &quot;*&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 * op2);
                break;
            case &quot;/&quot;:
                op2 = numStack.pop();
                op1 = numStack.pop();
                numStack.push(op1 / op2);
                break;
            default:
                numStack.push(Integer.valueOf(s));
                break;
            &#125;
        &#125;
        return numStack.pop();
    &#125;
&#125;
</code></pre>
<h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h2><pre><code>输入: [1,2,3,4]
输出: [24,12,8,6]
方法一：左右乘积列表
我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。
class Solution &#123;
    public int[] productExceptSelf(int[] nums) &#123;
        int length = nums.length;

    // L 和 R 分别表示左右两侧的乘积列表
    int[] L = new int[length];
    int[] R = new int[length];

    int[] answer = new int[length];

    // L[i] 为索引 i 左侧所有元素的乘积
    // 对于索引为 &#39;0&#39; 的元素，因为左侧没有元素，所以 L[0] = 1
    L[0] = 1;
    for (int i = 1; i &lt; length; i++) &#123;
        L[i] = nums[i - 1] * L[i - 1];
    &#125;

    // R[i] 为索引 i 右侧所有元素的乘积
    // 对于索引为 &#39;length-1&#39; 的元素，因为右侧没有元素，所以 R[length-1] = 1
    R[length - 1] = 1;
    for (int i = length - 2; i &gt;= 0; i--) &#123;
        R[i] = nums[i + 1] * R[i + 1];
    &#125;

    // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积
    for (int i = 0; i &lt; length; i++) &#123;
        answer[i] = L[i] * R[i];
    &#125;

    return answer;
&#125;
&#125;
方法二：空间复杂度 
第一个循环应该是表示下三角中自上而下对每一行做连乘，而第二个循环是对上三角自下而上的连乘
class Solution &#123;
    public int[] productExceptSelf(int[] nums) &#123;
        int length = nums.length;
        int[] answer = new int[length];

    // answer[i] 表示索引 i 左侧所有元素的乘积
    // 因为索引为 &#39;0&#39; 的元素左侧没有元素， 所以 answer[0] = 1
    answer[0] = 1;
    for (int i = 1; i &lt; length; i++) &#123;
        answer[i] = nums[i - 1] * answer[i - 1];
    &#125;

    // R 为右侧所有元素的乘积
    // 刚开始右边没有元素，所以 R = 1
    int R = 1;
    for (int i = length - 1; i &gt;= 0; i--) &#123;
        // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
        answer[i] = answer[i] * R;
        // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
        R *= nums[i];
    &#125;
    return answer;
&#125;
&#125;
</code></pre>
<h2 id="和为s的连续正数序列-（滑动窗口）"><a href="#和为s的连续正数序列-（滑动窗口）" class="headerlink" title="和为s的连续正数序列  （滑动窗口）"></a>和为s的连续正数序列  （滑动窗口）</h2><pre><code>    窗口的左边界和右边界永远只能向右移动
    当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动
    当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
什么是滑动窗口
滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。
窗口的左边界和右边界永远只能向右移动
第一个问题，窗口何时扩大，何时缩小？
第二个问题，滑动窗口能找到全部的解吗？
当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动
当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动
public int[][] findContinuousSequence(int target) &#123;
    int i = 1; // 滑动窗口的左边界
    int j = 1; // 滑动窗口的右边界
    int sum = 0; // 滑动窗口中数字的和
    List&lt;int[]&gt; res = new ArrayList&lt;&gt;();

while (i &lt;= target / 2) &#123;
    if (sum &lt; target) &#123;
        // 右边界向右移动
        sum += j;
        j++;
    &#125; else if (sum &gt; target) &#123;
        // 左边界向右移动
        sum -= i;
        i++;
    &#125; else &#123;
        // 记录结果
        int[] arr = new int[j-i];
        for (int k = i; k &lt; j; k++) &#123;
            arr[k-i] = k;
        &#125;
        res.add(arr);
        // 左边界向右移动
        sum -= i;
        i++;
    &#125;
&#125;

return res.toArray(new int[res.size()][]);
</code></pre>
<p>}</p>
<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><pre><code>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
单调队列
我们先看什么是单调的双向队列，双向队列大家都知道，既能在头部进行插入、删除操作，也能在尾部进行插入删除操作，而所谓的单调，就是我们人为规定从队列的头部到尾部，所存储的元素是依次递减（或依次递增）的。如下所示：

也就是说，我们维护一个单调的双向队列，窗口在每次滑动的时候，我就从队列头部取当前窗口中的最大值，每次窗口新进来一个元素的时候，我就将它与队列中的元素进行大小比较：

如果刚刚进来的元素比队列的尾部元素大，那么先将队列尾部的元素弹出，然后把刚刚进来的元素添到队列的尾部；
如果刚刚进来的元素比队列的尾部元素小，那么把刚刚进来的元素直接添到队列的尾部即可。

class Solution &#123;
    public int[] maxSlidingWindow(int[] nums, int k) &#123;
        if (nums == null || k &lt; 1 || nums.length &lt; k) &#123;
            return new int[0];
        &#125;

    int index = 0;
    int[] res = new int[nums.length - k + 1];
    LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();

    for (int i = 0; i &lt; nums.length; i++) &#123;
        // 在队列不为空的情况下，如果队列尾部的元素要比当前的元素小，或等于当前的元素
        // 那么为了维持从大到小的原则，我必须让尾部元素弹出
        while (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;= nums[i]) &#123;
            queue.pollLast();
        &#125;
        // 不走 while 的话，说明我们正常在队列尾部添加元素
        queue.addLast(i);
        // 如果滑动窗口已经略过了队列中头部的元素，则将头部元素弹出
        if (queue.peekFirst() == (i - k)) &#123;
            queue.pollFirst();
        &#125;
        // 看看窗口有没有形成，只有形成了大小为 k 的窗口，我才能收集窗口内的最大值
        if (i &gt;= (k - 1)) &#123;
            res[index++] = nums[queue.peekFirst()];
        &#125;
    &#125;
    return res;
&#125;
</code></pre>
<p>}</p>
<h2 id="将数组中所有-0-移动到数组末尾。"><a href="#将数组中所有-0-移动到数组末尾。" class="headerlink" title="将数组中所有 0 移动到数组末尾。"></a>将数组中所有 0 移动到数组末尾。</h2><pre><code>方法一：空间局部优化
class Solution &#123;
    public void moveZeroes(int[] nums) &#123;
        if(nums==null) &#123;
            return;
        &#125;
        //第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]
        int j = 0;
        for(int i=0;i&lt;nums.length;++i) &#123;
            if(nums[i]!=0) &#123;
                nums[j++] = nums[i];
            &#125;
        &#125;
        //非0元素统计完了，剩下的都是0了
        //所以第二次遍历把末尾的元素都赋为0即可
        for(int i=j;i&lt;nums.length;++i) &#123;
            nums[i] = 0;
        &#125;
    &#125;
&#125;    
方法二：空间最优，操作局部优化（双指针）
class Solution &#123;
    public void moveZeroes(int[] nums) &#123;
        if(nums==null) &#123;
            return;
        &#125;
        //两个指针i和j
        int j = 0;
        for(int i=0;i&lt;nums.length;i++) &#123;
            //当前元素!=0，就把其交换到左边，等于0的交换到右边
            if(nums[i]!=0) &#123;
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j++] = tmp;
            &#125;
        &#125;
    &#125;
&#125;    
</code></pre>
<h2 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h2><pre><code>方法一： 暴力 【通过】
暴力算法简单的来说就是把每个数放在一个 ”帽子“ 里面，每次从 ”帽子“ 里面随机摸一个数出来
class Solution &#123;
    private int[] array;
    private int[] original;

private Random rand = new Random();

private List&lt;Integer&gt; getArrayCopy() &#123;
    List&lt;Integer&gt; asList = new ArrayList&lt;Integer&gt;();
    for (int i = 0; i &lt; array.length; i++) &#123;
        asList.add(array[i]);
    &#125;
    return asList;
&#125;

public Solution(int[] nums) &#123;
    array = nums;
    original = nums.clone();
&#125;

public int[] reset() &#123;
    array = original;
    original = original.clone();
    return array;
&#125;

public int[] shuffle() &#123;
    List&lt;Integer&gt; aux = getArrayCopy();

    for (int i = 0; i &lt; array.length; i++) &#123;
        int removeIdx = rand.nextInt(aux.size());
        array[i] = aux.get(removeIdx);
        aux.remove(removeIdx);
    &#125;

    return array;
&#125;
</code></pre>
<p>}<br>    方法二： Fisher-Yates 洗牌算法 【通过】<br>    Fisher-Yates 洗牌算法跟暴力算法很像。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换 - 这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。</p>
<pre><code>class Solution &#123;
    private int[] array;
    private int[] original;

Random rand = new Random();

private int randRange(int min, int max) &#123;
    return rand.nextInt(max - min) + min;
&#125;

private void swapAt(int i, int j) &#123;
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
&#125;

public Solution(int[] nums) &#123;
    array = nums;
    original = nums.clone();
&#125;

public int[] reset() &#123;
    array = original;
    original = original.clone();
    return original;
&#125;

public int[] shuffle() &#123;
    for (int i = 0; i &lt; array.length; i++) &#123;
        swapAt(i, randRange(i, array.length));
    &#125;
    return array;
&#125;
&#125;
</code></pre>
<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><pre><code>public class Solution &#123;

public int reversePairs(int[] nums) &#123;
    int len = nums.length;

    if (len &lt; 2) &#123;
        return 0;
    &#125;

    int[] copy = new int[len];
    for (int i = 0; i &lt; len; i++) &#123;
        copy[i] = nums[i];
    &#125;

    int[] temp = new int[len];
    return reversePairs(copy, 0, len - 1, temp);
&#125;

/**
 * nums[left..right] 计算逆序对个数并且排序
 *
 * @param nums
 * @param left
 * @param right
 * @param temp
 * @return
 */
private int reversePairs(int[] nums, int left, int right, int[] temp) &#123;
    if (left == right) &#123;
        return 0;
    &#125;

    int mid = left + (right - left) / 2;
    int leftPairs = reversePairs(nums, left, mid, temp);
    int rightPairs = reversePairs(nums, mid + 1, right, temp);

    if (nums[mid] &lt;= nums[mid + 1]) &#123;
        return leftPairs + rightPairs;
    &#125;

    int crossPairs = mergeAndCount(nums, left, mid, right, temp);
    return leftPairs + rightPairs + crossPairs;
&#125;

/**
 * nums[left..mid] 有序，nums[mid + 1..right] 有序
 *
 * @param nums
 * @param left
 * @param mid
 * @param right
 * @param temp
 * @return
 */
private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) &#123;
    for (int i = left; i &lt;= right; i++) &#123;
        temp[i] = nums[i];
    &#125;

    int i = left;
    int j = mid + 1;

    int count = 0;
    for (int k = left; k &lt;= right; k++) &#123;

        if (i == mid + 1) &#123;
            nums[k] = temp[j];
            j++;
        &#125; else if (j == right + 1) &#123;
            nums[k] = temp[i];
            i++;
        &#125; else if (temp[i] &lt;= temp[j]) &#123;
            nums[k] = temp[i];
            i++;
        &#125; else &#123;
            nums[k] = temp[j];
            j++;
            count += (mid - i + 1);
        &#125;
    &#125;
    return count;
&#125;
&#125;
</code></pre>
<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><pre><code>    用快排最最最高效解决 TopK 问题：
    大根堆(前 K 小) / 小根堆（前 K 大),Java中有现成的 PriorityQueue，实现起来最简单：
    二叉搜索树也可以 解决 TopK 问题哦
    数据范围有限时直接计数排序就行了：
class Solution &#123;
    public int[] getLeastNumbers(int[] arr, int k) &#123;
        if (k == 0 || arr.length == 0) &#123;
            return new int[0];
        &#125;
        // 最后一个参数表示我们要找的是下标为k-1的数
        return quickSearch(arr, 0, arr.length - 1, k - 1);
    &#125;

private int[] quickSearch(int[] nums, int lo, int hi, int k) &#123;
    // 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；
    int j = partition(nums, lo, hi);
    if (j == k) &#123;
        return Arrays.copyOf(nums, j + 1);
    &#125;
    // 否则根据下标j与k的大小关系来决定继续切分左段还是右段。
    return j &gt; k? quickSearch(nums, lo, j - 1, k): quickSearch(nums, j + 1, hi, k);
&#125;

// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。
private int partition(int[] nums, int lo, int hi) &#123;
    int v = nums[lo];
    int i = lo, j = hi + 1;
    while (true) &#123;
        while (++i &lt;= hi &amp;&amp; nums[i] &lt; v);
        while (--j &gt;= lo &amp;&amp; nums[j] &gt; v);
        if (i &gt;= j) &#123;
            break;
        &#125;
        int t = nums[j];
        nums[j] = nums[i];
        nums[i] = t;
    &#125;
    nums[lo] = nums[j];
    nums[j] = v;
    return j;
&#125;
&#125;
我们用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。
// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：
// 1. 若目前堆的大小小于K，将当前数字放入堆中。
// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；
//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。
class Solution &#123;
    public int[] getLeastNumbers(int[] arr, int k) &#123;
        if (k == 0 || arr.length == 0) &#123;
            return new int[0];
        &#125;
        // 默认是小根堆，实现大根堆需要重写一下比较器。
        Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);
        for (int num: arr) &#123;
            if (pq.size() &lt; k) &#123;
                pq.offer(num);
            &#125; else if (num &lt; pq.peek()) &#123;
                pq.poll();
                pq.offer(num);
            &#125;
        &#125;
        
        // 返回堆中的元素
        int[] res = new int[pq.size()];
        int idx = 0;
        for(int num: pq) &#123;
            res[idx++] = num;
        &#125;
        return res;
    &#125;
&#125;
二叉搜索树也可以 O(NlogK)解决 TopK 问题哦
与前两种方法相比，BST 有一个好处是求得的前K大的数字是有序的。
class Solution &#123;
public int[] getLeastNumbers(int[] arr, int k) &#123;
    if (k == 0 || arr.length == 0) &#123;
        return new int[0];
    &#125;
    // TreeMap的key是数字, value是该数字的个数。
    // cnt表示当前map总共存了多少个数字。
    TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();
    int cnt = 0;
    for (int num: arr) &#123;
        // 1. 遍历数组，若当前map中的数字个数小于k，则map中当前数字对应个数+1
        if (cnt &lt; k) &#123;
            map.put(num, map.getOrDefault(num, 0) + 1);
            cnt++;
            continue;
        &#125; 
        // 2. 否则，取出map中最大的Key（即最大的数字), 判断当前数字与map中最大数字的大小关系：
        //    若当前数字比map中最大的数字还大，就直接忽略；
        //    若当前数字比map中最大的数字小，则将当前数字加入map中，并将map中的最大数字的个数-1。
        Map.Entry&lt;Integer, Integer&gt; entry = map.lastEntry();
        if (entry.getKey() &gt; num) &#123;
            map.put(num, map.getOrDefault(num, 0) + 1);
            if (entry.getValue() == 1) &#123;
                map.pollLastEntry();
            &#125; else &#123;
                map.put(entry.getKey(), entry.getValue() - 1);
            &#125;
        &#125;
    
&#125;

    // 最后返回map中的元素
    int[] res = new int[k];
    int idx = 0;
    for (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;
        int freq = entry.getValue();
        while (freq-- &gt; 0) &#123;
            res[idx++] = entry.getKey();
        &#125;
    &#125;
    return res;
&#125;
&#125;
四、数据范围有限时直接计数排序就行了：
class Solution &#123;
    public int[] getLeastNumbers(int[] arr, int k) &#123;
        if (k == 0 || arr.length == 0) &#123;
            return new int[0];
        &#125;
        // 统计每个数字出现的次数
        int[] counter = new int[10001];
        for (int num: arr) &#123;
            counter[num]++;
        &#125;
        // 根据counter数组从头找出k个数作为返回结果
        int[] res = new int[k];
        int idx = 0;
        for (int num = 0; num &lt; counter.length; num++) &#123;
            while (counter[num]-- &gt; 0 &amp;&amp; idx &lt; k) &#123;
                res[idx++] = num;
            &#125;
            if (idx == k) &#123;
                break;
            &#125;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><pre><code>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
    输入: [10,2]
    输出: &quot;102&quot;
    此题求拼接起来的 “最小数字” ，本质上是一个排序问题。
class Solution &#123;
    public String minNumber(int[] nums) &#123;
        String[] strs = new String[nums.length];
        for(int i = 0; i &lt; nums.length; i++)
            strs[i] = String.valueOf(nums[i]);
        fastSort(strs, 0, strs.length - 1);
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    &#125;
    void fastSort(String[] strs, int l, int r) &#123;
        if(l &gt;= r) return;
        int i = l, j = r;
        String tmp = strs[i];
        while(i &lt; j) &#123;
            while((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= 0 &amp;&amp; i &lt; j) j--;
            while((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= 0 &amp;&amp; i &lt; j) i++;
            tmp = strs[i];
            strs[i] = strs[j];
            strs[j] = tmp;
        &#125;
        strs[i] = strs[l];
        strs[l] = tmp;
        fastSort(strs, l, i - 1);
        fastSort(strs, i + 1, r);
    &#125;
&#125;
方法二：内置函数
public String minNumber(int[] nums) &#123;
        String[] strs = new String[nums.length];
        for(int i = 0; i &lt; nums.length; i++) 
            strs[i] = String.valueOf(nums[i]);
        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    &#125;
</code></pre>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><pre><code>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
    由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。

从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。

可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能

class Solution &#123;
    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;
            return false;
        &#125;
        int rows = matrix.length, columns = matrix[0].length;
        int row = 0, column = columns - 1;
        while (row &lt; rows &amp;&amp; column &gt;= 0) &#123;
            int num = matrix[row][column];
            if (num == target) &#123;
                return true;
            &#125; else if (num &gt; target) &#123;
                column--;
            &#125; else &#123;
                row++;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><pre><code>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],
[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],
[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]
    算法原理：
    深度优先搜索
class Solution &#123;
    public boolean exist(char[][] board, String word) &#123;
        char[] words = word.toCharArray();
        for(int i = 0; i &lt; board.length; i++) &#123;
            for(int j = 0; j &lt; board[0].length; j++) &#123;
                if(dfs(board, words, i, j, 0)) return true;
            &#125;
        &#125;
        return false;
    &#125;
    boolean dfs(char[][] board, char[] word, int i, int j, int k) &#123;
        if(i &gt;= board.length || i &lt; 0 || j &gt;= board[0].length || j &lt; 0 || board[i][j] != word[k]) return false;
        if(k == word.length - 1) return true;
        char tmp = board[i][j];
        board[i][j] = &#39;/&#39;;
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = tmp;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h2><pre><code>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
    本文选择使用广度优先搜索的方法来讲解。
    public int movingCount(int m, int n, int k) &#123;
        boolean[][] visited = new boolean[m][n];
        return dfs(0, 0, m, n, k, visited);
    &#125;
    public int dfs(int i, int j, int m, int n, int k, boolean[][] visited) &#123;
        if(i &gt;= m || j &gt;= n || k &lt; getSum(i) + getSum(j) || visited[i][j]) &#123;
            return 0;
        &#125;
        visited[i][j] = true;
        return 1 + dfs(i + 1, j, m, n, k, visited) + dfs(i, j + 1, m, n, k, visited);
    &#125;

private int getSum(int a) &#123;
    int sum = a % 10;
    int tmp = a / 10;
    while(tmp &gt; 0) &#123;
        sum += tmp % 10;
        tmp /= 10;
    &#125;
    return sum;
&#125;
    
</code></pre>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><pre><code>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
可以模拟打印矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，则顺时针旋转，进入下一个方向。
判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素
表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。
如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数
量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。
 public int[] spiralOrder(int[][] matrix) &#123;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;
            return new int[0];
        &#125;
        int rows = matrix.length, columns = matrix[0].length;
        boolean[][] visited = new boolean[rows][columns];
        int total = rows * columns;
        int[] order = new int[total];
        int row = 0, column = 0;
        int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;
        int directionIndex = 0;
        for (int i = 0; i &lt; total; i++) &#123;
            order[i] = matrix[row][column];
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow &lt; 0 || nextRow &gt;= rows || nextColumn &lt; 0 || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123;
                directionIndex = (directionIndex + 1) % 4;
            &#125;
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        &#125;
        return order;
    &#125;
</code></pre>
<h2 id="给定一个-n-x-n-矩阵，其中每行和每列元素均按升序排序，找到矩阵中第-k-小的元素。"><a href="#给定一个-n-x-n-矩阵，其中每行和每列元素均按升序排序，找到矩阵中第-k-小的元素。" class="headerlink" title="给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。"></a>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。</h2><pre><code>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
最直接的做法是将这个二维数组另存为为一维数组，并对该一维数组进行排序。最后这个一维数组中的第 k个数即为答案。
class Solution &#123;
    public int kthSmallest(int[][] matrix, int k) &#123;
        int rows = matrix.length, columns = matrix[0].length;
        int[] sorted = new int[rows * columns];
        int index = 0;
        for (int[] row : matrix) &#123;
            for (int num : row) &#123;
                sorted[index++] = num;
            &#125;
        &#125;
        Arrays.sort(sorted);
        return sorted[k - 1];
    &#125;
&#125;
方法二：归并排序
这个矩阵的每一行均为一个有序数组。问题即转化为从这 n 个有序数组中找第 
k 大的数，可以想到利用归并排序的做法，归并到第 k 个数即可停止。

class Solution &#123;
    public int kthSmallest(int[][] matrix, int k) &#123;
        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() &#123;
            public int compare(int[] a, int[] b) &#123;
                return a[0] - b[0];
            &#125;
        &#125;);
        int n = matrix.length;
        for (int i = 0; i &lt; n; i++) &#123;
            pq.offer(new int[]&#123;matrix[i][0], i, 0&#125;);
        &#125;
        for (int i = 0; i &lt; k - 1; i++) &#123;
            int[] now = pq.poll();
            if (now[2] != n - 1) &#123;
                pq.offer(new int[]&#123;matrix[now[1]][now[2] + 1], now[1], now[2] + 1&#125;);
            &#125;
        &#125;
        return pq.poll()[0];
    &#125;
&#125;
方法三：二分查找
那么矩阵中不大于 mid 的数，肯定全部分布在矩阵的左上角。
class Solution &#123;
    public int kthSmallest(int[][] matrix, int k) &#123;
        int n = matrix.length;
        int left = matrix[0][0];
        int right = matrix[n - 1][n - 1];
        while (left &lt; right) &#123;
            int mid = left + ((right - left) &gt;&gt; 1);
            if (check(matrix, mid, k, n)) &#123;
                right = mid;
            &#125; else &#123;
                left = mid + 1;
            &#125;
        &#125;
        return left;
    &#125;

    public boolean check(int[][] matrix, int mid, int k, int n) &#123;
        int i = n - 1;
        int j = 0;
        int num = 0;
        while (i &gt;= 0 &amp;&amp; j &lt; n) &#123;
            if (matrix[i][j] &lt;= mid) &#123;
                num += i + 1;
                j++;
            &#125; else &#123;
                i--;
            &#125;
        &#125;
        return num &gt;= k;
    &#125;
&#125;

可以将矩阵看成若干层，首先打印最外层的元素，其次打印次外层的元素，直到打印最内层的元素。
定义4个顶点的坐标位置left、right、top、bottom
1.从左到右遍历上侧元素， 当到达右顶点时停止
2.从上到下遍历右侧元素，当到达下右顶点时停止
3.从右向左侧遍历
4.从下向上遍历
遍历完毕后，四个顶点位置进行内缩
left和top分别加一
right和bottom分别减一，然后再遍历，直到遍历完所有元素为止。
 public int[] spiralOrder(int[][] matrix) &#123;
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;
            return new int[0];
        &#125;
        int rows = matrix.length, columns = matrix[0].length;
        int[] order = new int[rows * columns];
        int index = 0;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;
            for (int column = left; column &lt;= right; column++) &#123;
                order[index++] = matrix[top][column];
            &#125;
            for (int row = top + 1; row &lt;= bottom; row++) &#123;
                order[index++] = matrix[row][right];
            &#125;
            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;
                for (int column = right - 1; column &gt; left; column--) &#123;
                    order[index++] = matrix[bottom][column];
                &#125;
                for (int row = bottom; row &gt; top; row--) &#123;
                    order[index++] = matrix[row][left];
                &#125;
            &#125;
            left++;
            right--;
            top++;
            bottom--;
        &#125;
        return order;
    &#125;
</code></pre>
<h2 id="编写一个高效的算法来搜索-m-x-n-矩阵-matrix-中的一个目标值-target。"><a href="#编写一个高效的算法来搜索-m-x-n-矩阵-matrix-中的一个目标值-target。" class="headerlink" title="编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。"></a>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。</h2><pre><code>该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。
方法一：暴力法
方法二：二分法搜索
class Solution &#123;
    private boolean binarySearch(int[][] matrix, int target, int start, boolean vertical) &#123;
        int lo = start;
        int hi = vertical ? matrix[0].length-1 : matrix.length-1;

    while (hi &gt;= lo) &#123;
        int mid = (lo + hi)/2;
        if (vertical) &#123; // searching a column
            if (matrix[start][mid] &lt; target) &#123;
                lo = mid + 1;
            &#125; else if (matrix[start][mid] &gt; target) &#123;
                hi = mid - 1;
            &#125; else &#123;
                return true;
            &#125;
        &#125; else &#123; // searching a row
            if (matrix[mid][start] &lt; target) &#123;
                lo = mid + 1;
            &#125; else if (matrix[mid][start] &gt; target) &#123;
                hi = mid - 1;
            &#125; else &#123;
                return true;
            &#125;
        &#125;
    &#125;

    return false;
&#125;

public boolean searchMatrix(int[][] matrix, int target) &#123;
    // an empty matrix obviously does not contain `target`
    if (matrix == null || matrix.length == 0) &#123;
        return false;
    &#125;

    // iterate over matrix diagonals
    int shorterDim = Math.min(matrix.length, matrix[0].length);
    for (int i = 0; i &lt; shorterDim; i++) &#123;
        boolean verticalFound = binarySearch(matrix, target, i, true);
        boolean horizontalFound = binarySearch(matrix, target, i, false);
        if (verticalFound || horizontalFound) &#123;
            return true;
        &#125;
    &#125;
    
    return false; 
&#125;
&#125;
方法三修剪矩阵
首先，我们初始化一个指向矩阵左下角的 
(row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 
(row，col) 为止，我们执行以下操作：如果当前指向的值大于目标值，则可以 “向上” 移动一行。 否则，如果当前指向的值小于目标值，则可以移动一列。不难理解为什么这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。 因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大。也可以对列进行非常类似的论证，因此这种搜索方式将始终在矩阵中找到目标（如果存在）。
class Solution &#123;
    public boolean searchMatrix(int[][] matrix, int target) &#123;
        // start our &quot;pointer&quot; in the bottom-left
        int row = matrix.length-1;
        int col = 0;

    while (row &gt;= 0 &amp;&amp; col &lt; matrix[0].length) &#123;
        if (matrix[row][col] &gt; target) &#123;
            row--;
        &#125; else if (matrix[row][col] &lt; target) &#123;
            col++;
        &#125; else &#123; // found it
            return true;
        &#125;
    &#125;

    return false;
&#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift127NSObject%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift127NSObject%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">NSObject数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:19" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:19+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="object-class"><a href="#object-class" class="headerlink" title="object_class"></a>object_class</h2><p>继承:objc_object<br>内部：<br>Class superClass; 父类<br>cache_t cache;  缓存<br>class_data_bits_t bits  数据</p>
<p>isa指针关系<br>实例对象其指针指向类对象<br>类对象其指针指向元类对象</p>
<p>cache_t<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/45d409e77806">https://www.jianshu.com/p/45d409e77806</a><br>用散列表(哈希表)来缓存曾经调用过的方法，可以提高方法的查找速度，底层结构如下：<br>用于快速查找方法执行函数<br>是可增量扩展的哈希表结构<br>是局部性原理的最佳应用<br>cache 本质是一个 Hash表。存储bucket_t<br>bucket_t存储<br>cache_key_t _key;//@selector()<br>IMP _imp;//函数地址<br>哈希查找：发现当发生碰撞的时候，索引会+1，查找下一个。<br>槽位如果不够，_mask 会变换，变为原来的2倍，并且扩展槽位的时候，会清空数组里原有的缓存内容<br>子类没有实现方法会调用父类的方法，会将父类方法加入到子类自己的cache 里。<br>为什么要创建新的新的buckets来替换原有的buckets并抹掉原有的buckets的方案，而不是在在原有buckets的基础上进行扩容？<br>减少对方法快速查找流程的影响：调用objc_msgSend时会触发方法快速查找，如果进行扩容需要做一些读写操作，对快速查找影响比较大。<br>对性能要求比较高：开辟新的buckets空间并抹掉原有buckets的消耗比在原有buckets上进行扩展更加高效<br>当扩容后，会把新mask设置为newCapacity长度减一，然后清空缓存。<br>所有散列表(哈希表)的原理都是一样的，都是通过一个函数，这个函数传入一个key，通过这个key算出一个索引，如果索引冲突了就加一或者减一，直至不冲突为止，不同的就是算法不一样。</p>
<p>struct class_rw_t {<br>    uint32_t flags;<br>    uint32_t version;</p>
<pre><code>const class_ro_t *ro;

method_array_t methods;
property_array_t properties; //属性，和变量的区别，属性是名称，变量是值
protocol_array_t protocols;

Class firstSubclass;
Class nextSiblingClass;
</code></pre>
<p>};<br>class_rw_t结构体内有一个指向class_ro_t结构体的指针。</p>
<p>细看两个结构体的成员变量会发现很多相同的地方，他们都存放着当前类的属性、实例变量、方法、协议等等。区别在于：class_ro_t存放的是编译期间就确定的；而class_rw_t是在runtime时才确定，它会先将class_ro_t的内容拷贝过去，然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说class_rw_t是class_ro_t的超集，当然实际访问类的方法、属性等也都是访问的class_rw_t中的内容</p>
<p>哈希碰撞<br>开放地址法<br>链地址法</p>
<p>struct method_t {<br>    SEL name; //函数名<br>    const char *types; //编码（返回值类型、参数类型）<br>    IMP imp;//指向函数的指针（函数地址）<br>};</p>
<p>instance对象的isa指向class对象<br>class对象的isa指向meta-class对象<br>meta-class对象的isa指向基类的meta-class对象</p>
<p>发消息的步骤<br>检查target是不是nil    ObjC的特性允许对一个nil对象发消息而不会崩溃<br>通过isa，<br>对象方法查找类对象（类对象及继承链上找方法）<br>方法缓存列表，hashMap的结构，查找速度快<br>方法缓存找不到就查找类对象的方法列表中遍历class_rw_t，从后向前的遍历<br>查找父类的类对象—-同上，直至nsobjcect<br>类方法查找元类对象（元类对象及继承链上找方法）<br>方法缓存列表，hashMap的结构，查找速度快<br>方法缓存找不到就查找元类对象的方法列表中遍历class_rw_t，从后向前的遍历</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift143%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift143%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:16" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:16+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><pre><code>栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。


public int[] reversePrint(ListNode head) &#123;
    Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;();
    ListNode temp = head;
    while (temp != null) &#123;
        stack.push(temp);
        temp = temp.next;
    &#125;
    int size = stack.size();
    int[] print = new int[size];
    for (int i = 0; i &lt; size; i++) &#123;
        print[i] = stack.pop().val;
    &#125;
    return print;
&#125;
</code></pre>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><pre><code>class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* a=nullptr;
        ListNode* b=head;
        while(b!=nullptr)&#123;
            ListNode* temp = b-&gt;next; // 拿到下一个
            b-&gt;next = a; // 将当前反转
            a=b; // 获取上一个指针
            b=temp; // 获取下一个指针
        &#125;
        return a;
    &#125;
&#125;;
递归
public ListNode reverseList(ListNode head) &#123;
    if (head == null || head.next == null) return head;
    ListNode p = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
&#125;
</code></pre>
<h2 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h2><pre><code>class Solution &#123;
    //双指针
    public ListNode deleteNode(ListNode head, int val) &#123;
        if(head.val == val)&#123;
            return head.next;
        &#125;
        ListNode cur = head;
        ListNode se = cur.next ;
        while(se != null)&#123;
            if(se.val == val)&#123;
                cur.next = se.next;
                se = null;
                break;
            &#125;
            cur = se;
            se = se.next; 
        &#125;
        return head;
        &#125;
    //单指针
    public ListNode deleteNode(ListNode head, int val) &#123;
        if(head.val == val)&#123;
            return head.next;
        &#125;
        ListNode cur = head;
        while(cur.next != null)&#123;
            if(cur.next.val == val)&#123;
                cur.next = cur.next.next;
                break;
            &#125;
            cur = cur.next;
        &#125;
        return head;
    &#125;
&#125;
</code></pre>
<h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><pre><code>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
双指针，前面的指针先走k步，然后两个指针一起走，知道走到最后，两个指针之间的位置就是 
     public ListNode getKthFromEnd(ListNode head, int k) &#123;
        ListNode former = head, latter = head;
        for(int i = 0; i &lt; k; i++)
            former = former.next;
        while(former != null) &#123;
            former = former.next;
            latter = latter.next;
        &#125;
        return latter;
    &#125;
</code></pre>
<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><pre><code>双指针遍历两个链表，进行比较，小的放入新的链表中，直到两个链表都遍历完毕
public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;
        ListNode dum = new ListNode(0), cur = dum;
        while(l1 != null &amp;&amp; l2 != null) &#123;
            if(l1.val &lt; l2.val) &#123;
                cur.next = l1;
                l1 = l1.next;
            &#125;
            else &#123;
                cur.next = l2;
                l2 = l2.next;
            &#125;
            cur = cur.next;
        &#125;
        cur.next = l1 != null ? l1 : l2;
        return dum.next;
    &#125;
</code></pre>
<h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><pre><code>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
大家的题解都是双指针双百解法。
我来说一个这题的实际应用：
求两个类最低一层的公共父类，就是两个树节点最低一层的公共祖先节点。
这里的树节点内容不是left和right，而是指向父节点的指针。
两个类都用.getSuperclass()方法生成直到Object的两个链表，
再调用这个题的方法就求出了第一个公共祖先。
我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。
这样，当它们相遇时，所指向的结点就是第一个公共结点。
public class Solution &#123;
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
        if(headA == null || headB == null) return null;
        ListNode a = headA, b = headB;
        int len1 = 0, len2 = 0, sum = 0;
        while(a != null &amp;&amp; ++len1 &gt; 0) a = a.next;
        while(b != null &amp;&amp; ++len2 &gt; 0) b = b.next;
        a = headA;
        b = headB;
        while (a != b)&#123;
            if(a.next == null) a = headB;
            else a = a.next;
            if(b.next == null) b = headA;
            else b = b.next;
            if(sum++ &gt; len1 + len2) return null;
        &#125;
        return a;
    &#125;
&#125;
</code></pre>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><pre><code>class Node &#123;
    int val;
    Node next;
    Node random;

    public Node(int val) &#123;
        this.val = val;
        this.next = null;
        this.random = null;
    &#125;
&#125;
public Node copyRandomList(Node head) &#123;
        HashMap&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); //创建HashMap集合
        Node cur=head;
        //复制结点值
        while(cur!=null)&#123;
            //存储put:&lt;key,value1&gt;
            map.put(cur,new Node(cur.val)); //顺序遍历，存储老结点和新结点(先存储新创建的结点值)
            cur=cur.next;
        &#125;
        //复制结点指向
        cur = head;
        while(cur!=null)&#123;
            //得到get:&lt;key&gt;.value2,3
            map.get(cur).next = map.get(cur.next); //新结点next指向同旧结点的next指向
            map.get(cur).random = map.get(cur.random); //新结点random指向同旧结点的random指向
            cur = cur.next;
        &#125;

        //返回复制的链表
        return map.get(head);


    &#125;
</code></pre>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><pre><code>getIndex
addHead
addLast
addAtIndex
deleteIndex
  public class ListNode &#123;
      int val;
      ListNode next;
      ListNode(int x) &#123; val = x; &#125;
    &#125;

class MyLinkedList &#123;
  int size;
  ListNode head;  // sentinel node as pseudo-head
  public MyLinkedList() &#123;
    size = 0;
    head = new ListNode(0);
  &#125;

  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
  public int get(int index) &#123;
    // if index is invalid
    if (index &lt; 0 || index &gt;= size) return -1;

    ListNode curr = head;
    // index steps needed 
    // to move from sentinel node to wanted index
    for(int i = 0; i &lt; index + 1; ++i) curr = curr.next;
    return curr.val;
  &#125;

  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
  public void addAtHead(int val) &#123;
    addAtIndex(0, val);
  &#125;

  /** Append a node of value val to the last element of the linked list. */
  public void addAtTail(int val) &#123;
    addAtIndex(size, val);
  &#125;

  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
  public void addAtIndex(int index, int val) &#123;
    // If index is greater than the length, 
    // the node will not be inserted.
    if (index &gt; size) return;

    // [so weird] If index is negative, 
    // the node will be inserted at the head of the list.
    if (index &lt; 0) index = 0;

    ++size;
    // find predecessor of the node to be added
    ListNode pred = head;
    for(int i = 0; i &lt; index; ++i) pred = pred.next;

    // node to be added
    ListNode toAdd = new ListNode(val);
    // insertion itself
    toAdd.next = pred.next;
    pred.next = toAdd;
  &#125;

  /** Delete the index-th node in the linked list, if the index is valid. */
  public void deleteAtIndex(int index) &#123;
    // if the index is invalid, do nothing
    if (index &lt; 0 || index &gt;= size) return;

    size--;
    // find predecessor of the node to be deleted
    ListNode pred = head;
    for(int i = 0; i &lt; index; ++i) pred = pred.next;

    // delete pred.next 
    pred.next = pred.next.next;
  &#125;
&#125;
</code></pre>
<h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><pre><code>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。
public class Solution &#123;
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
        ListNode t1 = headA;
        ListNode t2 = headB;
        while(t1 != t2)&#123;
            t1 = t1 != null ? t1.next : headB;
            t2 = t2 != null ? t2.next : headA;
        &#125;
        return t2;
    &#125;
&#125;
</code></pre>
<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><pre><code>方法一：哈希表
public boolean hasCycle(ListNode head) &#123;
    Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();
    while (head != null) &#123;
        if (nodesSeen.contains(head)) &#123;
            return true;
        &#125; else &#123;
            nodesSeen.add(head);
        &#125;
        head = head.next;
    &#125;
    return false;
&#125;
方法二：双指针
通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。
public boolean hasCycle(ListNode head) &#123;
    if (head == null || head.next == null) &#123;
        return false;
    &#125;
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) &#123;
        if (fast == null || fast.next == null) &#123;
            return false;
        &#125;
        slow = slow.next;
        fast = fast.next.next;
    &#125;
    return true;
&#125;
</code></pre>
<h2 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h2><pre><code>输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295
输出：2 -&gt; 1 -&gt; 9，即912
class Solution &#123;
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;
        //初始进位为0
        int pre = 0;
        //操作数
        ListNode mid = new ListNode(0);
        //返回头节点
        ListNode anws = mid ;
        //当l1和l2都不为null时进入while循环
        while(l1!=null&amp;&amp;l2!=null)&#123;
            //操作数赋值
            mid.val = (l1.val+l2.val+pre)%10;
            //更新进位
            pre = (l1.val+l2.val+pre)/10;
            //更新头节点
            l1 = l1.next;
            l2=l2.next;
            //头节点更新后判断是否为空
            if(l1==null)&#123;
                //如果l1头节点为空且进位为0，则操作数的next直接为l2剩下的
                if(pre==0) &#123;
                    mid.next = l2;
                    return anws;
                &#125;else &#123;
                    //如果有进位，则递归调用addTwoNumbers方法
                    mid.next = addTwoNumbers(l2,new ListNode(pre));
                    return anws;
                &#125;
            &#125;
            //同上
            if(l2 == null)&#123;
                if(pre==0) &#123;
                    mid.next = l1;
                    return anws;
                &#125;else &#123;
                    mid.next = addTwoNumbers(l1,new ListNode(pre));
                    return anws;
                &#125;
            &#125;
            //l1 l2更新后都不为null，则设置操作数为0 进入下一次while循环
            mid.next =new ListNode(0);
            mid = mid.next;
        &#125;
        //l1为null，直接不能进入上面while循环的情况下，直接返回l2
        if(l1==null)&#123;
            return l2;
        &#125;//同上
        else if(l2 ==null)&#123;
            return l1;
        &#125;
        return anws;
    &#125;
&#125;
</code></pre>
<h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><pre><code>1，采用快慢两个指针去寻找链表的中间节点；
2，根据链表的中间节点反转后一半的链表；
class Solution &#123;
    public boolean isPalindrome(ListNode head) &#123;
        if(head == null) return true;

    ListNode midNode = findMidNode(head);
    ListNode secondHalfHead = reverseLinked(midNode.next);
    ListNode curr1 = head;
    ListNode curr2 = secondHalfHead;

    boolean palindrome = true;
    while(palindrome &amp;&amp; curr2 != null)&#123;
        if(curr1.val != curr2.val) palindrome = false;
        curr1 = curr1.next;
        curr2 = curr2.next;
    &#125;

    return palindrome;
&#125;

/* 反转链表 */
private ListNode reverseLinked(ListNode head)&#123;
    ListNode cur = head;
    ListNode prev = null;
    while(cur != null)&#123;
        ListNode nextTemp = cur.next;
        cur.next = prev;
        prev = cur;
        cur = nextTemp;
    &#125;
    return prev;
&#125;

/* 快慢指针寻找中间节点 */
private ListNode findMidNode(ListNode head)&#123;
    ListNode fast = head;
    ListNode low = head;
    while(fast.next != null &amp;&amp; fast.next.next != null)&#123;
        fast = fast.next.next;
        low = low.next;
    &#125;
    return low;
&#125;

&#125;
</code></pre>
<h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><pre><code>先将链表闭合成环
找到相应的位置断开这个环，确定新的链表头和链表尾
class Solution &#123;
  public ListNode rotateRight(ListNode head, int k) &#123;
    // base cases
    if (head == null) return null;
    if (head.next == null) return head;

// close the linked list into the ring
ListNode old_tail = head;
int n;
for(n = 1; old_tail.next != null; n++)
  old_tail = old_tail.next;
old_tail.next = head;

// find new tail : (n - k % n - 1)th node
// and new head : (n - k % n)th node
ListNode new_tail = head;
for (int i = 0; i &lt; n - k % n - 1; i++)
  new_tail = new_tail.next;
ListNode new_head = new_tail.next;

// break the ring
new_tail.next = null;

return new_head;
  &#125;
&#125;
</code></pre>
<h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><pre><code>归并排序（递归法）
解答一：归并排序（递归法）
分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；
合并 merge 环节： 将两个排序链表合并，转化为一个排序链表
class Solution &#123;
    public ListNode sortList(ListNode head) &#123;
        if (head == null || head.next == null)
            return head;
        ListNode fast = head.next, slow = head;
        while (fast != null &amp;&amp; fast.next != null) &#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        ListNode tmp = slow.next;
        slow.next = null;
        ListNode left = sortList(head);
        ListNode right = sortList(tmp);
        ListNode h = new ListNode(0);
        ListNode res = h;
        while (left != null &amp;&amp; right != null) &#123;
            if (left.val &lt; right.val) &#123;
                h.next = left;
                left = left.next;
            &#125; else &#123;
                h.next = right;
                right = right.next;
            &#125;
            h = h.next;
        &#125;
        h.next = left != null ? left : right;
        return res.next;
    &#125;
&#125;
</code></pre>
<h2 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h2><pre><code>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起
将奇节点放在一个链表里，偶链表放在另一个链表里。然后把偶链表接在奇链表的尾部。
public class Solution &#123;
    public ListNode oddEvenList(ListNode head) &#123;
        if (head == null) return null;
        ListNode odd = head, even = head.next, evenHead = even;
        while (even != null &amp;&amp; even.next != null) &#123;
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        &#125;
        odd.next = evenHead;
        return head;
    &#125;
&#125;
</code></pre>
<h2 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a>链表的中间结点</h2><pre><code>方法一：数组
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        ListNode[] A = new ListNode[100];
        int t = 0;
        while (head != null) &#123;
            A[t++] = head;
            head = head.next;
        &#125;
        return A[t / 2];
    &#125;
&#125;
方法二：单指针法
我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        int n = 0;
        ListNode cur = head;
        while (cur != null) &#123;
            ++n;
            cur = cur.next;
        &#125;
        int k = 0;
        cur = head;
        while (k &lt; n / 2) &#123;
            ++k;
            cur = cur.next;
        &#125;
        return cur;
    &#125;
&#125;
方法三：快慢指针法
slow 一次走一步，fast 一次走两步。那么当 fast 到达链表的末尾时，slow 必然位于中间。
class Solution &#123;
    public ListNode middleNode(ListNode head) &#123;
        ListNode slow = head, fast = head;
        while (fast != null &amp;&amp; fast.next != null) &#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        return slow;
    &#125;
&#125;
</code></pre>
<h2 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h2><pre><code>主要考虑翻转后如何链接
const myReverse = (head, tail) =&gt; &#123;
    let prev = tail.next;
    let p = head;
    while (prev !== tail) &#123;
        const nex = p.next;
        p.next = prev;
        prev = p;
        p = nex;
    &#125;
    return [tail, head];
&#125;
var reverseKGroup = function(head, k) &#123;
    const hair = new ListNode(0);
    hair.next = head;
    let pre = hair;

    while (head) &#123;
        let tail = pre;
        // 查看剩余部分长度是否大于等于 k
        for (let i = 0; i &lt; k; ++i) &#123;
            tail = tail.next;
            if (!tail) &#123;
                return hair.next;
            &#125;
        &#125;
        const nex = tail.next;
        [head, tail] = myReverse(head, tail);
        // 把子链表重新接回原链表
        pre.next = head;
        tail.next = nex;
        pre = tail;
        head = tail.next;
    &#125;
    return hair.next;
&#125;;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift142HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift142HashMap/" class="post-title-link" itemprop="url">HashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:12" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:12+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）"><a href="#HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）" class="headerlink" title="HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）"></a>HashMap存储相关（多用来存储唯一性数据，或数据数量的使用）</h1><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><pre><code>由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的
数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到
的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。
public int findRepeatNumber(int[] nums) &#123;
    Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
    int repeat = -1;
    for (int num : nums) &#123;
        if (!set.add(num)) &#123;
            repeat = num;
            break;
        &#125;
    &#125;
    return repeat;
&#125;
</code></pre>
<h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><pre><code>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
本题考察 哈希表 的使用，本文介绍 “哈希表” 和 “有序哈希表” 两种解法。其中
，在字符串很长时， “有序哈希表” 解法理论上效率更高。
public char firstUniqChar(String s) &#123;
    HashMap&lt;Character, Boolean&gt; dic = new HashMap&lt;&gt;();
    char[] sc = s.toCharArray();
    for(char c : sc)
        dic.put(c, !dic.containsKey(c));
    for(char c : sc)
        if(dic.get(c)) return c;
    return &#39; &#39;;
&#125;

在哈希表的基础上，有序哈希表中的键值对是 按照插入顺序排序 的。
基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 1 的字符”。
public char firstUniqChar(String s) &#123;
    Map&lt;Character, Boolean&gt; dic = new LinkedHashMap&lt;&gt;();
    char[] sc = s.toCharArray();
    for(char c : sc)
        dic.put(c, !dic.containsKey(c));
    for(Map.Entry&lt;Character, Boolean&gt; d : dic.entrySet())&#123;
       if(d.getValue()) return d.getKey();
    &#125;
    return &#39; &#39;;
&#125;
</code></pre>
<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><pre><code>首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，
然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，
则将该数字添加到答案，并减少哈希表中该数字出现的次数。
为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现
的次数，然后遍历较长的数组得到交集。
public int[] intersect(int[] nums1, int[] nums2) &#123;
    if (nums1.length &gt; nums2.length) &#123;
        return intersect(nums2, nums1);
    &#125;
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
    for (int num : nums1) &#123;
        int count = map.getOrDefault(num, 0) + 1;
        map.put(num, count);
    &#125;
    int[] intersection = new int[nums1.length];
    int index = 0;
    for (int num : nums2) &#123;
        int count = map.getOrDefault(num, 0);
        if (count &gt; 0) &#123;
            intersection[index++] = num;
            count--;
            if (count &gt; 0) &#123;
                map.put(num, count);
            &#125; else &#123;
                map.remove(num);
            &#125;
        &#125;
    &#125;
    return Arrays.copyOfRange(intersection, 0, index);
&#125;
</code></pre>
<h2 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h2><pre><code>class Node &#123;
    public int val;
    public Node next;
    public Node random;

    public Node() &#123;&#125;

    public Node(int _val,Node _next,Node _random) &#123;
        val = _val;
        next = _next;
        random = _random;
    &#125;
&#125;;
public Node copyRandomList(Node head) &#123;
    if(head==null) &#123;
        return null;
    &#125;
    //创建一个哈希表，key是原节点，value是新节点
    Map&lt;Node,Node&gt; map = new HashMap&lt;Node,Node&gt;();
    Node p = head;
    //将原节点和新节点放入哈希表中
    while(p!=null) &#123;
        Node newNode = new Node(p.val);
        map.put(p,newNode);
        p = p.next;
    &#125;
    p = head;
    //遍历原链表，设置新节点的next和random
    while(p!=null) &#123;
        Node newNode = map.get(p);
        //p是原节点，map.get(p)是对应的新节点，p.next是原节点的下一个
        //map.get(p.next)是原节点下一个对应的新节点
        if(p.next!=null) &#123;
            newNode.next = map.get(p.next);
        &#125;
        //p.random是原节点随机指向
        //map.get(p.random)是原节点随机指向  对应的新节点 
        if(p.random!=null) &#123;
            newNode.random = map.get(p.random);
        &#125;
        p = p.next;
    &#125;
    //返回头结点，即原节点对应的value(新节点)
    return map.get(head);
&#125;
</code></pre>
<h2 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h2><pre><code>我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。
public boolean hasCycle(ListNode head) &#123;
    Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;();
    while (head != null) &#123;
        if (nodesSeen.contains(head)) &#123;
            return true;
        &#125; else &#123;
            nodesSeen.add(head);
        &#125;
        head = head.next;
    &#125;
    return false;
&#125;
</code></pre>
<h2 id="找树中两个指定节点的最近公共祖先。"><a href="#找树中两个指定节点的最近公共祖先。" class="headerlink" title="找树中两个指定节点的最近公共祖先。"></a>找树中两个指定节点的最近公共祖先。</h2><pre><code>哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点
开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已
经访问过的节点，那么这个节点就是我们要找的最近公共祖先。
class Solution &#123;
Map&lt;Integer, TreeNode&gt; parent = new HashMap&lt;Integer, TreeNode&gt;();
Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;();

public void dfs(TreeNode root) &#123;
    if (root.left != null) &#123;
        parent.put(root.left.val, root);
        dfs(root.left);
    &#125;
    if (root.right != null) &#123;
        parent.put(root.right.val, root);
        dfs(root.right);
    &#125;
&#125;

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
    dfs(root);
    while (p != null) &#123;
        visited.add(p.val);
        p = parent.get(p.val);
    &#125;
    while (q != null) &#123;
        if (visited.contains(q.val)) &#123;
            return q;
        &#125;
        q = parent.get(q.val);
    &#125;
    return null;
&#125;
&#125;
</code></pre>
<h2 id="缺失数字"><a href="#缺失数字" class="headerlink" title="缺失数字"></a>缺失数字</h2><pre><code>给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。
public int missingNumber(int[] nums) &#123;
    Set&lt;Integer&gt; numSet = new HashSet&lt;Integer&gt;();
    for (int num : nums) numSet.add(num);

    int expectedNumCount = nums.length + 1;
    for (int number = 0; number &lt; expectedNumCount; number++) &#123;
        if (!numSet.contains(number)) &#123;
            return number;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<h2 id="找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）"><a href="#找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）" class="headerlink" title="找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）"></a>找出最长连续序列的长度（通过将数组中的数字放入set中，然后遍历数组，查找set中是否有连续的序列）</h2><pre><code>public int longestConsecutive(int[] nums) &#123;
    Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;();
    for (int num : nums) &#123;
        num_set.add(num);
    &#125;

    int longestStreak = 0;

    for (int num : num_set) &#123;
        if (!num_set.contains(num - 1)) &#123;
            int currentNum = num;
            int currentStreak = 1;

            while (num_set.contains(currentNum + 1)) &#123;
                currentNum += 1;
                currentStreak += 1;
            &#125;

            longestStreak = Math.max(longestStreak, currentStreak);
        &#125;
    &#125;

    return longestStreak;
&#125;
</code></pre>
<h2 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h2><pre><code>遍历五张牌，遇到大小王（即 0直接跳过。
判别重复： 利用 Set 实现遍历判重， Set 
获取最大 / 最小的牌： 借助辅助变量 ma 和 mi ，遍历统计即可。
public boolean isStraight(int[] nums) &#123;
    Set&lt;Integer&gt; repeat = new HashSet&lt;&gt;();
    int max = 0, min = 14;
    for(int num : nums) &#123;
        if(num == 0) continue; // 跳过大小王
        max = Math.max(max, num); // 最大牌
        min = Math.min(min, num); // 最小牌
        if(repeat.contains(num)) return false; // 若有重复，提前返回 false
        repeat.add(num); // 添加此牌至 Set
    &#125;
    return max - min &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子
&#125;
</code></pre>
<h2 id="四数相加（HashMap存一组，另一组和HashMap进行比对）"><a href="#四数相加（HashMap存一组，另一组和HashMap进行比对）" class="headerlink" title="四数相加（HashMap存一组，另一组和HashMap进行比对）"></a>四数相加（HashMap存一组，另一组和HashMap进行比对）</h2><pre><code>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组和为0
采用分为两组，HashMap存一组，另一组和HashMap进行比对。
public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    int res = 0;
    for(int i = 0;i&lt;A.length;i++)&#123;
        for(int j= 0;j&lt;B.length;j++)&#123;
            int sumAB = A[i]+B[j];
            if(map.containsKey(sumAB)) map.put(sumAB,map.get(sumAB)+1);
            else map.put(sumAB,1);
        &#125;
    &#125;

    for(int i = 0;i&lt;C.length;i++)&#123;
        for(int j = 0;j&lt;D.length;j++)&#123;
            int sumCD = -(C[i]+D[j]);
            if(map.containsKey(sumCD)) res += map.get(sumCD);
        &#125;
    &#125;
    return res;
&#125;
</code></pre>
<h2 id="至少有K个重复字符的最长子串"><a href="#至少有K个重复字符的最长子串" class="headerlink" title="至少有K个重复字符的最长子串"></a>至少有K个重复字符的最长子串</h2><pre><code>先用hash表统计s中每个字符出现的次数，显然如果字符c出现的次数小于k
，c必然不在最长子串里面，根据这个特性可以将原始s分割成多个子串递归地求解问
题，我们用一个split数组依次来存放每个分割点的索引，对每个分割区间同样求
解该问题(多路的分治问题)，并取结果的最大值保存在变量ans中，此处有一个小trick
（如果当前求解的子串长度比已存在的ans还要小，则没有必要求解
该区间，这样可以减少不必要的计算），最后递归的结束点就是当前求
解的字符串s符合最长子串的要求。
public:
    int longestSubstring(string s, int k) &#123;
        unordered_map&lt;char, int&gt; umap;
        for (auto c : s) umap[c]++;
        vector&lt;int&gt; split;
        for (int i = 0; i &lt; s.size(); i++) &#123;
            if (umap[s[i]] &lt; k) split.push_back(i);
        &#125;
        if (split.size() == 0) return s.length();
        int ans = 0, left= 0;
        split.push_back(s.length());
        for (int i = 0; i &lt; split.size(); i++) &#123;
            int len = split[i] - left;
            if (len &gt; ans) ans = max(ans, longestSubstring(s.substr(left, len), k));
            left = split[i]+1;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
<h2 id="给定两个字符串-s-和-t-，编写一个函数来判断-t-是否是-s-的字母异位词。"><a href="#给定两个字符串-s-和-t-，编写一个函数来判断-t-是否是-s-的字母异位词。" class="headerlink" title="给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。"></a>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</h2><pre><code>public boolean isAnagram(String s, String t) &#123;
    if (s.length() != t.length()) &#123;
        return false;
    &#125;
    int[] counter = new int[26];
    for (int i = 0; i &lt; s.length(); i++) &#123;
        counter[s.charAt(i) - &#39;a&#39;]++;
        counter[t.charAt(i) - &#39;a&#39;]--;
    &#125;
    for (int count : counter) &#123;
        if (count != 0) &#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;
</code></pre>
<h2 id="给定一个字符串，找到它的第一个不重复的字符"><a href="#给定一个字符串，找到它的第一个不重复的字符" class="headerlink" title="给定一个字符串，找到它的第一个不重复的字符"></a>给定一个字符串，找到它的第一个不重复的字符</h2><pre><code>public int firstUniqChar(String s) &#123;
    HashMap&lt;Character, Integer&gt; count = new HashMap&lt;Character, Integer&gt;();
    int n = s.length();
    for (int i = 0; i &lt; n; i++) &#123;
        char c = s.charAt(i);
        count.put(c, count.getOrDefault(c, 0) + 1);
    &#125;
    
    for (int i = 0; i &lt; n; i++) &#123;
        if (count.get(s.charAt(i)) == 1) 
            return i;
    &#125;
    return -1;
&#125;
</code></pre>
<h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><pre><code>public int lengthOfLongestSubstring(String s) &#123;
    Map&lt;Character, Integer&gt; dic = new HashMap&lt;&gt;();
    int res = 0, tmp = 0;
    for(int j = 0; j &lt; s.length(); j++) &#123;
        int i = dic.getOrDefault(s.charAt(j), -1); // 获取索引 i
        dic.put(s.charAt(j), j); // 更新哈希表
        tmp = tmp &lt; j - i ? tmp + 1 : j - i; // dp[j - 1] -&gt; dp[j]
        res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
    &#125;
    return res;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift141%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift141%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:08" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:08+08:00">2020-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 10:07:07" itemprop="dateModified" datetime="2022-04-29T10:07:07+08:00">2022-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>数组元素在内存上连续存放，可以通过下表查找元素；插入，删除需要移动大量元素，比较适用于元素很少的情况
优点：
1、按照索引查询元素速度快
2、按照索引遍历数组方便
事物都有两面性，有优点自然就有缺点了
缺点：
1、数组的大小固定后就无法扩容了
2、数组只能存储一种类型的数据
3、添加，删除的操作慢，因为要移动其他的元素。
高级语言中所用数组结构
NSArrayM 用了环形缓冲区 (circular buffer)。环形缓冲区的内容能在到达任意一端时绕向另一端。
NSArrayM 试着去最小化内存的移动，因此会移动最少的一边元素。
</code></pre>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><pre><code>常见的字典结构都是hashmap实现的
扩容：开放定址法的结构通常允许在通列表的数量达到了某个阈值，通常是通列表长度的80%使用量
时，对通列表进行一次扩充grow，然后重新计算数据的keyHash放入新桶中
但是不断扩容的空间就是其弊端，因此开放地址法最好存储的是临时需要，尽快释放的资源
例如字典参数和associated object，拉链法就保证了资源的可控性，像这种@synchronized
锁就可以根据地址拉链出一条对应的使用线程即可，随时使用。
</code></pre>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><pre><code>链表中的元素在内存中不是顺序存储的，查找慢，插入、删除只需要对元素指针重新赋值，效率高
</code></pre>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><pre><code>堆是一种经过排序的树形数据结构，每个节点都有一个值，通常
我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常
可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：
1.堆中某个节点的值总是不大于或不小于其父节点的值；
2.堆总是一棵完全二叉树。
堆常用来实现优先队列
</code></pre>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><pre><code>栈是限定仅在表尾进行插入和删除操作的线性表。我们
把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据
元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删
除位置，它始终只在栈顶进行。
栈的应用—递归
</code></pre>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><pre><code>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表
。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表
，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作
，和栈一样，队列是一种操作受限制的线性表。
</code></pre>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><pre><code>典型应用是用于统计和排序大量的字符串（但不仅限于字符串），
所以经常被搜索引擎系统用于文本词频统计。它的优点是：
最大限度地减少无谓的字符串比较，查询效率比哈希表高。
</code></pre>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><pre><code>线段树，类似区间树，是一个完全二叉树，它在各个节点保存一条线段
（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，
由于二叉结构的特性，它基本能保持每个操作的复杂度为O(lgN)!
性质：父亲的区间是[a,b],(c=(a+b)/2)左儿子的区间是[a,c]，
右儿子的区间是[c+1,b]，线段树需要的空间为数组大小的四倍
</code></pre>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><pre><code>是每个结点最多有两个子树的树结构。通常子树被称作
“左子树”（left subtree）和“右子树”（right subtree）。
</code></pre>
<h3 id="⼆叉搜索树"><a href="#⼆叉搜索树" class="headerlink" title="⼆叉搜索树"></a>⼆叉搜索树</h3><pre><code>假如固定左边子树小于根节点，右边子树大于根节点，
让元素存入的时候就排序好，那么访问速度就加快了，我们称这样的树为二叉搜索树。
1. 若任意节点的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值； 
2. 若任意节点的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值； 
3. 任意节点的左、右⼦树也分别为⼆叉查找树。
</code></pre>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><pre><code>顾名思义，就是用数组来模拟树形结构呗。那么衍生出一个问题，
为什么不直接建树？答案是没必要，因为树状数组能处理的问题就没必要建
树。和Trie树的构造方式有类似之处。
2.树状数组可以解决什么问题
可以解决大部分基于区间上的更新以及求和问题。
3.树状数组和线段树的区别在哪里
树状数组可以解决的问题都可以用线段树解决，这两
者的区别在哪里呢？树状数组的系数要少很多，就比如字符串模
拟大数可以解决大数问题，也可以解决1+1的问题，但没人会
在1+1的问题上用大数模拟。
4.树状数组的优点和缺点
修改和查询的复杂度都是O(logN)，而且相比线段树系数要少很多，比传统数组要快，而且容易写。
缺点是遇到复杂的区间问题还是不能解决，功能还是有限。
</code></pre>
<p>总结算法和自己的模板。</p>
<p>图</p>
<p>优先队列<br>双端队列<br>有向图<br>无向图<br>复杂数据结构</p>
<p>二叉树<br>树状数组<br>优先队列<br>双端队列<br>有向图<br>无向图<br>// 中序遍历<br>void dfs(TreeNode root) {<br>    if(root == null) return;<br>    dfs(root.left); // 左<br>    System.out.println(root.val); // 根<br>    dfs(root.right); // 右<br>}</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>冒泡排序<br>插入排序<br>归并排序<br>快速排序<br>拓扑排序<br>堆排序（大顶堆、小顶堆）<br>桶排序<br>二分搜索<br>广度优先搜索<br>深度优先搜索<br>递归<br>回溯<br>贪婪算法<br>动态规划<br>线性规划<br>区间规划<br>约束规划<br>自底向上<br>自定向下</p>
<p>解体思路</p>
<p>输入一棵二叉树的根结点，求该树的深度？<br>输入一课二叉树的根结点，判断该树是不是平衡二叉树？<br>写个算法，输出2~100的素数<br>写二叉树的先序遍历，然后用非递归写<br>写快排，并分析原理<br>在10亿个数中如何快速找到最大的前100个数？<br>C语言中strlen和sizeof的区别<br>链表反转；<br>字符串查找问题；<br>求k数<br>给一个数组，找出这样一些数，这个数左边的数都比它小，右边的数都比它大<br>算法题：leetcode1 两数之和，给出三种方法<br>剑指offer 62 圆圈中剩下的数字（约瑟夫环问题）<br>leetcode 41 缺失的第一个正数<br>汉洛塔<br>如果为了加快进度增加2根竹子 如何得到最优解<br>智力题：三个人分别点了三家外卖，又一个外卖小哥配送，他有多少种配送方式<br>手撕代码题：<br>两种方法链表翻转<br>最大上升子序列<br>问算法题两道反转列表和二分查找；<br>智力题：赛马题，网上能搜到<br>手撕代码：一棵树，从左边看，输出你能看到的结点（我说用层次遍历、队列、哨兵）<br>问了一题智力题：8个杯子，给5个球，每个杯子放一个球，求三个球连续的概率（排列组合知识遗忘+紧张，没做出来。。）<br>    总共有C（8,5）=56种方法<br>    三个空格相连有123、234、···678共6种<br>    而每种情况是等概率的<br>    所以三个空格相连的概率=6/56=3/28<br>给一个字符串去重；<br>决策树的实现原理<br>上海到北京有很多条公交路线，每条线有不同个数的站点，问：如何找到一条最优路线？<br>hash算法又解决了哪些问题，它的时间复杂度是多少等等；<br>问一个有关花开通知蜜蜂，花关通知蜜蜂的问题；<br>问给出二叉树的前序排序和中序排序结果重建二叉树<br>问 从字典中取数据，为什么比在数组中取数据快，底层原理是什么<br>问到大批量数据库导入如何处理优化；<br>问了些性能优化、重构的问题；<br>问用递归写一个阶乘算法；<br>问：要求想一个时间复杂度为O1的解法，来解决一个2的平方的算法题（答 无限空间换时间的策略）；<br>问二叉树翻转(递归翻转);<br>断开连接是只有客户端断开还是两方都能断开；<br>二叉树非递归遍历二叉树先序、中序、后序；<br>ACID银行家算法；<br>图片的获取与切割；<br>一个不多于5位数的整数，反序处理problem；<br>两个IP端是否有交集problem；<br>给字符串，内含很多整数，按指定要求排序后输出指定位置上的整数；<br>如何返回两个int型变量；<br>如何快速找到一个链表的中间节点；<br>1.给两个int a, b不用temp将数值调换；<br>    如: let a = 1,b=2;<br>    a的二进制: 0001<br>    b的二进制: 0010<br>    利用异或运算的规律：两个操作数的位中，相同返回0，不同相返回1<br>    a = a^b;//now a = 0011<br>    b = b^a;//a: 0011, b:0010, now b:0001<br>    a = a^b;//b:0001, a:0011, now a:0010<br>    达到互换<br>2.银行家算法；<br>3. public private；<br>4.先序遍历树；</p>
<p>两个无限长度链表（也就是可能有环）判断有没有交点<br>10万个数中如何找出前K个数；<br>写一个算法，输出2到100之间的素数（然后不停地问你优化点）；<br>写二叉树的非递归前序遍历；<br>在很多的数据中如何快速找到最大的100个数？<br>二叉树的最大宽度<br>算法：单链表是否存在环；<br>问1秒钟有1000条数据，我只显示10条怎么做；<br>如何判断一个链表是否是无限长的（答判断next指针是否指向NULL）<br>非波拉切数求第n个数的值；<br>写一道二分查找；<br>用中文的数字表示一个十进制数；<br>两个有序数组，找出合并后的中位数。<br> 问了微信红包并发的问题的；<br> 算法：动态规划<br>搜索历史记录的关键字匹配（用的iOS自带的谓词做匹配筛选）<br> 算法：一个数组，有个滑动窗口，求每次窗口中的中位数。<br> 一个较复杂的排序算法:一个多边形分割方法;<br> 一个类似于从篮子里如何取苹果的一个算法;<br> 一个凸多边形，如何求面积。（答把多边形分割成N个三角形，三角形知道三个点的坐标就可以求出面积，全部相加求出总面积。）<br> 你知道矩阵吗？我说知道，他说那你用矩阵变换.<br> 二叉树的镜像；<br> 一组整数求加起来等于0的3个数；<br> 堆排序；<br> 求公共祖先问题<br> 复杂度代码实现；</p>
<p> 复杂度推导。<br> 问：查找登陆次数最多的十个用户<br> 答：（不确定对不对，我的思路是）先用哈希表保存登陆次数和ID，然后用红黑树保存最大的十个数；<br> 问：简述排序算法。<br> 答：快排，partion函数的原理，堆排（不稳定），归并排序，基数排序；<br> 两个字符串，只打印一个字符串中在另一个字符串中出现的共有的字符<br> Vector是怎么实现的？<br>  最小路径算法（楼主说了Dijkstra和floyd算法）<br> 求一个二叉树的最大深度，该二叉树不确定是不是红黑树<br> 两个人掷硬币，先得到正面的人赢，游戏到有人赢结束。问先掷硬币的人赢的概率<br> 算法：两个链表求和<br> 法 求第n大的数。<br> 堆和优先队列有什么区别？什么是堆排序、最大堆、最小堆？<br> 什么是二分搜索树？什么是平衡二分搜索树？常见的平衡二分搜索树有那几种？AVL树、B树、红黑树有什么区别？<br> 什么是稳定排序？时间复杂度的定义是什么？<br> 算法题:如何计算x^n?</p>
<p> Q3:算法题:给定二叉树Root以及任意两个节点p/q,问p,q的最近公共父亲节点是什么?</p>
<p> 有15个瓶子，其中最多有一瓶有毒，现在有四只老鼠，喝了有毒的水之后，第二天就会死。如何在第二天就可以判断出哪个瓶子有毒<br> 答：开始我想到的是常规思路二分法，717，和面试官说了，发现四只老鼠根本不够，面试官友好的提示从老鼠面去想，这时候很快想到了一个老鼠有死和不死，也就0和1两个状态，四只老鼠有16个组合，正好是足够的。但是怎么分配瓶子，还没想好，演算了一会儿，因为面试官这边时间有限，就说思路是正确的。下面有兴趣在看怎么分哈。面试就到此结束了。</p>
<p> 算法思路：二选一</p>
<p> Q1:数学题:给一个棍子，随机砍两刀，组成一个三角形的概率是多少?</p>
<p> Q2:有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生命都会在一星期之后死亡。现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？<br> 如何用Core Graph画圆<br> ，现在我们来做两个算法题，先说一下nlogn的时间复杂度的排序，并调一种实现。</p>
<p> 9，给定两个数组，第一个数组是无序的数长为n，第二个数组每个元素是一对下标[(1,3),(2,4)]，表示第一个数组中下标1-3的和和2-4的和，长度为m，我们要把其相对于第一个数组和求出来，选择一个比较优的算法，并分析其时间复杂度。</p>
<p> 比如1-3和2-4 ，2-3这里出现了重复计算，我们可以用一个额外的数组去保存这些重复运算，这个数组长度为</p>
<p> n，存储的值是，比如下标是1的时候相对于第一个数组下标0的值加下标1的值，下标是2的时候0+1+2，当我们要取数组的(2,5)范围的值，可以用新创建存储重复运算的数组，取其下标5减去其下标2就可以得出3+4+5的值。这题花了15分钟吧，问了三次面试官才知道题目的意思，一开始想用动态规划，后面得出这种用数组存储重复运算，想递归优化那种思路吧，面试官觉得这个答案正确，叫我说一下时间复杂度，最坏是(0,n)即0+1+2…n(这里是第一个数组的下标，这时候已经把所有可以重用的数据求出来了，即后面我们的运算只需要1的复杂度(2,5)-&gt;缓存数组[5]-缓存数组[2]，所以时间复杂度是n+m。这题差点想放弃，大家碰到算法题听不懂的时候不要太快放弃，面试官会很耐心的重复几次。<br>APP的相似照片检测算法<br>人脸识别能做吗？<br>就说了上个项目做类似朋友圈的优化思路，谈到了空间换时间，缓存，渲染相关的技术点。不得不惊叹腾讯的面试官的逻辑条理，很快抓住了问题的本质。</p>
<p>该模块引申到的新话题还涉及到了增量更新，内存缓存，本地缓存。细节上还谈到了富文本绘制，Coretext框架的使用，但由于也好久没用了，最后只能凭借印象大概说了下绘制的流程，其实面试官都是由浅入深的，如果这边回答的不够深入。那么后面也就不会有更深入的探讨了。由于之前我们的产品需求比较简单，没有特别完善。这里我也只能说了大概。</p>
<h1 id="公司性质问题"><a href="#公司性质问题" class="headerlink" title="公司性质问题"></a>公司性质问题</h1><p>自我介绍<br>谈谈自己做过的项目；<br>你还有什么问题问我<br>为什么想来<br>你有什么创新能力<br>聊人生<br>职业规划<br>.会问在之前的项目中担任什么角***r /&gt; 5.再根据你的角色问相关问题。</p>
<p>为什么在快手实习要来抖音面试<br>你认为字节跳动最吸引你的地方或者说好的地方<br>你觉得你比其他人的优点在哪里<br>你觉得未来自己应该做哪些深入研究<br>你对于基础服务和需求featrue 哪个更有兴趣：<br>互联网上广告的形式都有哪几种；<br>产品设计时需要考虑的因素；<br>安卓和ios的区别和优缺点，并让设计一款更好的操作系统；</p>
<p>认识到了自己的不足：<br>怎么改善提高：</p>
<p>大数据中取前100大的数<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyq522376829/article/details/47686867">https://blog.csdn.net/zyq522376829/article/details/47686867</a><br>面试题：输入一个十进制整数，将这个数字转化成对应的十五进制数（在十五进制中，A表示10，B表示11，C表示12，D表示13， E表示14），请写入转换程序。例如：235表示为10A；</p>
<p>地图相关的算法<br>三角剖分</p>
<p>初期:<br>一.基本算法:<br>(1)枚举. (poj1753,poj2965)<br>(2)贪心(poj1328,poj2109,poj2586)<br>(3)递归和分治法.<br>(4)递推.<br>(5)构造法.(poj3295)<br>(6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)<br>二.图算法:<br>(1)图的深度优先遍历和广度优先遍历.<br>(2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)<br>(poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)<br>(3)最小生成树算法(prim,kruskal)<br>(poj1789,poj2485,poj1258,poj3026)<br>(4)拓扑排序 (poj1094)<br>(5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)<br>(6)最大流的增广路算法(KM算法). (poj1459,poj3436)<br>三.数据结构.<br>(1)串 (poj1035,poj3080,poj1936)<br>(2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)<br>(3)简单并查集的应用.<br>(4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)<br>(poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)<br> (5)哈夫曼树(poj3253)<br>(6)堆<br>(7)trie树(静态建树、动态建树) (poj2513)<br>四.简单搜索<br>(1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)<br>(2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)<br>(3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)<br>五.动态规划<br>(1)背包问题. (poj1837,poj1276)<br>(2)型如下表的简单DP(可参考lrj的书 page149):<br>1.E[j]=opt{D+w(i,j)} (poj3267,poj1836,poj1260,poj2533)<br>2.E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)<br>(poj3176,poj1080,poj1159)<br>3.C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)<br>六.数学<br>(1)组合数学:<br>1.加法原理和乘法原理.<br>2.排列组合.<br>3.递推关系.<br>(POJ3252,poj1850,poj1019,poj1942)<br>(2)数论.<br>1.素数与整除问题<br>2.进制位.<br>3.同余模运算.<br>(poj2635, poj3292,poj1845,poj2115)<br>(3)计算方法.<br>1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122)<br>七.计算几何学.<br>(1)几何公式.<br>(2)叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)<br>(3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)<br>(poj1408,poj1584)<br>(4)凸包. (poj2187,poj1113)<br>中级:<br>一.基本算法:<br>(1)C++的标准模版库的应用. (poj3096,poj3007)<br>(2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)<br>二.图算法:<br>(1)差分约束系统的建立和求解. (poj1201,poj2983)<br>(2)最小费用最大流(poj2516,poj2195)<br>(3)双连通分量(poj2942)<br>(4)强连通分支及其缩点.(poj2186)<br>(5)图的割边和割点(poj3352)<br>(6)最小割模型、网络流规约(poj3308, )<br>三.数据结构.<br>(1)线段树. (poj2528,poj2828,poj2777,poj2886,poj2750)<br>(2)静态二叉检索树. (poj2482,poj2352)<br>(3)树状树组(poj1195,poj3321)<br>(4)RMQ. (poj3264,poj3368)<br>(5)并查集的高级应用. (poj1703,2492)<br>(6)KMP算法. (poj1961,poj2406)<br>四.搜索<br>(1)最优化剪枝和可行性剪枝<br>(2)搜索的技巧和优化 (poj3411,poj1724)<br>(3)记忆化搜索(poj3373,poj1691)<br>五.动态规划<br>(1)较为复杂的动态规划(如动态规划解特别的施行商问题等)<br>(poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)<br>(2)记录状态的动态规划. (POJ3254,poj2411,poj1185)<br>(3)树型动态规划(poj2057,poj1947,poj2486,poj3140)<br>六.数学<br>(1)组合数学:<br>1.容斥原理.<br>2.抽屉原理.<br>3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026).<br>4.递推关系和母函数.<br>(2)数学.<br>1.高斯消元法(poj2947,poj1487, poj2065,poj1166,poj1222)<br>2.概率问题. (poj3071,poj3440)<br>3.GCD、扩展的欧几里德(中国剩余定理) (poj3101)<br>(3)计算方法.<br>1.0/1分数规划. (poj2976)<br>2.三分法求解单峰(单谷)的极值.<br>3.矩阵法(poj3150,poj3422,poj3070)<br>4.迭代逼近(poj3301)<br>(4)随机化算法(poj3318,poj2454)<br>(5)杂题.<br>(poj1870,poj3296,poj3286,poj1095)<br>七.计算几何学.<br>(1)坐标离散化.<br>(2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).<br>(poj1765,poj1177,poj1151,poj3277,poj2280,poj3004)<br>(3)多边形的内核(半平面交)(poj3130,poj3335)<br>(4)几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429<br>)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift140%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%861/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift140%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%861/" class="post-title-link" itemprop="url">UI相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:30:03" itemprop="dateCreated datePublished" datetime="2020-09-06T17:30:03+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="drawRect和layouSubviews-的区别"><a href="#drawRect和layouSubviews-的区别" class="headerlink" title="drawRect和layouSubviews 的区别"></a>drawRect和layouSubviews 的区别</h2><p>1   layoutSubviews方便数据计算，<br>2   drawRect方便视图重绘。<br>layoutSubviews在以下情况下会被调用：<br>addSubview、改变view的大小、滚动一个UIScrollView、<br>旋转Screen会触发父UIView上的layoutSubviews，调用setLayoutSubviews。<br>drawRect在以下情况下会被调用：（必须有大小）<br>loadView，viewDidLoad，sizeToFit<br>直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:<br>强制layout刷新,调用setNeedsLayout来代替</p>
<h2 id="setNeedsLayout与layoutIfNeeded的区别"><a href="#setNeedsLayout与layoutIfNeeded的区别" class="headerlink" title="setNeedsLayout与layoutIfNeeded的区别"></a>setNeedsLayout与layoutIfNeeded的区别</h2><p>UIView的setNeedsDisplay和setNeedsLayout两个方法都是异步执行的。<br>而setNeedsDisplay会自动调用drawRect方法，这样可以拿到<br>UIGraphicsGetCurrentContext进行绘制；而setNeedsLayout会默认调用<br>layoutSubViews，给当前的视图做了标记；layoutIfNeeded<br>查找是否有标记，如果有标记及立刻刷新。<br>只有setNeedsLayout和layoutIfNeeded这二者合起来使用，才会起到立刻刷新的效果。</p>
<h2 id="Core-Graphics的更底层的是什么；"><a href="#Core-Graphics的更底层的是什么；" class="headerlink" title="Core Graphics的更底层的是什么；"></a>Core Graphics的更底层的是什么；</h2><p>　1）获取上下文<br>　2）绘制路径<br>　3）添加路径到上下文<br>　4）修改图形状态参数<br>　5）渲染上下文<br>　CGContextRef、CGPathRef、UIBezierPath</p>
<h2 id="iOS-保持界面流畅的技巧"><a href="#iOS-保持界面流畅的技巧" class="headerlink" title="iOS 保持界面流畅的技巧"></a>iOS 保持界面流畅的技巧</h2><p>1.预排版，提前计算<br>在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。<br>尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式<br>2.预渲染，提前绘制<br>例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了<br>避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。<br>3.异步绘制<br>4.全局并发线程<br>5.高效的图片异步加载</p>
<h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h2 id="消息转发的流程"><a href="#消息转发的流程" class="headerlink" title="消息转发的流程"></a>消息转发的流程</h2><p>（动态添加） 首先是征询接收者所属的类,看其是否能动态添加调用的方法,来处理当前这个未知的选择子;<br>-(BOOL)resolveInstanceMethod:(SEL)selector<br>（重定向-备援接收者）寻找是否在其他对象内有该方法实现,并将该消息转发给这个对象</p>
<ul>
<li>(id)forwardingTargetForSelector:(SEL)aSelector<br>生成方法签名，然后系统用这个方法签名生成NSInvocation对象。</li>
<li>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector<br>改变选择子</li>
<li>(void)forwardInvocation:(NSInvocation *)Invocation<br>抛出异常</li>
<li>(void)doesNotRecognizeSelector:(SEL)aSelector方法<h2 id="runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）"><a href="#runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）"></a>runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</h2>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,<br>以及参数类型,其实selector本质就是方法名称,<br>通过这个方法名称就可以在方法列表中找到对应的方法实现.<h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2>在runtime中所有类都存在一个哈希表中，在table的buckets中存储</li>
</ul>
<ol>
<li>加载所有类到类的gdb_objc_realized_classes表中</li>
<li>对所有类做重映射</li>
<li>将所有SEL都注册到namedSelectors表中</li>
<li>修复函数指针遗留</li>
<li>将所有Protocol添加到protocol_map表中</li>
<li>将所有Protocol重映射</li>
<li>初始化所有非懒加载的类，进行rw，ro操作 </li>
<li>便利所有懒加载类，执行初始化</li>
<li>处理所有Category包括Class和MetaClass</li>
<li>初始化所有未初始化类<h2 id="msgSend参数都有哪些；"><a href="#msgSend参数都有哪些；" class="headerlink" title="msgSend参数都有哪些；"></a>msgSend参数都有哪些；</h2><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="NSObject内存分配、ISA指针的内存大小"><a href="#NSObject内存分配、ISA指针的内存大小" class="headerlink" title="NSObject内存分配、ISA指针的内存大小"></a>NSObject内存分配、ISA指针的内存大小</h2>在64位架构下，如果他的第一位是0 。则代表他是一个 isa<br>指针,表示当前对象的类对象的地址，如果是1，则不仅代表一个 isa<br>指针,类对象的地址，里面还存储内存管理相关的内容，第二位代表是否有关联对象，<br>0代表没有，1代表有（has_assoc）,第三位,代表当前对象是否含有C++代码<br>（has_cxx_dtor）,3-15表示当前对象的类对象内存地址,16-31<br>,也是，32-35位也是，也就是说，13+16+4 = 33位<h2 id="子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool"><a href="#子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool" class="headerlink" title="子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool"></a>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool</h2>在子线程你创建了 Pool 的话，产生的 Autorelease 对象就会交给 pool 去管理。<br>如果你没有创建 Pool ，但是产生了 Autorelease 对象，就会调用 autoreleaseNoPage<br>方法。在这个方法中，会自动帮你创建一个 hotpage（hotPage 可以理解为当前正在使用的<br>AutoreleasePoolPage，如果你还是不理解，可以先看看 Autoreleasepool<br>的源代码，再来看这个问题 ），并调用 page-&gt;add(obj)将对象添加到<br>AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！<h2 id="dealloc调用流程"><a href="#dealloc调用流程" class="headerlink" title="dealloc调用流程"></a>dealloc调用流程</h2></li>
<li>直接调用 objc_destructInstance()。</li>
<li>之后调用C的 free() 函数。</li>
<li>objc_destructInstance() 调用流程<br>1&gt;.先判断 hasCxxDtor，是否有析构函数（析构器），<br>要调用 object_cxxDestruct() ，释放（清除成员变量）。<br>2&gt;.再判断hasAssocitatedObjects，如果有的话，<br>要调用object_remove_associations()， 移除当前对象的关联对象。<br>3&gt;.然后调用 clearDeallocating()。 </li>
<li>clearDeallocating() 调用流程<br>0&gt;. 判断isa是否优化过，从arm64架构开始，对isa进行了优化，<br>变成了一个共用体（union）结构，所以结果一般是优化过了。<br>判断是否有弱引用或者引用计数<br>1&gt;.执行 clearDeallocating_slow()。<br>2&gt;.再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。<br>3&gt;.接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。<br>4&gt;.至此为止，Dealloc 的执行流程结束。<h2 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h2>启用Zombie Object进行悬挂指针的检测。<br>应用Product -&gt; Analysis进行内存泄露的初步检测。<br>可以在xcode的build setting中打开implicit retain of ‘self’<br>within blocks，xcode编译器会给出警告，逐个排查警告。<br>应用Leak Instrument进行内存泄露查找。<br>在以上方法不奏效的情况下，通过查看dealloc是否调用查看某个class是否泄露的问题</li>
</ol>
<h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><p>内存泄漏（memory leak）：是指申请的内存空间使用完毕之后未回收。<br>一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，<br>最终导致程序crash。（因此，开发中我们要尽量避免内存泄漏的出现）<br>内存溢出（out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用。<br>通俗理解就是内存不够用了，通常在运行大型应用或游戏时，应用或游戏所需要<br>的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。最终导致机器重启或者程序crash。<br>第一种：静态分析方法（Analyze）<br>第二种：动态分析方法（Instrument工具库里的Leaks）。一般推荐使用第二种。</p>
<h2 id="举例一些I-O操作的例子"><a href="#举例一些I-O操作的例子" class="headerlink" title="举例一些I/O操作的例子"></a>举例一些I/O操作的例子</h2><p>1）阻塞IO<br>2）非阻塞IO<br>3）IO复用（select和poll）<br>4）信号驱动IO（sigio）<br>5）异步IO（aio_）</p>
<h2 id="如何开辟一块内存；"><a href="#如何开辟一块内存；" class="headerlink" title="如何开辟一块内存；"></a>如何开辟一块内存；</h2><p>其实结论就是 实际分配内存是按照16字节对齐的 内存大小都是16 的倍数。</p>
<h2 id="怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手"><a href="#怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手" class="headerlink" title="怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手"></a>怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手</h2><p>复用机制<br>少使用xib<br>不要阻塞线程<br>图片优化<br>合理使用数组字典优化查找速度<br>懒加载<br>缓存<br>一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。可以用单例来处理，避免日期格式转换<br>选择正确的数据格式，json、xml、二进制数据流<br>少使用webView<br>优化tableView<br>选择正确的数据持久化</p>
<h2 id="问堆和栈的区别。"><a href="#问堆和栈的区别。" class="headerlink" title="问堆和栈的区别。"></a>问堆和栈的区别。</h2><p>（答对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。）</p>
<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop概念及数据结构、事件循环机制"><a href="#RunLoop概念及数据结构、事件循环机制" class="headerlink" title="RunLoop概念及数据结构、事件循环机制"></a>RunLoop概念及数据结构、事件循环机制</h2><p>CFRunLoop<br>CFRunLoopMode<br>Source/Timer/Observer<br>source0<br>需要手动唤醒线程<br>source1<br>具备唤醒线程的能力<br>CFRunLoopObserver<br>观测时间点<br>kCFRunLoopEntry<br>kCFRunLoopBeforeTimers<br>CommonMode的特性<br>NSRunLoopCommonModes<br>commonMode不是实际存在的一种mode<br>是同步Source/Timer/Observer到多个Mode中的一种技术方案<br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个<br>Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个<br>Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出<br>Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的<br>Source/Timer/Observer，让其互不影响。</p>
<h2 id="RunLoop和多线程"><a href="#RunLoop和多线程" class="headerlink" title="RunLoop和多线程"></a>RunLoop和多线程</h2><p>在异步线程中下载很多图片,如果失败了,该如何处理?请结合RunLoop来谈谈解决方案<br>在异步线程中启动一个RunLoop重新发送网络请求,下载图片<br>如果程序启动就需要执行一个耗时操作，你会怎么做？<br>开启一个异步的子线程，并启动它的RunLoop来执行该耗时操作</p>
<h2 id="你在开发过程中怎么使用RunLoop？什么应用场景？"><a href="#你在开发过程中怎么使用RunLoop？什么应用场景？" class="headerlink" title="你在开发过程中怎么使用RunLoop？什么应用场景？"></a>你在开发过程中怎么使用RunLoop？什么应用场景？</h2><p>开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来的消息，处理其他事件）<br>在子线程中开启一个定时器<br>在子线程中进行一些长期监控<br>可以控制定时器在特定模式下运行<br>可以让某些事件（行为，任务）在特定模式下执行<br>可以添加observer监听RunLoop的状态，比如监听点击事件的处理（比如在所有点击事件前做一些处理）<br>1）NSTimer<br>2）ImageView显示：控制方法在特定的模式下可用<br>3）PerformSelector<br>4）常驻线程：在子线程中开启一个runloop<br>5）自动释放池</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="GCD、NSOperation、NSThread区别优缺点"><a href="#GCD、NSOperation、NSThread区别优缺点" class="headerlink" title="GCD、NSOperation、NSThread区别优缺点"></a>GCD、NSOperation、NSThread区别优缺点</h2><p>第一种：pthread<br>    a.特点：<br>        1）一套通用的多线程API<br>        2）适用于Unix\Linux\Windows等系统<br>        3）跨平台\可移植<br>        4）使用难度大<br>    b.使用语言：c语言<br>    c.使用频率：几乎不用<br>    d.线程生命周期：由程序员进行管理<br>第二种：NSThread<br>    a.特点：<br>        1）使用更加面向对象<br>        2）简单易用，可直接操作线程对象<br>        b.使用语言：OC语言<br>        c.使用频率：偶尔使用<br>        d.线程生命周期：由程序员进行管理<br>第三种：GCD<br>    a.特点：<br>        1）旨在替代NSThread等线程技术<br>        2）充分利用设备的多核（自动）<br>    b.使用语言：C语言<br>    c.使用频率：经常使用<br>    d.线程生命周期：自动管理<br>第四种：NSOperation<br>    a.特点：<br>        1）基于GCD（底层是GCD）<br>        2）比GCD多了一些更简单实用的功能<br>        3）使用更加面向对象<br>    b.使用语言：OC语言<br>    c.使用频率：经常使用<br>    d.线程生命周期：自动管理</p>
<h2 id="如何让多个网络请求完成后执行下一步"><a href="#如何让多个网络请求完成后执行下一步" class="headerlink" title="如何让多个网络请求完成后执行下一步"></a>如何让多个网络请求完成后执行下一步</h2><p>  dispatch_group_t</p>
<h2 id="多个网络请求顺序执行后执行下一步"><a href="#多个网络请求顺序执行后执行下一步" class="headerlink" title="多个网络请求顺序执行后执行下一步"></a>多个网络请求顺序执行后执行下一步</h2><pre><code>dispatch_semaphore_wait
</code></pre>
<h2 id="异步操作两组数据时-执行完第一组之后-才能执行第二组"><a href="#异步操作两组数据时-执行完第一组之后-才能执行第二组" class="headerlink" title="异步操作两组数据时, 执行完第一组之后, 才能执行第二组"></a>异步操作两组数据时, 执行完第一组之后, 才能执行第二组</h2><pre><code>dispatch_barrier_async
</code></pre>
<h2 id="你知道哪些锁、使用场景"><a href="#你知道哪些锁、使用场景" class="headerlink" title="你知道哪些锁、使用场景"></a>你知道哪些锁、使用场景</h2><p>@synchronized 一个对象层面的锁，锁住了整个对象，底层使用了互斥递归<br>锁来实现<br>pathread_mutex 互斥锁（c语言）和信号量的实现原理类似，也是阻塞线程并进入睡眠<br>，需要进行上下文切换。<br>NSLock 对象锁-简单的互斥锁（内部封装了一个 pthread_mutex）<br>NSCondition （封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件<br>NSCondition和NSLock、@synchronized等是不同的是，<br>NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。<br>这是非常强大。<br>NSConditionLock （借助 NSCondition 来实现，本质是生产者-消费者模型）<br>也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。<br>NSRecursiveLock 递归锁有时候“加锁代码”中存在递归调用，递归开始前加<br>dispatch_semaphore GCD中信号量，也可以解决资源抢占问题,<br>支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；<br>每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，<br>直到信号量大于0开始执行<br>OSSpinLock 自旋锁(不建议使用)<br>自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取<br>锁就需要等待a线程释放锁。在没有获得锁的期间，b线程会一直处于忙等的状<br>态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太<br>划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。</p>
<h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><p>相同点：都能保证同一时间只有一个线程访问共享资源。<br>都能保证线程安全。<br>不同点：<br>互斥锁：如果共享数据已经有其他线程加锁了，线程会进入<br>休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的<br>线程会被唤醒。<br>自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环<br>的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会<br>立即执行。<br>自旋锁的效率高于互斥锁。<br>由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放<br>自旋锁，否则等待该自旋锁的线程会一直在哪里自旋，这就会浪<br>费CPU时间。<br>持有自旋锁的线程在sleep之前应该释放自旋锁以便其他可以获得<br>该自旋锁。内核编程中，如果持有自旋锁的代码sleep了就可能<br>导致整个系统挂起。</p>
<h2 id="runloop与autoreleasepool的关系"><a href="#runloop与autoreleasepool的关系" class="headerlink" title="runloop与autoreleasepool的关系"></a>runloop与autoreleasepool的关系</h2><p>(AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组成)<br>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），<br>除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址<br>iOS里的TaggedPointer不适用autorelesepool<br>AutoreleasePool 在 runloop 在开始时被push，在runloop休眠时(beforewaiting状态)pop</p>
<h2 id="GCD-在Runloop中的使用"><a href="#GCD-在Runloop中的使用" class="headerlink" title="GCD 在Runloop中的使用"></a>GCD 在Runloop中的使用</h2><pre><code>GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。
</code></pre>
<h2 id="GCD-Global队列创建线程进行耗时操作的风险"><a href="#GCD-Global队列创建线程进行耗时操作的风险" class="headerlink" title="GCD Global队列创建线程进行耗时操作的风险"></a>GCD Global队列创建线程进行耗时操作的风险</h2><p>dispatch_async 函数分发到全局队列不一定会新建线程执行任务，全局队列底层有一个的线程池，如果线程池满了，<br> 那么后续的任务会被 block 住，等待前面的任务执行完成，才会继续执行。如果线程池中的线程<br> 长时间不结束，后续堆积的任务会越来越多，此时就会存在 APP crash的风险。<br> 避免使用 GCD Global 队列创建 Runloop 常驻线程</p>
<h2 id="NSOperation数据结构"><a href="#NSOperation数据结构" class="headerlink" title="NSOperation数据结构"></a>NSOperation数据结构</h2><p>ddDependency操作依赖性<br>KVO 兼容属性<br>cancelAllOperations 响应取消命令<br>start;执行操作<br>NSBlockOperation：用于管理一个或多个block的并发执行。<br>NSInvocationOperation：NSInvocationOperation类是NSOperation的一个具体<br>子类，用于开启一个操作，该操作包括在指定对象上调用一个selector。</p>
<h2 id="重写NSOperation需要注意的点"><a href="#重写NSOperation需要注意的点" class="headerlink" title="重写NSOperation需要注意的点"></a>重写NSOperation需要注意的点</h2><p>1、如果需要自定义并发执行的 Operation，必须重写start、main、isExecuting、isFinished、isAsynchronous方法。<br>2、在 operation 的 main 方法里面，必须提供 autorelease pool,因为你的 operation 完成后需要销毁。<br>3、一旦你的 operation 开始了，必须通过 KVO，告诉所有的监听者，现在该operation的执行状态。<br>4、调用时，如果需要并发执行 Operation，必须调用performOperation:方法，当然，也可以改为自定义其他方法或者直接在start方法添加多线程调用。<br>5、对于自定义的 Operation 类，如果不需要并发执行，可以直接调用start</p>
<h2 id="进程中的哪些空间是线程所共有的？"><a href="#进程中的哪些空间是线程所共有的？" class="headerlink" title="进程中的哪些空间是线程所共有的？"></a>进程中的哪些空间是线程所共有的？</h2><p>  一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)</p>
<h2 id="使用GCD需要注意什么；"><a href="#使用GCD需要注意什么；" class="headerlink" title="使用GCD需要注意什么；"></a>使用GCD需要注意什么；</h2><p>dispatch_sync同步死锁（循环等待）<br>重复的获取互斥资源引发的等待（加锁）<br>开启过多线程<br>线程和RunLoop，子线程不会开启runloop</p>
<h2 id="runloop跟runtime有没有关联"><a href="#runloop跟runtime有没有关联" class="headerlink" title="runloop跟runtime有没有关联"></a>runloop跟runtime有没有关联</h2><p>个人想到的是autoreleasepool、其他的不好找<br>runloop中事件源都是由运行时runtime触发</p>
<h2 id="CPU和GPU怎么相互合作的"><a href="#CPU和GPU怎么相互合作的" class="headerlink" title="CPU和GPU怎么相互合作的"></a>CPU和GPU怎么相互合作的</h2><p>命令缓冲区包含了一个命令队列，由CPU向其中添加命令，而由GPU从中读取命令<br>，添加和读取的过程是互相独立的。命令缓冲区使得CPU和GPU可以互相独立工作<br>。当CPU需要渲染一些对象时，它可以向命令缓冲区中添加命令，而当GPU完成了上<br>一次的渲染任务后，它就可以从命令队列中再取出一个命令并执行它。</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTPS-TLS-SSL加密过程"><a href="#HTTPS-TLS-SSL加密过程" class="headerlink" title="HTTPS TLS/SSL加密过程"></a>HTTPS TLS/SSL加密过程</h2><p>1、客户端向服务器端索要并验证公钥。<br>2、双方协商生成”对话密钥”。<br>3、双方采用”对话密钥”进行加密通信。<br>其中，前两个阶段，被称为“握手阶段”。<br>TLS握手过程有单向验证和双向验证之分，简单解释一下，单向验证就是<br>server端将证书发送给客户端，客户端验证server端证书的合法性等，<br>例如百度、新浪、google等普通的https网站，双向验证则是不仅客户端会验<br>证server端的合法性，同时server端也会验证客户端的合法性，例如银行网银登陆<br>，支付宝登陆交易等。<br>1、确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>2、一个服务器生成的随机数（Sever Random），稍后用于生成”对话密钥”。<br>3、确认使用的加密方法，比如RSA公钥加密。<br>4、服务器证书（Certificate）。<br>5、支持的一些SSL/TLS扩展。</p>
<h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><p>①客户端发送报文进行SSL通信。报文中包含客户端支持的SSL的指定版本、<br>加密组件列表（加密算法及密钥长度等）。<br>②服务器应答，并在应答报文中包含SSL版本以及加密组件。<br>服务器的加密组件内容是从接受到的客户端加密组件内筛选出来的。<br>③服务器发送报文，报文中包含公开密钥证书。<br>④服务器发送报文通知客户端，最初阶段SSL握手协商部分结束。<br>⑤SSL第一次握手结束之后，客户端发送一个报文作为回应。<br>报文中包含通信加密中使用的一种被称Pre-master<br>secret的随机密码串。该密码串已经使用服务器的公钥加密。<br>⑥客户端发送报文，并提示服务器，此后的报文通信会采用<br>Pre-master secret密钥加密。<br>⑦客户端发送Finished报文。该报文包含连接至今全部报文的<br>整体校验值。这次握手协商是否能够完成成功，要以服务器是否能够正确解密该报文作为判定标准。<br>⑧服务器同样发送Change Cipher Spec报文。<br>⑨服务器同样发送Finished报文。<br>⑩服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。<br>⑪应用层协议通信，即发送HTTP响应。<br>⑫最后由客户端断开链接。断开链接时，发送close_nofify报文</p>
<h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><p>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。<br>  由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。<br>  对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，<br>  再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。<br>  pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，<br>  如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用<br>  pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和<br>  服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机<br>  可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，<br>  随机性增加的可不是一。</p>
<h2 id="TCP特点及与UDP区别"><a href="#TCP特点及与UDP区别" class="headerlink" title="TCP特点及与UDP区别"></a>TCP特点及与UDP区别</h2><p>基于连接（点对点）<br>传输数据前需要建立好连接，然后在传输<br>双工通信<br>TCP连接一旦建立，就可以在连接上进行双向的通信<br>基于字节流而非报文<br>将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制能够保证TCP协议的有序性和完整性，因此TCP能够提供可靠性传输</p>
<p>可靠传输<br>拥塞控制<br>慢启动，拥塞避免，拥塞发生，快速恢复四个算法<br>流量控制能力</p>
<h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><p>DNS服务器一般分三种，根DNS服务器，顶级DNS服务器，权威DNS服务器。<br>1）浏览器缓存　　<br>2）系统缓存　　<br>3）路由器缓存　　　　<br>4） ISP（互联网服务提供商）DNS缓存<br>5）根域名服务器　　　<br>6）顶级域名服务器　　<br>8）保存结果至缓存</p>
<h2 id="HTTP请求头都有哪些内容"><a href="#HTTP请求头都有哪些内容" class="headerlink" title="HTTP请求头都有哪些内容"></a>HTTP请求头都有哪些内容</h2><p>Accept: <em>/</em>(客户端能接收的资源类型)<br>Accept-Language: en-us(客户端接收的语言类型)<br>Connection: Keep-Alive(维护客户端和服务端的连接关系)<br>Host: localhost:8080(连接的目标主机和端口号)<br>Referer: <a target="_blank" rel="noopener" href="http://localhost/links.asp(%E5%91%8A%E8%AF%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%91%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%93%AA%E9%87%8C)">http://localhost/links.asp(告诉服务器我来自于哪里)</a><br>User-Agent: Mozilla/4.0(客户端版本号的名字)<br>Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)<br>If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)<br>Cookie(客户端暂存服务端的信息)<br>Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间</p>
<h2 id="哪些加密算法"><a href="#哪些加密算法" class="headerlink" title="哪些加密算法"></a>哪些加密算法</h2><p>MD5加密算法<br>RSA加密算法<br>AES加密算法<br>Base64加密算法</p>
<h2 id="断点续传怎么实现"><a href="#断点续传怎么实现" class="headerlink" title="断点续传怎么实现;"></a>断点续传怎么实现;</h2><p>续传的文件就好说了，只要给一个续传的标识位置，和对应的字节流就可以了，代码如下:<br>filePath:生成的文件,用来续传用<br>content:将要写入的字节<br>position:续传的字节位置</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p> 单一职责原则<br>      CALayer：动画和视图的显示。<br>      UIView：只负责事件传递、事件响应。<br>      生成的数据模型<br>  开闭原则<br>      对修改关闭，对扩展开放。 要考虑到后续的扩展性，而不是在原有的基础上来回修改<br>  接口隔离原则<br>      使用多个专门的协议、而不是一个庞大臃肿的协议，如<br>      UITableviewDelegate + UITableViewDataSource<br>  依赖倒置原则<br>      抽象不应该依赖于具体实现、具体实现可以依赖于抽象。<br>      调用接口感觉不到内部是如何操作的<br>  里氏替换原则<br>      父类可以被子类无缝替换，且原有的功能不受任何影响 如：KVO<br>  迪米特法则<br>      一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合</p>
<h2 id="iOS有哪些常见的设计模式"><a href="#iOS有哪些常见的设计模式" class="headerlink" title="iOS有哪些常见的设计模式?"></a>iOS有哪些常见的设计模式?</h2><p>01代理委托Delegate是协议的一种<br> ,通过@protocol方式实现，常见的有tableView，textField等。<br> 02观察者 通知机制(notification)和KVO机制(Key-value Observing)<br> 03MVC<br> 04单例（Singleton）,UIApplication, NSBundle, NSNotificationCenter,<br> NSFileManager, NSUserDefault, NSURLCache等都是单例.<br> 05策略<br> 06工厂</p>
<h2 id="内存设计、磁盘设计、网络设计原则"><a href="#内存设计、磁盘设计、网络设计原则" class="headerlink" title="内存设计、磁盘设计、网络设计原则"></a>内存设计、磁盘设计、网络设计原则</h2><p>内存设计:存储的Size,淘汰策略 LRU算法<br>磁盘设计:存储方式\大小限制\淘汰策略<br>网络设计:图片请求最大并发\请求超时策略\请求优先级</p>
<h2 id="MVVM模式思想"><a href="#MVVM模式思想" class="headerlink" title="MVVM模式思想"></a>MVVM模式思想</h2><p>MVVM 即模型-视图-视图模型<br>在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，<br>ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel<br>能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，<br>ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的<br>双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。<br>优点 VIew可以独立于Model的变化和修改，一个ViewModel可以绑定到不同的View上，<br> 降低耦合，增加重用<br> 缺点 过于简单的项目不适用、大型的项目视图状态较多时构建和维护成本太大<br> 合理的运用架构模式有利于项目、团队开发工作，但是到底选择哪个设计模式，</p>
<h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><p>Flux是Facebook用来构建用户端的web应用的应用程序体系架构。<br>它通过利用数据的单向流动为React的可复用的视图组件提供了补充。<br>相比于形式化的框架它更像是一个架构思想，不需要太多新的代码你就可以马上<br>使用Flux构建你的应用。<br>一个 Flux 应用主要包含四个部分：<br>dispatcher<br>处理动作分发，维护 Store 之间的依赖关系<br>stores<br>数据和逻辑部分<br>views<br>React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互<br>actions<br>提供给 dispatcher 传递数据给 store<br>视图上添加的所有的视图组成一个视图多叉树；<br>比如某个UI发生变化后，需要反向到根节点，然后由根节点想下遍历查找需<br>要更新的结点；<br>任何一个子节点是没有权利自我更新的，需要把自我变化更<br>新的消息传递给根节点，由根节点进行更新，相当于由主动行为变成被动行为</p>
<h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：<br>   排版，绘制，UI对象操作。<br>   排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>   绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>   UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。<br>   其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主<br>   线程完成，并且有时后面的操作需要依赖前面操作的结果<br>   （例如TextView创建时可能需要提前计算出文本的大小）。ASDK<br>   所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟<br>   (例如视图的创建、属性的调整)。<br>   为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了<br>   UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如<br>   frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只<br>   通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制<br>   放入了后台线程。但是无论怎么操作，<br>   这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>   ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面<br>   更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了<br>   kCFRunLoopBeforeWaiting 和 kCFRunLoopExit<br>   事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<h2 id="AFNetworking-底层原理分析"><a href="#AFNetworking-底层原理分析" class="headerlink" title="AFNetworking 底层原理分析"></a>AFNetworking 底层原理分析</h2><p>AFNetworking是封装的NSURLSession的网络请求，由五个模块组成：<br>分别由NSURLSession,Security,Reachability,Serialization,UIKit五部分组成<br>NSURLSession：网络通信模块（核心模块） 对应 AFNetworking中的<br>AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager<br>,AFHTTPSessionManager是继承于AFURLSessionmanager的<br>Security：网络通讯安全策略模块 对应 AFSecurityPolicy<br>Reachability：网络状态监听模块 对应AFNetworkReachabilityManager<br>Seriaalization：网络通信信息序列化、反序列化模块 对应AFURLResponseSerialization<br>UIKit：对于iOS UIKit的扩展库</p>
<h2 id="SDWebImage加载图片过程，图片缓存设计"><a href="#SDWebImage加载图片过程，图片缓存设计" class="headerlink" title="SDWebImage加载图片过程，图片缓存设计"></a>SDWebImage加载图片过程，图片缓存设计</h2><p>0、首先显示占位图<br>1、在webimagecache中寻找图片对应的缓存，它是以url为数据索引先在内存中<br>查找是否有缓存；<br>2、如果没有缓存，就通过md5处理过的key来在磁盘中查找<br>对应的数据，如果找到就会把磁盘中的数据加到内存中，并显示出来；<br>3、如果内存和磁盘中都没有找到，就会向远程服务器发送请求，开始下载图片；<br>4、下载完的图片加入缓存中，并写入到磁盘中；<br>5、整个获取图片的过程是在子线程中进行，在主线程中显示。</p>
<h2 id="组建化优缺点"><a href="#组建化优缺点" class="headerlink" title="组建化优缺点"></a>组建化优缺点</h2><p>业务分层、解耦，使代码变得可维护；<br>有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；<br>便于各业务功能拆分、抽离，实现真正的功能复用；<br>分工更加明确，提高开发效率<br>复用性更好，能迅速的组成更多的App</p>
<h2 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h2><p>视图层(View&amp;ViewController)<br>业务逻辑处理(ViewModel)<br>数据层(Model&amp;Engine)<br>数据流<br>数据与数据关系<br>MVVM框架思想<br>ReactiveNative的数据流思想<br>系统UIView更新机制的思想<br>FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想</p>
<h2 id="解耦的方式"><a href="#解耦的方式" class="headerlink" title="解耦的方式"></a>解耦的方式</h2><p>1、组件化<br>2、结合MVVM架构和数据驱动UI模式对原有MVC架构进行了兼容性优化<br>3、通过AOP技术对部分业务进行拆分解耦<br>4、优化事件传递方式</p>
<h2 id="项目中用的技术以及实现；"><a href="#项目中用的技术以及实现；" class="headerlink" title="项目中用的技术以及实现；"></a>项目中用的技术以及实现；</h2><p>1.复杂cell提前缓存行高和UI的frame<br>2.网络请求库的封装<br>3.组建化简单实现<br>4.tableView嵌套滑动<br>5.地图对象的单例封装<br>6.用View代替ViewController的实现<br>7.定时器使用</p>
<h2 id="缓存机制是怎么清除数据的？"><a href="#缓存机制是怎么清除数据的？" class="headerlink" title="缓存机制是怎么清除数据的？"></a>缓存机制是怎么清除数据的？</h2><p>沙盒：iOS系统为每一个应用程序创建一个文件目录,是一个的独立,封闭,安全的空间, 一个沙盒就是一个文件目录。沙盒规定了一个程序只能在自身的沙盒中进行操作,不能去访问其他应用程序的沙盒(iOS8已经部分开放访问)<br>沙盒的作用: 用来存放非代码文件(图片, 音频, 视频, 属性列表(plist), sqlite数据库, 文本文件, 其他等等)</p>
<h2 id="如何进行安全测试；"><a href="#如何进行安全测试；" class="headerlink" title="如何进行安全测试；"></a>如何进行安全测试；</h2><p>ipa包加壳（苹果）<br>敏感信息存储位置<br>通讯网络安全<br>代码混淆</p>
<h2 id="说下生产者-消费者模型，其中的同步机制是怎么样的"><a href="#说下生产者-消费者模型，其中的同步机制是怎么样的" class="headerlink" title="说下生产者-消费者模型，其中的同步机制是怎么样的"></a>说下生产者-消费者模型，其中的同步机制是怎么样的</h2><p>产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。<br>在生产者与消费者之间在加个缓冲区，我们形象的称之为仓库，生产<br>者负责往仓库了进商品，而消费者负责从仓库里拿商品，这就构成了生产者消费者模式。<br>dispatch_semaphore_wait<br>dispatch_semaphore_signal</p>
<h1 id="开发日常"><a href="#开发日常" class="headerlink" title="开发日常"></a>开发日常</h1><h2 id="APP启动时间应从哪些方面优化？"><a href="#APP启动时间应从哪些方面优化？" class="headerlink" title="APP启动时间应从哪些方面优化？"></a>APP启动时间应从哪些方面优化？</h2><p>App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit<br>   Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，<br>   优化需以下方面入手<br>   dylib loading time<br>       核心思想是减少dylibs的引用<br>       合并现有的dylibs（最好是6个以内）<br>       使用静态库<br>   rebase/binding time<br>       核心思想是减少DATA块内的指针<br>       减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）<br>       减少c++虚函数<br>       多使用Swift结构体（推荐使用swift）<br>   ObjC setup time<br>       核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时<br>   initializer time<br>       使用initialize替代load方法<br>       减少使用c/c++的attribute((constructor))；推荐使用<br>       dispatch_once() pthread_once() std:once()等方法<br>       推荐使用swift<br>       不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁<br>       ，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁<br>       不要在初始化中创建线程</p>
<h2 id="如何降低APP包的大小"><a href="#如何降低APP包的大小" class="headerlink" title="如何降低APP包的大小"></a>如何降低APP包的大小</h2><p>可执行文件<br>编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden<br>by Default 设置为 YES，去掉异常支持，Enable C++ Exceptions、Enable<br>Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions<br>利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code<br>编写LLVM插件检测出重复代码、未被调用的代码<br>资源（图片、音频、视频 等）<br>优化的方式可以对资源进行无损的压缩<br>去除没有用到的资源： </p>
<h2 id="UILabel图层混合"><a href="#UILabel图层混合" class="headerlink" title="UILabel图层混合"></a>UILabel图层混合</h2><p>UILabel图层混合解决方法： iOS8以后设置背景色为非透明色并且设置label.layer<br>.masksToBounds=YES让label只会渲染她的实际size区域，<br>就能解决UILabel的图层混合问题<br>iOS8 之前只要设置背景色为非透明的就行<br>为什么设置了背景色但是在iOS8上仍然出现了图层混合呢？<br>UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，<br>而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变。在<br>背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，设<br>置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪 图层混合问题解决了</p>
<h2 id="日常如何检查内存泄露？"><a href="#日常如何检查内存泄露？" class="headerlink" title="日常如何检查内存泄露？"></a>日常如何检查内存泄露？</h2><p>目前我知道的方式有以下几种<br>Memory Leaks<br>Alloctions<br>Analyse<br>Debug Memory Graph<br>MLeaksFinder<br>泄露的内存主要有以下两种：<br>Laek Memory 这种是忘记 Release 操作所泄露的内存。<br>Abandon Memory 这种是循环引用，无法释放掉的内存。</p>
<h2 id="LLDB常用的调试命令？"><a href="#LLDB常用的调试命令？" class="headerlink" title="LLDB常用的调试命令？"></a>LLDB常用的调试命令？</h2><p>po：print object的缩写，表示显示对象的文本描述，如果对象不存在则打印nil。<br>p：可以用来打印基本数据类型。<br>call：执行一段代码 如：call NSLog(@”%@”, @“yang”)<br>expr：动态执行指定表达式<br>bt：打印当前线程堆栈信息 （bt all 打印所有线程堆栈信息）<br>image：常用来寻找栈地址对应代码位置 如：image lookup –address 0xxxx</p>
<h2 id="iOS-常见的崩溃类型有哪些？"><a href="#iOS-常见的崩溃类型有哪些？" class="headerlink" title="iOS 常见的崩溃类型有哪些？"></a>iOS 常见的崩溃类型有哪些？</h2><p>unrecognized selector crash<br>KVO crash<br>NSNotification crash<br>NSTimer crash<br>Container crash<br>NSString crash<br>Bad Access crash （野指针）<br>UI not on Main Thread Crash</p>
<h2 id="iOS-App-稳定性指标及监测"><a href="#iOS-App-稳定性指标及监测" class="headerlink" title="iOS App 稳定性指标及监测"></a>iOS App 稳定性指标及监测</h2><p>开发过程中，主要是通过监控内存使用及泄露，CPU使用率，FPS，启动时间等指标，<br>以及常见的UI的主线程监测，NSAssert断言等，最好能在Debug模式下，实时显<br>示在界面上，针对出现的问题及早解决。</p>
<h2 id="iOS的签名机制是怎么样的"><a href="#iOS的签名机制是怎么样的" class="headerlink" title="iOS的签名机制是怎么样的"></a>iOS的签名机制是怎么样的</h2><p>签名机制：<br>先将应用内容通过摘要算法，得到摘要<br>再用私钥对摘要进行加密得到密文<br>将源文本、密文、和私钥对应的公钥一并发布<br>验证流程：<br>查看公钥是否是私钥方的<br>然后用公钥对密文进行解密得到摘要<br>将APP用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常</p>
<h2 id="instruments它为什么能检测内存泄漏"><a href="#instruments它为什么能检测内存泄漏" class="headerlink" title="instruments它为什么能检测内存泄漏"></a>instruments它为什么能检测内存泄漏</h2><h2 id="推送的原理"><a href="#推送的原理" class="headerlink" title="推送的原理"></a>推送的原理</h2><p>1.由App向iOS设备发送一个注册通知，用户需要同意系统发送推送。<br>2.iOS向APNs远程推送服务器发送App的Bundle Id和设备的UDID。<br>3.APNs根据设备的UDID和App的Bundle Id生成deviceToken再发回给App。<br>4.App再将deviceToken发送给远程推送服务器(自己的服务器), 由服务器保存在数据库中。<br>5.当自己的服务器想发送推送时, 在远程推送服务器中输入要发送的消息并选择发给哪些用户的deviceToken，由远程推送服务器发送给APNs。<br>6.APNs根据deviceToken发送给对应的用户。</p>
<h2 id="项目上线被拒原因"><a href="#项目上线被拒原因" class="headerlink" title="项目上线被拒原因"></a>项目上线被拒原因</h2><p>设计类型的问题，图标、UI等<br>app类型设置不准确<br>第三方资源用到广告等资源</p>
<h2 id="有了解过代码如何编译的嘛"><a href="#有了解过代码如何编译的嘛" class="headerlink" title="有了解过代码如何编译的嘛"></a>有了解过代码如何编译的嘛</h2><p>LLVM编译一个源文件的过程：预处理 -&gt; 词法分析 -&gt; Token -&gt; 语法分析 -&gt;<br>   AST -&gt; 代码生成 -&gt; LLVM IR -&gt; 优化 -&gt; 生成汇编代码 -&gt; Link -&gt; 目标文件</p>
<h2 id="针对线上版本的崩溃处理；"><a href="#针对线上版本的崩溃处理；" class="headerlink" title="针对线上版本的崩溃处理；"></a>针对线上版本的崩溃处理；</h2><p>UIKit不是线程安全的，执行UIKit操作如果不在主线程很可能造成程序Crash<br>KVO<br>避免 Foundation 类Carsh<br>容器越界（NSArray， NSDictionary,…）<br>unrecognized selector crash (这个很多时候是由于class使用错误导致)<br>第三方工具：友盟<br>dSYMTools分析</p>
<h2 id="Xcode构建过程；"><a href="#Xcode构建过程；" class="headerlink" title="Xcode构建过程；"></a>Xcode构建过程；</h2><p>解析项目文件，获取你项目中的所有文件、target 及其依赖关系、build settings，最后把它变成一个树形结构(有向图)。<br>增量构建。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift139%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift139%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">UI相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:58" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:58+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="程序绘制流程"><a href="#程序绘制流程" class="headerlink" title="程序绘制流程"></a>程序绘制流程</h2><pre><code>Core Animation 在 RunLoop 中注册了一个 Observer 监听
BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件 。
当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer
的层次时，或者手动调用了 UIView/CALayer 的 
setNeedsLayout/setNeedsDisplay方法后，这个
UIView/CALayer 就被标记为待处理，当渲染系统准备就绪，
调用视图的-display方法，同时装配像素存储空间，
建立一个CoreGraphics上下文（CGContextRef），将上下文push进
上下文堆栈，绘图程序进入对应的内存存储空间。
当Oberver监听的事件到来时，回调执行函数中会遍历所有待处理的
UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。
需要CPU和GPU一起协作一部数据通过CoreGraphics、CoreImage
由CPU预处理。最终通过OpenGL ES将数据传送到 GPU，最终显示到屏幕。
</code></pre>
<h2 id="试图绘制为什么不立即执行"><a href="#试图绘制为什么不立即执行" class="headerlink" title="试图绘制为什么不立即执行"></a>试图绘制为什么不立即执行</h2><pre><code>继承于UIView的子类重写，进行布局更新，刷新视图。如果某个视图
自身的bounds或者子视图的bounds发生改变，那么这个方法会在当前
runloop结束的时候被调用。为什么不是立即调用呢？因为渲染毕
竟比较消耗性能，特别是视图层级复杂的时候。这种机制下任何UI
控件布局上的变动不会立即生效，而是每次间隔一个周期，所有
UI控件在布局上的变动统一生效并且在视图上更新，苹果通过这种高
性能的机制保障了视图渲染的流畅性。
</code></pre>
<h2 id="事件响应流程"><a href="#事件响应流程" class="headerlink" title="事件响应流程"></a>事件响应流程</h2><pre><code>点击屏幕-》UIApplication-〉UIWindow-》hitTest：withEvent：
-〉pointInside：withEvent：
-》subviews-〉UIView-》倒序遍历-〉hitTest：withEvent：
hitTest：withEvent内部实现
</code></pre>
<h2 id="UI卡顿原因"><a href="#UI卡顿原因" class="headerlink" title="UI卡顿原因"></a>UI卡顿原因</h2><pre><code>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 
等机制通知 App，App 主线程开始在 CPU 中计算显示内容，
比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 
会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。
随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 
信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 
时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，
等待下一次机会再显示，而这时显示屏会保留之前的内容不变。
这就是界面卡顿的原因。
</code></pre>
<h2 id="滑动优化方案"><a href="#滑动优化方案" class="headerlink" title="滑动优化方案"></a>滑动优化方案</h2><pre><code>从CPU和GPU两个方面
CPU
对象创建，调整，销毁
预排版（布局计算、文字计算）
预渲染（文字等异步绘制、图片解码等）
GPU
纹理渲染（减少离屏渲染）
试图混合（减少不必要的试图、半透明颜色）
</code></pre>
<h2 id="什么是离屏渲染，触发的条件是什么"><a href="#什么是离屏渲染，触发的条件是什么" class="headerlink" title="什么是离屏渲染，触发的条件是什么"></a>什么是离屏渲染，触发的条件是什么</h2><pre><code>GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作
何时会触发
圆角（当和maskToBounds一起使用时）
图层蒙版
阴影
光栅化
</code></pre>
<h2 id="UIView和CALayer关系"><a href="#UIView和CALayer关系" class="headerlink" title="UIView和CALayer关系"></a>UIView和CALayer关系</h2><pre><code>layer给view提供了基础设施，使得绘制内容和呈现更高效动画更容易、更低耗
layer不参与view的事件处理、不参与响应链
layer的内容生成一个位图(bitmap)
,触发动画的时候，是把这个动画和状态信息传递给图形硬件，
图形硬件使用这两个数据就可以构造动画了。处理位图对于图形硬件更快。
</code></pre>
<h2 id="CALayer的mask作用"><a href="#CALayer的mask作用" class="headerlink" title="CALayer的mask作用"></a>CALayer的mask作用</h2><pre><code>mask是一个layer层，并且作为背景层和组成层之间的一个遮罩层通道，
默认是nil。并且如果要创建新的layer赋给mask，
那么新的layer必须没有superlayer，也不支持含有子mask。
mask作用的也不只是当前layer的内容，而是layer和它所有子layer的合成内容。
这个也是可以测试的，设置viewA的layer的mask,
然后不管在viewA上加多少个视图都是会被mask作用到。
不要使用不必要的mask，可以预处理图片为圆形；或者添加中间为圆形透
明的白色背景视图。即使添加额外的视图，会导致额外的计算；
但仍然会快一点，因为相对于切换上下文，GPU更擅长渲染。
</code></pre>
<h2 id="如何高性能给UIImageView加圆角"><a href="#如何高性能给UIImageView加圆角" class="headerlink" title="如何高性能给UIImageView加圆角"></a>如何高性能给UIImageView加圆角</h2><pre><code>不要使用不必要的mask，可以预处理图片为圆形；或者添加中间为圆形
透明的白色背景视图。 离屏渲染会导致GPU利用率不到100%，
帧率却很低。（切换上下文会产生idle time）
1.图片本身做圆角处理
2.添加一个额外的试图进行压盖
3.用贝塞尔曲线.重新绘制一个圆形图片
</code></pre>
<h2 id="如何使用核心动画"><a href="#如何使用核心动画" class="headerlink" title="如何使用核心动画"></a>如何使用核心动画</h2><pre><code>创建
设置相关属性
添加到 CALayer 上，会自动执行动画
</code></pre>
<h2 id="如何增加view点击范围"><a href="#如何增加view点击范围" class="headerlink" title="如何增加view点击范围"></a>如何增加view点击范围</h2><pre><code>在pointInside方法中更大范围返回true
</code></pre>
<h2 id="hitTest：withEvent内部实现"><a href="#hitTest：withEvent内部实现" class="headerlink" title="hitTest：withEvent内部实现"></a>hitTest：withEvent内部实现</h2><pre><code>// 1.是否响应的必要条件
if (self.userInteractionEnabled == NO ||self.alpha &lt; 0.05 || self.hidden == YES) &#123;
    return nil;
&#125;
// 2.判断点是不是在视野范围内
if ([self pointInside:point withEvent:event]) &#123;
    // 遍历所有的子试图
    for (UIView *subView  in  self.subviews) &#123;
        // 坐标转换
        CGPoint converPoint = [subView convertPoint:point toView:self];
        // 依次调用子试图的hit test方法
        UIView *fitView = [subView hitTest:converPoint withEvent:event];
        if (fitView) &#123;
            return fitView;
        &#125;
    &#125;
    // 如果子试图都没有返回自己
    return self;
&#125;
return nil;
首先调用当前视图的pointInside:withEvent:方法判断触摸点
是否在当前视图内；若返回NO,则hitTest:withEvent:返回nil;
若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:
消息，所有子视图的遍历顺序是从top到bottom，即从subviews
数组的末尾向前遍历,直到有子视图返回非空对象或者全部子视图遍历完毕；
若第一次有子视图返回非空对象,则hitTest:withEvent:方法返回此对象，处理结束；
如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。
</code></pre>
<h2 id="程序的启动速度优化"><a href="#程序的启动速度优化" class="headerlink" title="程序的启动速度优化"></a>程序的启动速度优化</h2><pre><code>App开始启动后，系统内核(XNU)首先加载可执行文件（自身App的所
有.o文件的集合），然后加载动态链接器dyld，dyld是一个专门用来加载动态链接库的库。
执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。 
动态链接库包括：iOS 中用到的所有系统 framework，加载OC
runtime方法的libobjc，系统级别的libSystem，例如libdispatch(GCD)
和libsystem_blocks (Block)。
 1、内核加载可执行文件
 2、load dylibs image (加载程序所需的动态库镜像文件)
 3、Rebase image /  Bind image (由于ASLR(address space layout
    randomization)的存在，可执行文件和动态链接库在虚拟内
    存中的加载地址每次启动都不固定，所以需要修复镜像中的资源指针)
 4、Objc setup (注册Objc类、将Category中的方法插入方法列表)
 5、initializers (调用Objc类的+load()方法、调用C++类的构造函数)
针对上边各个启动过程，我们可以做的优化有：
   1、减少动态库的引用，将项目中不使用的Framework及时删除，将Xcode配置中General -&gt; Linked Frameworks and Libraries中使用不到的系统库不再引用。
   2、合并动态库。
   3、尽量不使用内嵌（embedded）的dylib，加载内嵌dylib性能开销较大。
   4、清理项目中冗余的类、category。对于同一个类有多个category的，建议进行合并。
   5、将不必须在+load方法中做的事情延迟到+initialize中。
   6、尽量不要用C++虚函数(创建虚函数表有开销)，不要在C++构造函数中做大量耗时操作。
</code></pre>
<h2 id="drawRect和layouSubviews-的区别"><a href="#drawRect和layouSubviews-的区别" class="headerlink" title="drawRect和layouSubviews 的区别"></a>drawRect和layouSubviews 的区别</h2><pre><code>相同：
1 都是异步执行
2 都是UIView 的方法
不同：
1   layoutSubviews方便数据计算，
2   drawRect方便视图重绘。
layoutSubviews在以下情况下会被调用：
    1、init初始化不会触发layoutSubviews
    2、addSubview会触发layoutSubviews (向对象添加子视图,或者对象添加到父视图,frame为0时不会)
    3、改变view的width和hight的时候会触发layoutSubviews
    4、滚动一个UIScrollView会触发layoutSubviews(受contentSize 的影响)
    5、旋转Screen会触发父UIView上的layoutSubviews事件
    6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件
    7、直接调用setLayoutSubviews。
    8、不要直接调用这个方法,因为不会有任何的作用
    .如果你需要强制layout刷新,调用setNeedsLayout来代替, 
drawRect在以下情况下会被调用： 
    &gt;1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。
    drawRect 调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad
    两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了
    .这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量 值).
    2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。
    然后系统自动调用drawRect:方法。
    3、通过设置contentMode属性值为UIViewContentModeRedraw。
    那么将在每次设置或更改frame的时候自动调用drawRect:。
    4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，
    但是有个前提条件是rect不能为0。以上1,2推荐；而3,4不提倡
</code></pre>
<h2 id="setNeedsLayout与layoutIfNeeded的区别"><a href="#setNeedsLayout与layoutIfNeeded的区别" class="headerlink" title="setNeedsLayout与layoutIfNeeded的区别"></a>setNeedsLayout与layoutIfNeeded的区别</h2><pre><code>UIView的setNeedsDisplay和setNeedsLayout两个方法都是异步执行的。
而setNeedsDisplay会自动调用drawRect方法，这样可以拿到
UIGraphicsGetCurrentContext进行绘制；而setNeedsLayout会默认调用
layoutSubViews，给当前的视图做了标记；layoutIfNeeded
查找是否有标记，如果有标记及立刻刷新。
只有setNeedsLayout和layoutIfNeeded这二者合起来使用，才会起到立刻刷新的效果。
</code></pre>
<h2 id="UIResponder的理解和事件响应分析"><a href="#UIResponder的理解和事件响应分析" class="headerlink" title="UIResponder的理解和事件响应分析"></a>UIResponder的理解和事件响应分析</h2><pre><code>UIResponder类是专门用来响应用户的操作处理各种事件的，包括触摸事件(Touch Events)、
运动事件(Motion Events)、远程控制事件(Remote Control Events)。
我们知道UIApplication、UIView、UIViewController这几个类是直接继承自
UIResponder，所以这些类都可以响应事件。当然我们自定义的继承自UIView的
View以及自定义的继承自UIViewController的控制器都可以响应事件。
</code></pre>
<h2 id="loadView的作用"><a href="#loadView的作用" class="headerlink" title="loadView的作用"></a>loadView的作用</h2><pre><code>loadView方法会在每次访问UIViewController的view
(比如controller.view、self.view)而且view为nil时会被调用，
此方法主要用来负责创建UIViewController的view(重写loadView方法，
并且不需要调用[super loadView])
</code></pre>
<h2 id="UITableView卡顿原因"><a href="#UITableView卡顿原因" class="headerlink" title="UITableView卡顿原因"></a>UITableView卡顿原因</h2><pre><code>1.最常用的就是cell的重用， 注册重用标识符
2.避免cell的重新布局
3.提前计算并缓存cell的属性及内容
4.减少cell中控件的数量
5.不要使用ClearColor，无背景色，透明度也不要设置为0
6.使用局部更新
7.加载网络数据，下载图片，使用异步加载，并缓存
8.少使用addView 给cell动态添加view
9.按需加载cell，cell滚动很快时，只加载范围内的cell
10.不要实现无用的代理方法，tableView只遵守两个协议
11.缓存行高
12.不要做多余的绘制工作。
13.预渲染图像。
14.使用正确的数据结构来存储数据。
</code></pre>
<h2 id="UITableView优化"><a href="#UITableView优化" class="headerlink" title="UITableView优化"></a>UITableView优化</h2><pre><code>本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。
卡顿优化在 CPU 层面
尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView
不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改
尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
Autolayout 会比直接设置 frame 消耗更多的 CPU 资源
图片的 size 最好刚好跟 UIImageView 的 size 保持一致
控制一下线程的最大并发数量
尽量把耗时的操作放到子线程
文本处理（尺寸计算、绘制）
图片处理（解码、绘制）
卡顿优化在 GPU层面
尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸
尽量减少视图数量和层次
减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES
尽量避免出现离屏渲染
</code></pre>
<h2 id="iOS-保持界面流畅的技巧"><a href="#iOS-保持界面流畅的技巧" class="headerlink" title="iOS 保持界面流畅的技巧"></a>iOS 保持界面流畅的技巧</h2><pre><code>1.预排版，提前计算
在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。
尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式
2.预渲染，提前绘制
例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了
避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。
3.异步绘制
4.全局并发线程
5.高效的图片异步加载
</code></pre>
<h2 id="使用-drawRect有什么影响"><a href="#使用-drawRect有什么影响" class="headerlink" title="使用 drawRect有什么影响"></a>使用 drawRect有什么影响</h2><pre><code>drawRect 方法依赖 Core Graphics 框架来进行自定义的绘制 缺点：
它处理 touch 事件时每次按钮被点击后，都会用 setNeddsDisplay 
进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性
能的角度来说，对 CPU 和内存来说都是欠佳的。特别是如果在我们的界
面上有多个这样的UIButton 实例，那就会很糟糕了。这个方法的调用机制
也是非常特别. 当你调用 setNeedsDisplay 方法时, UIKit 将会把当前
图层标记为 dirty,但还是会显示原来的内容,直到下一次的视图渲染周期,才会将
标记为 dirty 的图层重新建立 Core Graphics 上下文,然后将内存
中的数据恢复出来, 再使用 CGContextRef 进行绘制
</code></pre>
<h1 id="OC相关"><a href="#OC相关" class="headerlink" title="OC相关"></a>OC相关</h1><h2 id="分类可以添加哪些内容，为什么不能添加属性"><a href="#分类可以添加哪些内容，为什么不能添加属性" class="headerlink" title="分类可以添加哪些内容，为什么不能添加属性"></a>分类可以添加哪些内容，为什么不能添加属性</h2><pre><code>实力方法、类方法、协议、属性（关联对象：）
在分类的指针结构体中，没有属性列表
在runtime 中，objc_class 结构体大小是固定的，
不可能往这里添加数据，只能修改。所以，ivars
指向了一个固定区域，ivars的内存布局在编译时就已经
决定，只能修改成员变量的值，不能增加
成员变量的个数。方法列表是一个二维数组，可以修改
*methodLists的值来增加成员方法，虽然没办法扩展
methodLists指向的内存区域，却可以改变这个内
存区域的值（里面存的是指针），因此，可以动态添加方法，
不可以添加成员变量。
</code></pre>
<h2 id="类扩展和分类的区别"><a href="#类扩展和分类的区别" class="headerlink" title="类扩展和分类的区别"></a>类扩展和分类的区别</h2><pre><code>OC分类属于Runtime运行时特性，是OC语言独有的创新，
其他编程语言所不具备这样的特性！
类扩展属于编译器特性，在编译阶段就会被添加合并到原类中！
</code></pre>
<h2 id="分类是如何实现的"><a href="#分类是如何实现的" class="headerlink" title="分类是如何实现的"></a>分类是如何实现的</h2><pre><code>获取cls中未完成整合的所有分类 unattachendCategoriesForClass
将分类拼接到class上 attachCategories
倒序遍历所有分类
获取该分类的方法、协议添加到主类上
// 添加方法
rw-&gt;methods.attachLists(mlists,mcount);
// 添加类方法
rw-&gt;properties.attachLists(proplists,propcount);
// 添加协议
rw-&gt;properties.attachLists(protolists,protocount);
计算拼接后的元素总数，根据新的总数重新分配内存
重新设置元素总数
执行内存移位
</code></pre>
<h2 id="分类重写了原类中同名方法会怎么样，为什么"><a href="#分类重写了原类中同名方法会怎么样，为什么" class="headerlink" title="分类重写了原类中同名方法会怎么样，为什么"></a>分类重写了原类中同名方法会怎么样，为什么</h2><pre><code>分类添加的方法可以覆盖原类方法
原因：分类是在运行时添加到原类上的
同名分类方法是能生效决定于编译顺序（倒序遍历所有分类）
名字相同的分类会引起编译报错
</code></pre>
<h2 id="如何给分类添加属性（关联对象）"><a href="#如何给分类添加属性（关联对象）" class="headerlink" title="如何给分类添加属性（关联对象）"></a>如何给分类添加属性（关联对象）</h2><pre><code>关联对象的实现
获取其维护的一个HashMap，是一个全局容器
根据对象指针，查找对象对应的ObjectAssociationMap中的map
添加关联对象
</code></pre>
<h2 id="什么是代理，和通知-BLOCK区别"><a href="#什么是代理，和通知-BLOCK区别" class="headerlink" title="什么是代理，和通知/BLOCK区别"></a>什么是代理，和通知/BLOCK区别</h2><pre><code>代理：是一对一的，对于一个协议就只能用一个代理，所以单例不能用代理。
通知：是一对多
block:可以替代代理，优点是代码简洁。缺点：
block会开辟内存，消耗比较大，delegate则不会
block防止循环引用，要用弱引用
</code></pre>
<h2 id="什么是通知"><a href="#什么是通知" class="headerlink" title="什么是通知"></a>什么是通知</h2><pre><code>同步和异步都是相对于发送通知所在的线程的。
postNotification:总是会卡住当前线程，待observer执行（如不特殊处
理selector也会在postNotification:所在线程执行）结束之后才会继续
往下执行。所以是同步的。
我们在底层当中的消息的触发其实是依赖与端口的，我们想要在一个线程中发消
息，在另一个线程中进行处理的话，我们可以用端口来实现
子线程发通知，需要在子线程添加runloop
[self performSelector:@selector(postNotification) onThread:self.thread withObject:nil waitUntilDone:YES];
</code></pre>
<h2 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h2><pre><code>KVO是通过isa-swizzling技术实现的(这句话是整个KVO实现的重点)。
在运行时根据原类创建一个中间类，这个中间类是原类的子类，并动态修改当前对象的isa指向中间类。
并且将class方法重写，返回原类的Class。所以苹果建议在开发中不应该依赖isa指针，
而是通过class实例方法来获取对象类型。
1.注册A类的name属性变化监听
       [a addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];
2.创建A的子类NSKVONotifyingA
Class noA = objc_allocateClassPair([A class], &quot;NSKVONotifyingA&quot;, observer);
3.isa指针混合
将A类的指针指向NSKVONotifyingA，从而到达调用NSKVONotifyingA类的方法的目的
4.当调用a的setName方法时进入到NSKVONotifyingA类的setName方法
5.调用willChangeValueForKey回调属性将要变化
6.调用NSKVONotifyingA类的【self setName】赋值，实际上执行的是A类的setName，达到赋值目的
7.调用didChangeValueForKey回调属性变化了
</code></pre>
<h2 id="KVC的实现原理"><a href="#KVC的实现原理" class="headerlink" title="KVC的实现原理"></a>KVC的实现原理</h2><pre><code>是一种键值机制
1.首先搜索是否有setKey:的方法（key是成员变量名，首字母大写）
,没有则会搜索是否有setIsKey:的方法。
2.如果没有找到setKey:的方法,此时看+
(BOOL)accessInstanceVariablesDirectly; （是否直接访问成员变量）方法。
若返回NO，则直接调用- (nullable id)valueForUndefinedKey:;(默认是抛出异常)。
</code></pre>
<h2 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h2><pre><code>1、nonatomic、atomiac
2、readwrite、readonly
3、strong、retain、weak、assign、copy、unsafe_unretained
@property 有两个对应的词，一个是 @synthesize，一个是 @dynamic。
如果 @synthesize 和 @dynamic 都没写，那么默认的就是 @syntheszie var = _var;
</code></pre>
<h2 id="include与-import的区别、-import-与-class-的区别"><a href="#include与-import的区别、-import-与-class-的区别" class="headerlink" title="include与#import的区别、#import 与@class 的区别"></a>include与#import的区别、#import 与@class 的区别</h2><pre><code>#include 和#import其效果相同,都是查询类中定义的行为(方法);
#import不会引起交叉编译,确保头文件只会被导入一次；
@class 的表明,只定 义了类的名称,而具体类的行为是未知的,一般用于.h 文件；
@class 比#import 编译效率更高。
</code></pre>
<h2 id="解释-const-static-inline-关键字"><a href="#解释-const-static-inline-关键字" class="headerlink" title="解释 const, static, inline 关键字"></a>解释 const, static, inline 关键字</h2><pre><code>const 修饰指针,或者常量,比如不可变,
static 修饰变量表示作用域,比如全局的私有变量,函数内部的 static 是内部的私有变量。
Static 修饰函数表示函数是文件作用域
Inline 表示内联。一般来说 inline 需要和 static 联合用 一般用法是 
static inline int max(int a, int b) &#123; 
static inline作用是和宏类似,只不过是方便调试(宏不能断掉调 试,
static inline 可以)。运行时候是一样的。
一般 c/c++短小的函数都用 static inline 内联函数 
</code></pre>
<h2 id="OC-里怎么实现多继承"><a href="#OC-里怎么实现多继承" class="headerlink" title="OC 里怎么实现多继承"></a>OC 里怎么实现多继承</h2><pre><code>通过协议实现多继承
通过分类Category实现多继承
</code></pre>
<h2 id="load方法实现原理与initialize区别"><a href="#load方法实现原理与initialize区别" class="headerlink" title="load方法实现原理与initialize区别"></a>load方法实现原理与initialize区别</h2><pre><code>1.调用方式
(1).load是根据函数地址直接调用。
(2).initialize是通过objc_msgSend调用。
2.调用时刻(什么时候会调用)
(1).load是runtime加载类、分类的时候调用(只会调用一次)
（子类的load之前，会先调用父类的load。）父类-&gt;子类-&gt;分类
(2).initialize是类第一次接收到消息的时候调用，
每一个类只会initialize一次(父类的initialize方法可能会被调用多次)。
</code></pre>
<h2 id="懒加载的使用"><a href="#懒加载的使用" class="headerlink" title="懒加载的使用"></a>懒加载的使用</h2><pre><code>- (NSArray *)infoArr &#123;
    if (!_infoArr) &#123;
        _infoArr = @[];
    &#125;
    return _infoArr;
&#125;
</code></pre>
<h2 id="写一个单例"><a href="#写一个单例" class="headerlink" title="写一个单例"></a>写一个单例</h2><pre><code>+ (SingleClass *)sharedSingleton &#123;
    static SingleClass *_single = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^&#123;
        _single = [[super allocWithZone:NULL] init];
    &#125;);
    return _single;
    
&#125;
+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;
    return [SingleClass sharedSingleton];
&#125;
- (id)copyWithZone:(NSZone *)zone &#123;
    return [SingleClass sharedSingleton];
&#125;
</code></pre>
<h2 id="nil-NIL-NSNULL区别，id-和-instanceType-区别，self和super的区别，struct和class的区别"><a href="#nil-NIL-NSNULL区别，id-和-instanceType-区别，self和super的区别，struct和class的区别" class="headerlink" title="nil NIL NSNULL区别，id 和 instanceType 区别，self和super的区别，struct和class的区别"></a>nil NIL NSNULL区别，id 和 instanceType 区别，self和super的区别，struct和class的区别</h2><pre><code>id 在编译的时候不能判断对象的真实类型，instancetype 在编译的时候可以判断对象的真实类型。instancetype 只能作为返回值类型。
self调用自己方法，super调用父类方法，self是类，super是预编译指令
分别对应objc_msgSend、 objc_msgSendSuper
class： 引用类型（位于栈上面的指针（引用）和位于堆上的实体对象）
struct：值类型（实例直接位于栈中）
</code></pre>
<h2 id="如何实现一个线程安全的-NSMutableArray"><a href="#如何实现一个线程安全的-NSMutableArray" class="headerlink" title="如何实现一个线程安全的 NSMutableArray?"></a>如何实现一个线程安全的 NSMutableArray?</h2><pre><code>用dispatch_sync和dispatch_barrier_async结合保证NSMutableArray的线程安全，
dispatch_sync是在当前线程上执行不会另开辟新的线程，当线程返回的时候就可以
拿到读取的结果，我认为这个方案是最完美的选择，既保证的线程安全有发挥了多
线程的优势还不用另写方法返回结果
</code></pre>
<h2 id="JS-和-OC-互相调用的几种方式"><a href="#JS-和-OC-互相调用的几种方式" class="headerlink" title="JS 和 OC 互相调用的几种方式"></a>JS 和 OC 互相调用的几种方式</h2><pre><code>1.利用定义url调用
2.利用js直接调用
3.利用js里对象调用
</code></pre>
<h2 id="数据持久性有哪几种"><a href="#数据持久性有哪几种" class="headerlink" title="数据持久性有哪几种"></a>数据持久性有哪几种</h2><pre><code>iOS本地数据保存有多种方式,比如NSUserDefaults、归档、文件保存、数据库、
CoreData、KeyChain(钥匙串)等多种方式。其中KeyChain
(钥匙串)是保存到沙盒范围以外的地方，也就是与沙盒无关。
</code></pre>
<h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h2 id="NSObject的数据结构"><a href="#NSObject的数据结构" class="headerlink" title="NSObject的数据结构"></a>NSObject的数据结构</h2><pre><code>对象是objc_object结构体
内部有一个 objc_class 类型isa指针
objc_class 内部有isa指针指向根元类
根元类的isa指针指向自己
内部：
Class superClass; 父类
cache_t cache;  缓存
class_data_bits_t bits  数据
</code></pre>
<h2 id="类对象和实例对象的isa指针的指向"><a href="#类对象和实例对象的isa指针的指向" class="headerlink" title="类对象和实例对象的isa指针的指向"></a>类对象和实例对象的isa指针的指向</h2><pre><code>实例对象的isa指向类对象
类的isa指向元类对象
元类指向根元类；
根元类指向自己；
NSObject的父类是nil，根元类的父类是NSObject。
</code></pre>
<h2 id="为什么id类型可以指向OC中任意对象"><a href="#为什么id类型可以指向OC中任意对象" class="headerlink" title="为什么id类型可以指向OC中任意对象"></a>为什么id类型可以指向OC中任意对象</h2><pre><code>id类型被定义为指向对象的指针
NSObject只有一个Class对象isa，而objc_object也是只有一个Class对
象isa,也就是说id等价于NSObject*。所以id是一个一个比较灵活的对象指
针，并且是一个指向任何一个继承了Object（或者NSObject）类的对象
</code></pre>
<h2 id="为什么不能用isa判断一个类的继承关系"><a href="#为什么不能用isa判断一个类的继承关系" class="headerlink" title="为什么不能用isa判断一个类的继承关系"></a>为什么不能用isa判断一个类的继承关系</h2><pre><code>isa指针不总是指向实例对象所属的类，不能依靠它来确定
类型，而是应该用class方法来确定实例对象的类。
因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类
</code></pre>
<h2 id="cache-t的数据结构、实现原理及扩容"><a href="#cache-t的数据结构、实现原理及扩容" class="headerlink" title="cache_t的数据结构、实现原理及扩容"></a>cache_t的数据结构、实现原理及扩容</h2><pre><code>用散列表(哈希表)来缓存曾经调用过的方法，可以提高方法的查找速度，底层结构如下：
用于快速查找方法执行函数
是可增量扩展的哈希表结构
是局部性原理的最佳应用
哈希查找：发现当发生碰撞的时候，索引会+1，查找下一个。
槽位如果不够，_mask 会变换，变为原来的2倍，
并且扩展槽位的时候，会清空数组里原有的缓存内容
子类没有实现方法会调用父类的方法，
会将父类方法加入到子类自己的cache 里。
</code></pre>
<h2 id="cache-t-扩容"><a href="#cache-t-扩容" class="headerlink" title="cache_t 扩容"></a>cache_t 扩容</h2><pre><code>创建新的新的buckets来替换原有的buckets并抹掉原有的buckets
减少对方法快速查找流程的影响：调用objc_msgSend时会触发方法
快速查找，如果进行扩容需要做一些读写操作，对快速查找影响比较大。
对性能要求比较高：开辟新的buckets空间并抹掉原有buckets
的消耗比在原有buckets上进行扩展更加高效
当扩容后，会把新mask设置为newCapacity长度减一，然后清空缓存。
</code></pre>
<h2 id="class-rw-t的数据结构，实现原理"><a href="#class-rw-t的数据结构，实现原理" class="headerlink" title="class_rw_t的数据结构，实现原理"></a>class_rw_t的数据结构，实现原理</h2><pre><code>class_ro_t存放的是编译期间就确定的；
而class_rw_t是在runtime时才确定，它会先将class_ro_t的内容拷贝过去，
然后再将当前类的分类的这些属性、方法等拷贝到其中。所以可以说class_rw_t
是class_ro_t的超集，当然实际访问类的方法、属性等也都是访问的class_rw_t中的内容
struct class_rw_t &#123;
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro; // 编译时生成的属性方法列表，不可改变

    method_array_t methods; // 方法列表
    property_array_t properties; //属性，和变量的区别，属性是名称，变量是值
    protocol_array_t protocols; // 协议

    Class firstSubclass;
    Class nextSiblingClass;
&#125;;
</code></pre>
<h2 id="哈希碰撞的解决方法"><a href="#哈希碰撞的解决方法" class="headerlink" title="哈希碰撞的解决方法"></a>哈希碰撞的解决方法</h2><pre><code>开放地址法
链地址法
(哈希表)的原理都是一样的，都是通过一个函数，这个函数传入一个key，
通过这个key算出一个索引，如果索引冲突了就加一或者减一
，直至不冲突为止，不同的就是算法不一样。
</code></pre>
<h2 id="方法查找的过程"><a href="#方法查找的过程" class="headerlink" title="方法查找的过程"></a>方法查找的过程</h2><pre><code>1.检查这个selector是不是要被忽略的，比如mac os开发，
   有垃圾回收，就不考虑 retain，release这些函数
2.检测这个target是不是nil对象，
   ObjC的特性允许对一个nil对象发消息而不会崩溃
3.如果以上都通过了，就通过isa指针开始查找这个类的方法列表，
   先从缓存中找（hashMap的结构，查找速度快），完了跳到对应函数执行
4.如果缓存列表找不到，class_rw_t就找一下方法分发表
5.如果方法列表找不到，就到超类的方法分发列表找，
   一直找到NSObject
</code></pre>
<h2 id="消息转发的流程"><a href="#消息转发的流程" class="headerlink" title="消息转发的流程"></a>消息转发的流程</h2><pre><code>（动态添加） 首先是征询接收者所属的类,看其是否能动态添加调用的方法,来处理当前这个未知的选择子;
-(BOOL)resolveInstanceMethod:(SEL)selector
（重定向-备援接收者）寻找是否在其他对象内有该方法实现,并将该消息转发给这个对象
- (id)forwardingTargetForSelector:(SEL)aSelector  
生成方法签名，然后系统用这个方法签名生成NSInvocation对象。
- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 
改变选择子
- (void)forwardInvocation:(NSInvocation *)Invocation 
抛出异常
- (void)doesNotRecognizeSelector:(SEL)aSelector方法
</code></pre>
<h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><pre><code>当前对象无论调用任何方法返回的都是当前对象
无论何时，要调用objc_msgSend函数，必须要将函数强制转
换成合适的函数指针类型才能调用。
其实编译器会根据情况在objc_msgSend,
objc_msgSend_stret, objc_msgSendSuper, 或
objc_msgSendSuper_stret四个方法中选择一个来调用。
</code></pre>
<h2 id="系统如何解决新增实例冲突"><a href="#系统如何解决新增实例冲突" class="headerlink" title="系统如何解决新增实例冲突"></a>系统如何解决新增实例冲突</h2><pre><code>类的结构体在编译时都是固定的，如果想修改类的结构需要重新编译
原来UIViewController的结构体中增加了
childViewControllers属性，这个时候和子类的内存偏移就
发生了冲突，只不过，runtime有检测内存地址冲突的机制，
在类生成实例变量时，会判断实例变量是否有地址冲突，
如果发生冲突则调整对象的地址偏移。
</code></pre>
<h2 id="常用的runtime方法有哪些"><a href="#常用的runtime方法有哪些" class="headerlink" title="常用的runtime方法有哪些"></a>常用的runtime方法有哪些</h2><pre><code>获取属性列表
获取方法列表
获取成员变量列表
获取协议列表
获得类方法
添加一个实例变量
添加方法
替换方法
交换方法
</code></pre>
<h2 id="runtime的具体应用有哪些，你在什么地方用到了"><a href="#runtime的具体应用有哪些，你在什么地方用到了" class="headerlink" title="runtime的具体应用有哪些，你在什么地方用到了"></a>runtime的具体应用有哪些，你在什么地方用到了</h2><pre><code>动态交换两个方法的实现
拦截并替换方法
在方法上增加额外功能
实现NSCoding的自动归档和解档
实现字典转模型的自动转换JSONModel、YYModel
给分类添加属性
消息转发机制
KVO实现
JSPatch替换已有的OC方法实行
</code></pre>
<h2 id="runtime-怎么添加属性，方法等"><a href="#runtime-怎么添加属性，方法等" class="headerlink" title="runtime 怎么添加属性，方法等"></a>runtime 怎么添加属性，方法等</h2><pre><code>添加属性：class_addIvar
但是得在调用objc_allocateClassPari之后，
objc_registerClassPair之前。
添加方法：class_addMethod
</code></pre>
<h2 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="runtime 如何实现 weak 属性"></a>runtime 如何实现 weak 属性</h2><pre><code>runtime 对注册的类，会进行内存布局，存储到 hash 表，这是一个全局表，
表中是用 weak 指向的对象内存地址作为 key，用所有指向该对象的 weak 指针表作为 value。
当此对象的引用计数为 0 的时候会 dealloc，假如该对象内存地址是 a，那么就会以 a 为
key，在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil。
</code></pre>
<h2 id="runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）"><a href="#runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）"></a>runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</h2><pre><code>每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,
以及参数类型,其实selector本质就是方法名称,
通过这个方法名称就可以在方法列表中找到对应的方法实现.
</code></pre>
<h2 id="runtime如何实现weak变量的自动置nil"><a href="#runtime如何实现weak变量的自动置nil" class="headerlink" title="runtime如何实现weak变量的自动置nil"></a>runtime如何实现weak变量的自动置nil</h2><pre><code>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表
中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时
候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 
在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil
</code></pre>
<h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2><pre><code>在runtime中所有类都存在一个哈希表中，在table的buckets中存储
1. 加载所有类到类的gdb_objc_realized_classes表中
2. 对所有类做重映射
3. 将所有SEL都注册到namedSelectors表中
4. 修复函数指针遗留
5. 将所有Protocol添加到protocol_map表中
6. 将所有Protocol重映射
7. 初始化所有非懒加载的类，进行rw，ro操作 
8. 便利所有懒加载类，执行初始化
9. 处理所有Category包括Class和MetaClass
10. 初始化所有未初始化类
</code></pre>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存中的5大区都是什么？"><a href="#内存中的5大区都是什么？" class="headerlink" title="内存中的5大区都是什么？"></a>内存中的5大区都是什么？</h2><pre><code>堆区
栈区
常量区
全局区（静态区）
程序代码区
</code></pre>
<h2 id="C-内存如何分布、堆和栈的区别"><a href="#C-内存如何分布、堆和栈的区别" class="headerlink" title="C++内存如何分布、堆和栈的区别"></a>C++内存如何分布、堆和栈的区别</h2><pre><code>堆和栈的区别，工程项目中的哪些数据是储存在堆哪些在栈中
malloc咋实现
析构函数是不是必须是虚函数
</code></pre>
<h2 id="ARC实现机制，遵循哪些原则"><a href="#ARC实现机制，遵循哪些原则" class="headerlink" title="ARC实现机制，遵循哪些原则"></a>ARC实现机制，遵循哪些原则</h2><pre><code>ARC是RunTime和LLVM共同协作完成的
</code></pre>
<h2 id="NSObject内存分配、ISA指针的内存大小"><a href="#NSObject内存分配、ISA指针的内存大小" class="headerlink" title="NSObject内存分配、ISA指针的内存大小"></a>NSObject内存分配、ISA指针的内存大小</h2><pre><code>在64位架构下，如果他的第一位是0 。则代表他是一个 isa
指针,表示当前对象的类对象的地址，如果是1，则不仅代表一个 isa
指针,类对象的地址，里面还存储内存管理相关的内容，第二位代表是否有关联对象，
0代表没有，1代表有（has_assoc）,第三位,代表当前对象是否含有C++代码
（has_cxx_dtor）,3-15表示当前对象的类对象内存地址,16-31
,也是，32-35位也是，也就是说，13+16+4 = 33位
</code></pre>
<h2 id="Tagged-Pointer、NONPOINTER-ISA实现机制和作用"><a href="#Tagged-Pointer、NONPOINTER-ISA实现机制和作用" class="headerlink" title="Tagged Pointer、NONPOINTER_ISA实现机制和作用"></a>Tagged Pointer、NONPOINTER_ISA实现机制和作用</h2><pre><code>利用联合体可以用相同的存储空间存储不同型别的数据类型，从而节省内存空间
1.Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate
2.Tagged Pointer指针的值不再是地址了，而是真正的值。
    实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。
    它的内存并不存储在堆中，也不需要malloc和free。
3.在内存读取上有着3倍的效率，创建时比以前快106倍。
4.它不单单是一个指针，还包括了其值+类型
 NONPOINTER_ISA在64位机上，对象的isa区域不再只是一个指向另一块存储空间的指针。
 还包含了更多信息，比如引用计数，析构状态，被其他weak 变量引用情况等。
 如果引用计数超过了当前指针所能表示的范围，Runtime 会使用一张散列表来管理用计数。
</code></pre>
<h2 id="异步多线程访问导致的内存问题分析及解决办法。（代码题）"><a href="#异步多线程访问导致的内存问题分析及解决办法。（代码题）" class="headerlink" title="异步多线程访问导致的内存问题分析及解决办法。（代码题）"></a>异步多线程访问导致的内存问题分析及解决办法。（代码题）</h2><pre><code>ispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);
   for (int i = 0; i &lt; 1000; i ++) &#123;
       dispatch_async(queue, ^&#123;
           self.name = [NSString stringWithFormat:@&quot;abcdefghijklmn&quot;];
       &#125;);
   &#125;
运行结果：崩溃（坏内存访问）
因为setter方法中，对strong修饰的属性会有一个retain和release的操作。在并发多线程的赋值操作中，都是对_name指针进行的操作，可能在_name刚刚被release后进行赋值操作，这个时候_name指向的内存地址是已经被释放了，所以造成了坏内存访问崩溃
解决办法：
1.异步改同步
2.将属性改成原子性
3.加锁
dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);
for (int i = 0; i &lt; 1000; i ++) &#123;
    dispatch_async(queue, ^&#123;
        self.name = [NSString stringWithFormat:@&quot;a&quot;];
    &#125;);
&#125;
为什么不崩溃了？因为没有用到引用计数的内存管理方法，使用的是TaggedPointer
从64bit开始，iOS引入了Tagged
Pointer技术，用于优化NSNumber、NSDate、NSString等小对象存储
</code></pre>
<h2 id="SideTables数据结构及实现原理，为什么用多个SideTables"><a href="#SideTables数据结构及实现原理，为什么用多个SideTables" class="headerlink" title="SideTables数据结构及实现原理，为什么用多个SideTables"></a>SideTables数据结构及实现原理，为什么用多个SideTables</h2><pre><code> SideTables包括了多个SideTable，在不同系统架构中SideTable的个数是不同的；
 SideTables是哈希表，可以通过一个对象的指针来找到具体的引用计数表或弱引用
 表在哪一个具体的SideTable中。
 如果只有一个table，意味着内存中分配的所有对象都要在一个表中操作，
 因为多个线程可能同时操作这个表，所以就要对这个表加锁，如果并发操作这个表的线
 程有成千上万个，就会产生效率问题。所以系统引入了分离锁这样一个技术方案，
 把大表拆成多个小表来进行操作，分别对小表加锁，从而提升效率。
  自旋锁：
                       
</code></pre>
<h2 id="Autoreleasepool的数据结构及实现原理，什么时候释放"><a href="#Autoreleasepool的数据结构及实现原理，什么时候释放" class="headerlink" title="Autoreleasepool的数据结构及实现原理，什么时候释放"></a>Autoreleasepool的数据结构及实现原理，什么时候释放</h2><pre><code>以栈为结点，由双向链表的形式合成的数据结构。与线程一一对应。
AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），
除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址
一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，
连接链表，后来的autorelease对象在新的page加入
Main函数自动添加了@autoreleasepool&#123;&#125;;
在for循环中alloc图片数据等内存消耗较大的场景手动插入autoreleasePool。
在当次runloop将要结束的时候调用AutoreleasePoolPage::pop()。
在for循环大量使用imageNamed:之类的方法生成UIImage对象可能是个更要命的事情，内
存随时可能因为占用过多被系统杀掉。
这种情况下利用Autoreleasepool可以大幅度降低程序的内存占用。
</code></pre>
<h2 id="AutoreleasePool-为何可以嵌套使用"><a href="#AutoreleasePool-为何可以嵌套使用" class="headerlink" title="AutoreleasePool 为何可以嵌套使用"></a>AutoreleasePool 为何可以嵌套使用</h2><pre><code>,每次创建一个AutoreleasePool，@AutoreleasePool，其实系统就
是为我们创建了一个哨兵对象,其实就是创建page，若果当前page没有满，
其实就是创建一个哨兵，所以可以嵌套使用
中间用nil作为分割
从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page
</code></pre>
<h2 id="子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool"><a href="#子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool" class="headerlink" title="子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool"></a>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool</h2><pre><code>在子线程你创建了 Pool 的话，产生的 Autorelease 对象就会交给 pool 去管理。
如果你没有创建 Pool ，但是产生了 Autorelease 对象，就会调用 autoreleaseNoPage
方法。在这个方法中，会自动帮你创建一个 hotpage（hotPage 可以理解为当前正在使用的
AutoreleasePoolPage，如果你还是不理解，可以先看看 Autoreleasepool
的源代码，再来看这个问题 ），并调用 page-&gt;add(obj)将对象添加到
AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏啦！
</code></pre>
<h2 id="dealloc调用流程"><a href="#dealloc调用流程" class="headerlink" title="dealloc调用流程"></a>dealloc调用流程</h2><pre><code>1.直接调用 objc_destructInstance()。
2.之后调用C的 free() 函数。
3.objc_destructInstance() 调用流程
1&gt;.先判断 hasCxxDtor，是否有析构函数（析构器），
要调用 object_cxxDestruct() ，释放（清除成员变量）。
2&gt;.再判断hasAssocitatedObjects，如果有的话，
要调用object_remove_associations()， 移除当前对象的关联对象。
3&gt;.然后调用 clearDeallocating()。 
4.clearDeallocating() 调用流程
0&gt;. 判断isa是否优化过，从arm64架构开始，对isa进行了优化，
变成了一个共用体（union）结构，所以结果一般是优化过了。
判断是否有弱引用或者引用计数
1&gt;.执行 clearDeallocating_slow()。
2&gt;.再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。
3&gt;.接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。
4&gt;.至此为止，Dealloc 的执行流程结束。
</code></pre>
<h2 id="常见的循环引用，如何破除循环引用"><a href="#常见的循环引用，如何破除循环引用" class="headerlink" title="常见的循环引用，如何破除循环引用"></a>常见的循环引用，如何破除循环引用</h2><pre><code>方式1:－－打断引用链条         方式2:－－使用__weak  
NSTimer破除循环引用
weak指针：
既然是强引用导致循环引用，那么用__weak修饰self就好了，想法是对的，但是做法是无效的。
中间类，block
及时销毁
创建一个继承NSProxy的子类WeakProxy，并实现消息转发的相关方法
</code></pre>
<h2 id="weak-修饰的变量在地址被释放后，为何被置为-nil？"><a href="#weak-修饰的变量在地址被释放后，为何被置为-nil？" class="headerlink" title="__weak 修饰的变量在地址被释放后，为何被置为 nil？"></a>__weak 修饰的变量在地址被释放后，为何被置为 nil？</h2><pre><code>1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针
指向对象的地址。
2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数，
objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。
3、释放时，调用clearDeallocating函数。clearDeallocating
函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中
的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。
</code></pre>
<h2 id="深拷贝和浅拷贝区别"><a href="#深拷贝和浅拷贝区别" class="headerlink" title="深拷贝和浅拷贝区别"></a>深拷贝和浅拷贝区别</h2><pre><code>对于对象来说浅拷贝只是增加引用，深拷贝时开辟新的内存地址存放复制对象
</code></pre>
<h2 id="atomic是安全的吗"><a href="#atomic是安全的吗" class="headerlink" title="atomic是安全的吗"></a>atomic是安全的吗</h2><pre><code>不是，只能保证在set和get方法内安全
</code></pre>
<h2 id="assign-vs-weak，-block-vs-weak-区别"><a href="#assign-vs-weak，-block-vs-weak-区别" class="headerlink" title="assign vs weak，_block vs _weak 区别"></a>assign vs weak，_block vs _weak 区别</h2><pre><code>weak和assign都是引用计算不变，两个的差别在于，weak用于object
type，就是指针类型，而assign用于简单的数据类型，如int BOOL 等。
assign看起来跟weak一样，其实不能混用的，assign的变量在释放后并不设置为nil
（和weak不同），当你再去引用时候就会发生错误
block 会对对象强引用，引起retain-cycle，需要使用__weak
（两个指针，指向同一块地址（self））；
__weak和__unsafe_unretained这两个关键字都能产生弱引用，但是它们又有以下不同：
__weak产生的弱引用，当弱指针指向的对象销毁时，也会将这个弱指针的值置为nil
__block修饰的变量，在运行时会生成一个__block对象，拥有__forwarding指针
当block拷贝到堆上时，__forwarding指向了堆上的__block 的__forwarding指针
</code></pre>
<h2 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h2><pre><code>启用Zombie Object进行悬挂指针的检测。
应用Product -&gt; Analysis进行内存泄露的初步检测。
可以在xcode的build setting中打开implicit retain of ‘self’ 
within blocks，xcode编译器会给出警告，逐个排查警告。
应用Leak Instrument进行内存泄露查找。
在以上方法不奏效的情况下，通过查看dealloc是否调用查看某个class是否泄露的问题
</code></pre>
<h2 id="图片加载占用内存对比"><a href="#图片加载占用内存对比" class="headerlink" title="图片加载占用内存对比"></a>图片加载占用内存对比</h2><pre><code>图片较小，并且使用频繁，使用 imageName: 来加载(按钮图标/主页里面图片)
图片较大，并且使用较少，使用 imageWithContentsOfFile: 来加载(版本新特性/相册)
</code></pre>
<h2 id="block一般用那个关键字修饰，为什么"><a href="#block一般用那个关键字修饰，为什么" class="headerlink" title="block一般用那个关键字修饰，为什么"></a>block一般用那个关键字修饰，为什么</h2><pre><code>此答案便是因为block在创建时是stack对象,（栈空间上）
如果我们需要在离开当前函数仍能够使用我们创建的block。
我们就需要把它拷贝到堆上以便进行以引用计数为基础的内存管理。
</code></pre>
<h2 id="写一个MRC的set方法"><a href="#写一个MRC的set方法" class="headerlink" title="写一个MRC的set方法"></a>写一个MRC的set方法</h2><pre><code>-(void)setDelegate:(id)delegate 
&#123; 
    if (_delegate != delegate) &#123; 
        [_delegate release]; 
        _delegate = [delegate retain/copy]; 
    &#125; 
&#125;
</code></pre>
<h2 id="如何解决定时器循环引用"><a href="#如何解决定时器循环引用" class="headerlink" title="如何解决定时器循环引用"></a>如何解决定时器循环引用</h2><pre><code>1.及时调用invalidate
在控制器中创建定时器将target给到self，在runloop中，对timer、self有了强引用
如果timer执行invalidate，则在runloop中，就会取消对timer及self的强引用了。
2.使用带block的定时器（支持iOS10以上），在block里面用walkSelf
3.加入了一个中间者NSProxy，使得timer不直接持有self，而是持有proxy，
让proxy对象弱引用self来解决循环引用（消息重定）
NSProxy是一个用来做消息转发的抽象类
,使用时需写一个子类继承自NSProxy并且子类需要实现两个方法，
- (void)forwardInvocation:(NSInvocation *)invocation;
和- (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel。
当NSProxy对象发送消息时，会跳过查找方法实现、动态方法解析、
被援接受者几个步骤直接进行消息的重定向，所以相比较NSObject的消息转发而言，
NSProxy减少了几个步骤，效率更高性能更优。
</code></pre>
<h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><h2 id="Block为什么用copy"><a href="#Block为什么用copy" class="headerlink" title="Block为什么用copy"></a>Block为什么用copy</h2><pre><code>Block在没有使用外部变量时，内存存在全局区，然而，当Block在使用外部变量的时候，
内存是存在于栈区，当Block copy之后，是存在堆区的。存在于栈区的特点是对象随时有
可能被销毁，一旦销毁在调用的时候，就会造成系统的崩溃。所以Block要用copy关键字。
</code></pre>
<h2 id="Block如何截获不同变量，代码分析"><a href="#Block如何截获不同变量，代码分析" class="headerlink" title="Block如何截获不同变量，代码分析"></a>Block如何截获不同变量，代码分析</h2><pre><code>Block是将函数及其执行上下文封装起来的对象。
对于基本数据类型的局部变量截获的是其值
对于对象类型的局部变量连同所有权修饰符一起截获（强引用）
以指针形式结果局部静态变量
不截获全局变量、全局静态变量
</code></pre>
<h2 id="Block本质数据结构"><a href="#Block本质数据结构" class="headerlink" title="Block本质数据结构"></a>Block本质数据结构</h2><pre><code>Block是将函数及其执行上下文封装起来的对象。
Block本质上是一个结构体，也有自己的isa
</code></pre>
<h2 id="栈上的Block经过copy操作后发生哪些变化"><a href="#栈上的Block经过copy操作后发生哪些变化" class="headerlink" title="栈上的Block经过copy操作后发生哪些变化"></a>栈上的Block经过copy操作后发生哪些变化</h2><pre><code>ARC环境下，一旦Block赋值就会触发copy，__block就会copy到堆上，
Block也是__NSMallocBlock。ARC环境下也是存在__NSStackBlock的时候，
这种情况下，__block就在栈上。
</code></pre>
<h2 id="block循环引用"><a href="#block循环引用" class="headerlink" title="block循环引用"></a>block循环引用</h2><pre><code>__weak所有权修饰变量，是联通属性关键字拷贝的
</code></pre>
<h2 id="block原理"><a href="#block原理" class="headerlink" title="__block原理"></a>__block原理</h2><pre><code>__block 修改变量
都有.__forwarding指针
栈上的__forwarding指向自己（变量）
经过copy后，栈上的.__forwarding指针指向了堆上的__block变量
.__forwarding存在的意义
不论任何内存位置都可以顺利访问统一个__block变量
</code></pre>
<h2 id="strong原理"><a href="#strong原理" class="headerlink" title="__strong原理"></a>__strong原理</h2><pre><code>strongSelf是block内部的一个局部变量，变量的作用域仅限于局部代码，
而程序一旦跳出作用域，strongSelf就会被释放，这个临时产生的“循环引用”
就会被自动打破，代码的执行事实上也是这样子的。
__strong修饰的变量在超出其作用域时retain是会自减
</code></pre>
<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop概念及数据结构、事件循环机制"><a href="#RunLoop概念及数据结构、事件循环机制" class="headerlink" title="RunLoop概念及数据结构、事件循环机制"></a>RunLoop概念及数据结构、事件循环机制</h2><pre><code>CFRunLoop
CFRunLoopMode
Source/Timer/Observer
source0
需要手动唤醒线程
source1
具备唤醒线程的能力
CFRunLoopObserver
观测时间点
kCFRunLoopEntry
kCFRunLoopBeforeTimers
CommonMode的特性
NSRunLoopCommonModes
commonMode不是实际存在的一种mode
是同步Source/Timer/Observer到多个Mode中的一种技术方案
一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个
Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个
Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出
Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的
Source/Timer/Observer，让其互不影响。
</code></pre>
<h2 id="CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用"><a href="#CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用" class="headerlink" title="CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用"></a>CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用</h2><h2 id="RunLoop和NStimer"><a href="#RunLoop和NStimer" class="headerlink" title="RunLoop和NStimer"></a>RunLoop和NStimer</h2><pre><code>NSTimer需要添加到Runloop中， 才能执行的情况
准确的Timer应该和当前线程的RunLoopMode保持一致
一个RunLoop不能同时共存两个mode
当滚动视图滚动时，当前RunLoop处于UITrackingRunLoopMode，
NSTimer的RunLoopMode和当前线程的RunLoopMode不一致，所以会停止
解决方式：将timer的runloopMode改为UITrackingRunLoopMode或
者NSRunLoopCommonModes
如果NSTimer在分线程中创建，会发生什么NSTimer没有启动
在主线程中，系统默认创建并启动主线程的runloop
在分线程中，系统不会自动启动runloop，需要手动启动？
</code></pre>
<h2 id="RunLoop和多线程"><a href="#RunLoop和多线程" class="headerlink" title="RunLoop和多线程"></a>RunLoop和多线程</h2><pre><code>在异步线程中下载很多图片,如果失败了,该如何处理?请结合RunLoop来谈谈解决方案
在异步线程中启动一个RunLoop重新发送网络请求,下载图片
如果程序启动就需要执行一个耗时操作，你会怎么做？
开启一个异步的子线程，并启动它的RunLoop来执行该耗时操作
</code></pre>
<h2 id="如何实现一个常驻线程"><a href="#如何实现一个常驻线程" class="headerlink" title="如何实现一个常驻线程"></a>如何实现一个常驻线程</h2><pre><code>给子线程添加RunLoop
 @autoreleasepool &#123;
    // 子线程对应的runloop需要自己创建并开启
    // 创建子线程对应的runloop,使子线程一直存在
    NSRunLoop *currentRunloop = [NSRunLoop currentRunLoop];
    // 给runloop添加一个基于port的事件(系统事件),让runloop的运行模式不为空,保证runloop不退出
    [currentRunloop addPort:[NSPort port] forMode:NSDefaultRunLoopMode];
    // 开启运行循环
    [currentRunloop run];
    &#125;
</code></pre>
<h2 id="利用-runloop-解释一下页面的渲染的过程"><a href="#利用-runloop-解释一下页面的渲染的过程" class="headerlink" title="利用 runloop 解释一下页面的渲染的过程"></a>利用 runloop 解释一下页面的渲染的过程</h2><pre><code>当我们调用 [UIView setNeedsDisplay] 时，这时会调用当前 View.layer 
的 [view.layer setNeedsDisplay]方法。
这等于给当前的 layer 打上了一个脏标记，而此时并没有直接进行绘制工作。
而是会到当前的 Runloop 即将休眠，也就是 beforeWaiting 时才会进行绘制工作。
紧接着会调用 [CALayer display]，进入到真正绘制的工作。CALayer 
层会判断自己的 delegate 有没有实现异步绘制的代理方法
displayer:，这个代理方法是异步绘制的入口，如果没有实现这个方法，
那么会继续进行系统绘制的流程，然后绘制结束。
CALayer 内部会创建一个 Backing Store，用来获取图形上下文。
接下来会判断这个 layer 是否有 delegate。
如果有的话，会调用 [layer.delegate drawLayer:inContext:]，
并且会返回给我们 [UIView DrawRect:] 的回调，让我们在系统绘制的基础之上再做一些事情。
如果没有 delegate，那么会调用 [CALayer drawInContext:]。
以上两个分支，最终 CALayer 都会将位图提交到 Backing Store，最后提交给 GPU。
</code></pre>
<h2 id="你在开发过程中怎么使用RunLoop？什么应用场景？"><a href="#你在开发过程中怎么使用RunLoop？什么应用场景？" class="headerlink" title="你在开发过程中怎么使用RunLoop？什么应用场景？"></a>你在开发过程中怎么使用RunLoop？什么应用场景？</h2><pre><code>开启一个常驻线程（让一个子线程不进入消亡状态，等待其他线程发来的消息，处理其他事件）
在子线程中开启一个定时器
在子线程中进行一些长期监控
可以控制定时器在特定模式下运行
可以让某些事件（行为，任务）在特定模式下执行
可以添加observer监听RunLoop的状态，比如监听点击事件的处理（比如在所有点击事件前做一些处理）
1）NSTimer
2）ImageView显示：控制方法在特定的模式下可用
3）PerformSelector
4）常驻线程：在子线程中开启一个runloop
5）自动释放池
</code></pre>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程与线程、并行-和-并发-区别"><a href="#进程与线程、并行-和-并发-区别" class="headerlink" title="进程与线程、并行 和 并发 区别"></a>进程与线程、并行 和 并发 区别</h2><pre><code>1.线程是进程的执行单元，进程的所有任务都在线程中执行
2.线程是 CPU 分配资源和调度的最小单位
多线程的实现原理：事实上，同一时间内单核的CPU只能执行一个线程，
多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。
并行：充分利用计算机的多核，在多个线程上同步进行
并发：在一条线程上通过快速切换，让人感觉在同步进行
</code></pre>
<h2 id="GCD、NSOperation、NSThread区别优缺点"><a href="#GCD、NSOperation、NSThread区别优缺点" class="headerlink" title="GCD、NSOperation、NSThread区别优缺点"></a>GCD、NSOperation、NSThread区别优缺点</h2><pre><code>第一种：pthread
    a.特点：
        1）一套通用的多线程API
        2）适用于Unix\Linux\Windows等系统
        3）跨平台\可移植
        4）使用难度大
    b.使用语言：c语言
    c.使用频率：几乎不用
    d.线程生命周期：由程序员进行管理
第二种：NSThread
    a.特点：
        1）使用更加面向对象
        2）简单易用，可直接操作线程对象
        b.使用语言：OC语言
        c.使用频率：偶尔使用
        d.线程生命周期：由程序员进行管理
第三种：GCD
    a.特点：
        1）旨在替代NSThread等线程技术
        2）充分利用设备的多核（自动）
    b.使用语言：C语言
    c.使用频率：经常使用
    d.线程生命周期：自动管理
第四种：NSOperation
    a.特点：
        1）基于GCD（底层是GCD）
        2）比GCD多了一些更简单实用的功能
        3）使用更加面向对象
    b.使用语言：OC语言
    c.使用频率：经常使用
    d.线程生命周期：自动管理
</code></pre>
<h2 id="performSelector-withObject-afterDelay-为什么在子线程无效"><a href="#performSelector-withObject-afterDelay-为什么在子线程无效" class="headerlink" title="performSelector:withObject:afterDelay:为什么在子线程无效"></a>performSelector:withObject:afterDelay:为什么在子线程无效</h2><pre><code>没有performSelector内部实现时NSTimer，nstime需要基于runloop才能实现
</code></pre>
<h2 id="如何让多个网络请求完成后执行下一步"><a href="#如何让多个网络请求完成后执行下一步" class="headerlink" title="如何让多个网络请求完成后执行下一步"></a>如何让多个网络请求完成后执行下一步</h2><pre><code>dispatch_group_t
</code></pre>
<h2 id="多个网络请求顺序执行后执行下一步"><a href="#多个网络请求顺序执行后执行下一步" class="headerlink" title="多个网络请求顺序执行后执行下一步"></a>多个网络请求顺序执行后执行下一步</h2><pre><code>dispatch_semaphore_wait
</code></pre>
<h2 id="异步操作两组数据时-执行完第一组之后-才能执行第二组"><a href="#异步操作两组数据时-执行完第一组之后-才能执行第二组" class="headerlink" title="异步操作两组数据时, 执行完第一组之后, 才能执行第二组"></a>异步操作两组数据时, 执行完第一组之后, 才能执行第二组</h2><pre><code>dispatch_barrier_async
</code></pre>
<h2 id="你知道哪些锁、使用场景"><a href="#你知道哪些锁、使用场景" class="headerlink" title="你知道哪些锁、使用场景"></a>你知道哪些锁、使用场景</h2><pre><code>@synchronized 一个对象层面的锁，锁住了整个对象，底层使用了互斥递归
锁来实现
pathread_mutex 互斥锁（c语言）和信号量的实现原理类似，也是阻塞线程并进入睡眠
，需要进行上下文切换。
NSLock 对象锁-简单的互斥锁（内部封装了一个 pthread_mutex）
NSCondition （封装了一个互斥锁和条件变量。互斥锁保证线程安全，条件
NSCondition和NSLock、@synchronized等是不同的是，
NSCondition可以给每个线程分别加锁，加锁后不影响其他线程进入临界区。
这是非常强大。
NSConditionLock （借助 NSCondition 来实现，本质是生产者-消费者模型）
也可以像NSCondition一样做多线程之间的任务等待调用，而且是线程安全的。
NSRecursiveLock 递归锁有时候“加锁代码”中存在递归调用，递归开始前加
dispatch_semaphore GCD中信号量，也可以解决资源抢占问题,
支持信号通知和信号等待。每当发送一个信号通知，则信号量+1；
每当发送一个等待信号时信号量-1,；如果信号量为0则信号会处于等待状态，
直到信号量大于0开始执行
OSSpinLock 自旋锁(不建议使用)
自旋锁的实现原理比较简单，就是死循环。当a线程获得锁以后，b线程想要获取
锁就需要等待a线程释放锁。在没有获得锁的期间，b线程会一直处于忙等的状
态。如果a线程在临界区的执行时间过长，则b线程会消耗大量的cpu时间，不太
划算。所以，自旋锁用在临界区执行时间比较短的环境性能会很高。
</code></pre>
<h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><pre><code>相同点：都能保证同一时间只有一个线程访问共享资源。
都能保证线程安全。
不同点：
互斥锁：如果共享数据已经有其他线程加锁了，线程会进入
休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的
线程会被唤醒。
自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环
的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会
立即执行。
自旋锁的效率高于互斥锁。
由于自旋时不释放CPU，因而持有自旋锁的线程应该尽快释放
自旋锁，否则等待该自旋锁的线程会一直在哪里自旋，这就会浪
费CPU时间。
持有自旋锁的线程在sleep之前应该释放自旋锁以便其他可以获得
该自旋锁。内核编程中，如果持有自旋锁的代码sleep了就可能
导致整个系统挂起。
</code></pre>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP请求方式有哪些"><a href="#HTTP请求方式有哪些" class="headerlink" title="HTTP请求方式有哪些"></a>HTTP请求方式有哪些</h2><pre><code>GET、POST、HEAD、PUT、DELETE、OPTIONS
</code></pre>
<h2 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h2><pre><code>无连接：HTTP的持久性
是限制每次连接只处理一个请求。服务器处理完客户的请求，
并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接
无状态：Cookie/Session
无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。
即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，
发送完，不会记录任何信息。缺少状态意味着如果后续处理需要前面的信息，
则它必须重传，这样可能导致每次连接传送的数据量增大。
HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。
</code></pre>
<h2 id="HTTP三次握手，为什么需要三次"><a href="#HTTP三次握手，为什么需要三次" class="headerlink" title="HTTP三次握手，为什么需要三次"></a>HTTP三次握手，为什么需要三次</h2><pre><code>客户端发送SYN请求连接
服务端接受SYN，返回SYN和ACK
客户端接受SYN和ACK，返回服务端ACK
“第三次握手”是客户端向服务器端发送数据，这个数据就是要告诉服务器，
客户端有没有收到服务器“第二次握手”时传过去的数据。若发送的这个数据是“
收到了”的信息，接收后服务器就正常建立TCP连接，否则建立TCP连接失败，
服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。
</code></pre>
<h2 id="HTTP四次挥手，为什么需要四次"><a href="#HTTP四次挥手，为什么需要四次" class="headerlink" title="HTTP四次挥手，为什么需要四次"></a>HTTP四次挥手，为什么需要四次</h2><pre><code>客户端发送FIN请求释放连接  FIN-WAIT-1阶段
服务端返回ACK，服务端处于准备断开状态  CLOSE-WAIT阶段（半关闭状态），客户端收到，进入FIN-WAIT-2阶段
服务端做好释放准备，再次向客户端发送FIN和ACK，LAST-ACK阶段
客户端收到FIN和ACK，发送ACK断开连接，TIME-WAIT阶段
随后客户端开始在TIME-WAIT阶段等待2MSL
服务端收到客户端LAST-ACK，进入CLOSED阶段。
与“三次挥手”一样，在客户端与服务器端传输的TCP报文中，双方的确认号Ack和
序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文
传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续&quot;挥手&quot;，
以此确保了&quot;四次挥手&quot;的顺利完成。
</code></pre>
<h2 id="为什么“握手”是三次，“挥手”却要四次？"><a href="#为什么“握手”是三次，“挥手”却要四次？" class="headerlink" title="为什么“握手”是三次，“挥手”却要四次？"></a>为什么“握手”是三次，“挥手”却要四次？</h2><pre><code>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，
可以直接返回SYN和ACK报文，开始建立连接。
释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能
立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文
，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。
</code></pre>
<h2 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL"></a>为什么客户端在TIME-WAIT阶段要等2MSL</h2><pre><code>为的是确认服务器端是否收到客户端发出的ACK确认报文
当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。
所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment
Lifetime：一段TCP报文在传输过程中的最大生命周期。
2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。
</code></pre>
<h2 id="HTTPS-TLS-SSL加密过程"><a href="#HTTPS-TLS-SSL加密过程" class="headerlink" title="HTTPS TLS/SSL加密过程"></a>HTTPS TLS/SSL加密过程</h2><pre><code>1、身份验证机制
2、数据传输的机密性
3、消息完整性验证
1、客户端向服务器端索要并验证公钥。
 2、双方协商生成&quot;对话密钥&quot;。
 3、双方采用&quot;对话密钥&quot;进行加密通信。
 其中，前两个阶段，被称为“握手阶段”。
 TLS握手过程有单向验证和双向验证之分，简单解释一下，单向验证就是
 server端将证书发送给客户端，客户端验证server端证书的合法性等，
 例如百度、新浪、google等普通的https网站，双向验证则是不仅客户端会验
 证server端的合法性，同时server端也会验证客户端的合法性，例如银行网银登陆
 ，支付宝登陆交易等。
 1、确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
 2、一个服务器生成的随机数（Sever Random），稍后用于生成&quot;对话密钥&quot;。
 3、确认使用的加密方法，比如RSA公钥加密。
 4、服务器证书（Certificate）。
 5、支持的一些SSL/TLS扩展。
</code></pre>
<h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><pre><code>①客户端发送报文进行SSL通信。报文中包含客户端支持的SSL的指定版本、
加密组件列表（加密算法及密钥长度等）。
②服务器应答，并在应答报文中包含SSL版本以及加密组件。
服务器的加密组件内容是从接受到的客户端加密组件内筛选出来的。
③服务器发送报文，报文中包含公开密钥证书。
④服务器发送报文通知客户端，最初阶段SSL握手协商部分结束。
⑤SSL第一次握手结束之后，客户端发送一个报文作为回应。
报文中包含通信加密中使用的一种被称Pre-master
secret的随机密码串。该密码串已经使用服务器的公钥加密。
⑥客户端发送报文，并提示服务器，此后的报文通信会采用
Pre-master secret密钥加密。
⑦客户端发送Finished报文。该报文包含连接至今全部报文的
整体校验值。这次握手协商是否能够完成成功，要以服务器是否能够正确解密该报文作为判定标准。
⑧服务器同样发送Change Cipher Spec报文。
⑨服务器同样发送Finished报文。
⑩服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。
⑪应用层协议通信，即发送HTTP响应。
⑫最后由客户端断开链接。断开链接时，发送close_nofify报文
</code></pre>
<h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><pre><code>不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。
由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。
对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，
再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。
pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，
如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用
pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和
服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机
可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，
随机性增加的可不是一。
</code></pre>
<h2 id="中间人攻击（charles抓包原理）"><a href="#中间人攻击（charles抓包原理）" class="headerlink" title="中间人攻击（charles抓包原理）"></a>中间人攻击（charles抓包原理）</h2><pre><code>1、截获客户端与服务器通信的通道
2、然后在 SSL 建立连接的时候，进行中间人攻击
3、将自己伪装成客户端，获取到服务器真实有效的 CA 证书（非对称加密的公钥）
4、将自己伪装成服务器，获取到客服端的之后通信的密钥（对称加密的密钥）
5、有了证书和密钥就可以监听之后通信的内容了
</code></pre>
<h2 id="UDP协议及特点、"><a href="#UDP协议及特点、" class="headerlink" title="UDP协议及特点、"></a>UDP协议及特点、</h2><pre><code>无连接协议，也称透明协议，也位于传输层。
UDP通讯协议的特点：
将数据封装为数据包。面向无连接。
每个数据包大小限制在64K。
因为无连接，所以不可靠。
因为不需要建立连接，所以速度快。
UDP通讯是不分服务端和客服端的，只分发送端和接收端。
</code></pre>
<h2 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h2><pre><code>基于连接（点对点）
传输数据前需要建立好连接，然后在传输
双工通信
TCP连接一旦建立，就可以在连接上进行双向的通信
基于字节流而非报文
将数据按字节大小进行编号，接收端通过ACK来确认收到的数据编号，通过这种机制能够保证TCP协议的有序性和完整性，因此TCP能够提供可靠性传输

可靠传输
拥塞控制
慢启动，拥塞避免，拥塞发生，快速恢复四个算法
流量控制能力
</code></pre>
<h2 id="TCP特点及与UDP区别"><a href="#TCP特点及与UDP区别" class="headerlink" title="TCP特点及与UDP区别"></a>TCP特点及与UDP区别</h2><pre><code>1） TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）；
UDP提供无连接的传输，通信前不需要建立连接。
2） TCP提供可靠的传输（有序，无差错，不丢失，不重复）；
UDP提供不可靠的传输。
3） TCP面向字节流的传输，因此它能将信息分割成组，
并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。
4） TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。
</code></pre>
<h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><pre><code>DNS服务器一般分三种，根DNS服务器，顶级DNS服务器，权威DNS服务器。
1）浏览器缓存　　
2）系统缓存　　
3）路由器缓存　　　　
4） ISP（互联网服务提供商）DNS缓存
5）根域名服务器　　　
6）顶级域名服务器　　
8）保存结果至缓存
</code></pre>
<h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><pre><code>一般而言，用户上网的DNS服务器都是运营商分配的，所以，在这个节点上，运营商可以为所欲为。
例如，访问http://jiankang.qq.com/index.html，
正常DNS应该返回腾讯的ip，而DNS劫持后，会返回一个运营商的中间服务器ip。
访问该服务器会一致性的返回302，让用户浏览器跳转到预处理好的带广告的网页，
在该网页中再通过iframe打开用户原来访问的地址。
</code></pre>
<h2 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h2><pre><code>在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而
且是html类型请求，则拦截处理。后续做法往往分为2种，1种是类
似DNS劫持返回302让用户浏览器跳转到另外的地址，还有1种是在服务器返
回的HTML数据中插入js或dom节点（广告）。
</code></pre>
<h2 id="Cookie机制及作用"><a href="#Cookie机制及作用" class="headerlink" title="Cookie机制及作用"></a>Cookie机制及作用</h2><pre><code>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。
在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。
服务器在向客户端回传相应的超文本的同时也会发回这些个人
信息存放于HTTP响应头（Response Header）；当客户端浏览器接收到来
自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置
自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。
Cookie的maxAge决定着Cookie的有效期，单位为秒（Second）。
</code></pre>
<h2 id="Session机制及作用"><a href="#Session机制及作用" class="headerlink" title="Session机制及作用"></a>Session机制及作用</h2><pre><code>Web应用程序中还经常使用Session来记录客户端状态。
Session是服务器端使用的一种记录客户端状态的机制，
使用上比Cookie简单一些，相应的也增加了服务器的存储压力。
Session技术则是服务端的解决方案，它是通过服务器来保持状态的。
URL地址重写是对客户端不支持Cookie的解决方案。
URL地址重写的原理是将该用户Session的id信息重写到URL地址中。
服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，
也可以使用Session来记录用户状态。
</code></pre>
<h2 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h2><pre><code>cookie数据存放在客户的浏览器上，session数据放在服务器上；
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
，考虑到安全应当使用session；
session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的
性能。考虑到减轻服务器性能方面，应当使用COOKIE；
</code></pre>
<h2 id="如何保证cookie的安全"><a href="#如何保证cookie的安全" class="headerlink" title="如何保证cookie的安全"></a>如何保证cookie的安全</h2><pre><code>对cookie进行加密处理
只在https上携带cookie
设置cookie为httpOnly，防止跨站脚本攻击
</code></pre>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><pre><code>单一职责原则
    CALayer：动画和视图的显示。
    UIView：只负责事件传递、事件响应。
    生成的数据模型
开闭原则
    对修改关闭，对扩展开放。 要考虑到后续的扩展性，而不是在原有的基础上来回修改
接口隔离原则
    使用多个专门的协议、而不是一个庞大臃肿的协议，如 
    UITableviewDelegate + UITableViewDataSource
依赖倒置原则
    抽象不应该依赖于具体实现、具体实现可以依赖于抽象。 
    调用接口感觉不到内部是如何操作的
里氏替换原则
    父类可以被子类无缝替换，且原有的功能不受任何影响 如：KVO
迪米特法则
    一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合
</code></pre>
<h2 id="iOS有哪些常见的设计模式"><a href="#iOS有哪些常见的设计模式" class="headerlink" title="iOS有哪些常见的设计模式?"></a>iOS有哪些常见的设计模式?</h2><pre><code>01代理委托Delegate是协议的一种
,通过@protocol方式实现，常见的有tableView，textField等。
02观察者 通知机制(notification)和KVO机制(Key-value Observing)
03MVC
04单例（Singleton）,UIApplication, NSBundle, NSNotificationCenter,
NSFileManager, NSUserDefault, NSURLCache等都是单例.
05策略
06工厂
</code></pre>
<h2 id="单例优缺点"><a href="#单例优缺点" class="headerlink" title="单例优缺点"></a>单例优缺点</h2><pre><code>主要优点：
1、提供了对唯一实例的受控访问。
2、由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需
要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
3、允许可变数目的实例。
主要缺点：
1、由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。
2、单例类的职责过重，在一定程度上违背了“单一职责原则”。
3、滥用单例将带来一些负面问题，会导致共享连接池对象的程序过多而出现连接池溢出
</code></pre>
<h2 id="内存设计、磁盘设计、网络设计原则"><a href="#内存设计、磁盘设计、网络设计原则" class="headerlink" title="内存设计、磁盘设计、网络设计原则"></a>内存设计、磁盘设计、网络设计原则</h2><pre><code>内存设计:存储的Size,淘汰策略 LRU算法
磁盘设计:存储方式\大小限制\淘汰策略
网络设计:图片请求最大并发\请求超时策略\请求优先级
</code></pre>
<h2 id="MVP、MVVM模式思想"><a href="#MVP、MVVM模式思想" class="headerlink" title="MVP、MVVM模式思想"></a>MVP、MVVM模式思想</h2><pre><code>MVVM 即模型-视图-视图模型
在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，
ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel
能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，
ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的
双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。
优点 VIew可以独立于Model的变化和修改，一个ViewModel可以绑定到不同的View上，
降低耦合，增加重用
缺点 过于简单的项目不适用、大型的项目视图状态较多时构建和维护成本太大
合理的运用架构模式有利于项目、团队开发工作，但是到底选择哪个设计模式，
哪种设计模式更好，就像本文开头所说，不同的设计模式，只是让不同的场
景有了更多的选择方案。根据项目场景和开发需求，选择最合适的解决方案。
MVP（Model、View、Presenter）：MVP模式是MVC模式的一个演化版本，其中Model
与MVC模式中Model层没有太大区别，主要提供数据存储功能，一般都是用来封
装网络获取的json数据；
优点 模型和视图完全分离，可以做到修改视图而不影响模型；更高效的使用模型，View不依赖Model，可以说VIew能做到对业务逻辑完全分离
缺点 Presenter中除了处理业务逻辑以外，还要处理View-Model两层的协调，也会导致Presenter层的臃肿
</code></pre>
<h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><pre><code>Flux是Facebook用来构建用户端的web应用的应用程序体系架构。
它通过利用数据的单向流动为React的可复用的视图组件提供了补充。
相比于形式化的框架它更像是一个架构思想，不需要太多新的代码你就可以马上
使用Flux构建你的应用。
一个 Flux 应用主要包含四个部分：
dispatcher
处理动作分发，维护 Store 之间的依赖关系
stores
数据和逻辑部分
views
React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互
actions
提供给 dispatcher 传递数据给 store
视图上添加的所有的视图组成一个视图多叉树；
比如某个UI发生变化后，需要反向到根节点，然后由根节点想下遍历查找需
要更新的结点；
任何一个子节点是没有权利自我更新的，需要把自我变化更
新的消息传递给根节点，由根节点进行更新，相当于由主动行为变成被动行为
</code></pre>
<h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><pre><code>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：
排版，绘制，UI对象操作。
排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。
绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。
UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。
其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主
线程完成，并且有时后面的操作需要依赖前面操作的结果
（例如TextView创建时可能需要提前计算出文本的大小）。ASDK
所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟
(例如视图的创建、属性的调整)。
为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了
UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如
frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只
通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制
放入了后台线程。但是无论怎么操作，
这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。

ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面
更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了
kCFRunLoopBeforeWaiting 和 kCFRunLoopExit
事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。
</code></pre>
<h2 id="AFNetworking-底层原理分析"><a href="#AFNetworking-底层原理分析" class="headerlink" title="AFNetworking 底层原理分析"></a>AFNetworking 底层原理分析</h2><pre><code>AFNetworking是封装的NSURLSession的网络请求，由五个模块组成：
分别由NSURLSession,Security,Reachability,Serialization,UIKit五部分组成
NSURLSession：网络通信模块（核心模块） 对应 AFNetworking中的
AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager
,AFHTTPSessionManager是继承于AFURLSessionmanager的
Security：网络通讯安全策略模块 对应 AFSecurityPolicy
Reachability：网络状态监听模块 对应AFNetworkReachabilityManager
Seriaalization：网络通信信息序列化、反序列化模块 对应AFURLResponseSerialization
UIKit：对于iOS UIKit的扩展库
</code></pre>
<h2 id="SDWebImage加载图片过程，图片缓存设计"><a href="#SDWebImage加载图片过程，图片缓存设计" class="headerlink" title="SDWebImage加载图片过程，图片缓存设计"></a>SDWebImage加载图片过程，图片缓存设计</h2><pre><code>0、首先显示占位图
1、在webimagecache中寻找图片对应的缓存，它是以url为数据索引先在内存中
查找是否有缓存；
2、如果没有缓存，就通过md5处理过的key来在磁盘中查找
对应的数据，如果找到就会把磁盘中的数据加到内存中，并显示出来；
3、如果内存和磁盘中都没有找到，就会向远程服务器发送请求，开始下载图片；
4、下载完的图片加入缓存中，并写入到磁盘中；
5、整个获取图片的过程是在子线程中进行，在主线程中显示。
</code></pre>
<h2 id="SDWebImage框架设计中"><a href="#SDWebImage框架设计中" class="headerlink" title="SDWebImage框架设计中"></a>SDWebImage框架设计中</h2><pre><code>1.设计UIImageView的分类，添加方法
2.在SDWebImageManager里面判断图片加载逻辑
3.在SDWebImageDecoder处理图片解码
4.在SDWebImageDownloader处理图片下载
5.在SDImageCache里缓存图片
</code></pre>
<h2 id="YYKit"><a href="#YYKit" class="headerlink" title="YYKit"></a>YYKit</h2><pre><code>YYModel — 高性能的 iOS JSON 模型框架。
YYCache — 高性能的 iOS 缓存框架。
YYImage — 功能强大的 iOS 图像框架。
YYWebImage — 高性能的 iOS 异步图像加载框架。
YYText — 功能强大的 iOS 富文本框架。
</code></pre>
<h2 id="组建化优缺点"><a href="#组建化优缺点" class="headerlink" title="组建化优缺点"></a>组建化优缺点</h2><pre><code>业务分层、解耦，使代码变得可维护；
有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；
便于各业务功能拆分、抽离，实现真正的功能复用；
</code></pre>
<h2 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h2><pre><code>视图层(View&amp;ViewController)
业务逻辑处理(ViewModel)
数据层(Model&amp;Engine)
数据流
数据与数据关系
MVVM框架思想
ReactiveNative的数据流思想
系统UIView更新机制的思想
FaceBook的开源框架AsyncDisplayKit关于预排版的设计思想
</code></pre>
<h1 id="开发日常"><a href="#开发日常" class="headerlink" title="开发日常"></a>开发日常</h1><h2 id="APP启动时间应从哪些方面优化？"><a href="#APP启动时间应从哪些方面优化？" class="headerlink" title="APP启动时间应从哪些方面优化？"></a>APP启动时间应从哪些方面优化？</h2><pre><code>App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme–&gt;Edit 
Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，
优化需以下方面入手
dylib loading time
    核心思想是减少dylibs的引用
    合并现有的dylibs（最好是6个以内）
    使用静态库
rebase/binding time
    核心思想是减少DATA块内的指针
    减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）
    减少c++虚函数
    多使用Swift结构体（推荐使用swift）
ObjC setup time
    核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时
initializer time
    使用initialize替代load方法
    减少使用c/c++的attribute((constructor))；推荐使用
    dispatch_once() pthread_once() std:once()等方法
    推荐使用swift
    不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁
    ，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁
    不要在初始化中创建线程
</code></pre>
<h2 id="如何降低APP包的大小"><a href="#如何降低APP包的大小" class="headerlink" title="如何降低APP包的大小"></a>如何降低APP包的大小</h2><pre><code>可执行文件
编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden
by Default 设置为 YES，去掉异常支持，Enable C++ Exceptions、Enable
Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions
利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code
编写LLVM插件检测出重复代码、未被调用的代码
资源（图片、音频、视频 等）
优化的方式可以对资源进行无损的压缩
去除没有用到的资源： 
</code></pre>
<h2 id="如何检测离屏渲染与优化"><a href="#如何检测离屏渲染与优化" class="headerlink" title="如何检测离屏渲染与优化"></a>如何检测离屏渲染与优化</h2><pre><code>检测，通过勾选Xcode的Debug-&gt;View Debugging–&gt;Rendering-&gt;Run-&gt;Color 
Offscreen-Rendered Yellow项。
优化，如阴影，在绘制时添加阴影的路径
</code></pre>
<h2 id="怎么检测图层混合"><a href="#怎么检测图层混合" class="headerlink" title="怎么检测图层混合"></a>怎么检测图层混合</h2><pre><code>1、模拟器debug中color blended layers红色区域表示图层发生了混合
2、Instrument-选中Core Animation-勾选Color Blended Layers
避免图层混合：
确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明
如无特殊需要，不要设置低于1的alpha值
确保UIImage没有alpha通道
</code></pre>
<h2 id="UILabel图层混合"><a href="#UILabel图层混合" class="headerlink" title="UILabel图层混合"></a>UILabel图层混合</h2><pre><code>UILabel图层混合解决方法： iOS8以后设置背景色为非透明色并且设置label.layer
.masksToBounds=YES让label只会渲染她的实际size区域，
就能解决UILabel的图层混合问题
iOS8 之前只要设置背景色为非透明的就行
为什么设置了背景色但是在iOS8上仍然出现了图层混合呢？
UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，
而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变。在
背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，设
置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪 图层混合问题解决了
</code></pre>
<h2 id="日常如何检查内存泄露？"><a href="#日常如何检查内存泄露？" class="headerlink" title="日常如何检查内存泄露？"></a>日常如何检查内存泄露？</h2><pre><code>目前我知道的方式有以下几种
Memory Leaks
Alloctions
Analyse
Debug Memory Graph
MLeaksFinder
泄露的内存主要有以下两种：
Laek Memory 这种是忘记 Release 操作所泄露的内存。
Abandon Memory 这种是循环引用，无法释放掉的内存。
</code></pre>
<h2 id="LLDB常用的调试命令？"><a href="#LLDB常用的调试命令？" class="headerlink" title="LLDB常用的调试命令？"></a>LLDB常用的调试命令？</h2><pre><code>po：print object的缩写，表示显示对象的文本描述，如果对象不存在则打印nil。
p：可以用来打印基本数据类型。
call：执行一段代码 如：call NSLog(@&quot;%@&quot;, @“yang”)
expr：动态执行指定表达式
bt：打印当前线程堆栈信息 （bt all 打印所有线程堆栈信息）
image：常用来寻找栈地址对应代码位置 如：image lookup --address 0xxxx
</code></pre>
<h2 id="iOS-常见的崩溃类型有哪些？"><a href="#iOS-常见的崩溃类型有哪些？" class="headerlink" title="iOS 常见的崩溃类型有哪些？"></a>iOS 常见的崩溃类型有哪些？</h2><pre><code>unrecognized selector crash
KVO crash
NSNotification crash
NSTimer crash
Container crash
NSString crash
Bad Access crash （野指针）
UI not on Main Thread Crash
</code></pre>
<h2 id="iOS-App-稳定性指标及监测"><a href="#iOS-App-稳定性指标及监测" class="headerlink" title="iOS App 稳定性指标及监测"></a>iOS App 稳定性指标及监测</h2><pre><code>开发过程中，主要是通过监控内存使用及泄露，CPU使用率，FPS，启动时间等指标，
以及常见的UI的主线程监测，NSAssert断言等，最好能在Debug模式下，实时显
示在界面上，针对出现的问题及早解决。
</code></pre>
<h2 id="cocoapods-常见问题"><a href="#cocoapods-常见问题" class="headerlink" title="cocoapods 常见问题"></a>cocoapods 常见问题</h2><pre><code>cocoaPods 是为IOS 提供依赖管理的工具,他是管理第三方类库的工具.
pod update
cocoaPods的实现思路，为什么没有使用cocoaPods管理自己的SDK
</code></pre>
<h2 id="iOS的签名机制是怎么样的"><a href="#iOS的签名机制是怎么样的" class="headerlink" title="iOS的签名机制是怎么样的"></a>iOS的签名机制是怎么样的</h2><pre><code>签名机制：
先将应用内容通过摘要算法，得到摘要
再用私钥对摘要进行加密得到密文
将源文本、密文、和私钥对应的公钥一并发布
验证流程：
查看公钥是否是私钥方的
然后用公钥对密文进行解密得到摘要
将APP用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift138%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift138%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">面试总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:52" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:52+08:00">2020-09-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="58同城"><a href="#58同城" class="headerlink" title="58同城"></a>58同城</h2><h2 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h2><p>我们创建的一般都是静态库，可以制作动态库，不允许上架app store的<br>iOS8，swift以后，出现了阉割版的Extension动态库。这种动态库允许APP和APP Extension共享代码<br>静态库：链接时，静态库会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝<br>系统动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存<br>iOS有没有动态库<br>iOS的动态库（被阉割的动态库）<br>iOS8之前因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，并且iOS是单进程的，也就是某一时刻只有一个进程在运行，那么你写个共享库，给谁共享呢。同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，综上所以上动态库也就没有存在的必要了。<br>但是后来iOS8之后，iOS有了App Extesion特性，而且Swift也诞生了。由于iOS主App需要和Extension共享代码，Swift语言机制也需要动态库，于是苹果后来提出了Embedded Framework，这种动态库允许APP和APP Extension共享代码，但是这份动态库的生命被限定在一个APP进程内。简单点可以理解为被阉割的动态库。<br> App 中（App 和 Extension 的 Bundle 是共享的）所以苹果没有直接把这种Embedded Framework称作动态库而是叫Embedded Framework。<br>前面提到的静态库可以简单理解为一堆目标文件(.o/.obj)的打包体(并非二进制文件)，而动态库可以简单理解为 一个没有main函数的可执行文件。<br>大学再讲编译原理的时候有两个非常重要的过程，编译和链接。编译可以理解为将源代码编译为目标文件，链接可以理解为将各种目标文件上加一些第三方库、并且和系统库链接起来为可执行文件。因为某个目标文件的符号（可以理解为变化、函数）可能来至其他目标文件，链接最为主要的就是决议符号的地址。<br>编译会生成目标文件，目标文件没有经过链接的过程，某些符号还没有调整过，Windows下的.obj文件，Linux下的.o文件，Unix的.out文件。</p>
<p>链接的过程可以简单描述如下：<br>假如主程序main.c 使用了 fun.c 模块的 foo函数，那么main.c在编译的过程，对于调用foo函数的指令，对于指令的目标地址暂时搁置；待到链接的时候，由链接器来填写foo函数的地址。</p>
<h2 id="OC反射"><a href="#OC反射" class="headerlink" title="OC反射"></a>OC反射</h2><p>通过类明获取类，通过方法名获取方法<br>所以说通过上面runtime的方式可以通过指针输出你想要的类当中的的全部属性，当然反过来也是可以实现的（这里对runtime不做过多的讲解，改天更新文章再对runtime进行分享</p>
<h2 id="编译和链接的区别"><a href="#编译和链接的区别" class="headerlink" title="编译和链接的区别"></a>编译和链接的区别</h2><p>将预处理生成的文件，经过词法分析、语法分析、语义分析以及优化后编译成若干个目标模块。可以理解为将高级语言翻译为计算机可以理解的二进制代码，即机器语言。<br>由链接程序将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的载入模型。链接主要解决模块间的相互引用问题。分为地址和空间分配，符号解析和重定位几个步骤。在编译阶段生成目标文件时，会暂时搁置那些外部引用，而这些外部引用就是在链接时进行确定的，链接器在链接时，会根据符号名称去相应模块中寻找对应符号。待符号确定之后，链接器会重写之前那些未确定的符号的地址，这个过程就是重定位。链接一般分为静态链接、载入时动态链接以及运行时动态链接三种。</p>
<h2 id="OC和JS交互方式"><a href="#OC和JS交互方式" class="headerlink" title="OC和JS交互方式"></a>OC和JS交互方式</h2><p>注入 API 和 拦截 URL SCHEME<br>UIWebView 拦截 URL<br>WebViewJavascriptBridge。<br>只要调用<br>window.location.href = “openimagepicker://“<br>就会调用<br>(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</p>
<p>WebViewJavascriptBridge中OC调用JS采用的是WebView提供的JS执行方法；而JS调用OC采用的是URL拦截的方式，OC端通过识别特定的URL来区分是否需要拦截，并做相应的逻辑处理。<br>addScriptMessageHandler<br>evaluateJavaScript<br>JavaScriptCore<br>JSContext上下文，类似全局t对象，html的window对象一样</p>
<p>WKwebView，直接注入了JS方法名，不需要通过JavaScriptCore作为中间件<br>WKWebView 白屏问题： WKWebView 是一个多进程组件，Other Process 的内存占用会增加。WebContent Process 会 crash，从而出现白屏现象<br>缺点：承载当前webView的控制器无法正常释放<br>原因注意：这种方法很可能照成循环引用，所以在适当的时机要移除。</p>
<h2 id="OC和JS是如何交互的"><a href="#OC和JS是如何交互的" class="headerlink" title="OC和JS是如何交互的"></a>OC和JS是如何交互的</h2><p>依赖注入<br>OC先声明一段JS代码，在第一次进入此webView页的时候注入到 webView中，之后webView上下文中就有了这些js函数。<br>注册声明 js 会被 oc 调用的方法存放在 js 环境的字典中；<br>oc 发起调用，生成一个message字典，三个参数（handlerName 方法名，data数据， callbackId 回调方法）<br>把message字典转成json字符串，处理字符串里面的\、\、\r、\n 等特殊字符。生成新的字符串并加上<br>WebViewJavascriptBridge._handleMessageFromObjC(‘messageJSON‘)，形成一段字符串形式的js代码（既通过提前注入js中的函数_handleMessageFromObjC去处理 messageJSON 参数）。</p>
<h2 id="模块化同层的依赖如何实现"><a href="#模块化同层的依赖如何实现" class="headerlink" title="模块化同层的依赖如何实现"></a>模块化同层的依赖如何实现</h2><p>通过引用的方式打出framework，所以需要在项目中同时使用</p>
<p>DNS过程 DNS劫持</p>
<p>编译过程</p>
<p>线程同步方法<br>死锁。如何避免<br>输入url后的事件流程<br>获取mac地址的过程<br>10亿数据查找目标，bitmap<br>浏览器渲染页面过程<br>设计一个StringBuffer<br>设计多线程下载一个1G文件<br>讲一讲hashmap 和hashtable 的区别<br>分享一个最值得分享的经历，觉得最有成就感的？过程中最有收获的点<br>什么是信号量<br>git<br>问这三个http版本有啥区别的区别<br>进程和线程切换的开销<br>    切换虚拟地址空间<br>    切换CPU上下文<br>    切换内核栈<br>进程间通讯的四种方式<br>    共享内存<br>    信号<br>    管道<br>    消息队列<br>动态链接库和共享内存的区别在哪呢？ 区别就在于：多个程序虽然可以共享同一个动态链接库中的相同代码，但每一个进程都为动态链接库使用的全部数据分配了自己的地址空间。而共享内存是代码和数据均被多个程序所共享。动态链接库只是实现了代码的复用，对于数据，各个程序要自己保存。共享内存用于进程间通信，主要用于数据…</p>
<p>DNS查询<br>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/06/M_Swift138%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="门乾强">
      <meta itemprop="description" content="博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Men的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/M_Swift138%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">UI相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 17:29:47" itemprop="dateCreated datePublished" datetime="2020-09-06T17:29:47+08:00">2020-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-03 14:03:52" itemprop="dateModified" datetime="2022-03-03T14:03:52+08:00">2022-03-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="程序绘制流程"><a href="#程序绘制流程" class="headerlink" title="程序绘制流程"></a>程序绘制流程</h2><h2 id="试图绘制为什么不立即执行"><a href="#试图绘制为什么不立即执行" class="headerlink" title="试图绘制为什么不立即执行"></a>试图绘制为什么不立即执行</h2><h2 id="事件响应流程"><a href="#事件响应流程" class="headerlink" title="事件响应流程"></a>事件响应流程</h2><h2 id="UI卡顿原因"><a href="#UI卡顿原因" class="headerlink" title="UI卡顿原因"></a>UI卡顿原因</h2><h2 id="滑动优化方案"><a href="#滑动优化方案" class="headerlink" title="滑动优化方案"></a>滑动优化方案</h2><h2 id="什么是离屏渲染，触发的条件是什么"><a href="#什么是离屏渲染，触发的条件是什么" class="headerlink" title="什么是离屏渲染，触发的条件是什么"></a>什么是离屏渲染，触发的条件是什么</h2><h2 id="UIView和CALayer关系"><a href="#UIView和CALayer关系" class="headerlink" title="UIView和CALayer关系"></a>UIView和CALayer关系</h2><h2 id="CALayer的mask作用"><a href="#CALayer的mask作用" class="headerlink" title="CALayer的mask作用"></a>CALayer的mask作用</h2><h2 id="如何高性能给UIImageView加圆角"><a href="#如何高性能给UIImageView加圆角" class="headerlink" title="如何高性能给UIImageView加圆角"></a>如何高性能给UIImageView加圆角</h2><h2 id="如何使用核心动画"><a href="#如何使用核心动画" class="headerlink" title="如何使用核心动画"></a>如何使用核心动画</h2><h2 id="如何增加view点击范围"><a href="#如何增加view点击范围" class="headerlink" title="如何增加view点击范围"></a>如何增加view点击范围</h2><h2 id="hitTest：withEvent内部实现"><a href="#hitTest：withEvent内部实现" class="headerlink" title="hitTest：withEvent内部实现"></a>hitTest：withEvent内部实现</h2><h2 id="程序的启动速度优化"><a href="#程序的启动速度优化" class="headerlink" title="程序的启动速度优化"></a>程序的启动速度优化</h2><h2 id="drawRect和layouSubviews-的区别"><a href="#drawRect和layouSubviews-的区别" class="headerlink" title="drawRect和layouSubviews 的区别"></a>drawRect和layouSubviews 的区别</h2><h2 id="setNeedsLayout与layoutIfNeeded的区别"><a href="#setNeedsLayout与layoutIfNeeded的区别" class="headerlink" title="setNeedsLayout与layoutIfNeeded的区别"></a>setNeedsLayout与layoutIfNeeded的区别</h2><h2 id="UIResponder的理解和事件响应分析"><a href="#UIResponder的理解和事件响应分析" class="headerlink" title="UIResponder的理解和事件响应分析"></a>UIResponder的理解和事件响应分析</h2><h2 id="loadView的作用"><a href="#loadView的作用" class="headerlink" title="loadView的作用"></a>loadView的作用</h2><h2 id="UITableView卡顿原因"><a href="#UITableView卡顿原因" class="headerlink" title="UITableView卡顿原因"></a>UITableView卡顿原因</h2><h2 id="UITableView优化"><a href="#UITableView优化" class="headerlink" title="UITableView优化"></a>UITableView优化</h2><h2 id="iOS-保持界面流畅的技巧"><a href="#iOS-保持界面流畅的技巧" class="headerlink" title="iOS 保持界面流畅的技巧"></a>iOS 保持界面流畅的技巧</h2><h2 id="使用-drawRect有什么影响"><a href="#使用-drawRect有什么影响" class="headerlink" title="使用 drawRect有什么影响"></a>使用 drawRect有什么影响</h2><h2 id="tableViewCell的自适应如何实现，如何保证性能"><a href="#tableViewCell的自适应如何实现，如何保证性能" class="headerlink" title="tableViewCell的自适应如何实现，如何保证性能"></a>tableViewCell的自适应如何实现，如何保证性能</h2><h2 id="转场动画相关操作"><a href="#转场动画相关操作" class="headerlink" title="转场动画相关操作"></a>转场动画相关操作</h2><h2 id="绘图相关知识-coreGraphics框架的使用"><a href="#绘图相关知识-coreGraphics框架的使用" class="headerlink" title="绘图相关知识(coreGraphics框架的使用)"></a>绘图相关知识(coreGraphics框架的使用)</h2><h2 id="view的生命周期"><a href="#view的生命周期" class="headerlink" title="view的生命周期"></a>view的生命周期</h2><h2 id="系统UIView更新机制的思想"><a href="#系统UIView更新机制的思想" class="headerlink" title="系统UIView更新机制的思想"></a>系统UIView更新机制的思想</h2><h2 id="drawRect常用作用"><a href="#drawRect常用作用" class="headerlink" title="drawRect常用作用"></a>drawRect常用作用</h2><h2 id="layoutSubView和drawRect的调用时机；"><a href="#layoutSubView和drawRect的调用时机；" class="headerlink" title="layoutSubView和drawRect的调用时机；"></a>layoutSubView和drawRect的调用时机；</h2><h2 id="用UIView实现Scrollview。"><a href="#用UIView实现Scrollview。" class="headerlink" title="用UIView实现Scrollview。"></a>用UIView实现Scrollview。</h2><h2 id="轮播图的实现"><a href="#轮播图的实现" class="headerlink" title="轮播图的实现"></a>轮播图的实现</h2><h2 id="CGSize-intrinsicContentSize-是干什么用的？"><a href="#CGSize-intrinsicContentSize-是干什么用的？" class="headerlink" title="-(CGSize)intrinsicContentSize:是干什么用的？"></a>-(CGSize)intrinsicContentSize:是干什么用的？</h2><h2 id="渲染UI为什么要在主线程？"><a href="#渲染UI为什么要在主线程？" class="headerlink" title="渲染UI为什么要在主线程？"></a>渲染UI为什么要在主线程？</h2><h2 id="如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？"><a href="#如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？" class="headerlink" title="如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？"></a>如果有一个controller请求了网络数据，但数据还没返回之前就pop出去了，问，数据会怎么样？</h2><h2 id="scrollview与消息响应链冲突？"><a href="#scrollview与消息响应链冲突？" class="headerlink" title="scrollview与消息响应链冲突？"></a>scrollview与消息响应链冲突？</h2><h2 id="Core-Graphics的更底层的是什么；"><a href="#Core-Graphics的更底层的是什么；" class="headerlink" title="Core Graphics的更底层的是什么；"></a>Core Graphics的更底层的是什么；</h2><h1 id="OC相关"><a href="#OC相关" class="headerlink" title="OC相关"></a>OC相关</h1><h2 id="分类可以添加哪些内容，为什么不能添加属性"><a href="#分类可以添加哪些内容，为什么不能添加属性" class="headerlink" title="分类可以添加哪些内容，为什么不能添加属性"></a>分类可以添加哪些内容，为什么不能添加属性</h2><h2 id="类扩展和分类的区别"><a href="#类扩展和分类的区别" class="headerlink" title="类扩展和分类的区别"></a>类扩展和分类的区别</h2><h2 id="分类是如何实现的"><a href="#分类是如何实现的" class="headerlink" title="分类是如何实现的"></a>分类是如何实现的</h2><h2 id="分类重写了原类中同名方法会怎么样，为什么"><a href="#分类重写了原类中同名方法会怎么样，为什么" class="headerlink" title="分类重写了原类中同名方法会怎么样，为什么"></a>分类重写了原类中同名方法会怎么样，为什么</h2><h2 id="如何给分类添加属性（关联对象）"><a href="#如何给分类添加属性（关联对象）" class="headerlink" title="如何给分类添加属性（关联对象）"></a>如何给分类添加属性（关联对象）</h2><h2 id="什么是代理，和通知-BLOCK区别"><a href="#什么是代理，和通知-BLOCK区别" class="headerlink" title="什么是代理，和通知/BLOCK区别"></a>什么是代理，和通知/BLOCK区别</h2><h2 id="什么是通知"><a href="#什么是通知" class="headerlink" title="什么是通知"></a>什么是通知</h2><h2 id="KVO实现原理"><a href="#KVO实现原理" class="headerlink" title="KVO实现原理"></a>KVO实现原理</h2><h2 id="KVC的实现原理"><a href="#KVC的实现原理" class="headerlink" title="KVC的实现原理"></a>KVC的实现原理</h2><h2 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h2><h2 id="include与-import的区别、-import-与-class-的区别"><a href="#include与-import的区别、-import-与-class-的区别" class="headerlink" title="include与#import的区别、#import 与@class 的区别"></a>include与#import的区别、#import 与@class 的区别</h2><h2 id="解释-const-static-inline-关键字"><a href="#解释-const-static-inline-关键字" class="headerlink" title="解释 const, static, inline 关键字"></a>解释 const, static, inline 关键字</h2><h2 id="OC-里怎么实现多继承"><a href="#OC-里怎么实现多继承" class="headerlink" title="OC 里怎么实现多继承"></a>OC 里怎么实现多继承</h2><h2 id="load方法实现原理与initialize区别"><a href="#load方法实现原理与initialize区别" class="headerlink" title="load方法实现原理与initialize区别"></a>load方法实现原理与initialize区别</h2><h2 id="懒加载的使用"><a href="#懒加载的使用" class="headerlink" title="懒加载的使用"></a>懒加载的使用</h2><h2 id="写一个单例"><a href="#写一个单例" class="headerlink" title="写一个单例"></a>写一个单例</h2><h2 id="nil-NIL-NSNULL区别，id-和-instanceType-区别，self和super的区别，struct和class的区别"><a href="#nil-NIL-NSNULL区别，id-和-instanceType-区别，self和super的区别，struct和class的区别" class="headerlink" title="nil NIL NSNULL区别，id 和 instanceType 区别，self和super的区别，struct和class的区别"></a>nil NIL NSNULL区别，id 和 instanceType 区别，self和super的区别，struct和class的区别</h2><h2 id="如何实现一个线程安全的-NSMutableArray"><a href="#如何实现一个线程安全的-NSMutableArray" class="headerlink" title="如何实现一个线程安全的 NSMutableArray?"></a>如何实现一个线程安全的 NSMutableArray?</h2><h2 id="JS-和-OC-互相调用的几种方式"><a href="#JS-和-OC-互相调用的几种方式" class="headerlink" title="JS 和 OC 互相调用的几种方式"></a>JS 和 OC 互相调用的几种方式</h2><h2 id="数据持久性有哪几种"><a href="#数据持久性有哪几种" class="headerlink" title="数据持久性有哪几种"></a>数据持久性有哪几种</h2><h2 id="blcok，NSNotification，delegate，Observer比较"><a href="#blcok，NSNotification，delegate，Observer比较" class="headerlink" title="blcok，NSNotification，delegate，Observer比较"></a>blcok，NSNotification，delegate，Observer比较</h2><h2 id="const-extern-static-用法区别"><a href="#const-extern-static-用法区别" class="headerlink" title="const extern static 用法区别"></a>const extern static 用法区别</h2><h2 id="写一个宏定义函数，实现返回三个数中最大的"><a href="#写一个宏定义函数，实现返回三个数中最大的" class="headerlink" title="写一个宏定义函数，实现返回三个数中最大的"></a>写一个宏定义函数，实现返回三个数中最大的</h2><h2 id="static和extern的访问范围，用extern的情况下什么时候程序会报错"><a href="#static和extern的访问范围，用extern的情况下什么时候程序会报错" class="headerlink" title="static和extern的访问范围，用extern的情况下什么时候程序会报错"></a>static和extern的访问范围，用extern的情况下什么时候程序会报错</h2><h2 id="inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？"><a href="#inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？" class="headerlink" title="inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？"></a>inline知道吗？说说它的作用。inline在什么时候展开、编译还是运行？</h2><h2 id="OC里的基本数据类型如数组字典等的数据结构是怎样的；"><a href="#OC里的基本数据类型如数组字典等的数据结构是怎样的；" class="headerlink" title="OC里的基本数据类型如数组字典等的数据结构是怎样的；"></a>OC里的基本数据类型如数组字典等的数据结构是怎样的；</h2><h2 id="sychronized实现原理"><a href="#sychronized实现原理" class="headerlink" title="sychronized实现原理"></a>sychronized实现原理</h2><h2 id="问NSTimer的底层实现原理"><a href="#问NSTimer的底层实现原理" class="headerlink" title="问NSTimer的底层实现原理"></a>问NSTimer的底层实现原理</h2><h2 id="block中为什么要用Strong类型的引用来保持self；"><a href="#block中为什么要用Strong类型的引用来保持self；" class="headerlink" title="block中为什么要用Strong类型的引用来保持self；"></a>block中为什么要用Strong类型的引用来保持self；</h2><h2 id="问-ifdef-cplusplus-extern-“C-“"><a href="#问-ifdef-cplusplus-extern-“C-“" class="headerlink" title="问#ifdef __cplusplus extern “C “"></a>问#ifdef __cplusplus extern “C “</h2><h2 id="说下ASCII和unicode的区别utf-8的优势"><a href="#说下ASCII和unicode的区别utf-8的优势" class="headerlink" title="说下ASCII和unicode的区别utf-8的优势"></a>说下ASCII和unicode的区别utf-8的优势</h2><h2 id="iOS-launchwith-options-返回no有什么作用；"><a href="#iOS-launchwith-options-返回no有什么作用；" class="headerlink" title="iOS launchwith options 返回no有什么作用；"></a>iOS launchwith options 返回no有什么作用；</h2><h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h2 id="NSObject的数据结构"><a href="#NSObject的数据结构" class="headerlink" title="NSObject的数据结构"></a>NSObject的数据结构</h2><h2 id="类对象和实例对象的isa指针的指向"><a href="#类对象和实例对象的isa指针的指向" class="headerlink" title="类对象和实例对象的isa指针的指向"></a>类对象和实例对象的isa指针的指向</h2><h2 id="为什么id类型可以指向OC中任意对象"><a href="#为什么id类型可以指向OC中任意对象" class="headerlink" title="为什么id类型可以指向OC中任意对象"></a>为什么id类型可以指向OC中任意对象</h2><h2 id="为什么不能用isa判断一个类的继承关系"><a href="#为什么不能用isa判断一个类的继承关系" class="headerlink" title="为什么不能用isa判断一个类的继承关系"></a>为什么不能用isa判断一个类的继承关系</h2><h2 id="cache-t的数据结构、实现原理及扩容"><a href="#cache-t的数据结构、实现原理及扩容" class="headerlink" title="cache_t的数据结构、实现原理及扩容"></a>cache_t的数据结构、实现原理及扩容</h2><h2 id="cache-t-扩容"><a href="#cache-t-扩容" class="headerlink" title="cache_t 扩容"></a>cache_t 扩容</h2><h2 id="class-rw-t的数据结构，实现原理"><a href="#class-rw-t的数据结构，实现原理" class="headerlink" title="class_rw_t的数据结构，实现原理"></a>class_rw_t的数据结构，实现原理</h2><h2 id="哈希碰撞的解决方法"><a href="#哈希碰撞的解决方法" class="headerlink" title="哈希碰撞的解决方法"></a>哈希碰撞的解决方法</h2><h2 id="方法查找的过程"><a href="#方法查找的过程" class="headerlink" title="方法查找的过程"></a>方法查找的过程</h2><h2 id="消息转发的流程"><a href="#消息转发的流程" class="headerlink" title="消息转发的流程"></a>消息转发的流程</h2><h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><h2 id="系统如何解决新增实例冲突"><a href="#系统如何解决新增实例冲突" class="headerlink" title="系统如何解决新增实例冲突"></a>系统如何解决新增实例冲突</h2><h2 id="常用的runtime方法有哪些"><a href="#常用的runtime方法有哪些" class="headerlink" title="常用的runtime方法有哪些"></a>常用的runtime方法有哪些</h2><h2 id="runtime的具体应用有哪些，你在什么地方用到了"><a href="#runtime的具体应用有哪些，你在什么地方用到了" class="headerlink" title="runtime的具体应用有哪些，你在什么地方用到了"></a>runtime的具体应用有哪些，你在什么地方用到了</h2><h2 id="runtime-怎么添加属性，方法等"><a href="#runtime-怎么添加属性，方法等" class="headerlink" title="runtime 怎么添加属性，方法等"></a>runtime 怎么添加属性，方法等</h2><h2 id="runtime-如何实现-weak-属性"><a href="#runtime-如何实现-weak-属性" class="headerlink" title="runtime 如何实现 weak 属性"></a>runtime 如何实现 weak 属性</h2><h2 id="runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）"><a href="#runtime-如何通过selector-找到对应的-IMP-地址？（分别考虑类方法和实例方法）" class="headerlink" title="runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）"></a>runtime 如何通过selector 找到对应的 IMP 地址？（分别考虑类方法和实例方法）</h2><h2 id="runtime如何实现weak变量的自动置nil"><a href="#runtime如何实现weak变量的自动置nil" class="headerlink" title="runtime如何实现weak变量的自动置nil"></a>runtime如何实现weak变量的自动置nil</h2><h2 id="map-images-函数Runtime-初始化操作"><a href="#map-images-函数Runtime-初始化操作" class="headerlink" title="map_images 函数Runtime 初始化操作"></a>map_images 函数Runtime 初始化操作</h2><h2 id="共用体方法查找"><a href="#共用体方法查找" class="headerlink" title="共用体方法查找"></a>共用体方法查找</h2><h2 id="msgSend如何查找"><a href="#msgSend如何查找" class="headerlink" title="msgSend如何查找"></a>msgSend如何查找</h2><h2 id="msgSend参数都有哪些；"><a href="#msgSend参数都有哪些；" class="headerlink" title="msgSend参数都有哪些；"></a>msgSend参数都有哪些；</h2><h2 id="class方法相关"><a href="#class方法相关" class="headerlink" title="class方法相关"></a>class方法相关</h2><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存中的5大区都是什么？"><a href="#内存中的5大区都是什么？" class="headerlink" title="内存中的5大区都是什么？"></a>内存中的5大区都是什么？</h2><h2 id="C-内存如何分布、堆和栈的区别"><a href="#C-内存如何分布、堆和栈的区别" class="headerlink" title="C++内存如何分布、堆和栈的区别"></a>C++内存如何分布、堆和栈的区别</h2><h2 id="ARC实现机制，遵循哪些原则"><a href="#ARC实现机制，遵循哪些原则" class="headerlink" title="ARC实现机制，遵循哪些原则"></a>ARC实现机制，遵循哪些原则</h2><h2 id="NSObject内存分配、ISA指针的内存大小"><a href="#NSObject内存分配、ISA指针的内存大小" class="headerlink" title="NSObject内存分配、ISA指针的内存大小"></a>NSObject内存分配、ISA指针的内存大小</h2><h2 id="Tagged-Pointer、NONPOINTER-ISA实现机制和作用"><a href="#Tagged-Pointer、NONPOINTER-ISA实现机制和作用" class="headerlink" title="Tagged Pointer、NONPOINTER_ISA实现机制和作用"></a>Tagged Pointer、NONPOINTER_ISA实现机制和作用</h2><h2 id="异步多线程访问导致的内存问题分析及解决办法。（代码题）"><a href="#异步多线程访问导致的内存问题分析及解决办法。（代码题）" class="headerlink" title="异步多线程访问导致的内存问题分析及解决办法。（代码题）"></a>异步多线程访问导致的内存问题分析及解决办法。（代码题）</h2><h2 id="SideTables数据结构及实现原理，为什么用多个SideTables"><a href="#SideTables数据结构及实现原理，为什么用多个SideTables" class="headerlink" title="SideTables数据结构及实现原理，为什么用多个SideTables"></a>SideTables数据结构及实现原理，为什么用多个SideTables</h2><pre><code>                       
</code></pre>
<h2 id="Autoreleasepool的数据结构及实现原理，什么时候释放"><a href="#Autoreleasepool的数据结构及实现原理，什么时候释放" class="headerlink" title="Autoreleasepool的数据结构及实现原理，什么时候释放"></a>Autoreleasepool的数据结构及实现原理，什么时候释放</h2><h2 id="AutoreleasePool-为何可以嵌套使用"><a href="#AutoreleasePool-为何可以嵌套使用" class="headerlink" title="AutoreleasePool 为何可以嵌套使用"></a>AutoreleasePool 为何可以嵌套使用</h2><h2 id="子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool"><a href="#子线程默认不会开启-Runloop，那出现-Autorelease-对象如何处理，在什么情况下子线程使用AutoreleasePool" class="headerlink" title="子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool"></a>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理，在什么情况下子线程使用AutoreleasePool</h2><h2 id="dealloc调用流程"><a href="#dealloc调用流程" class="headerlink" title="dealloc调用流程"></a>dealloc调用流程</h2><h2 id="常见的循环引用，如何破除循环引用"><a href="#常见的循环引用，如何破除循环引用" class="headerlink" title="常见的循环引用，如何破除循环引用"></a>常见的循环引用，如何破除循环引用</h2><h2 id="weak-修饰的变量在地址被释放后，为何被置为-nil？"><a href="#weak-修饰的变量在地址被释放后，为何被置为-nil？" class="headerlink" title="__weak 修饰的变量在地址被释放后，为何被置为 nil？"></a>__weak 修饰的变量在地址被释放后，为何被置为 nil？</h2><h2 id="深拷贝和浅拷贝区别"><a href="#深拷贝和浅拷贝区别" class="headerlink" title="深拷贝和浅拷贝区别"></a>深拷贝和浅拷贝区别</h2><h2 id="atomic是安全的吗"><a href="#atomic是安全的吗" class="headerlink" title="atomic是安全的吗"></a>atomic是安全的吗</h2><h2 id="assign-vs-weak，-block-vs-weak-区别"><a href="#assign-vs-weak，-block-vs-weak-区别" class="headerlink" title="assign vs weak，_block vs _weak 区别"></a>assign vs weak，_block vs _weak 区别</h2><h2 id="怎么检查内存泄露"><a href="#怎么检查内存泄露" class="headerlink" title="怎么检查内存泄露"></a>怎么检查内存泄露</h2><h2 id="图片加载占用内存对比"><a href="#图片加载占用内存对比" class="headerlink" title="图片加载占用内存对比"></a>图片加载占用内存对比</h2><h2 id="block一般用那个关键字修饰，为什么"><a href="#block一般用那个关键字修饰，为什么" class="headerlink" title="block一般用那个关键字修饰，为什么"></a>block一般用那个关键字修饰，为什么</h2><h2 id="写一个MRC的set方法"><a href="#写一个MRC的set方法" class="headerlink" title="写一个MRC的set方法"></a>写一个MRC的set方法</h2><h2 id="如何解决定时器循环引用"><a href="#如何解决定时器循环引用" class="headerlink" title="如何解决定时器循环引用"></a>如何解决定时器循环引用</h2><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><h2 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h2><h2 id="什么是虚拟内存、共享内存、物理内存"><a href="#什么是虚拟内存、共享内存、物理内存" class="headerlink" title="什么是虚拟内存、共享内存、物理内存"></a>什么是虚拟内存、共享内存、物理内存</h2><h2 id="举例一些I-O操作的例子"><a href="#举例一些I-O操作的例子" class="headerlink" title="举例一些I/O操作的例子"></a>举例一些I/O操作的例子</h2><h2 id="如何开辟一块内存；"><a href="#如何开辟一块内存；" class="headerlink" title="如何开辟一块内存；"></a>如何开辟一块内存；</h2><h2 id="什么时候深复制，什么时候浅复制；"><a href="#什么时候深复制，什么时候浅复制；" class="headerlink" title="什么时候深复制，什么时候浅复制；"></a>什么时候深复制，什么时候浅复制；</h2><h2 id="怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手"><a href="#怎么控制内存和优化内存；如果是你考虑怎么优化内存-从什么地方着手" class="headerlink" title="怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手"></a>怎么控制内存和优化内存；如果是你考虑怎么优化内存,从什么地方着手</h2><h2 id="问堆和栈的区别。"><a href="#问堆和栈的区别。" class="headerlink" title="问堆和栈的区别。"></a>问堆和栈的区别。</h2><h2 id="Block的创建，何时被释放。"><a href="#Block的创建，何时被释放。" class="headerlink" title="Block的创建，何时被释放。"></a>Block的创建，何时被释放。</h2><h2 id="dynamic的应用场景？"><a href="#dynamic的应用场景？" class="headerlink" title="@dynamic的应用场景？"></a>@dynamic的应用场景？</h2><h2 id="问题：-property-copy-NSMutableArray-array"><a href="#问题：-property-copy-NSMutableArray-array" class="headerlink" title="问题：@property (copy) NSMutableArray *array;"></a>问题：@property (copy) NSMutableArray *array;</h2><h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><h2 id="Block为什么用copy"><a href="#Block为什么用copy" class="headerlink" title="Block为什么用copy"></a>Block为什么用copy</h2><h2 id="Block如何截获不同变量，代码分析"><a href="#Block如何截获不同变量，代码分析" class="headerlink" title="Block如何截获不同变量，代码分析"></a>Block如何截获不同变量，代码分析</h2><h2 id="Block本质数据结构"><a href="#Block本质数据结构" class="headerlink" title="Block本质数据结构"></a>Block本质数据结构</h2><h2 id="栈上的Block经过copy操作后发生哪些变化"><a href="#栈上的Block经过copy操作后发生哪些变化" class="headerlink" title="栈上的Block经过copy操作后发生哪些变化"></a>栈上的Block经过copy操作后发生哪些变化</h2><h2 id="block循环引用"><a href="#block循环引用" class="headerlink" title="block循环引用"></a>block循环引用</h2><h2 id="block原理"><a href="#block原理" class="headerlink" title="__block原理"></a>__block原理</h2><h2 id="strong原理"><a href="#strong原理" class="headerlink" title="__strong原理"></a>__strong原理</h2><h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop概念及数据结构、事件循环机制"><a href="#RunLoop概念及数据结构、事件循环机制" class="headerlink" title="RunLoop概念及数据结构、事件循环机制"></a>RunLoop概念及数据结构、事件循环机制</h2><h2 id="CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用"><a href="#CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用" class="headerlink" title="CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用"></a>CFRunLoopMode、CFRunLoopTimer、CFRunLoopObserver作用</h2><h2 id="RunLoop和NStimer"><a href="#RunLoop和NStimer" class="headerlink" title="RunLoop和NStimer"></a>RunLoop和NStimer</h2><h2 id="RunLoop和多线程"><a href="#RunLoop和多线程" class="headerlink" title="RunLoop和多线程"></a>RunLoop和多线程</h2><h2 id="如何实现一个常驻线程"><a href="#如何实现一个常驻线程" class="headerlink" title="如何实现一个常驻线程"></a>如何实现一个常驻线程</h2><h2 id="利用-runloop-解释一下页面的渲染的过程"><a href="#利用-runloop-解释一下页面的渲染的过程" class="headerlink" title="利用 runloop 解释一下页面的渲染的过程"></a>利用 runloop 解释一下页面的渲染的过程</h2><h2 id="你在开发过程中怎么使用RunLoop？什么应用场景？"><a href="#你在开发过程中怎么使用RunLoop？什么应用场景？" class="headerlink" title="你在开发过程中怎么使用RunLoop？什么应用场景？"></a>你在开发过程中怎么使用RunLoop？什么应用场景？</h2><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程与线程、并行-和-并发-区别"><a href="#进程与线程、并行-和-并发-区别" class="headerlink" title="进程与线程、并行 和 并发 区别"></a>进程与线程、并行 和 并发 区别</h2><h2 id="GCD、NSOperation、NSThread区别优缺点"><a href="#GCD、NSOperation、NSThread区别优缺点" class="headerlink" title="GCD、NSOperation、NSThread区别优缺点"></a>GCD、NSOperation、NSThread区别优缺点</h2><h2 id="performSelector-withObject-afterDelay-为什么在子线程无效"><a href="#performSelector-withObject-afterDelay-为什么在子线程无效" class="headerlink" title="performSelector:withObject:afterDelay:为什么在子线程无效"></a>performSelector:withObject:afterDelay:为什么在子线程无效</h2><h2 id="如何让多个网络请求完成后执行下一步"><a href="#如何让多个网络请求完成后执行下一步" class="headerlink" title="如何让多个网络请求完成后执行下一步"></a>如何让多个网络请求完成后执行下一步</h2><h2 id="多个网络请求顺序执行后执行下一步"><a href="#多个网络请求顺序执行后执行下一步" class="headerlink" title="多个网络请求顺序执行后执行下一步"></a>多个网络请求顺序执行后执行下一步</h2><h2 id="异步操作两组数据时-执行完第一组之后-才能执行第二组"><a href="#异步操作两组数据时-执行完第一组之后-才能执行第二组" class="headerlink" title="异步操作两组数据时, 执行完第一组之后, 才能执行第二组"></a>异步操作两组数据时, 执行完第一组之后, 才能执行第二组</h2><h2 id="你知道哪些锁、使用场景"><a href="#你知道哪些锁、使用场景" class="headerlink" title="你知道哪些锁、使用场景"></a>你知道哪些锁、使用场景</h2><h2 id="自旋和互斥对比"><a href="#自旋和互斥对比" class="headerlink" title="自旋和互斥对比"></a>自旋和互斥对比</h2><h2 id="CommonMode的特性"><a href="#CommonMode的特性" class="headerlink" title="CommonMode的特性"></a>CommonMode的特性</h2><h2 id="runloop与autoreleasepool的关系"><a href="#runloop与autoreleasepool的关系" class="headerlink" title="runloop与autoreleasepool的关系"></a>runloop与autoreleasepool的关系</h2><h2 id="GCD-在Runloop中的使用"><a href="#GCD-在Runloop中的使用" class="headerlink" title="GCD 在Runloop中的使用"></a>GCD 在Runloop中的使用</h2><h2 id="GCD-Global队列创建线程进行耗时操作的风险"><a href="#GCD-Global队列创建线程进行耗时操作的风险" class="headerlink" title="GCD Global队列创建线程进行耗时操作的风险"></a>GCD Global队列创建线程进行耗时操作的风险</h2><h2 id="CADispalyTimer和Timer哪个更精确"><a href="#CADispalyTimer和Timer哪个更精确" class="headerlink" title="CADispalyTimer和Timer哪个更精确"></a>CADispalyTimer和Timer哪个更精确</h2><h2 id="怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"><a href="#怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作" class="headerlink" title="怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作"></a>怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作</h2><h2 id="分析线程同步串行、同步并行、异步串行、异步并行问题"><a href="#分析线程同步串行、同步并行、异步串行、异步并行问题" class="headerlink" title="分析线程同步串行、同步并行、异步串行、异步并行问题"></a>分析线程同步串行、同步并行、异步串行、异步并行问题</h2><h2 id="GCD执行原理、问题分析"><a href="#GCD执行原理、问题分析" class="headerlink" title="GCD执行原理、问题分析"></a>GCD执行原理、问题分析</h2><h2 id="dispatch-once如何实现一次性代码"><a href="#dispatch-once如何实现一次性代码" class="headerlink" title="dispatch_once如何实现一次性代码"></a>dispatch_once如何实现一次性代码</h2><h2 id="NSOperation数据结构"><a href="#NSOperation数据结构" class="headerlink" title="NSOperation数据结构"></a>NSOperation数据结构</h2><h2 id="重写NSOperation需要注意的点"><a href="#重写NSOperation需要注意的点" class="headerlink" title="重写NSOperation需要注意的点"></a>重写NSOperation需要注意的点</h2><h2 id="进程中的哪些空间是线程所共有的？"><a href="#进程中的哪些空间是线程所共有的？" class="headerlink" title="进程中的哪些空间是线程所共有的？"></a>进程中的哪些空间是线程所共有的？</h2><h2 id="使用GCD需要注意什么；"><a href="#使用GCD需要注意什么；" class="headerlink" title="使用GCD需要注意什么；"></a>使用GCD需要注意什么；</h2><h2 id="runloop跟runtime有没有关联"><a href="#runloop跟runtime有没有关联" class="headerlink" title="runloop跟runtime有没有关联"></a>runloop跟runtime有没有关联</h2><h2 id="CPU和GPU怎么相互合作的"><a href="#CPU和GPU怎么相互合作的" class="headerlink" title="CPU和GPU怎么相互合作的"></a>CPU和GPU怎么相互合作的</h2><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP请求方式有哪些"><a href="#HTTP请求方式有哪些" class="headerlink" title="HTTP请求方式有哪些"></a>HTTP请求方式有哪些</h2><h2 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h2><h2 id="HTTP三次握手，为什么需要三次"><a href="#HTTP三次握手，为什么需要三次" class="headerlink" title="HTTP三次握手，为什么需要三次"></a>HTTP三次握手，为什么需要三次</h2><h2 id="HTTP四次挥手，为什么需要四次"><a href="#HTTP四次挥手，为什么需要四次" class="headerlink" title="HTTP四次挥手，为什么需要四次"></a>HTTP四次挥手，为什么需要四次</h2><h2 id="为什么“握手”是三次，“挥手”却要四次？"><a href="#为什么“握手”是三次，“挥手”却要四次？" class="headerlink" title="为什么“握手”是三次，“挥手”却要四次？"></a>为什么“握手”是三次，“挥手”却要四次？</h2><h2 id="为什么客户端在TIME-WAIT阶段要等2MSL"><a href="#为什么客户端在TIME-WAIT阶段要等2MSL" class="headerlink" title="为什么客户端在TIME-WAIT阶段要等2MSL"></a>为什么客户端在TIME-WAIT阶段要等2MSL</h2><h2 id="HTTPS-TLS-SSL加密过程"><a href="#HTTPS-TLS-SSL加密过程" class="headerlink" title="HTTPS TLS/SSL加密过程"></a>HTTPS TLS/SSL加密过程</h2><h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><h2 id="为什么一定要用三个随机数，来生成”会话密钥"><a href="#为什么一定要用三个随机数，来生成”会话密钥" class="headerlink" title="为什么一定要用三个随机数，来生成”会话密钥"></a>为什么一定要用三个随机数，来生成”会话密钥</h2><h2 id="中间人攻击（charles抓包原理）"><a href="#中间人攻击（charles抓包原理）" class="headerlink" title="中间人攻击（charles抓包原理）"></a>中间人攻击（charles抓包原理）</h2><h2 id="UDP协议及特点、"><a href="#UDP协议及特点、" class="headerlink" title="UDP协议及特点、"></a>UDP协议及特点、</h2><h2 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h2><h2 id="TCP特点及与UDP区别"><a href="#TCP特点及与UDP区别" class="headerlink" title="TCP特点及与UDP区别"></a>TCP特点及与UDP区别</h2><h2 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h2><h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><h2 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h2><h2 id="Cookie机制及作用"><a href="#Cookie机制及作用" class="headerlink" title="Cookie机制及作用"></a>Cookie机制及作用</h2><h2 id="Session机制及作用"><a href="#Session机制及作用" class="headerlink" title="Session机制及作用"></a>Session机制及作用</h2><h2 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h2><h2 id="如何保证cookie的安全"><a href="#如何保证cookie的安全" class="headerlink" title="如何保证cookie的安全"></a>如何保证cookie的安全</h2><h2 id="HTTP请求头都有哪些内容"><a href="#HTTP请求头都有哪些内容" class="headerlink" title="HTTP请求头都有哪些内容"></a>HTTP请求头都有哪些内容</h2><h2 id="哪些加密算法"><a href="#哪些加密算法" class="headerlink" title="哪些加密算法"></a>哪些加密算法</h2><h2 id="TCP和UDP各自使用场景"><a href="#TCP和UDP各自使用场景" class="headerlink" title="TCP和UDP各自使用场景"></a>TCP和UDP各自使用场景</h2><h2 id="http为什么底层是tcp不是udp"><a href="#http为什么底层是tcp不是udp" class="headerlink" title="http为什么底层是tcp不是udp ?"></a>http为什么底层是tcp不是udp ?</h2><h2 id="socket异常断开时，设计一个合理的重连机制。"><a href="#socket异常断开时，设计一个合理的重连机制。" class="headerlink" title="socket异常断开时，设计一个合理的重连机制。"></a>socket异常断开时，设计一个合理的重连机制。</h2><h2 id="有了mac地址为什么要有ip地址"><a href="#有了mac地址为什么要有ip地址" class="headerlink" title="有了mac地址为什么要有ip地址"></a>有了mac地址为什么要有ip地址</h2><h2 id="断点续传怎么实现"><a href="#断点续传怎么实现" class="headerlink" title="断点续传怎么实现;"></a>断点续传怎么实现;</h2><h2 id="大型文件怎么下载并保存到本地；"><a href="#大型文件怎么下载并保存到本地；" class="headerlink" title="大型文件怎么下载并保存到本地；"></a>大型文件怎么下载并保存到本地；</h2><h2 id="xml和json的区别"><a href="#xml和json的区别" class="headerlink" title="xml和json的区别"></a>xml和json的区别</h2><h2 id="加密解密的技术讲解。"><a href="#加密解密的技术讲解。" class="headerlink" title="加密解密的技术讲解。"></a>加密解密的技术讲解。</h2><h2 id="reachability如何检测到网络状态变化？"><a href="#reachability如何检测到网络状态变化？" class="headerlink" title="reachability如何检测到网络状态变化？"></a>reachability如何检测到网络状态变化？</h2><h2 id="IP-地址用-int-保存和读取转化"><a href="#IP-地址用-int-保存和读取转化" class="headerlink" title="IP 地址用 int 保存和读取转化"></a>IP 地址用 int 保存和读取转化</h2><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h2 id="iOS有哪些常见的设计模式"><a href="#iOS有哪些常见的设计模式" class="headerlink" title="iOS有哪些常见的设计模式?"></a>iOS有哪些常见的设计模式?</h2><h2 id="单例优缺点"><a href="#单例优缺点" class="headerlink" title="单例优缺点"></a>单例优缺点</h2><h2 id="内存设计、磁盘设计、网络设计原则"><a href="#内存设计、磁盘设计、网络设计原则" class="headerlink" title="内存设计、磁盘设计、网络设计原则"></a>内存设计、磁盘设计、网络设计原则</h2><h2 id="MVP、MVVM模式思想"><a href="#MVP、MVVM模式思想" class="headerlink" title="MVP、MVVM模式思想"></a>MVP、MVVM模式思想</h2><h2 id="ReactNative的数据流思想"><a href="#ReactNative的数据流思想" class="headerlink" title="ReactNative的数据流思想"></a>ReactNative的数据流思想</h2><h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><h2 id="AFNetworking-底层原理分析"><a href="#AFNetworking-底层原理分析" class="headerlink" title="AFNetworking 底层原理分析"></a>AFNetworking 底层原理分析</h2><h2 id="SDWebImage加载图片过程，图片缓存设计"><a href="#SDWebImage加载图片过程，图片缓存设计" class="headerlink" title="SDWebImage加载图片过程，图片缓存设计"></a>SDWebImage加载图片过程，图片缓存设计</h2><h2 id="YYKit"><a href="#YYKit" class="headerlink" title="YYKit"></a>YYKit</h2><h2 id="组建化优缺点"><a href="#组建化优缺点" class="headerlink" title="组建化优缺点"></a>组建化优缺点</h2><h2 id="复杂页面架构"><a href="#复杂页面架构" class="headerlink" title="复杂页面架构"></a>复杂页面架构</h2><h2 id="为什么要做组件化"><a href="#为什么要做组件化" class="headerlink" title="为什么要做组件化"></a>为什么要做组件化</h2><h2 id="你认为组件化的一些收益"><a href="#你认为组件化的一些收益" class="headerlink" title="你认为组件化的一些收益"></a>你认为组件化的一些收益</h2><h2 id="redux-单向数据流是怎么产生的-描述下"><a href="#redux-单向数据流是怎么产生的-描述下" class="headerlink" title="redux 单向数据流是怎么产生的 描述下"></a>redux 单向数据流是怎么产生的 描述下</h2><h2 id="Charts框架底层实现；"><a href="#Charts框架底层实现；" class="headerlink" title="Charts框架底层实现；"></a>Charts框架底层实现；</h2><h2 id="画出项目的结构图。"><a href="#画出项目的结构图。" class="headerlink" title="画出项目的结构图。"></a>画出项目的结构图。</h2><h2 id="yyModel的逻辑"><a href="#yyModel的逻辑" class="headerlink" title="yyModel的逻辑"></a>yyModel的逻辑</h2><h2 id="解耦的方式"><a href="#解耦的方式" class="headerlink" title="解耦的方式"></a>解耦的方式</h2><h2 id="项目中用的技术以及实现；"><a href="#项目中用的技术以及实现；" class="headerlink" title="项目中用的技术以及实现；"></a>项目中用的技术以及实现；</h2><h2 id="就是项目中遇到的问题以及解决方式；"><a href="#就是项目中遇到的问题以及解决方式；" class="headerlink" title="就是项目中遇到的问题以及解决方式；"></a>就是项目中遇到的问题以及解决方式；</h2><h2 id="缓存机制是怎么清除数据的？"><a href="#缓存机制是怎么清除数据的？" class="headerlink" title="缓存机制是怎么清除数据的？"></a>缓存机制是怎么清除数据的？</h2><h2 id="如何进行安全测试；"><a href="#如何进行安全测试；" class="headerlink" title="如何进行安全测试；"></a>如何进行安全测试；</h2><h2 id="涂鸦怎么实现；"><a href="#涂鸦怎么实现；" class="headerlink" title="涂鸦怎么实现；"></a>涂鸦怎么实现；</h2><h2 id="实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；"><a href="#实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；" class="headerlink" title="实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；"></a>实现一个项目的设计方案，比如数据库的设计，字段的设计，接口的设计；</h2><h2 id="说下生产者-消费者模型，其中的同步机制是怎么样的"><a href="#说下生产者-消费者模型，其中的同步机制是怎么样的" class="headerlink" title="说下生产者-消费者模型，其中的同步机制是怎么样的"></a>说下生产者-消费者模型，其中的同步机制是怎么样的</h2><h1 id="开发日常"><a href="#开发日常" class="headerlink" title="开发日常"></a>开发日常</h1><h2 id="APP启动时间应从哪些方面优化？"><a href="#APP启动时间应从哪些方面优化？" class="headerlink" title="APP启动时间应从哪些方面优化？"></a>APP启动时间应从哪些方面优化？</h2><h2 id="如何降低APP包的大小"><a href="#如何降低APP包的大小" class="headerlink" title="如何降低APP包的大小"></a>如何降低APP包的大小</h2><h2 id="如何检测离屏渲染与优化"><a href="#如何检测离屏渲染与优化" class="headerlink" title="如何检测离屏渲染与优化"></a>如何检测离屏渲染与优化</h2><h2 id="怎么检测图层混合"><a href="#怎么检测图层混合" class="headerlink" title="怎么检测图层混合"></a>怎么检测图层混合</h2><h2 id="UILabel图层混合"><a href="#UILabel图层混合" class="headerlink" title="UILabel图层混合"></a>UILabel图层混合</h2><h2 id="日常如何检查内存泄露？"><a href="#日常如何检查内存泄露？" class="headerlink" title="日常如何检查内存泄露？"></a>日常如何检查内存泄露？</h2><h2 id="LLDB常用的调试命令？"><a href="#LLDB常用的调试命令？" class="headerlink" title="LLDB常用的调试命令？"></a>LLDB常用的调试命令？</h2><h2 id="iOS-常见的崩溃类型有哪些？"><a href="#iOS-常见的崩溃类型有哪些？" class="headerlink" title="iOS 常见的崩溃类型有哪些？"></a>iOS 常见的崩溃类型有哪些？</h2><h2 id="iOS-App-稳定性指标及监测"><a href="#iOS-App-稳定性指标及监测" class="headerlink" title="iOS App 稳定性指标及监测"></a>iOS App 稳定性指标及监测</h2><h2 id="cocoapods-常见问题"><a href="#cocoapods-常见问题" class="headerlink" title="cocoapods 常见问题"></a>cocoapods 常见问题</h2><h2 id="iOS的签名机制是怎么样的"><a href="#iOS的签名机制是怎么样的" class="headerlink" title="iOS的签名机制是怎么样的"></a>iOS的签名机制是怎么样的</h2><h2 id="instruments它为什么能检测内存泄漏"><a href="#instruments它为什么能检测内存泄漏" class="headerlink" title="instruments它为什么能检测内存泄漏"></a>instruments它为什么能检测内存泄漏</h2><h2 id="推送的原理"><a href="#推送的原理" class="headerlink" title="推送的原理"></a>推送的原理</h2><h2 id="项目上线被拒原因"><a href="#项目上线被拒原因" class="headerlink" title="项目上线被拒原因"></a>项目上线被拒原因</h2><h2 id="项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线"><a href="#项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线" class="headerlink" title="项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线"></a>项目中遇到的问题，项目的框架搭建，模块分布，设计类图，开发，自测，上线</h2><h2 id="iPhone自带的AssistiveTouch你如何实现"><a href="#iPhone自带的AssistiveTouch你如何实现" class="headerlink" title="iPhone自带的AssistiveTouch你如何实现"></a>iPhone自带的AssistiveTouch你如何实现</h2><h2 id="有了解过代码如何编译的嘛"><a href="#有了解过代码如何编译的嘛" class="headerlink" title="有了解过代码如何编译的嘛"></a>有了解过代码如何编译的嘛</h2><h2 id="编译好的目标文件有data-和text段他们两者有啥区别"><a href="#编译好的目标文件有data-和text段他们两者有啥区别" class="headerlink" title="编译好的目标文件有data 和text段他们两者有啥区别"></a>编译好的目标文件有data 和text段他们两者有啥区别</h2><h2 id="appstore上架流程"><a href="#appstore上架流程" class="headerlink" title="appstore上架流程"></a>appstore上架流程</h2><h2 id="一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ"><a href="#一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ" class="headerlink" title="一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ;"></a>一个APP如何检测手机中另一个APP的存在？解释原理？例如QQ;</h2><h2 id="针对线上版本的崩溃处理；"><a href="#针对线上版本的崩溃处理；" class="headerlink" title="针对线上版本的崩溃处理；"></a>针对线上版本的崩溃处理；</h2><h2 id="Xcode构建过程；"><a href="#Xcode构建过程；" class="headerlink" title="Xcode构建过程；"></a>Xcode构建过程；</h2><h2 id="js和Oc交互以及区别；"><a href="#js和Oc交互以及区别；" class="headerlink" title="js和Oc交互以及区别；"></a>js和Oc交互以及区别；</h2><h2 id="pod-install和pod-update有什么区别？"><a href="#pod-install和pod-update有什么区别？" class="headerlink" title="pod install和pod update有什么区别？"></a>pod install和pod update有什么区别？</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/41/">41</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">门乾强</p>
  <div class="site-description" itemprop="description">博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">403</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">门乾强</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
